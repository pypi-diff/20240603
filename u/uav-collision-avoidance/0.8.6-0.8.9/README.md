# Comparing `tmp/uav_collision_avoidance-0.8.6-py3-none-any.whl.zip` & `tmp/uav_collision_avoidance-0.8.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,305 +1,324 @@
-Zip file size: 515873 bytes, number of entries: 303
+Zip file size: 560500 bytes, number of entries: 322
+-rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
+-rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
+-rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx     9540 b- defN 24-Apr-11 18:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx     8671 b- defN 24-Apr-16 07:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     6057 b- defN 24-Apr-11 11:29 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
+-rw-r--r--  2.0 unx     7112 b- defN 24-Apr-11 19:12 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
+-rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx     6110 b- defN 24-Apr-11 12:04 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    23164 b- defN 24-Apr-11 12:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx     9540 b- defN 24-Apr-11 18:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     8671 b- defN 24-Apr-16 07:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     6057 b- defN 24-Apr-11 11:29 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     7112 b- defN 24-Apr-11 19:12 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6110 b- defN 24-Apr-11 12:04 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    23164 b- defN 24-Apr-11 12:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    13017 b- defN 24-Apr-24 17:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     9630 b- defN 24-Apr-24 17:35 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     7072 b- defN 24-Apr-24 14:39 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     6613 b- defN 24-Apr-24 14:18 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     6290 b- defN 24-Apr-24 14:18 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    25822 b- defN 24-Apr-24 16:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    13017 b- defN 24-Apr-24 17:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    14940 b- defN 24-Apr-25 10:35 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     9630 b- defN 24-Apr-24 17:35 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     7072 b- defN 24-Apr-24 14:39 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     9632 b- defN 24-Apr-25 10:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     8427 b- defN 24-Apr-24 20:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     6613 b- defN 24-Apr-24 14:18 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     8170 b- defN 24-Apr-25 10:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6290 b- defN 24-Apr-24 14:18 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    25822 b- defN 24-Apr-24 16:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     6343 b- defN 24-Apr-25 10:24 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    26085 b- defN 24-Apr-25 10:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    14940 b- defN 24-Apr-25 10:35 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    15437 b- defN 24-Apr-25 10:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     9632 b- defN 24-Apr-25 10:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     9632 b- defN 24-Apr-25 11:01 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx     8427 b- defN 24-Apr-24 20:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     8170 b- defN 24-Apr-25 10:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     8359 b- defN 24-Apr-25 10:56 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx     6343 b- defN 24-Apr-25 10:24 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    26085 b- defN 24-Apr-25 10:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    15437 b- defN 24-Apr-25 10:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx     9632 b- defN 24-Apr-25 11:01 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx     8427 b- defN 24-Apr-24 20:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx     8359 b- defN 24-Apr-25 10:56 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx     6343 b- defN 24-Apr-25 10:24 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    26085 b- defN 24-Apr-25 10:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
--rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    15437 b- defN 24-Apr-25 10:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
--rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     9632 b- defN 24-Apr-25 11:01 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     8427 b- defN 24-Apr-24 20:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
--rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     8359 b- defN 24-Apr-25 10:56 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
--rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
+-rw-r--r--  2.0 unx     2581 b- defN 24-Apr-29 10:36 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx    21654 b- defN 24-Apr-29 10:37 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 10:38 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx    11968 b- defN 24-Apr-29 10:51 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    11341 b- defN 24-Apr-29 10:34 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
+-rw-r--r--  2.0 unx     9854 b- defN 24-Apr-29 10:27 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6343 b- defN 24-Apr-25 10:24 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    26085 b- defN 24-Apr-25 10:19 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx    16393 b- defN 24-Apr-29 08:53 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    29872 b- defN 24-Apr-29 07:47 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     2581 b- defN 24-Apr-29 10:36 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    21654 b- defN 24-Apr-29 10:37 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    21656 b- defN 24-Apr-29 17:33 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 10:38 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    11968 b- defN 24-Apr-29 10:51 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    11341 b- defN 24-Apr-29 10:34 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx    16524 b- defN 24-Apr-29 17:36 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    12039 b- defN 24-Apr-29 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     4188 b- defN 24-Apr-29 17:33 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     9854 b- defN 24-Apr-29 10:27 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx    10905 b- defN 24-Apr-29 17:37 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx    16393 b- defN 24-Apr-29 08:53 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    29872 b- defN 24-Apr-29 07:47 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
--rw-r--r--  2.0 unx     2581 b- defN 24-Apr-29 10:36 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    21656 b- defN 24-Apr-29 17:33 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     2129 b- defN 24-May-06 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx    21998 b- defN 24-May-09 18:35 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 10:38 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    16524 b- defN 24-Apr-29 17:36 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    12039 b- defN 24-Apr-29 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
--rw-r--r--  2.0 unx     4188 b- defN 24-Apr-29 17:33 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
+-rw-r--r--  2.0 unx    46337 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    13437 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     6819 b- defN 24-Apr-29 22:06 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx    10905 b- defN 24-Apr-29 17:37 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
--rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx      746 b- defN 24-Apr-29 21:32 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx    16393 b- defN 24-Apr-29 08:53 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    29872 b- defN 24-Apr-29 07:47 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx    29933 b- defN 24-May-08 20:06 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
--rw-r--r--  2.0 unx     2129 b- defN 24-May-06 13:54 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    21998 b- defN 24-May-09 18:35 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     2457 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx    21998 b- defN 24-May-14 15:28 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 10:38 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    46337 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    13437 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
--rw-r--r--  2.0 unx     6819 b- defN 24-Apr-29 22:06 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
+-rw-r--r--  2.0 unx    48946 b- defN 24-May-18 14:57 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    13522 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     7182 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      746 b- defN 24-Apr-29 21:32 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx    16393 b- defN 24-Apr-29 08:53 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    29933 b- defN 24-May-08 20:06 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx    29933 b- defN 24-May-14 19:03 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     2457 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    21998 b- defN 24-May-14 15:28 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
--rw-r--r--  2.0 unx     7090 b- defN 24-Apr-29 10:38 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    48946 b- defN 24-May-18 14:57 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    13522 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     7100 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx    48944 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    13523 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     7182 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
--rw-r--r--  2.0 unx      746 b- defN 24-Apr-29 21:32 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx    16393 b- defN 24-Apr-29 08:53 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    29933 b- defN 24-May-14 19:03 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx      746 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx    16399 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    29935 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     2457 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    21998 b- defN 24-May-14 15:28 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     7100 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx    48944 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx    13523 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     7182 b- defN 24-May-15 17:40 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      746 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx    16399 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    29935 b- defN 24-May-23 20:49 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     2457 b- defN 24-May-15 17:40 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    21998 b- defN 24-May-14 15:28 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     7100 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
 -rw-r--r--  2.0 unx    48944 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 -rw-r--r--  2.0 unx    13523 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     7182 b- defN 24-May-15 17:40 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      746 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
 -rw-r--r--  2.0 unx    16399 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    29935 b- defN 24-May-23 20:49 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 build/lib/tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 build/lib/tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 build/lib/tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/uav_collision_avoidance/version.py
--rw-r--r--  2.0 unx     2457 b- defN 24-May-15 17:40 build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    21998 b- defN 24-May-14 15:28 build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
--rw-r--r--  2.0 unx     7100 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    48944 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    13523 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
--rw-r--r--  2.0 unx     7182 b- defN 24-May-15 17:40 build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
+-rw-r--r--  2.0 unx      902 b- defN 24-May-27 12:12 build/lib/uav_collision_avoidance/docs/conf.py
+-rw-r--r--  2.0 unx     2457 b- defN 24-May-27 12:12 build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx    22241 b- defN 24-May-28 10:37 build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     7100 b- defN 24-May-27 12:12 build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx    53612 b- defN 24-May-29 10:20 build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    15131 b- defN 24-May-28 10:27 build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     7692 b- defN 24-May-28 10:05 build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
--rw-r--r--  2.0 unx      746 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx    16399 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    29935 b- defN 24-May-23 20:49 build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx      988 b- defN 24-May-28 10:43 build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx    16405 b- defN 24-May-27 20:37 build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    31060 b- defN 24-May-27 21:24 build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      169 b- defN 24-Apr-29 22:03 tests/__init__.py
--rw-r--r--  2.0 unx     1604 b- defN 24-May-29 09:59 tests/test_headless.py
+-rw-r--r--  2.0 unx     1604 b- defN 24-Jun-02 16:25 tests/test_headless.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-26 09:45 tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 uav_collision_avoidance/__init__.py
--rw-r--r--  2.0 unx     7699 b- defN 24-May-29 09:58 uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx     7761 b- defN 24-Jun-02 16:26 uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 uav_collision_avoidance/version.py
--rw-r--r--  2.0 unx      902 b- defN 24-May-27 12:12 uav_collision_avoidance/docs/conf.py
+-rw-r--r--  2.0 unx      902 b- defN 24-May-31 16:10 uav_collision_avoidance/docs/conf.py
 -rw-r--r--  2.0 unx     2457 b- defN 24-May-27 12:12 uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    22241 b- defN 24-May-28 10:37 uav_collision_avoidance/src/aircraft/aircraft_fcc.py
--rw-r--r--  2.0 unx     7100 b- defN 24-May-27 12:12 uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx    53612 b- defN 24-May-29 10:20 uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx    15131 b- defN 24-May-28 10:27 uav_collision_avoidance/src/simulation/simulation_adsb.py
--rw-r--r--  2.0 unx     7692 b- defN 24-May-28 10:05 uav_collision_avoidance/src/simulation/simulation_data.py
+-rw-r--r--  2.0 unx    22241 b- defN 24-May-31 16:10 uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     7100 b- defN 24-May-31 16:10 uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx    58313 b- defN 24-Jun-02 16:03 uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx    15131 b- defN 24-May-31 16:10 uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     7692 b- defN 24-May-31 16:10 uav_collision_avoidance/src/simulation/simulation_data.py
 -rw-r--r--  2.0 unx     2642 b- defN 24-Apr-28 18:07 uav_collision_avoidance/src/simulation/simulation_fps.py
 -rw-r--r--  2.0 unx    11104 b- defN 24-May-14 10:06 uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1341 b- defN 24-Apr-28 19:23 uav_collision_avoidance/src/simulation/simulation_render.py
--rw-r--r--  2.0 unx      988 b- defN 24-May-28 10:43 uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx    16405 b- defN 24-May-27 20:37 uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    31060 b- defN 24-May-27 21:24 uav_collision_avoidance/src/simulation/simulation_widget.py
--rw-r--r--  2.0 unx     1075 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/LICENSE
--rw-r--r--  2.0 unx    11439 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/WHEEL
--rw-r--r--  2.0 unx       73 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       80 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    54459 b- defN 24-May-29 10:25 uav_collision_avoidance-0.8.6.dist-info/RECORD
-303 files, 2155054 bytes uncompressed, 418285 bytes compressed:  80.6%
+-rw-r--r--  2.0 unx      988 b- defN 24-May-31 16:10 uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx    16405 b- defN 24-May-31 16:10 uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    31060 b- defN 24-May-31 16:10 uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     7048 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx    11425 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       73 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       80 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    59382 b- defN 24-Jun-02 22:11 uav_collision_avoidance-0.8.9.dist-info/RECORD
+322 files, 2354366 bytes uncompressed, 453788 bytes compressed:  80.7%
```

## zipnote {}

```diff
@@ -1,7 +1,58 @@
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+Comment: 
+
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
@@ -486,14 +537,17 @@
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 Comment: 
 
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py
+Comment: 
+
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
@@ -792,14 +846,17 @@
 
 Filename: build/lib/uav_collision_avoidance/main.py
 Comment: 
 
 Filename: build/lib/uav_collision_avoidance/version.py
 Comment: 
 
+Filename: build/lib/uav_collision_avoidance/docs/conf.py
+Comment: 
+
 Filename: build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 Comment: 
 
 Filename: build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 Comment: 
 
 Filename: build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
@@ -885,26 +942,26 @@
 
 Filename: uav_collision_avoidance/src/simulation/simulation_state.py
 Comment: 
 
 Filename: uav_collision_avoidance/src/simulation/simulation_widget.py
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/LICENSE
+Filename: uav_collision_avoidance-0.8.9.dist-info/LICENSE
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/METADATA
+Filename: uav_collision_avoidance-0.8.9.dist-info/METADATA
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/WHEEL
+Filename: uav_collision_avoidance-0.8.9.dist-info/WHEEL
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/entry_points.txt
+Filename: uav_collision_avoidance-0.8.9.dist-info/entry_points.txt
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/top_level.txt
+Filename: uav_collision_avoidance-0.8.9.dist-info/top_level.txt
 Comment: 
 
-Filename: uav_collision_avoidance-0.8.6.dist-info/RECORD
+Filename: uav_collision_avoidance-0.8.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -27,14 +27,16 @@
             self.target_yaw_angle : float = self.find_best_yaw_angle(aircraft.position, initial_target)
             self.add_first_destination(initial_target)
 
         self.initial_course : float = copy(self.target_yaw_angle)
         self.target_roll_angle : float = 0.0
         self.target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
+        self.__is_turning_right : bool = False
+        self.__is_turning_left : bool = False
 
         self.__evade_maneuver : bool = False
         self.vector_sharing_resolution : QVector3D | None = None
 
         self.destinations_history : List[QVector3D] = []
         self.visited : List[QVector3D] = []
     
@@ -44,37 +46,63 @@
         return self.__target_speed
     
     @target_speed.setter
     def target_speed(self, speed : float) -> None:
         """Sets target speed"""
         if speed > 0:
             self.__target_speed = speed
+    
+    @property
+    def is_turning_right(self) -> bool:
+        """Returns turning right state"""
+        return self.__is_turning_right
+    
+    @is_turning_right.setter
+    def is_turning_right(self, value : bool) -> None:
+        """Sets turning right state"""
+        self.__is_turning_right = value
+
+    @property
+    def is_turning_left(self) -> bool:
+        """Returns turning left state"""
+        return self.__is_turning_left
+    
+    @is_turning_left.setter
+    def is_turning_left(self, value : bool) -> None:
+        """Sets turning left state"""
+        self.__is_turning_left = value
 
     def add_last_destination(self, destination : QVector3D) -> None:
-        """Appends given location to the end of destinations list"""
-        assert isinstance(destination.x(), (int, float))
-        assert isinstance(destination.y(), (int, float))
-        assert isinstance(destination.z(), (int, float))
+        """Appends the given location (QVector3D) to the end of the destinations list."""
+        if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
+            raise TypeError("Destination coordinates must be int or float.")
 
         self.destinations.append(destination)
 
     def add_first_destination(self, destination : QVector3D) -> None:
         """Pushes given location to the top of destinations list"""
-        assert isinstance(destination.x(), (int, float))
-        assert isinstance(destination.y(), (int, float))
-        assert isinstance(destination.z(), (int, float))
+        if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
+            raise TypeError("Destination coordinates must be int or float.")
 
-        if len(self.destinations) > 0 and dist(destination.toTuple(), self.destinations[0].toTuple()) < 1:
+        if len(self.destinations) > 0 and dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
             print("Attempted to stack same destination")
-            logging.warning("Attempted to stack same destination")
+            logging.warning(f"Attempted to stack same destination: {destination}")
             return
 
         self.destinations.appendleft(destination)
         logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
+    @property
+    def destination(self) -> QVector3D | None:
+        """Returns current destination"""
+        if len(self.destinations) > 0:
+            return self.destinations[0]
+        else:
+            return None
+
     def append_visited(self) -> None:
         """Appends current location to visited list"""
         self.visited.append(copy(self.aircraft.position))
 
     def normalize_angle(self, angle : float) -> float:
         """Normalizes -180-180 angle into 360 domain"""
         angle = angle % 360
@@ -121,19 +149,46 @@
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         if self.__evade_maneuver:
             logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = False
             #self.vector_sharing_resolution = None
 
-    def find_best_roll_angle(self, current_yaw_angle : float, target_yaw_angle : float) -> float:
+    def find_best_roll_angle(self, current_yaw_angle: float, target_yaw_angle: float) -> float:
         """Finds best roll angle for the targeted yaw angle"""
         difference = (target_yaw_angle - current_yaw_angle + 180) % 360 - 180
-        return 0.0 if abs(difference) < 0.01 else 30.0 if difference > 0 else -30.0
-
+        if abs(difference) < 0.001:
+            self.is_turning_right = False
+            self.is_turning_left = False
+            return 0.0
+        elif difference > 0:
+            self.is_turning_right = True
+            self.is_turning_left = False
+            if difference > 90:
+                return 30.0
+            elif difference > 45:
+                return 20.0
+            elif difference > 20:
+                return 10.0
+            else:
+                return 5.0
+        elif difference < 0:
+            self.is_turning_left = True
+            self.is_turning_right = False
+            if difference < -90:
+                return -30.0
+            elif difference < -45:
+                return -20.0
+            elif difference < -20:
+                return -10.0
+            else:
+                return -5.0
+        else:
+            return 0.0
+        
     def find_best_yaw_angle(self, position : QVector3D, destination : QVector3D) -> float:
         """Finds best yaw angle for the given destination"""
         target_yaw_angle : float  = degrees(atan2(
             destination.y() - position.y(),
             destination.x() - position.x()))
         target_yaw_angle += 90
         return self.format_angle(target_yaw_angle)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -23,38 +23,46 @@
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
         super().__init__()
         SimulationSettings().__init__()
         if aircrafts is None:
-            self.aircrafts : List[Aircraft] = [
-                Aircraft( # detection test
-                    position = QVector3D(100, 1000, 1000),
-                    speed = QVector3D(50, -50, 0),
-                    initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
-                Aircraft(
-                    position = QVector3D(900, 1300, 1000),
-                    speed = QVector3D(0, -70, 0),
-                    initial_target = QVector3D(900, -1_001_300, 1000)),
-                # Aircraft( # head on
-                #     position = QVector3D(100, 500, 1000),
-                #     speed = QVector3D(70, 0, 0)),
-                # Aircraft(
-                #     position = QVector3D(900, 500, 1000),
-                #     speed = QVector3D(-50, 0, 0)),
-                # Aircraft( # avoidance test
-                #     position = QVector3D(10, -10, 0),
-                #     speed = QVector3D(300, -300, 0),
-                #     initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
-                # Aircraft(
-                #     position = QVector3D(0, -100_000, 0),
-                #     speed = QVector3D(300, 290, 0),
-                #     initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
-            ]
+            test_case : int = 0
+            if test_case == 0:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # detection test
+                        position = QVector3D(-800, 4000, 1000),
+                        speed = QVector3D(60, -60, 0),
+                        initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
+                    Aircraft(
+                        position = QVector3D(4000, 6000, 1000),
+                        speed = QVector3D(0, -85, 0),
+                        initial_target = QVector3D(900, -1_001_300, 1000)),
+                ]
+            elif test_case == 1:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # almost head on
+                        position = QVector3D(-3000, 500, 1000),
+                        speed = QVector3D(70, 0.1, 0)),
+                    Aircraft(
+                        position = QVector3D(5000, 500, 1000),
+                        speed = QVector3D(-50, 0, 0)),
+                ]
+            elif test_case == 2:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # avoidance test
+                        position = QVector3D(10, -10, 1000),
+                        speed = QVector3D(300, -300, 0),
+                        initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
+                    Aircraft(
+                        position = QVector3D(0, -100_000, 1000),
+                        speed = QVector3D(300, 290, 0),
+                        initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
+                ]
         else:
             self.aircrafts = aircrafts
         self.simulation_time : int = simulation_time
         self.state : SimulationState | None = None
 
     def run_realtime(self) -> None:
         """Executes realtime simulation"""
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -40,14 +40,22 @@
             self.adsb_cycles += 1
             self.simulation_state.update_adsb_settings()
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
+            
+            for aircraft in self.aircraft_vehicles:
+                # path
+                self.aircraft_fccs[aircraft.aircraft_id].append_visited()
+
+                # console output
+                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
+                    self.print_adsb_report(aircraft)
 
             if not self.simulation_state.avoid_collisions:
                 return
 
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
@@ -81,31 +89,43 @@
                 if collision_region > 0:
                     print("Collision detected")
             else:
                 for aircraft in self.aircraft_fccs:
                     if aircraft.evade_maneuver:
                         aircraft.reset_evade_maneuver()
 
-            for aircraft in self.aircraft_vehicles:
-                # path
-                self.aircraft_fccs[aircraft.aircraft_id].append_visited()
-
-                # console output
-                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
-                    self.print_adsb_report(aircraft)
-
     def print_adsb_report(self, aircraft : AircraftVehicle) -> None:
         """Prints ADS-B report for the aircraft to the console"""
-        print("Aircraft id: " + str(aircraft.aircraft_id) +
+        fcc = self.aircraft_fccs[aircraft.aircraft_id]
+        turning_direction = "Not turning"
+        if fcc.is_turning_left:
+            turning_direction = "Turning left"
+        elif fcc.is_turning_right:
+            turning_direction = "Turning right"
+        print("- Aircraft id: " + str(aircraft.aircraft_id) +
             "; speed: " + "{:.2f}".format(aircraft.absolute_speed) +
-            "; target speed: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_speed) +
+            "; turning: " + turning_direction +
+            "; roll angle: " + "{:.2f}".format(aircraft.roll_angle) +
+            "; target roll angle: " + "{:.2f}".format(fcc.target_roll_angle) +
+            "; yaw angle: " + "{:.2f}".format(aircraft.yaw_angle) +
+            "; target yaw angle: " + "{:.2f}".format(fcc.target_yaw_angle) +
             "; x: " + "{:.2f}".format(aircraft.position.x()) +
             "; y: " + "{:.2f}".format(aircraft.position.y()) +
-            "; yaw angle: " + "{:.2f}".format(aircraft.yaw_angle) +
-            "; target yaw angle: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_yaw_angle) +
-            "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
-            "; roll angle: " + "{:.2f}".format(aircraft.roll_angle) +
-            "; target roll angle: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_roll_angle) +
-            "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
-            "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
-            "; t: " + str(self.adsb_cycles) +
-            "; phys: " + str(self.simulation_state.physics_cycles))
+            "; z: " + "{:.2f}".format(aircraft.position.z()))
+        if fcc.destination is not None:
+            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                "; dest x: " + "{:.2f}".format(fcc.destination.x()) +
+                "; dest y: " + "{:.2f}".format(fcc.destination.y()) +
+                "; dest z: " + "{:.2f}".format(fcc.destination.z()) +
+                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                "; t: " + str(self.adsb_cycles) +
+                "; phys: " + str(self.simulation_state.physics_cycles))
+        else:
+            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                "; t: " + str(self.adsb_cycles) +
+                "; phys: " + str(self.simulation_state.physics_cycles) +
+                "; no destination")
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -117,34 +117,24 @@
             # pitch angle
 
             # yaw angle
             roll_angle : float = aircraft.roll_angle
 
             if roll_angle == 0.0:
                 continue
-            elif fcc.target_roll_angle > 0.0 and roll_angle < 0.0:
-                continue
-            elif fcc.target_roll_angle < 0.0 and roll_angle > 0.0:
-                continue
 
             current_yaw_angle : float = aircraft.yaw_angle
             target_yaw_angle : float = fcc.target_yaw_angle
             if abs(current_yaw_angle - target_yaw_angle) < 0.001:
                 continue
             current_horizontal_speed : float = aircraft.horizontal_speed
-            max_delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
-            max_delta_yaw_angle = abs(max_delta_yaw_angle)
-            if roll_angle < 0.0:
-                max_delta_yaw_angle = -max_delta_yaw_angle
+            delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
 
             new_yaw_angle : float = 0.0
-            if abs(current_yaw_angle - target_yaw_angle) < abs(max_delta_yaw_angle):
-                new_yaw_angle = target_yaw_angle
-            else:
-                new_yaw_angle = current_yaw_angle + max_delta_yaw_angle
+            new_yaw_angle = current_yaw_angle + delta_yaw_angle
 
             aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
             aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
 
     def count_cycles(self) -> None:
         """Increments physics cycle counter"""
         self.cycles += 1
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -23,28 +23,32 @@
         self.minimum_separation : float = 9260.0 # 5nmi
         self.physics_cycles : int = 0
         self.is_paused : bool = False
         self.is_running : bool = True
         self.__reset_demanded : bool = False
         self.pause_start_timestamp : QTime | None = None
         self.time_paused : int = 0 # ms
-        self.__adsb_report : bool = False
+        self.__adsb_report : bool = True
         self.__collision : bool = False
         self.__first_cause_collision : bool = False
         self.__second_cause_collision : bool = False
 
         if is_realtime:
             # render state
-            self.__gui_scale : float = 1.0 # define gui scaling
-            if SimulationSettings.screen_resolution.height() < 1440:
-                self.gui_scale = 0.75
-            elif SimulationSettings.screen_resolution.height() < 1080:
-                self.gui_scale = 0.5
-            elif SimulationSettings.screen_resolution.height() < 480:
-                self.gui_scale = 0.25
+            override_gui_scale : bool = True
+            if not override_gui_scale:
+                self.__gui_scale : float = 0.5 # define gui scaling
+                if SimulationSettings.screen_resolution.height() < 1440:
+                    self.gui_scale = 0.375
+                elif SimulationSettings.screen_resolution.height() < 1080:
+                    self.gui_scale = 0.25
+                elif SimulationSettings.screen_resolution.height() < 480:
+                    self.gui_scale = 0.125
+            else:
+                self.__gui_scale : float = 0.75
             self.fps : float = 0.0
             self.draw_fps : bool = True
             self.draw_aircraft : bool = True
             self.draw_grid : bool = False
             self.draw_path : bool = True
             self.draw_speed_vectors : bool = True
             self.draw_collision_detection : bool = True
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -396,17 +396,17 @@
                 return super().keyPressEvent(event)
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.reset()
         elif event.key() == Qt.Key.Key_Plus:
-            self.zoom(0.25)
+            self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
-            self.zoom(-0.25)
+            self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
             self.simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
             self.aircraft_fccs[0].target_speed -= 10.0
         elif event.key() == Qt.Key.Key_F3:
             self.aircraft_fccs[0].target_speed += 10.0
         elif event.key() == Qt.Key.Key_O:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -29,14 +29,15 @@
 
         self.initial_course : float = copy(self.target_yaw_angle)
         self.target_roll_angle : float = 0.0
         self.target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
         self.__is_turning_right : bool = False
         self.__is_turning_left : bool = False
+        self.ignore_destinations : bool = False
 
         self.__evade_maneuver : bool = False
         self.vector_sharing_resolution : QVector3D | None = None
 
         self.destinations_history : List[QVector3D] = []
         self.visited : List[QVector3D] = []
     
@@ -120,34 +121,49 @@
 
     def apply_evade_maneuver(self, opponent_speed : QVector3D, miss_distance_vector : QVector3D, unresolved_region : float, time_to_closest_approach : float) -> None:
         """Applies evade maneuver"""
         print(str(self.aircraft.aircraft_id) + ": opponent speed: " + "{:.2f}".format(opponent_speed.x()) + " " + "{:.2f}".format(opponent_speed.y()) + " " + "{:.2f}".format(opponent_speed.z()))
         print(str(self.aircraft.aircraft_id) + ": miss distance vector: " + "{:.2f}".format(miss_distance_vector.x()) + " " + "{:.2f}".format(miss_distance_vector.y()) + " " + "{:.2f}".format(miss_distance_vector.z()))
         print(str(self.aircraft.aircraft_id) + ": unresolved region: " + "{:.2f}".format(unresolved_region))
         print(str(self.aircraft.aircraft_id) + ": time to closest approach: " + "{:.2f}".format(time_to_closest_approach))
-        
-        if (miss_distance_vector.x() == 0 and miss_distance_vector.y() == 0 and miss_distance_vector.z() == 0):
-            return
 
         if self.__evade_maneuver:
             logging.warning("Another evade maneuver in progress")
         else:
             print(f"Aircraft {self.aircraft.aircraft_id} applying evade maneuver")
             logging.info("Aircraft %s applying evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = True
-            self.vector_sharing_resolution : QVector3D | None = None
-            if self.aircraft_id == 0:
-                self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * -(miss_distance_vector)) / ((self.aircraft.speed.length() + opponent_speed.length()) * miss_distance_vector.length())
+
+            # this is temporal solution of the problem below
+            if miss_distance_vector.length() == 0:
+                miss_distance_vector = QVector3D(0.01, 0.01, 0.0)
+
+            target_avoiding : QVector3D = QVector3D()
+            if miss_distance_vector.length() == 0:
+                # todo: fix or just change height
+                # modified_speed_vector : QVector3D = self.aircraft.speed + 0.01 * (self.aircraft.speed.normalized().z() * self.aircraft.speed)
+                # modified_speed_vector : QVector3D = self.aircraft.speed + 0.01 * QVector3D.crossProduct(self.aircraft.speed.normalized(), self.aircraft.speed)
+                # modified_speed_vector : QVector3D = self.aircraft.speed + (QVector3D.crossProduct(QVector3D(0, 0, self.aircraft.speed.normalized().z()), self.aircraft.speed))
+                # print("Modified speed vector: " + "{:.2f}".format(modified_speed_vector.x()) + " " + "{:.2f}".format(modified_speed_vector.y()) + " " + "{:.2f}".format(modified_speed_vector.z()))
+                # unit_vector : QVector3D = modified_speed_vector.normalized()
+                # print("Unit vector: " + "{:.2f}".format(unit_vector.x()) + " " + "{:.2f}".format(unit_vector.y()) + " " + "{:.2f}".format(unit_vector.z()))
+                # target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
+                pass
             else:
-                self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * miss_distance_vector) / ((opponent_speed.length() + self.aircraft.speed.length()) * miss_distance_vector.length())
-            print("Vector sharing resolution: " + "{:.2f}".format(self.vector_sharing_resolution.x()) + " " + "{:.2f}".format(self.vector_sharing_resolution.y()) + " " + "{:.2f}".format(self.vector_sharing_resolution.z()))
+                self.vector_sharing_resolution : QVector3D | None = None
+                if self.aircraft_id == 0:
+                    self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * -(miss_distance_vector)) / ((self.aircraft.speed.length() + opponent_speed.length()) * miss_distance_vector.length())
+                elif self.aircraft_id == 1:
+                    self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * miss_distance_vector) / ((opponent_speed.length() + self.aircraft.speed.length()) * miss_distance_vector.length())
+                print("Vector sharing resolution: " + "{:.2f}".format(self.vector_sharing_resolution.x()) + " " + "{:.2f}".format(self.vector_sharing_resolution.y()) + " " + "{:.2f}".format(self.vector_sharing_resolution.z()))
+                modified_speed_vector : QVector3D = (self.aircraft.speed * time_to_closest_approach + self.vector_sharing_resolution)
+                unit_vector : QVector3D = modified_speed_vector.normalized()
+                target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
             
-            # self.vector_sharing_resolution *= 2
-
-            target_avoiding : QVector3D = self.aircraft.position + (self.aircraft.speed * time_to_closest_approach + self.vector_sharing_resolution)
+            print("Set target avoiding collision: " + "{:.2f}".format(target_avoiding.x()) + " " + "{:.2f}".format(target_avoiding.y()) + " " + "{:.2f}".format(target_avoiding.z()))
             self.add_first_destination(target_avoiding)
 
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         if self.__evade_maneuver:
             logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = False
@@ -191,15 +207,15 @@
             destination.y() - position.y(),
             destination.x() - position.x()))
         target_yaw_angle += 90
         return self.format_angle(target_yaw_angle)
 
     def update_target_yaw_angle(self) -> None:
         """Updates current yaw angle"""
-        if self.destinations:
+        if self.destinations and not self.ignore_destinations:
             destination = self.destinations[0]
             distance = dist(self.aircraft.position.toTuple(), destination.toTuple())
             if distance < self.aircraft.size / 2:
                 self.destinations_history.append(self.destinations.popleft())
                 if self.destinations:
                     destination = self.destinations[0]
                     logging.info("Aircraft %s visited destination and took next one", self.aircraft.aircraft_id)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -23,15 +23,15 @@
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
         super().__init__()
         SimulationSettings().__init__()
         if aircrafts is None:
-            test_case : int = 0
+            test_case : int = 3
             if test_case == 0:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # detection test
                         position = QVector3D(-800, 4000, 1000),
                         speed = QVector3D(60, -60, 0),
                         initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
                     Aircraft(
@@ -47,21 +47,32 @@
                     Aircraft(
                         position = QVector3D(5000, 500, 1000),
                         speed = QVector3D(-50, 0, 0)),
                 ]
             elif test_case == 2:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # avoidance test
-                        position = QVector3D(10, -10, 1000),
+                        position = QVector3D(0, 0, 1000),
+                        speed = QVector3D(30, -30, 0),
+                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
+                    Aircraft(
+                        position = QVector3D(0, -100_000, 1000),
+                        speed = QVector3D(30, 29, 0),
+                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
+                ]
+            elif test_case == 3:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # avoidance test fast
+                        position = QVector3D(0, 0, 1000),
                         speed = QVector3D(300, -300, 0),
-                        initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
+                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                     Aircraft(
                         position = QVector3D(0, -100_000, 1000),
                         speed = QVector3D(300, 290, 0),
-                        initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
+                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
                 ]
         else:
             self.aircrafts = aircrafts
         self.simulation_time : int = simulation_time
         self.state : SimulationState | None = None
 
     def run_realtime(self) -> None:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -62,16 +62,15 @@
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m")
 
                 if miss_distance_vector.length() == 0:
                     print("Head-on collision detected")
-                    # todo: height change maneuver
-                    # else other evade maneuver
+                    logging.info("Head-on collision detected")
 
                 # resolve confict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
                     print("Conflict condition detected")
                     for aircraft in self.aircraft_fccs:
                         if not aircraft.evade_maneuver:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -38,24 +38,42 @@
             SimulationSettings.screen_resolution.height() / 2 - self.window_height / 2 - 30,
             self.window_width,
             self.window_height)
         self.setStyleSheet("background-color: white;")
         self.setWindowTitle(QApplication.applicationName() + " " + QApplication.applicationVersion())
 
         self.icon = QIcon()
-        self.icon.addPixmap(self.simulation_state.aircraft_pixmap, QIcon.Mode.Normal, QIcon.State.Off)
+        self.icon.addPixmap(self.generate_icon(), QIcon.Mode.Normal, QIcon.State.Off)
         self.setWindowIcon(self.icon)
 
-        self.__moving_view_up = False
-        self.__moving_view_down = False
-        self.__moving_view_left = False
-        self.__moving_view_right = False
+        self.__moving_view_up : bool = False
+        self.__moving_view_down : bool = False
+        self.__moving_view_left : bool = False
+        self.__moving_view_right : bool = False
+        self.__steering_left : bool = False
+        self.__steering_right : bool = False
+        self.__steering_up : bool = False
+        self.__steering_down : bool = False
 
         self.center_offsets()
 
+    def generate_icon(self) -> QPixmap:
+        """Returns icon for the main window"""
+        pixmap = QPixmap(self.simulation_state.aircraft_pixmap)
+        painter = QPainter(pixmap)
+        painter.setBrush(QColor("white"))
+        painter.drawEllipse(self.simulation_state.aircraft_pixmap.rect())
+        painter.drawPixmap(
+            self.simulation_state.aircraft_pixmap.width() * 0.125,
+            self.simulation_state.aircraft_pixmap.height() * 0.125,
+            self.simulation_state.aircraft_pixmap.scaled(self.simulation_state.aircraft_pixmap.width() * 0.75,
+            self.simulation_state.aircraft_pixmap.height() * 0.75))
+        painter.end()
+        return pixmap
+
     def draw_aircraft(self, aircraft : AircraftVehicle, scale : float) -> None:
         """Draws given aircraft vehicle"""
         yaw_angle : float = aircraft.yaw_angle
         size : float = aircraft.size * scale
         pixmap : QPixmap
         if not self.simulation_state.aircraft_pixmap.isNull():
             pixmap = self.simulation_state.aircraft_pixmap.scaled(
@@ -272,14 +290,40 @@
         if self.__moving_view_down:
             self.screen_offset_y -= 10.0 / scale
         if self.__moving_view_left:
             self.screen_offset_x += 10.0 / scale
         if self.__moving_view_right:
             self.screen_offset_x -= 10.0 / scale
 
+    def update_steering(self) -> None:
+        """Updates aircraft steering based on current input"""
+        if self.aircrafts[0] and (self.__steering_up or self.__steering_down or self.__steering_left or self.__steering_right):
+            if sum([self.__steering_up, self.__steering_down, self.__steering_left, self.__steering_right]) >= 3:
+                return
+            self.aircraft_fccs[0].ignore_destinations = True
+            target_yaw_angle : float | None = None
+            if self.__steering_up and self.__steering_left:
+                target_yaw_angle = -45.0
+            elif self.__steering_up and self.__steering_right:
+                target_yaw_angle = 45.0
+            elif self.__steering_down and self.__steering_left:
+                target_yaw_angle = -135.0
+            elif self.__steering_down and self.__steering_right:
+                target_yaw_angle = 135.0
+            elif self.__steering_up:
+                target_yaw_angle = 0.0
+            elif self.__steering_down:
+                target_yaw_angle = 180.0
+            elif self.__steering_left:
+                target_yaw_angle = -90.0
+            elif self.__steering_right:
+                target_yaw_angle = 90.0
+            if target_yaw_angle is not None:
+                self.aircraft_fccs[0].target_yaw_angle = target_yaw_angle
+
     def center_offsets(self) -> None:
         """Updates screen offsets centering on selected aircraft"""
         scale : float = self.simulation_state.gui_scale
         id = self.simulation_state.focus_aircraft_id
         self.screen_offset_x = - self.aircraft_vehicles[id].position.x() + self.window_width / 2 / scale
         self.screen_offset_y = - self.aircraft_vehicles[id].position.y() + self.window_height / 2 / scale
 
@@ -291,21 +335,22 @@
     def zoom(self, factor : float) -> None:
         """Zooms in/out the simulation render"""
         if self.simulation_state.gui_scale + factor <= 0:
             return
         old_scale : float = self.simulation_state.gui_scale
         self.simulation_state.gui_scale += factor
         scale : float = self.simulation_state.gui_scale
-        self.screen_offset_x = self.screen_offset_x * old_scale / scale
-        self.screen_offset_y = self.screen_offset_y * old_scale / scale
+        self.screen_offset_x = self.screen_offset_x * (old_scale / scale)
+        self.screen_offset_y = self.screen_offset_y * (old_scale / scale)
 
     def paintEvent(self, event : QPaintEvent) -> None:
         """Qt method painting the aircrafts"""
         self.simulation_fps.count_frame()
         scale : float = self.simulation_state.gui_scale
+        self.update_steering()
         if not self.simulation_state.follow_aircraft:
             self.update_moving_offsets()
         else:
             self.center_offsets()
 
         if self.simulation_state.draw_fps:
             self.draw_text(QVector3D(10, 10, 0), 0, "FPS: " + "{:.2f}".format(self.simulation_state.fps))
@@ -395,14 +440,15 @@
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.reset()
+            self.center_offsets()
         elif event.key() == Qt.Key.Key_Plus:
             self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
             self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
             self.simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
@@ -425,35 +471,45 @@
             self.__moving_view_right = True
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = True
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = True
         if self.aircrafts[0]:
             if event.key() == Qt.Key.Key_A:
-                self.aircraft_fccs[0].target_yaw_angle = -90.0
+                self.__steering_left = True
             elif event.key() == Qt.Key.Key_D:
-                self.aircraft_fccs[0].target_yaw_angle = 90.0
+                self.__steering_right = True
             elif event.key() == Qt.Key.Key_W:
-                self.aircraft_fccs[0].target_yaw_angle = 0.0
+                self.__steering_up = True
             elif event.key() == Qt.Key.Key_S:
-                self.aircraft_fccs[0].target_yaw_angle = 180.0
+                self.__steering_down = True
         return super().keyPressEvent(event)
     
     def keyReleaseEvent(self, event: QKeyEvent) -> None:
         """Qt method controlling keyboard input"""
         if event.key() == Qt.Key.Key_Slash and event.isAutoRepeat() and self.simulation_state.is_paused:
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_Left:
             self.__moving_view_left = False
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = False
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = False
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = False
+        if self.aircrafts[0]:
+            self.aircraft_fccs[0].ignore_destinations = False
+            if event.key() == Qt.Key.Key_A:
+                self.__steering_left = False
+            elif event.key() == Qt.Key.Key_D:
+                self.__steering_right = False
+            elif event.key() == Qt.Key.Key_W:
+                self.__steering_up = False
+            elif event.key() == Qt.Key.Key_S:
+                self.__steering_down = False
         return super().keyReleaseEvent(event)
     
     def resizeEvent(self, event: QPaintEvent) -> None:
         """Qt method controlling window resize event"""
         self.update_resolutions()
         return super().resizeEvent(event)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -31,14 +31,15 @@
         self.target_roll_angle : float = 0.0
         self.target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
         self.__is_turning_right : bool = False
         self.__is_turning_left : bool = False
         self.ignore_destinations : bool = False
 
+        self.__safe_zone_occupied : bool = False
         self.__evade_maneuver : bool = False
         self.vector_sharing_resolution : QVector3D | None = None
 
         self.destinations_history : List[QVector3D] = []
         self.visited : List[QVector3D] = []
     
     @property
@@ -68,33 +69,43 @@
         return self.__is_turning_left
     
     @is_turning_left.setter
     def is_turning_left(self, value : bool) -> None:
         """Sets turning left state"""
         self.__is_turning_left = value
 
-    def add_last_destination(self, destination : QVector3D) -> None:
-        """Appends the given location (QVector3D) to the end of the destinations list."""
+    def check_new_destination(self, destination : QVector3D, first : bool) -> QVector3D | None:
+        """Checks if the given destination is already in the destinations list"""
         if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
             raise TypeError("Destination coordinates must be int or float.")
+        if len(self.destinations) > 0 and first:
+            if dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
+                print("Attempted to stack same destination")
+                logging.warning(f"Attempted to stack same destination: {destination}")
+                return None
+        elif len(self.destinations) > 0 and not first:
+            if dist(destination.toTuple(), self.destinations[len(self.destinations) - 1].toTuple()) < 1.0:
+                print("Attempted to stack same destination")
+                logging.warning(f"Attempted to stack same destination: {destination}")
+                return None
+        return destination
 
-        self.destinations.append(destination)
+    def add_last_destination(self, destination : QVector3D) -> None:
+        """Appends the given location (QVector3D) to the end of the destinations list."""
+        destination = self.check_new_destination(destination, False)
+        if destination is not None:
+            self.destinations.append(destination)
+            logging.info("Aircraft %s added new last destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
     def add_first_destination(self, destination : QVector3D) -> None:
         """Pushes given location to the top of destinations list"""
-        if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
-            raise TypeError("Destination coordinates must be int or float.")
-
-        if len(self.destinations) > 0 and dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
-            print("Attempted to stack same destination")
-            logging.warning(f"Attempted to stack same destination: {destination}")
-            return
-
-        self.destinations.appendleft(destination)
-        logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
+        destination = self.check_new_destination(destination, True)
+        if destination is not None:
+            self.destinations.appendleft(destination)
+            logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
     @property
     def destination(self) -> QVector3D | None:
         """Returns current destination"""
         if len(self.destinations) > 0:
             return self.destinations[0]
         else:
@@ -105,20 +116,36 @@
         self.visited.append(copy(self.aircraft.position))
 
     def normalize_angle(self, angle : float) -> float:
         """Normalizes -180-180 angle into 360 domain"""
         angle = angle % 360
         return angle if angle >= 0 else angle + 360
 
-    def format_angle(self, angle : float) -> float:
+    def format_yaw_angle(self, angle : float) -> float:
         """Formats angle into -180-180 domain"""
         angle = self.normalize_angle(angle)
         return angle if angle <= 180 else -180 + (angle - 180)
     
     @property
+    def safe_zone_occupied(self) -> bool:
+        """Returns safe zone occupied state"""
+        return self.__safe_zone_occupied
+    
+    @safe_zone_occupied.setter
+    def safe_zone_occupied(self, value : bool) -> None:
+        """Sets safe zone occupied state"""
+        if self.__safe_zone_occupied and value:
+            print("Safe zone already occupied")
+            logging.warning("Safe zone already occupied")
+        if not self.__safe_zone_occupied and not value:
+            print("Safe zone already free")
+            logging.warning("Safe zone already free")
+        self.__safe_zone_occupied = value
+    
+    @property
     def evade_maneuver(self) -> bool:
         """Returns evade maneuver state"""
         return self.__evade_maneuver
 
     def apply_evade_maneuver(self, opponent_speed : QVector3D, miss_distance_vector : QVector3D, unresolved_region : float, time_to_closest_approach : float) -> None:
         """Applies evade maneuver"""
         print(str(self.aircraft.aircraft_id) + ": opponent speed: " + "{:.2f}".format(opponent_speed.x()) + " " + "{:.2f}".format(opponent_speed.y()) + " " + "{:.2f}".format(opponent_speed.z()))
@@ -203,17 +230,24 @@
         
     def find_best_yaw_angle(self, position : QVector3D, destination : QVector3D) -> float:
         """Finds best yaw angle for the given destination"""
         target_yaw_angle : float  = degrees(atan2(
             destination.y() - position.y(),
             destination.x() - position.x()))
         target_yaw_angle += 90
-        return self.format_angle(target_yaw_angle)
+        return self.format_yaw_angle(target_yaw_angle)
+    
+    def find_best_pitch_angle(self, position : QVector3D, destination : QVector3D) -> float:
+        """Finds best pitch angle for the given destination"""
+        target_pitch_angle : float = degrees(atan2(
+            destination.z() - position.z(),
+            dist(position.toTuple(), destination.toTuple())))
+        return target_pitch_angle
 
-    def update_target_yaw_angle(self) -> None:
+    def update_target_yaw_pitch_angles(self) -> None:
         """Updates current yaw angle"""
         if self.destinations and not self.ignore_destinations:
             destination = self.destinations[0]
             distance = dist(self.aircraft.position.toTuple(), destination.toTuple())
             if distance < self.aircraft.size / 2:
                 self.destinations_history.append(self.destinations.popleft())
                 if self.destinations:
@@ -223,14 +257,17 @@
                 else:
                     logging.info("Aircraft %s visited destination and is free now", self.aircraft.aircraft_id)
                     print(f"Aircraft {self.aircraft.aircraft_id} visited destination and is free now")
                     return
             self.target_yaw_angle = self.find_best_yaw_angle(
                 self.aircraft.position,
                 destination)
+            self.target_pitch_angle = self.find_best_pitch_angle(
+                self.aircraft.position,
+                destination)
             
     def update_target_roll_angle(self) -> None:
         """Updates target roll angle"""
         current_yaw_angle = self.normalize_angle(self.aircraft.yaw_angle)
         target_yaw_angle = self.normalize_angle(self.target_yaw_angle)
         self.target_roll_angle = self.find_best_roll_angle(current_yaw_angle, target_yaw_angle)
 
@@ -240,21 +277,21 @@
                 next_position = self.destinations[0]
                 next_destination = self.destinations[1]
                 next_target_yaw_angle : float = self.find_best_yaw_angle(next_position, next_destination)
                 self.target_roll_angle = self.find_best_roll_angle(current_yaw_angle, next_target_yaw_angle)
 
     def update(self) -> None:
         """Updates current targeted movement angles"""
-        self.update_target_yaw_angle()
+        self.update_target_yaw_pitch_angles()
         self.update_target_roll_angle()
 
     def update_target(self, target : QVector3D) -> None:
         """Updates target position"""
         self.target_yaw_angle = self.find_best_yaw_angle(self.aircraft.position, target)
-        self.update_target_roll_angle()    
+        self.update_target_roll_angle()      
 
     def reset(self) -> None:
         """Resets aircraft flight control computer"""
         self.destinations.clear()
         self.destinations_history.clear()
         self.visited.clear()
         self.target_yaw_angle = self.initial_course
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -23,25 +23,25 @@
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
         super().__init__()
         SimulationSettings().__init__()
         if aircrafts is None:
-            test_case : int = 3
+            test_case : int = 0
             if test_case == 0:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # detection test
                         position = QVector3D(-800, 4000, 1000),
                         speed = QVector3D(60, -60, 0),
-                        initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
+                        initial_target = QVector3D(1_000_100, -1_001_000, 10000)),
                     Aircraft(
                         position = QVector3D(4000, 6000, 1000),
                         speed = QVector3D(0, -85, 0),
-                        initial_target = QVector3D(900, -1_001_300, 1000)),
+                        initial_target = QVector3D(900, -1_001_300, 10000)),
                 ]
             elif test_case == 1:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # almost head on
                         position = QVector3D(-3000, 500, 1000),
                         speed = QVector3D(70, 0.1, 0)),
                     Aircraft(
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -42,21 +42,42 @@
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
             
             for aircraft in self.aircraft_vehicles:
+                fcc : AircraftFCC = self.aircraft_fccs[aircraft.aircraft_id]
+
                 # path
-                self.aircraft_fccs[aircraft.aircraft_id].append_visited()
+                fcc.append_visited()
+
+                # console destination reach time
+                if fcc.destination and self.simulation_state.adsb_report:
+                    time_to_reaching_destination : float = (QVector3D.dotProduct(fcc.destination - aircraft.position, aircraft.speed) / QVector3D.dotProduct(aircraft.speed, aircraft.speed))
+                    print(f"Aircraft {aircraft.aircraft_id} will reach its destination in " + "{:.2f}".format(time_to_reaching_destination) + " (" + "{:.1f}".format(time_to_reaching_destination / 60) + " minutes or " + "{:.1f}".format(time_to_reaching_destination / 3600) + " hours)")
 
-                # console output
+                # console report output
                 if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
                     self.print_adsb_report(aircraft)
 
+                # safe zone occupancy check
+                if relative_position.length() < self.simulation_state.minimum_separation:
+                    if not fcc.safe_zone_occupied:
+                        fcc.safe_zone_occupied = True
+                        if not self.simulation_state.override_avoid_collisions:
+                            self.simulation_state.avoid_collisions = True
+                    print("Safe zone occupied")
+                else:
+                    if fcc.safe_zone_occupied:
+                        fcc.safe_zone_occupied = False
+                        self.simulation_state.avoid_collisions = False
+                    print("Safe zone free")
+                    return
+
             if not self.simulation_state.avoid_collisions:
                 return
 
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -1,12 +1,12 @@
 """Simulation physics thread module"""
 
 import logging
 from copy import copy
-from math import sin, cos, dist, tan, radians
+from math import sin, cos, dist, tan, radians, sqrt
 from typing import List
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QVector3D
 from PySide6.QtWidgets import QApplication, QMainWindow
 
 from ..aircraft.aircraft import Aircraft
@@ -50,15 +50,15 @@
         if self.simulation_state.reset_demanded:
             self.reset_aircrafts()
         if not self.simulation_state.is_paused:
             self.count_cycles()
             self.simulation_state.update_simulation_settings()
             self.update_aircrafts_speed_angles(elapsed_time)
             if self.update_aircrafts_position(elapsed_time):
-                logging.warn("Aircrafts collided at coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
+                logging.warn("Collision Occured. Aircrafts coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
                 QApplication.beep()
                 self.simulation_state.register_collision()
                 if self.isRunning():
                     self.requestInterruption()
 
     def reset_aircrafts(self) -> None:
         """Resets aircrafts to initial state"""
@@ -67,17 +67,20 @@
         self.aircraft_fccs[0].reset()
         self.aircraft_fccs[1].reset()
         self.simulation_state.apply_reset()
 
     def update_aircrafts_position(self, elapsed_time : float) -> bool:
         """Updates aircrafts position, returns true on collision"""
         for aircraft in self.aircraft_vehicles:
+            if aircraft.position.z() <= 0.0:
+                print("Collision with ground")
+                return True
             relative_distance : float = dist(aircraft.position.toTuple(), self.aircraft_vehicles[1 - aircraft.aircraft_id].position.toTuple())
             if relative_distance <= aircraft.size:
-                print("Collision")
+                print("Collision with another aircraft")
                 return True
             old_pos : QVector3D = copy(aircraft.position)
             aircraft.move(
                 aircraft.speed.x() * elapsed_time / 1000.0,
                 aircraft.speed.y() * elapsed_time / 1000.0,
                 aircraft.speed.z() * elapsed_time / 1000.0)
             aircraft.distance_covered = dist(old_pos.toTuple(), aircraft.position.toTuple())
@@ -93,15 +96,15 @@
             cause_collision = self.simulation_state.first_cause_collision if id == 0 else self.simulation_state.second_cause_collision
             fcc.update() if not cause_collision else fcc.update_target(self.aircraft_vehicles[1 - id].position + self.aircraft_vehicles[1 - id].speed)
             
             # speed
             current_speed = aircraft.absolute_speed
             target_speed = fcc.target_speed
             speed_difference = abs(current_speed - target_speed)
-            if speed_difference > 0.001 and target_speed > 20.0:
+            if speed_difference > 0.001 and current_speed > 20.0 and current_speed < 340: # make drone subsonic
                 max_speed_delta = aircraft.max_acceleration / elapsed_time
                 if speed_difference < max_speed_delta:
                     pass # become target
                 elif current_speed < target_speed:
                     target_speed = current_speed + max_speed_delta
                 else:
                     target_speed = current_speed - max_speed_delta
@@ -111,31 +114,48 @@
                     aircraft.speed.y() * speed_scale_factor,
                     aircraft.speed.z() * speed_scale_factor)
 
             # roll angle
             aircraft.roll_angle = (1.0 / (aircraft.roll_dynamic_delay / elapsed_time)) * (fcc.target_roll_angle - aircraft.roll_angle)
 
             # pitch angle
+            current_pitch_angle : float = aircraft.pitch_angle
+            target_pitch_angle : float = copy(fcc.target_pitch_angle)
+            if not abs(current_pitch_angle - target_pitch_angle) < 0.001 and current_pitch_angle < 90.0 and current_pitch_angle > -90.0:
+                delta_pitch_angle : float = (1.0 / (aircraft.pitch_dynamic_delay / elapsed_time)) * (target_pitch_angle - aircraft.pitch_angle)
+                new_pitch_angle : float = current_pitch_angle
+                if target_pitch_angle > 0:
+                    if target_pitch_angle > current_pitch_angle:
+                        new_pitch_angle = current_pitch_angle + delta_pitch_angle
+                    else:
+                        new_pitch_angle = current_pitch_angle - delta_pitch_angle
+                else: # target_pitch_angle < 0
+                    if target_pitch_angle < current_pitch_angle:
+                        new_pitch_angle = current_pitch_angle + delta_pitch_angle
+                    else:
+                        new_pitch_angle = current_pitch_angle - delta_pitch_angle
 
+                current_speed : float = aircraft.absolute_speed
+                new_speed_z = current_speed * sin(radians(new_pitch_angle))
+                aircraft.speed = QVector3D(
+                    aircraft.speed.x(),
+                    aircraft.speed.y(),
+                    new_speed_z)
+                
             # yaw angle
             roll_angle : float = aircraft.roll_angle
-
-            if roll_angle == 0.0:
-                continue
-
             current_yaw_angle : float = aircraft.yaw_angle
             target_yaw_angle : float = fcc.target_yaw_angle
-            if abs(current_yaw_angle - target_yaw_angle) < 0.001:
-                continue
-            current_horizontal_speed : float = aircraft.horizontal_speed
-            delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
+            if not (roll_angle == 0.0 or abs(current_yaw_angle - target_yaw_angle) < 0.001):
+                current_horizontal_speed : float = aircraft.horizontal_speed
+                delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
 
-            new_yaw_angle : float = 0.0
-            new_yaw_angle = current_yaw_angle + delta_yaw_angle
+                new_yaw_angle : float = 0.0
+                new_yaw_angle = current_yaw_angle + delta_yaw_angle
 
-            aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
-            aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
+                aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
+                aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
 
     def count_cycles(self) -> None:
         """Increments physics cycle counter"""
         self.cycles += 1
         self.simulation_state.physics_cycles = self.cycles
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -16,14 +16,15 @@
         self.__mutex : QMutex = QMutex()
 
         # simulation state
         self.simulation_settings = simulation_settings
         self.update_settings()
         self.is_realtime : bool = is_realtime
         self.avoid_collisions : bool = avoid_collisions
+        self.override_avoid_collisions : bool = True
         self.minimum_separation : float = 9260.0 # 5nmi
         self.physics_cycles : int = 0
         self.is_paused : bool = False
         self.is_running : bool = True
         self.__reset_demanded : bool = False
         self.pause_start_timestamp : QTime | None = None
         self.time_paused : int = 0 # ms
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -217,15 +217,15 @@
         predicted_collision : bool = False
         time_to_closest_approach : float = 0.0
         if self.simulation_state.collision:
             self.draw_text(QVector3D(self.window_width - 70, 10, 0), 0, "COLLISION", QColor(255, 0, 0))
             return
         for aircraft in self.aircraft_vehicles:
             relative_position = aircraft.position - self.aircraft_vehicles[1 - aircraft.aircraft_id].position
-            speed_difference = aircraft.speed - self.aircraft_vehicles[1 - aircraft.aircraft_id].speed
+            speed_difference : QVector3D = aircraft.speed - self.aircraft_vehicles[1 - aircraft.aircraft_id].speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             if time_to_closest_approach > 0:
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 collision_distance = aircraft.size / 2 + self.aircraft_vehicles[1 - aircraft.aircraft_id].size / 2
@@ -320,26 +320,31 @@
             if target_yaw_angle is not None:
                 self.aircraft_fccs[0].target_yaw_angle = target_yaw_angle
 
     def center_offsets(self) -> None:
         """Updates screen offsets centering on selected aircraft"""
         scale : float = self.simulation_state.gui_scale
         id = self.simulation_state.focus_aircraft_id
-        self.screen_offset_x = - self.aircraft_vehicles[id].position.x() + self.window_width / 2 / scale
-        self.screen_offset_y = - self.aircraft_vehicles[id].position.y() + self.window_height / 2 / scale
+        self.screen_offset_x = (self.window_width / 2.0) / scale - self.aircraft_vehicles[id].position.x()
+        self.screen_offset_y = (self.window_height / 2.0) / scale - self.aircraft_vehicles[id].position.y()
 
     def update_resolutions(self) -> None:
         """Updates bounding box resolution"""
         self.window_width = self.width()
         self.window_height = self.height()
 
     def zoom(self, factor : float) -> None:
         """Zooms in/out the simulation render"""
-        if self.simulation_state.gui_scale + factor <= 0:
+        if self.simulation_state.gui_scale + factor >= 2:
+            self.simulation_state.gui_scale = 2
             return
+        while factor > 0 and factor > 2 * self.simulation_state.gui_scale:
+            factor /= 2
+        while factor < 0 and self.simulation_state.gui_scale + factor <= 0:
+            factor /= 2
         old_scale : float = self.simulation_state.gui_scale
         self.simulation_state.gui_scale += factor
         scale : float = self.simulation_state.gui_scale
         self.screen_offset_x = self.screen_offset_x * (old_scale / scale)
         self.screen_offset_y = self.screen_offset_y * (old_scale / scale)
 
     def paintEvent(self, event : QPaintEvent) -> None:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -83,26 +83,34 @@
                 logging.warning(f"Attempted to stack same destination: {destination}")
                 return None
         elif len(self.destinations) > 0 and not first:
             if dist(destination.toTuple(), self.destinations[len(self.destinations) - 1].toTuple()) < 1.0:
                 print("Attempted to stack same destination")
                 logging.warning(f"Attempted to stack same destination: {destination}")
                 return None
+        if destination.z() < 500:
+            if destination.z() < 0:
+                print("Attempted to set destination below ground")
+                logging.warning(f"Attempted to set destination below ground: {destination}")
+            else:
+                print("Attempted to set destination too low")
+                logging.warning(f"Attempted to set destination too low: {destination}")
+            destination = QVector3D(destination.x(), destination.y(), 500)
         return destination
 
     def add_last_destination(self, destination : QVector3D) -> None:
         """Appends the given location (QVector3D) to the end of the destinations list."""
-        destination = self.check_new_destination(destination, False)
+        destination : QVector3D = self.check_new_destination(destination, False)
         if destination is not None:
             self.destinations.append(destination)
             logging.info("Aircraft %s added new last destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
     def add_first_destination(self, destination : QVector3D) -> None:
         """Pushes given location to the top of destinations list"""
-        destination = self.check_new_destination(destination, True)
+        destination : QVector3D = self.check_new_destination(destination, True)
         if destination is not None:
             self.destinations.appendleft(destination)
             logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
     @property
     def destination(self) -> QVector3D | None:
         """Returns current destination"""
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -50,15 +50,14 @@
         if self.simulation_state.reset_demanded:
             self.reset_aircrafts()
         if not self.simulation_state.is_paused:
             self.count_cycles()
             self.simulation_state.update_simulation_settings()
             self.update_aircrafts_speed_angles(elapsed_time)
             if self.update_aircrafts_position(elapsed_time):
-                logging.warn("Collision Occured. Aircrafts coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
                 QApplication.beep()
                 self.simulation_state.register_collision()
                 if self.isRunning():
                     self.requestInterruption()
 
     def reset_aircrafts(self) -> None:
         """Resets aircrafts to initial state"""
@@ -68,18 +67,20 @@
         self.aircraft_fccs[1].reset()
         self.simulation_state.apply_reset()
 
     def update_aircrafts_position(self, elapsed_time : float) -> bool:
         """Updates aircrafts position, returns true on collision"""
         for aircraft in self.aircraft_vehicles:
             if aircraft.position.z() <= 0.0:
+                logging.warn("Aircraft's " + str(aircraft.aircraft_id) + "collision with the ground. Coordinates: " + str(self.aircraft_vehicles[aircraft.aircraft_id].position.toTuple()))
                 print("Collision with ground")
                 return True
             relative_distance : float = dist(aircraft.position.toTuple(), self.aircraft_vehicles[1 - aircraft.aircraft_id].position.toTuple())
             if relative_distance <= aircraft.size:
+                logging.warn("Aircrafts' 0 and 1 collision. Coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
                 print("Collision with another aircraft")
                 return True
             old_pos : QVector3D = copy(aircraft.position)
             aircraft.move(
                 aircraft.speed.x() * elapsed_time / 1000.0,
                 aircraft.speed.y() * elapsed_time / 1000.0,
                 aircraft.speed.z() * elapsed_time / 1000.0)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py

```diff
@@ -1,53 +1,74 @@
 """Aircraft class module"""
 
 from copy import copy
 
-from PySide6.QtCore import QObject
+from PySide6.QtCore import QObject, QMutex, QMutexLocker
 from PySide6.QtGui import QVector3D
 
 from .aircraft_vehicle import AircraftVehicle
 from .aircraft_fcc import AircraftFCC
 
 class Aircraft(QObject):
     """Main aircraft class"""
     
     __current_id : int = 0
 
-    def __init__(self, position : QVector3D, speed : QVector3D, initial_target : QVector3D | None = None) -> None:
+    def __init__(self, position : QVector3D, speed : QVector3D, initial_target : QVector3D | None = None, initial_roll_angle : float = 0.0) -> None:
         super().__init__()
+        self.__mutex : QMutex = QMutex()
         self.__aircraft_id = self.__obtain_id()
-        self.__vehicle = AircraftVehicle(self.__aircraft_id, position=position, speed=speed)
+        self.__vehicle = AircraftVehicle(self.__aircraft_id, position=position, speed=speed, initial_roll_angle=initial_roll_angle)
         self.__fcc = AircraftFCC(self.__aircraft_id, initial_target, self.__vehicle)
         self.__initial_position = copy(position)
         self.__initial_speed = copy(speed)
+        self.__initial_roll_angle = initial_roll_angle
     
     @property
     def vehicle(self) -> AircraftVehicle:
         """Returns aircraft vehicle"""
-        return self.__vehicle
+        with QMutexLocker(self.__mutex):
+            return self.__vehicle
     
     @property
     def fcc(self) -> AircraftFCC:
         """Returns aircraft fcc"""
-        return self.__fcc
+        with QMutexLocker(self.__mutex):
+            return self.__fcc
     
     @property
     def initial_position(self) -> QVector3D:
         """Returns initial position"""
-        return self.__initial_position
+        with QMutexLocker(self.__mutex):
+            return self.__initial_position
     
     @property
     def initial_speed(self) -> QVector3D:
         """Returns initial speed"""
-        return self.__initial_speed
+        with QMutexLocker(self.__mutex):
+            return self.__initial_speed
+        
+    @property
+    def initial_roll_angle(self) -> float:
+        """Returns initial roll angle"""
+        with QMutexLocker(self.__mutex):
+            return self.__initial_roll_angle
 
     def __obtain_id(self) -> int:
         """Gets unique id for the aircraft"""
-        aircraft_id = Aircraft.__current_id
-        Aircraft.__current_id += 1
-        return aircraft_id
-    
+        with QMutexLocker(self.__mutex):
+            aircraft_id = Aircraft.__current_id
+            Aircraft.__current_id += 1
+            return aircraft_id
+    
+    def __reset_current_id(self) -> None:
+        """Resets current id"""
+        with QMutexLocker(self.__mutex):
+            Aircraft.__current_id = 0
+
     def reset(self) -> None:
         """Resets aircraft to initial state"""
+        self.__reset_current_id()
         self.__vehicle.speed = copy(self.initial_speed)
         self.__vehicle.position = copy(self.initial_position)
+        self.__vehicle.roll_angle = copy(self.initial_roll_angle)
+        self.__vehicle.reset_distance_covered()
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -2,80 +2,187 @@
 
 import logging
 from copy import copy
 from typing import List
 from collections import deque
 from math import dist, atan2, degrees
 
-from PySide6.QtCore import QObject
+from PySide6.QtCore import QObject, QMutex, QMutexLocker
 from PySide6.QtGui import QVector3D
 
 from .aircraft_vehicle import AircraftVehicle
 
 class AircraftFCC(QObject):
     """Aircraft Flight Control Computer"""
-
+    
     def __init__(self, aircraft_id : int, initial_target : QVector3D | None, aircraft : AircraftVehicle) -> None:
         super().__init__()
-        self.aircraft_id = aircraft_id
-        self.aircraft = aircraft
-
-        self.destinations : deque[QVector3D] = deque()
-
+        self.__mutex : QMutex = QMutex()
+        self.__aircraft_id = aircraft_id
+        self.__aircraft = aircraft
+        self.__destinations : deque[QVector3D] = deque()
+        self.__destinations_history : List[QVector3D] = []
+        self.__visited : List[QVector3D] = []
+        self.__autopilot : bool = True
+        self.__ignore_destinations : bool = False
+        self.__initial_target : QVector3D | None = initial_target
+        self.__target_yaw_angle : float = 0.0
         if initial_target is None:
-            self.target_yaw_angle : float = aircraft.yaw_angle
+            self.__target_yaw_angle = aircraft.yaw_angle
+            self.__autopilot = False
         else:
-            self.target_yaw_angle : float = self.find_best_yaw_angle(aircraft.position, initial_target)
+            self.__target_yaw_angle = self.find_best_yaw_angle(aircraft.position, initial_target)
             self.add_first_destination(initial_target)
-
-        self.initial_course : float = copy(self.target_yaw_angle)
-        self.target_roll_angle : float = 0.0
-        self.target_pitch_angle : float = 0.0
+        self.__target_roll_angle : float = 0.0
+        self.__target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
         self.__is_turning_right : bool = False
         self.__is_turning_left : bool = False
-        self.ignore_destinations : bool = False
-
         self.__safe_zone_occupied : bool = False
         self.__evade_maneuver : bool = False
-        self.vector_sharing_resolution : QVector3D | None = None
+        self.__vector_sharing_resolution : QVector3D | None = None
+
+    @property
+    def aircraft_id(self) -> int:
+        """Returns aircraft id"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id
+    
+    @property
+    def aircraft(self) -> AircraftVehicle:
+        """Returns aircraft vehicle"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft
+    
+    @property
+    def destinations(self) -> deque[QVector3D]:
+        """Returns destinations list"""
+        with QMutexLocker(self.__mutex):
+            return self.__destinations
+    
+    @property
+    def destinations_history(self) -> List[QVector3D]:
+        """Returns destinations history list"""
+        with QMutexLocker(self.__mutex):
+            return self.__destinations_history
+    
+    @property
+    def visited(self) -> List[QVector3D]:
+        """Returns visited list"""
+        with QMutexLocker(self.__mutex):
+            return self.__visited
+    
+    @property
+    def autopilot(self) -> bool:
+        """Returns autopilot state"""
+        with QMutexLocker(self.__mutex):
+            return self.__autopilot
+    
+    def toggle_autopilot(self) -> None:
+        """Toggles autopilot state"""
+        with QMutexLocker(self.__mutex):
+            self.__autopilot = not self.__autopilot
 
-        self.destinations_history : List[QVector3D] = []
-        self.visited : List[QVector3D] = []
+    @property
+    def ignore_destinations(self) -> bool:
+        """Returns ignore destinations state"""
+        with QMutexLocker(self.__mutex):
+            return self.__ignore_destinations
+    
+    @ignore_destinations.setter
+    def ignore_destinations(self, value : bool) -> None:
+        """Sets ignore destinations state"""
+        with QMutexLocker(self.__mutex):
+            self.__ignore_destinations = value
+
+    @property
+    def initial_target(self) -> QVector3D | None:
+        """Returns initial target"""
+        with QMutexLocker(self.__mutex):
+            return self.__initial_target
+
+    @property
+    def target_yaw_angle(self) -> float:
+        """Returns target yaw angle"""
+        with QMutexLocker(self.__mutex):
+            return self.__target_yaw_angle
+    
+    @target_yaw_angle.setter
+    def target_yaw_angle(self, angle : float) -> None:
+        """Sets target yaw angle"""
+        with QMutexLocker(self.__mutex):
+            self.__target_yaw_angle = angle
+
+    @property
+    def target_roll_angle(self) -> float:
+        """Returns target roll angle"""
+        with QMutexLocker(self.__mutex):
+            return self.__target_roll_angle
+    
+    @target_roll_angle.setter
+    def target_roll_angle(self, angle : float) -> None:
+        """Sets target roll angle"""
+        with QMutexLocker(self.__mutex):
+            self.__target_roll_angle = angle
+
+    @property
+    def target_pitch_angle(self) -> float:
+        """Returns target pitch angle"""
+        with QMutexLocker(self.__mutex):
+            return self.__target_pitch_angle
+    
+    @target_pitch_angle.setter
+    def target_pitch_angle(self, angle : float) -> None:
+        """Sets target pitch angle"""
+        with QMutexLocker(self.__mutex):
+            self.__target_pitch_angle = angle
     
     @property
     def target_speed(self) -> float:
         """Returns target speed"""
-        return self.__target_speed
+        with QMutexLocker(self.__mutex):
+            return self.__target_speed
     
     @target_speed.setter
     def target_speed(self, speed : float) -> None:
         """Sets target speed"""
         if speed > 0:
-            self.__target_speed = speed
+            with QMutexLocker(self.__mutex):
+                self.__target_speed = speed
+
+    def accelerate(self, acceleration : float) -> None:
+        """Accelerates aircraft's targeted speed"""
+        with QMutexLocker(self.__mutex):
+            if self.__target_speed + acceleration <= 0:
+                return
+            self.__target_speed += acceleration
     
     @property
     def is_turning_right(self) -> bool:
         """Returns turning right state"""
-        return self.__is_turning_right
+        with QMutexLocker(self.__mutex):
+            return self.__is_turning_right
     
     @is_turning_right.setter
     def is_turning_right(self, value : bool) -> None:
         """Sets turning right state"""
-        self.__is_turning_right = value
+        with QMutexLocker(self.__mutex):
+            self.__is_turning_right = value
 
     @property
     def is_turning_left(self) -> bool:
         """Returns turning left state"""
-        return self.__is_turning_left
+        with QMutexLocker(self.__mutex):
+            return self.__is_turning_left
     
     @is_turning_left.setter
     def is_turning_left(self, value : bool) -> None:
         """Sets turning left state"""
-        self.__is_turning_left = value
+        with QMutexLocker(self.__mutex):
+            self.__is_turning_left = value
 
     def check_new_destination(self, destination : QVector3D, first : bool) -> QVector3D | None:
         """Checks if the given destination is already in the destinations list"""
         if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
             raise TypeError("Destination coordinates must be int or float.")
         if len(self.destinations) > 0 and first:
             if dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
@@ -91,37 +198,44 @@
             if destination.z() < 0:
                 print("Attempted to set destination below ground")
                 logging.warning(f"Attempted to set destination below ground: {destination}")
             else:
                 print("Attempted to set destination too low")
                 logging.warning(f"Attempted to set destination too low: {destination}")
             destination = QVector3D(destination.x(), destination.y(), 500)
+        elif destination.z() > 10000:
+            print("Attempted to set destination too high")
+            logging.warning(f"Attempted to set destination too high: {destination}")
+            destination = QVector3D(destination.x(), destination.y(), 10000)
         return destination
 
     def add_last_destination(self, destination : QVector3D) -> None:
         """Appends the given location (QVector3D) to the end of the destinations list."""
         destination : QVector3D = self.check_new_destination(destination, False)
         if destination is not None:
-            self.destinations.append(destination)
-            logging.info("Aircraft %s added new last destination: %s", self.aircraft.aircraft_id, destination.toTuple())
+            with QMutexLocker(self.__mutex):
+                self.__destinations.append(destination)
+                logging.info("Aircraft %s added new last destination: %s", self.__aircraft.aircraft_id, destination.toTuple())
 
     def add_first_destination(self, destination : QVector3D) -> None:
         """Pushes given location to the top of destinations list"""
         destination : QVector3D = self.check_new_destination(destination, True)
         if destination is not None:
-            self.destinations.appendleft(destination)
-            logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
+            with QMutexLocker(self.__mutex):
+                self.__destinations.appendleft(destination)
+                logging.info("Aircraft %s added new first destination: %s", self.__aircraft.aircraft_id, destination.toTuple())
 
     @property
     def destination(self) -> QVector3D | None:
         """Returns current destination"""
-        if len(self.destinations) > 0:
-            return self.destinations[0]
-        else:
-            return None
+        with QMutexLocker(self.__mutex):
+            if len(self.__destinations) > 0:
+                return self.__destinations[0]
+            else:
+                return None
 
     def append_visited(self) -> None:
         """Appends current location to visited list"""
         self.visited.append(copy(self.aircraft.position))
 
     def normalize_angle(self, angle : float) -> float:
         """Normalizes -180-180 angle into 360 domain"""
@@ -130,33 +244,48 @@
 
     def format_yaw_angle(self, angle : float) -> float:
         """Formats angle into -180-180 domain"""
         angle = self.normalize_angle(angle)
         return angle if angle <= 180 else -180 + (angle - 180)
     
     @property
+    def vector_sharing_resolution(self) -> QVector3D | None:
+        """Returns vector sharing resolution"""
+        with QMutexLocker(self.__mutex):
+            return self.__vector_sharing_resolution
+    
+    @vector_sharing_resolution.setter
+    def vector_sharing_resolution(self, value : QVector3D | None) -> None:
+        """Sets vector sharing resolution"""
+        with QMutexLocker(self.__mutex):
+            self.__vector_sharing_resolution = value
+
+    @property
     def safe_zone_occupied(self) -> bool:
         """Returns safe zone occupied state"""
-        return self.__safe_zone_occupied
+        with QMutexLocker(self.__mutex):
+            return self.__safe_zone_occupied
     
     @safe_zone_occupied.setter
     def safe_zone_occupied(self, value : bool) -> None:
         """Sets safe zone occupied state"""
-        if self.__safe_zone_occupied and value:
-            print("Safe zone already occupied")
-            logging.warning("Safe zone already occupied")
-        if not self.__safe_zone_occupied and not value:
-            print("Safe zone already free")
-            logging.warning("Safe zone already free")
-        self.__safe_zone_occupied = value
+        with QMutexLocker(self.__mutex):
+            if self.__safe_zone_occupied and value:
+                print("Safe zone already occupied")
+                logging.warning("Safe zone already occupied")
+            if not self.__safe_zone_occupied and not value:
+                print("Safe zone already free")
+                logging.warning("Safe zone already free")
+            self.__safe_zone_occupied = value
     
     @property
     def evade_maneuver(self) -> bool:
         """Returns evade maneuver state"""
-        return self.__evade_maneuver
+        with QMutexLocker(self.__mutex):
+            return self.__evade_maneuver
 
     def apply_evade_maneuver(self, opponent_speed : QVector3D, miss_distance_vector : QVector3D, unresolved_region : float, time_to_closest_approach : float) -> None:
         """Applies evade maneuver"""
         print(str(self.aircraft.aircraft_id) + ": opponent speed: " + "{:.2f}".format(opponent_speed.x()) + " " + "{:.2f}".format(opponent_speed.y()) + " " + "{:.2f}".format(opponent_speed.z()))
         print(str(self.aircraft.aircraft_id) + ": miss distance vector: " + "{:.2f}".format(miss_distance_vector.x()) + " " + "{:.2f}".format(miss_distance_vector.y()) + " " + "{:.2f}".format(miss_distance_vector.z()))
         print(str(self.aircraft.aircraft_id) + ": unresolved region: " + "{:.2f}".format(unresolved_region))
         print(str(self.aircraft.aircraft_id) + ": time to closest approach: " + "{:.2f}".format(time_to_closest_approach))
@@ -195,18 +324,19 @@
                 target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
             
             print("Set target avoiding collision: " + "{:.2f}".format(target_avoiding.x()) + " " + "{:.2f}".format(target_avoiding.y()) + " " + "{:.2f}".format(target_avoiding.z()))
             self.add_first_destination(target_avoiding)
 
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
-        if self.__evade_maneuver:
-            logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
-            self.__evade_maneuver = False
-            #self.vector_sharing_resolution = None
+        with QMutexLocker(self.__mutex):
+            if self.__evade_maneuver:
+                logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
+                self.__evade_maneuver = False
+                #self.vector_sharing_resolution = None
 
     def find_best_roll_angle(self, current_yaw_angle: float, target_yaw_angle: float) -> float:
         """Finds best roll angle for the targeted yaw angle"""
         difference = (target_yaw_angle - current_yaw_angle + 180) % 360 - 180
         if abs(difference) < 0.001:
             self.is_turning_right = False
             self.is_turning_left = False
@@ -249,15 +379,15 @@
         target_pitch_angle : float = degrees(atan2(
             destination.z() - position.z(),
             dist(position.toTuple(), destination.toTuple())))
         return target_pitch_angle
 
     def update_target_yaw_pitch_angles(self) -> None:
         """Updates current yaw angle"""
-        if self.destinations and not self.ignore_destinations:
+        if self.destinations and self.autopilot and not self.ignore_destinations:
             destination = self.destinations[0]
             distance = dist(self.aircraft.position.toTuple(), destination.toTuple())
             if distance < self.aircraft.size / 2:
                 self.destinations_history.append(self.destinations.popleft())
                 if self.destinations:
                     destination = self.destinations[0]
                     logging.info("Aircraft %s visited destination and took next one", self.aircraft.aircraft_id)
@@ -298,11 +428,47 @@
         self.update_target_roll_angle()      
 
     def reset(self) -> None:
         """Resets aircraft flight control computer"""
         self.destinations.clear()
         self.destinations_history.clear()
         self.visited.clear()
-        self.target_yaw_angle = self.initial_course
-        self.target_roll_angle = 0.0
-        self.target_pitch_angle = 0.0
+        if self.initial_target is not None:
+            self.add_first_destination(self.initial_target)
+        self.__target_yaw_angle = 0.0
+        self.__target_roll_angle = 0.0
+        self.__target_pitch_angle = 0.0
         self.__evade_maneuver = False
+        self.__vector_sharing_resolution = None
+        self.__safe_zone_occupied = False
+        self.__autopilot = True
+        self.__ignore_destinations = False
+        self.__is_turning_right = False
+        self.__is_turning_left = False
+
+    def __str__(self) -> str:
+        return f"AircraftFCC: {self.aircraft_id}"
+    
+    def __repr__(self) -> str:
+        return f"AircraftFCC: {self.aircraft_id}"
+    
+    def __del__(self) -> None:
+        with QMutexLocker(self.__mutex):
+            del self.__aircraft_id
+            del self.__aircraft
+            del self.__destinations
+            del self.__destinations_history
+            del self.__visited
+            del self.__autopilot
+            del self.__ignore_destinations
+            del self.__initial_target
+            del self.__target_yaw_angle
+            del self.__target_roll_angle
+            del self.__target_pitch_angle
+            del self.__target_speed
+            del self.__is_turning_right
+            del self.__is_turning_left
+            del self.__safe_zone_occupied
+            del self.__evade_maneuver
+            del self.__vector_sharing_resolution
+            del self.__mutex
+            del self
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py

```diff
@@ -8,79 +8,100 @@
 class AircraftVehicle(QObject):
     """Aircraft physical UAV"""
 
     roll_dynamic_delay : float = 1000 # ms
     pitch_dynamic_delay : float = 2000 # ms
     max_acceleration : float = 2.0 # m/s^2
 
-    def __init__(self, aircraft_id : int, position : QVector3D, speed : QVector3D) -> None:
+    def __init__(self, aircraft_id : int, position : QVector3D, speed : QVector3D, initial_roll_angle : float) -> None:
         super().__init__()
         self.__mutex : QMutex = QMutex()
         
         self.__aircraft_id = aircraft_id
         self.__position = position
         if self.__position.z() < 0:
             self.__position.setZ(0)
         self.__speed = speed
 
         self.__size : float = 20.0
-        self.__roll_angle = 0.0 # bank angle
-        self.initial_roll_angle = self.__roll_angle
+        self.__roll_angle = initial_roll_angle
+        self.__initial_roll_angle = self.__roll_angle
         self.__distance_covered : float = 0.0
 
     @property
     def aircraft_id(self) -> int:
         """Returns aircraft id"""
-        return self.__aircraft_id
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id
     
     @property
     def position(self) -> QVector3D:
         """Returns position"""
-        return self.__position
+        with QMutexLocker(self.__mutex):
+            return self.__position
     
     @position.setter
     def position(self, position : QVector3D) -> None:
         """Sets position"""
         del self.__position
-        self.__position = position
+        with QMutexLocker(self.__mutex):
+            self.__position = position
     
     @property
     def speed(self) -> QVector3D:
         """Returns speed"""
-        return self.__speed
+        with QMutexLocker(self.__mutex):
+            return self.__speed
     
     @speed.setter
     def speed(self, speed : QVector3D) -> None:
         """Sets speed"""
-        self.__speed = speed
+        with QMutexLocker(self.__mutex):
+            self.__speed = speed
     
     @property
     def size(self) -> float:
         """Returns size"""
-        return self.__size
+        with QMutexLocker(self.__mutex):
+            return self.__size
     
     @property
     def roll_angle(self) -> float:
         """Returns roll angle"""
-        return self.__roll_angle
+        with QMutexLocker(self.__mutex):
+            return self.__roll_angle
 
     @roll_angle.setter
     def roll_angle(self, roll_angle_delta : float) -> None:
         """Adds roll angle delta"""
-        self.__roll_angle += roll_angle_delta
+        with QMutexLocker(self.__mutex):
+            self.__roll_angle += roll_angle_delta
+
+    @property
+    def initial_roll_angle(self) -> float:
+        """Returns initial roll angle"""
+        with QMutexLocker(self.__mutex):
+            return self.__initial_roll_angle
     
     @property
     def distance_covered(self) -> float:
         """Returns covered distance"""
-        return self.__distance_covered
+        with QMutexLocker(self.__mutex):
+            return self.__distance_covered
 
     @distance_covered.setter
     def distance_covered(self, distance_covered_delta : float) -> None:
         """Appends delta to distance covered"""
-        self.__distance_covered += distance_covered_delta
+        with QMutexLocker(self.__mutex):
+            self.__distance_covered += distance_covered_delta
+
+    def reset_distance_covered(self) -> None:
+        """Resets distance covered"""
+        with QMutexLocker(self.__mutex):
+            self.__distance_covered = 0.0
     
     def move(self, dx : float, dy : float, dz : float = 0.0) -> None:
         """Applies position deltas for the vehicle"""
         with QMutexLocker(self.__mutex):
             self.__position.setX(self.__position.x() + dx)
             self.__position.setY(self.__position.y() + dy)
             self.__position.setZ(self.__position.z() + dz)
@@ -124,7 +145,59 @@
             return degrees(atan2(speed.x(), -speed.y()))
 
     @property
     def pitch_angle(self) -> float:
         """Returns pitch angle"""
         with QMutexLocker(self.__mutex):
             return degrees(atan2(self.__speed.z(), sqrt(self.__speed.x() ** 2 + self.__speed.y() ** 2)))
+
+    def __str__(self) -> str:
+        with QMutexLocker(self.__mutex):
+            return f"Vehicle {self.__aircraft_id} at {self.__position} with speed {self.__speed} and roll angle {self.__roll_angle} degrees"
+        
+    def __repr__(self) -> str:
+        with QMutexLocker(self.__mutex):
+            return f"Vehicle {self.__aircraft_id} at {self.__position} with speed {self.__speed} and roll angle {self.__roll_angle} degrees"
+        
+    def __eq__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id == other.__aircraft_id
+        
+    def __ne__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id != other.__aircraft_id
+        
+    def __lt__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id < other.__aircraft_id
+        
+    def __le__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id <= other.__aircraft_id
+        
+    def __gt__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id > other.__aircraft_id
+        
+    def __ge__(self, other) -> bool:
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_id >= other.__aircraft_id
+        
+    def __copy__(self):
+        with QMutexLocker(self.__mutex):
+            return AircraftVehicle(self.__aircraft_id, self.__position, self.__speed, self.__initial_roll_angle)
+
+    def __deepcopy__(self, memo):
+        with QMutexLocker(self.__mutex):
+            return AircraftVehicle(self.__aircraft_id, self.__position, self.__speed, self.__initial_roll_angle)
+        
+    def __del__(self):
+        with QMutexLocker(self.__mutex):
+            del self.__position
+            del self.__speed
+            del self.__roll_angle
+            del self.__initial_roll_angle
+            del self.__distance_covered
+            del self.__size
+            del self.__aircraft_id
+            del self.__mutex
+            del self
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -19,148 +19,150 @@
 from ..simulation.simulation_widget import SimulationWidget
 from ..simulation.simulation_adsb import SimulationADSB
 from ..simulation.simulation_fps import SimulationFPS
 
 class Simulation(QMainWindow):
     """Main simulation App"""
 
-    def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
+    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 10_000_000) -> None: # 10_000_000 ms = 10_000 s = 2h 46m 40s
         super().__init__()
         SimulationSettings().__init__()
-        if aircrafts is None:
-            test_case : int = 0
-            if test_case == 0:
-                self.aircrafts : List[Aircraft] = [
-                    Aircraft( # detection test
-                        position = QVector3D(-800, 4000, 1000),
-                        speed = QVector3D(60, -60, 0),
-                        initial_target = QVector3D(1_000_100, -1_001_000, 10000)),
-                    Aircraft(
-                        position = QVector3D(4000, 6000, 1000),
-                        speed = QVector3D(0, -85, 0),
-                        initial_target = QVector3D(900, -1_001_300, 10000)),
-                ]
-            elif test_case == 1:
-                self.aircrafts : List[Aircraft] = [
-                    Aircraft( # almost head on
-                        position = QVector3D(-3000, 500, 1000),
-                        speed = QVector3D(70, 0.1, 0)),
-                    Aircraft(
-                        position = QVector3D(5000, 500, 1000),
-                        speed = QVector3D(-50, 0, 0)),
-                ]
-            elif test_case == 2:
-                self.aircrafts : List[Aircraft] = [
-                    Aircraft( # avoidance test
-                        position = QVector3D(0, 0, 1000),
-                        speed = QVector3D(30, -30, 0),
-                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
-                    Aircraft(
-                        position = QVector3D(0, -100_000, 1000),
-                        speed = QVector3D(30, 29, 0),
-                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
-                ]
-            elif test_case == 3:
-                self.aircrafts : List[Aircraft] = [
-                    Aircraft( # avoidance test fast
-                        position = QVector3D(0, 0, 1000),
-                        speed = QVector3D(300, -300, 0),
-                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
-                    Aircraft(
-                        position = QVector3D(0, -100_000, 1000),
-                        speed = QVector3D(300, 290, 0),
-                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
-                ]
-        else:
-            self.aircrafts = aircrafts
-        self.simulation_time : int = simulation_time
-        self.state : SimulationState | None = None
-
-    def run_realtime(self) -> None:
-        """Executes realtime simulation"""
+        self.__headless : bool = headless
+        self.__tests : bool = tests
+        self.__simulation_time : int = simulation_time
+        self.__aircrafts : List[Aircraft] | None = None
+        self.__state : SimulationState | None = None
+        self.run()
+
+    @property
+    def headless(self) -> bool:
+        """Returns headless flag"""
+        return self.__headless
+    
+    @property
+    def tests(self) -> bool:
+        """Returns tests flag"""
+        return self.__tests
+    
+    @property
+    def simulation_time(self) -> int:
+        """Returns simulation time"""
+        return self.__simulation_time
+    
+    @property
+    def aircrafts(self) -> List[Aircraft]:
+        """Returns aircrafts list"""
+        return self.__aircrafts
+    
+    @property
+    def state(self) -> SimulationState:
+        """Returns simulation state"""
+        return self.__state
+    
+    @state.setter
+    def state(self, state : SimulationState) -> None:
+        """Sets simulation state"""
+        self.__state = state
+    
+    def run(self) -> None:
+        """Executes simulation"""
         if self.state is not None:
             print("Another instance already running")
             return
+        if self.headless:
+            if self.tests:
+                self.run_tests()
+            else:
+                self.run_headless()
+        else:
+            self.run_gui()
+
+    def run_gui(self) -> None:
+        """Executes realtime simulation"""
+        if self.aircrafts is None or self.aircrafts == []:
+            self.setup_debug_aircrafts()
         logging.info("Starting realtime simulation")
         self.state = SimulationState(SimulationSettings(), is_realtime = True)
-
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
-        self.simulation_physics.start(priority = QThread.Priority.TimeCriticalPriority)
-
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
-        self.simulation_adsb.start(priority = QThread.Priority.NormalPriority)
-
         self.simulation_fps = SimulationFPS(self, self.state)
-        self.simulation_fps.start(priority = QThread.Priority.NormalPriority)
-
         self.simulation_widget = SimulationWidget(self.aircrafts, self.simulation_fps, self.state)
-        self.simulation_widget.show()
-
         self.simulation_render = SimulationRender(self, self.simulation_widget, self.state)
+        self.simulation_physics.start(priority = QThread.Priority.TimeCriticalPriority)
+        self.simulation_adsb.start(priority = QThread.Priority.NormalPriority)
+        self.simulation_fps.start(priority = QThread.Priority.NormalPriority)
+        self.simulation_widget.show()
         self.simulation_render.start(priority = QThread.Priority.NormalPriority)
-
-        self.simulation_widget.stop_signal.connect(self.stop_simulation)
+        self.simulation_widget.stop_signal.connect(self.stop)
     
-    def run_prerender(self) -> None:
-        """Executes prerender simulation"""
-        if self.state is not None:
-            print("Another instance already running")
-            return
-        logging.info("Starting prerendered simulation")
-        self.state = SimulationState(SimulationSettings(), is_realtime = False)
+    def run_headless(self, aircrafts : List[Aircraft] | None = None, avoid_collisions : bool = False) -> None:
+        """Executes simulation without GUI"""
+        logging.info("Starting headless simulation")
+        if aircrafts is None or aircrafts == []:
+            self.setup_debug_aircrafts()
+        else:
+            self.setup_aircrafts(aircrafts)
+        self.state = SimulationState(SimulationSettings(), is_realtime = False, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
         time_step : int = int(self.state.simulation_threshold)
         adsb_step : int = int(self.state.adsb_threshold)
         partial_time_counter : int = adsb_step
-        for time in range(0, self.simulation_time, time_step):
+        for time in range(0, int(self.simulation_time / self.state.simulation_threshold), time_step):
             print(time)
             self.simulation_physics.cycle(time_step)
             if partial_time_counter >= adsb_step:
                 self.simulation_adsb.cycle()
                 partial_time_counter = 0
             partial_time_counter += time_step
             if self.state.collision:
                 break
-        self.stop_simulation()
+        self.stop()
     
     def run_tests(self, test_number : int = 10) -> None:
         """Runs simulation tests"""
         if test_number < 1:
             test_number = 10
         logging.info("Running simulation tests")
         start_timestamp = QTime.currentTime()
+        #list_of_aircrafts : List[List[Aircraft]] = self.generate_test_aircrafts(test_number) # todo
         for i in range(0, test_number, 1):
-            logging.info("Test %d", i)
-            self.run_prerender()
+            logging.info("Test %d - no collision avoidance", i)
+            # self.run_headless(aircrafts = list_of_aircrafts[i], avoid_collisions = False)
+            self.run_headless()
+            # self.export_results()
+            self.state = None
+
+            logging.info("Test %d - collision avoidance", i)
+            # self.run_headless(aircrafts = list_of_aircrafts[i], avoid_collisions = True)
+            self.run_headless()
+            # self.export_results()
             self.state = None
         real_time : float = start_timestamp.msecsTo(QTime.currentTime()) / 1000
         print("Total time elapsed: " + "{:.2f}".format(real_time) + "s")
         logging.info("Total time elapsed: %ss", "{:.2f}".format(real_time))
     
-    def stop_simulation(self) -> None:
+    def stop(self) -> None:
         """Stops simulation"""
-        if self.state.is_realtime:
-            self.stop_realtime_simulation()
+        if self.headless:
+            self.stop_headless_simulation()
         else:
-            self.stop_prerender_simulation()
+            self.stop_realtime_simulation()
         self.state.reset()
         self.state.is_running = False
 
     def stop_realtime_simulation(self) -> None:
         """Finishes all active realtime simulation threads"""
         if not self.state.is_running:
             return
         logging.info("Stopping realtime simulation")
-
         self.simulation_physics.requestInterruption()
         self.simulation_adsb.requestInterruption()
         self.simulation_render.requestInterruption()
         self.simulation_fps.requestInterruption()
-
         self.simulation_physics.quit()
         self.simulation_physics.wait()
 
         if self.state.is_paused:
             self.state.append_paused_time()
         simulated_time : float = self.state.physics_cycles / (1000 / self.state.simulation_threshold)
         real_time_pauses : float = self.simulation_physics.global_start_timestamp.msecsTo(self.simulation_physics.global_stop_timestamp) / 1000
@@ -171,30 +173,92 @@
         else:
             print("Time elapsed: " + "{:.2f}".format(real_time) + "s (" + "{:.2f}".format(real_time_pauses) + "s with pauses)")
         if real_time != 0:
             print("Time efficiency: " + "{:.2f}".format(simulated_time / real_time * 100) + "%")
             logging.info("Calculated time efficiency: " + "{:.2f}".format(simulated_time / real_time * 100) + "%")
 
         self.export_visited_locations()
-
         self.simulation_adsb.quit()
         self.simulation_adsb.wait()
         self.simulation_render.quit()
         self.simulation_render.wait()
         self.simulation_fps.quit()
         self.simulation_fps.wait()
     
-    def stop_prerender_simulation(self) -> None:
-        """Finishes all active prerender simulation threads"""
+    def stop_headless_simulation(self) -> None:
+        """Finishes headless simulation"""
         if not self.state.is_running:
+            print("No simulation running")
             return
-        logging.info("Stopping prerendered simulation")
+        logging.info("Stopping headless simulation")
         self.simulation_physics.reset_aircrafts()
         self.state.reset()
-    
+
+    def add_aircraft(self, aircraft : Aircraft) -> None:
+        """Adds aircraft to simulation"""
+        if self.aircrafts is None:
+            self.__aircrafts = []
+        self.aircrafts.append(aircraft)
+
+    def remove_aircraft(self, aircraft : Aircraft) -> None:
+        """Removes aircraft from simulation"""
+        if self.aircrafts is not None:
+            self.aircrafts.remove(aircraft)
+
+    def setup_aircrafts(self, aircrafts : List[Aircraft]) -> None:
+        """Sets up aircrafts list"""
+        self.__aircrafts = aircrafts
+
+    def setup_debug_aircrafts(self) -> None:
+        """Sets up debug aircrafts list"""
+        test_case : int = 3
+        if test_case == 0:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # detection test
+                    position = QVector3D(-800, 4000, 1000),
+                    speed = QVector3D(60, -60, 0),
+                    initial_target = QVector3D(51_900, -50_000, 10000)),
+                Aircraft(
+                    position = QVector3D(4000, 6000, 1000),
+                    speed = QVector3D(0, -85, 0),
+                    initial_target = QVector3D(900, -1_001_300, 1000)),
+            ]
+        elif test_case == 1:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # almost head on
+                    position = QVector3D(-3000, 500, 1000),
+                    speed = QVector3D(70, 0.1, 0)),
+                Aircraft(
+                    position = QVector3D(5000, 500, 1000),
+                    speed = QVector3D(-50, 0, 0)),
+            ]
+        elif test_case == 2:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # avoidance test
+                    position = QVector3D(0, 0, 1000),
+                    speed = QVector3D(30, -30, 0),
+                    initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
+                Aircraft(
+                    position = QVector3D(0, -100_000, 1000),
+                    speed = QVector3D(30, 29, 0),
+                    initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
+            ]
+        elif test_case == 3:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # avoidance test fast
+                    position = QVector3D(0, 0, 1000),
+                    speed = QVector3D(300, -300, 0),
+                    initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
+                Aircraft(
+                    position = QVector3D(0, -100_000, 1000),
+                    speed = QVector3D(300, 290, 0),
+                    initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
+            ]
+        self.setup_aircrafts(aircrafts)
+
     def export_visited_locations(self) -> None:
         """Exports aircrafts visited location lists"""
         export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
         aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
         for aircraft in aircraft_fccs:
             try:
                 Path("logs/visited").mkdir(parents=True, exist_ok=True)
@@ -204,10 +268,10 @@
             writer = csv.writer(file)
             writer.writerow(["x","y","z"])
             for position in aircraft.visited:
                 writer.writerow([("{:.2f}".format(position.x())),("{:.2f}".format(position.y())),("{:.2f}".format(position.z()))])
     
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
-        self.stop_simulation()
+        self.stop()
         event.accept()
         return super().closeEvent(event)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -1,11 +1,12 @@
 """Simulation ADS-B system simulation thread module"""
 
 import logging
 from typing import List
+from math import sqrt
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QVector3D
 from PySide6.QtWidgets import QMainWindow
 
 from ..aircraft.aircraft import Aircraft
 from ..aircraft.aircraft_vehicle import AircraftVehicle
@@ -13,35 +14,67 @@
 from .simulation_state import SimulationState
 
 class SimulationADSB(QThread):
     """Thread running ADS-B system for collision detection and avoidance"""
 
     def __init__(self, parent : QMainWindow, aircrafts : List[Aircraft], simulation_state : SimulationState) -> None:
         super(SimulationADSB, self).__init__(parent)
-        self.aircrafts = aircrafts
-        self.aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
-        self.aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
-        self.simulation_state = simulation_state
-        self.adsb_cycles : int = 0
+        self.__aircrafts = aircrafts
+        self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
+        self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
+        self.__simulation_state = simulation_state
+        self.__adsb_cycles : int = 0
         
+    @property
+    def aircrafts(self) -> List[Aircraft]:
+        """Returns aircrafts"""
+        return self.__aircrafts
+    
+    @property
+    def aircraft_vehicles(self) -> List[AircraftVehicle]:
+        """Returns aircraft vehicles"""
+        self.__aircraft_vehicles = [aircraft.vehicle for aircraft in self.aircrafts]
+        return self.__aircraft_vehicles
+    
+    @property
+    def aircraft_fccs(self) -> List[AircraftFCC]:
+        """Returns aircraft flight control computers"""
+        self.__aircraft_fccs = [aircraft.fcc for aircraft in self.aircrafts]
+        return self.__aircraft_fccs
+    
+    @property
+    def simulation_state(self) -> SimulationState:
+        """Returns simulation state"""
+        return self.__simulation_state
+    
+    @property
+    def adsb_cycles(self) -> int:
+        """Returns ADS-B cycles count"""
+        return self.__adsb_cycles
+    
+    def count_adsb_cycles(self) -> None:
+        """Increments ADS-B cycle counter"""
+        self.__adsb_cycles += 1
+        self.simulation_state.adsb_cycles = self.adsb_cycles
+
     def run(self) -> None:
         """Runs ADS-B simulation thread with precise timeout"""
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.cycle()
             self.msleep(max(0, self.simulation_state.adsb_threshold - start_timestamp.msecsTo(QTime.currentTime())))
         return super().run()
     
     def cycle(self) -> None:
         """Executes ADS-B simulation cycle"""
         aircraft_vehicle_1 : AircraftVehicle = self.aircraft_vehicles[0]
         aircraft_vehicle_2 : AircraftVehicle = self.aircraft_vehicles[1]
 
         if not self.simulation_state.is_paused:
-            self.adsb_cycles += 1
+            self.count_adsb_cycles()
             self.simulation_state.update_adsb_settings()
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
             
@@ -53,15 +86,15 @@
 
                 # console destination reach time
                 if fcc.destination and self.simulation_state.adsb_report:
                     time_to_reaching_destination : float = (QVector3D.dotProduct(fcc.destination - aircraft.position, aircraft.speed) / QVector3D.dotProduct(aircraft.speed, aircraft.speed))
                     print(f"Aircraft {aircraft.aircraft_id} will reach its destination in " + "{:.2f}".format(time_to_reaching_destination) + " (" + "{:.1f}".format(time_to_reaching_destination / 60) + " minutes or " + "{:.1f}".format(time_to_reaching_destination / 3600) + " hours)")
 
                 # console report output
-                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
+                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0 and self.simulation_state.is_realtime:
                     self.print_adsb_report(aircraft)
 
                 # safe zone occupancy check
                 if relative_position.length() < self.simulation_state.minimum_separation:
                     if not fcc.safe_zone_occupied:
                         fcc.safe_zone_occupied = True
                         if not self.simulation_state.override_avoid_collisions:
@@ -70,41 +103,38 @@
                 else:
                     if fcc.safe_zone_occupied:
                         fcc.safe_zone_occupied = False
                         self.simulation_state.avoid_collisions = False
                     print("Safe zone free")
                     return
 
-            if not self.simulation_state.avoid_collisions:
-                return
-
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
-                print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m")
+                print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
 
                 if miss_distance_vector.length() == 0:
                     print("Head-on collision detected")
                     logging.info("Head-on collision detected")
 
                 # resolve confict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
                     print("Conflict condition detected")
-                    for aircraft in self.aircraft_fccs:
-                        if not aircraft.evade_maneuver:
-                            aircraft.apply_evade_maneuver(
-                                opponent_speed = self.aircraft_vehicles[1 - aircraft.aircraft_id].speed,
-                                miss_distance_vector = miss_distance_vector,
-                                unresolved_region = unresolved_region,
-                                time_to_closest_approach = time_to_closest_approach)
-                    # print("Sum of vector sharing resolutions: ", self.aircraft_fccs[0].vector_sharing_resolution.length() + self.aircraft_fccs[1].vector_sharing_resolution.length() + miss_distance_vector.length())
+                    if self.simulation_state.avoid_collisions:
+                        for aircraft in self.aircraft_fccs:
+                            if not aircraft.evade_maneuver:
+                                aircraft.apply_evade_maneuver(
+                                    opponent_speed = self.aircraft_vehicles[1 - aircraft.aircraft_id].speed,
+                                    miss_distance_vector = miss_distance_vector,
+                                    unresolved_region = unresolved_region,
+                                    time_to_closest_approach = time_to_closest_approach)
                     print("Relative distance: "+ "{:.2f}".format(relative_position.length()) + "m")
 
                 # probable collision
                 collision_distance = aircraft_vehicle_1.size / 2 + aircraft_vehicle_2.size / 2
                 collision_region = collision_distance - miss_distance_vector.length()
                 if collision_region > 0:
                     print("Collision detected")
@@ -128,24 +158,51 @@
             "; target roll angle: " + "{:.2f}".format(fcc.target_roll_angle) +
             "; yaw angle: " + "{:.2f}".format(aircraft.yaw_angle) +
             "; target yaw angle: " + "{:.2f}".format(fcc.target_yaw_angle) +
             "; x: " + "{:.2f}".format(aircraft.position.x()) +
             "; y: " + "{:.2f}".format(aircraft.position.y()) +
             "; z: " + "{:.2f}".format(aircraft.position.z()))
         if fcc.destination is not None:
-            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
-                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
-                "; dest x: " + "{:.2f}".format(fcc.destination.x()) +
-                "; dest y: " + "{:.2f}".format(fcc.destination.y()) +
-                "; dest z: " + "{:.2f}".format(fcc.destination.z()) +
-                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
-                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
-                "; t: " + str(self.adsb_cycles) +
-                "; phys: " + str(self.simulation_state.physics_cycles))
+            if self.simulation_state.is_realtime:
+                print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                    "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                    "; dest x: " + "{:.2f}".format(fcc.destination.x()) +
+                    "; dest y: " + "{:.2f}".format(fcc.destination.y()) +
+                    "; dest z: " + "{:.2f}".format(fcc.destination.z()) +
+                    "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                    "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                    "; t: " + str(self.adsb_cycles) +
+                    "; phys: " + str(self.simulation_state.physics_cycles))
+            else:
+                print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                    "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                    "; dest x: " + "{:.2f}".format(fcc.destination.x()) +
+                    "; dest y: " + "{:.2f}".format(fcc.destination.y()) +
+                    "; dest z: " + "{:.2f}".format(fcc.destination.z()) +
+                    "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                    "; t: " + str(self.adsb_cycles) +
+                    "; phys: " + str(self.simulation_state.physics_cycles))
         else:
-            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
-                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
-                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
-                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
-                "; t: " + str(self.adsb_cycles) +
-                "; phys: " + str(self.simulation_state.physics_cycles) +
-                "; no destination")
+            if self.simulation_state.is_realtime:
+                print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                    "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                    "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                    "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                    "; t: " + str(self.adsb_cycles) +
+                    "; phys: " + str(self.simulation_state.physics_cycles) +
+                    "; no destination")
+            else:
+                print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                    "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                    "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                    "; t: " + str(self.adsb_cycles) +
+                    "; phys: " + str(self.simulation_state.physics_cycles) +
+                    "; no destination")
+        # speed check
+        absolute_speed = sqrt(aircraft.speed.x() ** 2 + aircraft.speed.y() ** 2 + aircraft.speed.z() ** 2)
+        horizontal_speed = sqrt(aircraft.speed.x() ** 2 + aircraft.speed.y() ** 2)
+        vertical_speed = abs(aircraft.speed.z())
+        geometrical_speed = sqrt(horizontal_speed ** 2 + vertical_speed ** 2)
+        print("absolute speed: " + "{:.2f}".format(absolute_speed) +
+            "; horizontal speed: " + "{:.2f}".format(horizontal_speed) +
+            "; vertical speed: " + "{:.2f}".format(vertical_speed) +
+            "; geometrical speed: " + "{:.2f}".format(geometrical_speed))
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py

```diff
@@ -8,18 +8,17 @@
 
 class SimulationFPS(QThread):
     """Thread running frames per second counter"""
 
     def __init__(self, parent : QMainWindow, simulation_state : SimulationState) -> None:
         super(SimulationFPS, self).__init__(parent)
         self.__mutex : QMutex = QMutex()
+        self.__simulation_state = simulation_state
         self.__counted_frames : int = 0
-
-        self.simulation_state = simulation_state
-        self.previous_timestamp = QTime.currentTime()
+        self.__previous_timestamp = QTime.currentTime()
         
     def run(self) -> None:
         """Runs rendered simulation frames counter thread with precise 500ms timeout"""
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             elapsed_time : float = self.previous_timestamp.msecsTo(start_timestamp)
             if self.counted_frames() > 0:
@@ -29,24 +28,42 @@
                 self.simulation_state.fps = 0.0
             self.previous_timestamp = QTime.currentTime()
             self.msleep(max(0, 500 - start_timestamp.msecsTo(QTime.currentTime())))
         return super().run()
 
     def count_frame(self) -> None:
         """Increments fps count"""
-        QMutexLocker(self.__mutex)
-        self.__counted_frames += 1
+        with QMutexLocker(self.__mutex):
+            self.__counted_frames += 1
 
     def reset_frames(self) -> None:
         """Resets fps count"""
-        QMutexLocker(self.__mutex)
-        self.__counted_frames = 0
+        with QMutexLocker(self.__mutex):
+            self.__counted_frames = 0
 
     def counted_frames(self) -> int:
         """Returns counted frames"""
-        QMutexLocker(self.__mutex)
-        return self.__counted_frames
+        with QMutexLocker(self.__mutex):
+            return self.__counted_frames
+        
+    @property
+    def simulation_state(self) -> SimulationState:
+        """Returns simulation state"""
+        with QMutexLocker(self.__mutex):
+            return self.__simulation_state
+    
+    @property
+    def previous_timestamp(self) -> QTime:
+        """Returns previous timestamp"""
+        with QMutexLocker(self.__mutex):
+            return self.__previous_timestamp
+    
+    @previous_timestamp.setter
+    def previous_timestamp(self, previous_timestamp : QTime) -> None:
+        """Sets previous timestamp"""
+        with QMutexLocker(self.__mutex):
+            self.__previous_timestamp = previous_timestamp
 
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
         event.accept()
         return super().closeEvent(event)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -15,39 +15,81 @@
 from .simulation_state import SimulationState
 
 class SimulationPhysics(QThread):
     """Thread running simulation's physics"""
 
     def __init__(self, parent : QMainWindow, aircrafts : List[Aircraft], simulation_state : SimulationState) -> None:
         super(SimulationPhysics, self).__init__(parent)
-        self.aircrafts = aircrafts
-        self.aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
-        self.aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
-        self.simulation_state = simulation_state
-        self.cycles : int = 0
-        self.global_start_timestamp : QTime | None = None
-        self.global_stop_timestamp : QTime | None = None
+        self.__aircrafts = aircrafts
+        self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
+        self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
+        self.__simulation_state = simulation_state
+        self.__cycles : int = 0
+        self.__global_start_timestamp : QTime | None = None
+        self.__global_stop_timestamp : QTime | None = None
+
+    @property
+    def aircrafts(self) -> List[Aircraft]:
+        """Returns aircrafts"""
+        return self.__aircrafts
+    
+    @property
+    def aircraft_vehicles(self) -> List[AircraftVehicle]:
+        """Returns aircraft vehicles"""
+        self.__aircraft_vehicles = [aircraft.vehicle for aircraft in self.aircrafts]
+        return self.__aircraft_vehicles
+    
+    @property
+    def aircraft_fccs(self) -> List[AircraftFCC]:
+        """Returns aircraft flight control computers"""
+        self.__aircraft_fccs = [aircraft.fcc for aircraft in self.aircrafts]
+        return self.__aircraft_fccs
+    
+    @property
+    def simulation_state(self) -> SimulationState:
+        """Returns simulation state"""
+        return self.__simulation_state
+    
+    @property
+    def cycles(self) -> int:
+        """Returns physics cycles count"""
+        return self.__cycles
+    
+    def count_cycles(self) -> None:
+        """Increments physics cycle counter"""
+        self.__cycles += 1
+        self.simulation_state.physics_cycles = self.cycles
+    
+    @property
+    def global_start_timestamp(self) -> QTime | None:
+        """Returns global start timestamp"""
+        return self.__global_start_timestamp
+    
+    @property
+    def global_stop_timestamp(self) -> QTime | None:
+        """Returns global stop timestamp"""
+        return self.__global_stop_timestamp
 
     def run(self) -> None:
         """Runs physics simulation thread"""
         self.mark_start_time()
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.cycle(self.simulation_state.simulation_threshold)
             self.msleep(max(0, (self.simulation_state.simulation_threshold) - start_timestamp.msecsTo(QTime.currentTime())))
         self.mark_stop_time()
         return super().run()
     
     def mark_start_time(self) -> None:
         """Marks start time of the simulation"""
-        self.global_start_timestamp = QTime.currentTime()
+        self.__global_start_timestamp = QTime.currentTime()
 
     def mark_stop_time(self) -> None:
         """Marks stop time of the simulation"""
-        self.global_stop_timestamp = QTime.currentTime()
+        self.__global_stop_timestamp = QTime.currentTime()
     
     def cycle(self, elapsed_time : float) -> None:
         """Executes physics simulation cycle"""
         if self.simulation_state.reset_demanded:
             self.reset_aircrafts()
         if not self.simulation_state.is_paused:
             self.count_cycles()
@@ -67,20 +109,20 @@
         self.aircraft_fccs[1].reset()
         self.simulation_state.apply_reset()
 
     def update_aircrafts_position(self, elapsed_time : float) -> bool:
         """Updates aircrafts position, returns true on collision"""
         for aircraft in self.aircraft_vehicles:
             if aircraft.position.z() <= 0.0:
-                logging.warn("Aircraft's " + str(aircraft.aircraft_id) + "collision with the ground. Coordinates: " + str(self.aircraft_vehicles[aircraft.aircraft_id].position.toTuple()))
+                logging.warning("Aircraft's " + str(aircraft.aircraft_id) + "collision with the ground. Coordinates: " + str(self.aircraft_vehicles[aircraft.aircraft_id].position.toTuple()))
                 print("Collision with ground")
                 return True
             relative_distance : float = dist(aircraft.position.toTuple(), self.aircraft_vehicles[1 - aircraft.aircraft_id].position.toTuple())
             if relative_distance <= aircraft.size:
-                logging.warn("Aircrafts' 0 and 1 collision. Coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
+                logging.warning("Aircrafts' 0 and 1 collision. Coordinates: " + str(self.aircraft_vehicles[0].position.toTuple()) + " and " + str(self.aircraft_vehicles[1].position.toTuple()))
                 print("Collision with another aircraft")
                 return True
             old_pos : QVector3D = copy(aircraft.position)
             aircraft.move(
                 aircraft.speed.x() * elapsed_time / 1000.0,
                 aircraft.speed.y() * elapsed_time / 1000.0,
                 aircraft.speed.z() * elapsed_time / 1000.0)
@@ -88,25 +130,30 @@
         return False
     
     def update_aircrafts_speed_angles(self, elapsed_time : float) -> None:
         """Updates aircrafts movement speed and angles"""
         assert elapsed_time > 0.0
         for aircraft in self.aircraft_vehicles:
             # flight control computer
-            id : int = aircraft.aircraft_id
-            fcc : AircraftFCC = self.aircraft_fccs[id]
-            cause_collision = self.simulation_state.first_cause_collision if id == 0 else self.simulation_state.second_cause_collision
-            fcc.update() if not cause_collision else fcc.update_target(self.aircraft_vehicles[1 - id].position + self.aircraft_vehicles[1 - id].speed)
+            aircraft_id : int = aircraft.aircraft_id
+            try:
+                fcc : AircraftFCC = self.aircraft_fccs[aircraft_id]
+            except IndexError:
+                logging.error("Aircraft's " + str(aircraft_id) + " flight control computer not found")
+                return
+            cause_collision = self.simulation_state.first_cause_collision if aircraft_id == 0 else self.simulation_state.second_cause_collision
+            fcc.update() if not cause_collision else fcc.update_target(self.aircraft_vehicles[1 - aircraft_id].position + self.aircraft_vehicles[1 - aircraft_id].speed)
             
             # speed
             current_speed = aircraft.absolute_speed
             target_speed = fcc.target_speed
             speed_difference = abs(current_speed - target_speed)
-            if speed_difference > 0.001 and current_speed > 20.0 and current_speed < 340: # make drone subsonic
-                max_speed_delta = aircraft.max_acceleration / elapsed_time
+            max_speed_delta = aircraft.max_acceleration / elapsed_time
+            if speed_difference > 0.001 and current_speed - max_speed_delta > 20.0 and current_speed + max_speed_delta < 340: # make drone subsonic
+                
                 if speed_difference < max_speed_delta:
                     pass # become target
                 elif current_speed < target_speed:
                     target_speed = current_speed + max_speed_delta
                 else:
                     target_speed = current_speed - max_speed_delta
                 speed_scale_factor : float = target_speed / current_speed
@@ -151,12 +198,7 @@
                 delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
 
                 new_yaw_angle : float = 0.0
                 new_yaw_angle = current_yaw_angle + delta_yaw_angle
 
                 aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
                 aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
-
-    def count_cycles(self) -> None:
-        """Increments physics cycle counter"""
-        self.cycles += 1
-        self.simulation_state.physics_cycles = self.cycles
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py

```diff
@@ -7,17 +7,27 @@
 from .simulation_state import SimulationState
 
 class SimulationRender(QThread):
     """Thread running simulation rendering"""
 
     def __init__(self, parent : QMainWindow, simulation_widget : SimulationWidget, simulation_state : SimulationState) -> None:
         super(SimulationRender, self).__init__(parent)
-        self.simulation_widget = simulation_widget
-        self.simulation_state = simulation_state
+        self.__simulation_widget = simulation_widget
+        self.__simulation_state = simulation_state
         
+    @property
+    def simulation_widget(self) -> SimulationWidget:
+        """Returns simulation widget"""
+        return self.__simulation_widget
+    
+    @property
+    def simulation_state(self) -> SimulationState:
+        """Returns simulation state"""
+        return self.__simulation_state
+
     def run(self) -> None:
         """Runs simulation widget update with precise timeout"""
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.simulation_state.update_render_settings()
             self.simulation_widget.update()
             self.msleep(max(0, self.simulation_state.gui_render_threshold - start_timestamp.msecsTo(QTime.currentTime())))
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -12,157 +12,448 @@
     """Class defining simulation's traits"""
 
     def __init__(self, simulation_settings : SimulationSettings, is_realtime : bool = True, avoid_collisions : bool = False) -> None:
         super(SimulationState, self).__init__()
         self.__mutex : QMutex = QMutex()
 
         # simulation state
-        self.simulation_settings = simulation_settings
-        self.update_settings()
-        self.is_realtime : bool = is_realtime
-        self.avoid_collisions : bool = avoid_collisions
-        self.override_avoid_collisions : bool = True
-        self.minimum_separation : float = 9260.0 # 5nmi
-        self.physics_cycles : int = 0
-        self.is_paused : bool = False
-        self.is_running : bool = True
+        self.__simulation_settings = simulation_settings
+        self.__is_realtime : bool = is_realtime
+        self.__avoid_collisions : bool = avoid_collisions
+        self.__override_avoid_collisions : bool = True
+        self.__minimum_separation : float = 9260.0 # 5nmi
+        self.__physics_cycles : int = 0
+        self.__is_paused : bool = False
+        self.__is_running : bool = True
         self.__reset_demanded : bool = False
-        self.pause_start_timestamp : QTime | None = None
-        self.time_paused : int = 0 # ms
+        self.__pause_start_timestamp : QTime | None = None
+        self.__time_paused : int = 0 # ms
         self.__adsb_report : bool = True
         self.__collision : bool = False
         self.__first_cause_collision : bool = False
         self.__second_cause_collision : bool = False
+        self.update_settings()
 
+        # render state
+        self.__fps : float = 0.0
         if is_realtime:
-            # render state
             override_gui_scale : bool = True
             if not override_gui_scale:
                 self.__gui_scale : float = 0.5 # define gui scaling
                 if SimulationSettings.screen_resolution.height() < 1440:
-                    self.gui_scale = 0.375
+                    self.__gui_scale = 0.375
                 elif SimulationSettings.screen_resolution.height() < 1080:
-                    self.gui_scale = 0.25
+                    self.__gui_scale = 0.25
                 elif SimulationSettings.screen_resolution.height() < 480:
-                    self.gui_scale = 0.125
+                    self.__gui_scale = 0.125
             else:
                 self.__gui_scale : float = 0.75
-            self.fps : float = 0.0
-            self.draw_fps : bool = True
-            self.draw_aircraft : bool = True
-            self.draw_grid : bool = False
-            self.draw_path : bool = True
-            self.draw_speed_vectors : bool = True
-            self.draw_collision_detection : bool = True
-            self.optimize_drawing : bool = False
-            self.follow_aircraft : bool = False
-            self.focus_aircraft_id : int = 0
+            self.__draw_fps : bool = True
+            self.__draw_aircraft : bool = True
+            self.__draw_grid : bool = False
+            self.__draw_path : bool = True
+            self.__draw_speed_vectors : bool = True
+            self.__draw_safezones : bool = True
+            self.__draw_collision_detection : bool = True
+            self.__optimize_drawing : bool = False
+            self.__follow_aircraft : bool = False
+            self.__focus_aircraft_id : int = 0
 
             # assets
-            self.aircraft_pixmap : QPixmap = QPixmap()
-            if not self.aircraft_pixmap.load("assets/aircraft.png"):
+            self.__aircraft_pixmap : QPixmap = QPixmap()
+            if not self.__aircraft_pixmap.load("assets/aircraft.png"):
                 try:
                     Path("assets").mkdir(parents=True, exist_ok=True)
                     urlretrieve(
                         "https://raw.githubusercontent.com/mldxo/uav-collision-avoidance/main/assets/aircraft.png",
                         "assets/aircraft.png")
-                    self.aircraft_pixmap.load("assets/aircraft.png")
+                    self.__aircraft_pixmap.load("assets/aircraft.png")
                 except:
                     pass
+
+    @property
+    def simulation_settings(self) -> SimulationSettings:
+        """Returns simulation settings"""
+        with QMutexLocker(self.__mutex):
+            return self.__simulation_settings
     
     @property
-    def adsb_report(self) -> None:
-        """Returns ADS-B commandline info reporting flag"""
-        return self.__adsb_report
+    def is_realtime(self) -> bool:
+        """Returns simulation type"""
+        with QMutexLocker(self.__mutex):
+            return self.__is_realtime
+    
+    @property
+    def avoid_collisions(self) -> bool:
+        """Returns collision avoidance flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__avoid_collisions
+    
+    @avoid_collisions.setter
+    def avoid_collisions(self, avoid_collisions : bool) -> None:
+        """Sets collision avoidance flag"""
+        with QMutexLocker(self.__mutex):
+            self.__avoid_collisions = avoid_collisions
 
-    def update_settings(self) -> None:
-        """Updates all state settings"""
-        self.update_render_settings()
-        self.update_simulation_settings()
-        self.update_adsb_settings()
+    def toggle_avoid_collisions(self) -> None:
+        """Toggles collision avoidance"""
+        with QMutexLocker(self.__mutex):
+            self.__avoid_collisions = not self.__avoid_collisions
 
-    def toggle_adsb_report(self) -> None:
-        """Toggles ADS-B commandline info report"""
-        self.__adsb_report = not self.__adsb_report
+    @property
+    def override_avoid_collisions(self) -> bool:
+        """Returns collision avoidance override flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__override_avoid_collisions
     
-    def update_render_settings(self) -> None:
-        """Updates simulation render state settings"""
-        self.gui_render_threshold = self.simulation_settings.gui_render_threshold
+    @override_avoid_collisions.setter
+    def override_avoid_collisions(self, override_avoid_collisions : bool) -> None:
+        """Sets collision avoidance override flag"""
+        with QMutexLocker(self.__mutex):
+            self.__override_avoid_collisions = override_avoid_collisions
+
+    @property
+    def minimum_separation(self) -> float:
+        """Returns minimum separation distance"""
+        with QMutexLocker(self.__mutex):
+            return self.__minimum_separation
     
-    def update_simulation_settings(self) -> None:
-        """Updates simulation physics state settings"""
-        self.simulation_threshold = self.simulation_settings.simulation_threshold
-        self.g_acceleration = self.simulation_settings.g_acceleration
+    @property
+    def physics_cycles(self) -> int:
+        """Returns physics cycles count"""
+        with QMutexLocker(self.__mutex):
+            return self.__physics_cycles
+        
+    @physics_cycles.setter
+    def physics_cycles(self, physics_cycles : int) -> None:
+        """Sets physics cycles count"""
+        with QMutexLocker(self.__mutex):
+            self.__physics_cycles = physics_cycles
     
-    def update_adsb_settings(self) -> None:
-        """Updates simulation ADS-B state settings"""
-        self.adsb_threshold = self.simulation_settings.adsb_threshold
-
-    def append_paused_time(self) -> None:
-        """Appends time elapsed during recent pause"""
-        if self.pause_start_timestamp is not None:
-            self.time_paused += self.pause_start_timestamp.msecsTo(QTime.currentTime())
-
+    @property
+    def is_paused(self) -> bool:
+        """Returns pause state"""
+        with QMutexLocker(self.__mutex):
+            return self.__is_paused
+        
+    @is_paused.setter
+    def is_paused(self, is_paused : bool) -> None:
+        """Sets pause state"""
+        with QMutexLocker(self.__mutex):
+            self.__is_paused = is_paused
+        
     def toggle_pause(self) -> None:
         """Pauses the simulation"""
         if self.is_paused:
             self.append_paused_time()
             self.is_paused = False
         else:
             if not self.is_running:
                 return
             self.pause_start_timestamp = QTime.currentTime()
             self.is_paused = True
     
     @property
+    def is_running(self) -> bool:
+        """Returns running state"""
+        with QMutexLocker(self.__mutex):
+            return self.__is_running
+        
+    @is_running.setter
+    def is_running(self, is_running : bool) -> None:
+        """Sets running state"""
+        with QMutexLocker(self.__mutex):
+            self.__is_running = is_running
+    
+    @property
+    def reset_demanded(self) -> bool:
+        """Returns simulation reset state"""
+        with QMutexLocker(self.__mutex):
+            return self.__reset_demanded
+        
+    def reset(self) -> None:
+        """Resets simulation to its start state"""
+        with QMutexLocker(self.__mutex):
+            self.__reset_demanded = True
+
+    def apply_reset(self) -> None:
+        """Sets back simulation reset state"""
+        with QMutexLocker(self.__mutex):
+            self.__reset_demanded = False
+    
+    @property
+    def pause_start_timestamp(self) -> QTime | None:
+        """Returns pause start timestamp"""
+        with QMutexLocker(self.__mutex):
+            return self.__pause_start_timestamp
+        
+    @pause_start_timestamp.setter
+    def pause_start_timestamp(self, pause_start_timestamp : QTime | None) -> None:
+        """Sets pause start timestamp"""
+        with QMutexLocker(self.__mutex):
+            self.__pause_start_timestamp = pause_start_timestamp
+        
+    def append_paused_time(self) -> None:
+        """Appends time elapsed during recent pause"""
+        with QMutexLocker(self.__mutex):
+            if self.__pause_start_timestamp is not None:
+                self.__time_paused += self.__pause_start_timestamp.msecsTo(QTime.currentTime())
+    
+    @property
+    def time_paused(self) -> int:
+        """Returns time paused"""
+        with QMutexLocker(self.__mutex):
+            return self.__time_paused
+        
+    @time_paused.setter
+    def time_paused(self, time_paused : int) -> None:
+        """Sets time paused"""
+        with QMutexLocker(self.__mutex):
+            self.__time_paused = time_paused
+    
+    @property
+    def adsb_report(self) -> None:
+        """Returns ADS-B commandline info reporting flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__adsb_report
+
+    def toggle_adsb_report(self) -> None:
+        """Toggles ADS-B commandline info report"""
+        with QMutexLocker(self.__mutex):
+            self.__adsb_report = not self.__adsb_report
+
+    @property
     def collision(self) -> bool:
         """Returns collision state"""
-        return self.__collision
+        with QMutexLocker(self.__mutex):
+            return self.__collision
 
     def register_collision(self) -> None:
         """Registers collision"""
-        self.__collision = True
+        with QMutexLocker(self.__mutex):
+            self.__collision = True
     
     @property
     def first_cause_collision(self) -> bool:
         """Returns causing collision state"""
-        return self.__first_cause_collision
+        with QMutexLocker(self.__mutex):
+            return self.__first_cause_collision
     
     def toggle_first_causing_collision(self) -> None:
         """Toggles causing collision state"""
-        self.__first_cause_collision = not self.__first_cause_collision
+        with QMutexLocker(self.__mutex):
+            self.__first_cause_collision = not self.__first_cause_collision
     
     @property
     def second_cause_collision(self) -> bool:
         """Returns causing collision state"""
-        return self.__second_cause_collision
+        with QMutexLocker(self.__mutex):
+            return self.__second_cause_collision
     
     def toggle_second_causing_collision(self) -> None:
         """Toggles causing collision state"""
-        self.__second_cause_collision = not self.__second_cause_collision
+        with QMutexLocker(self.__mutex):
+            self.__second_cause_collision = not self.__second_cause_collision
+
+    @property
+    def gui_scale(self) -> float:
+        """Returns GUI scaling factor"""
+        with QMutexLocker(self.__mutex):
+            return self.__gui_scale
     
+    @gui_scale.setter
+    def gui_scale(self, gui_scale : float) -> None:
+        """Sets GUI scaling factor"""
+        with QMutexLocker(self.__mutex):
+            self.__gui_scale = gui_scale
+
     @property
-    def reset_demanded(self) -> bool:
-        """Returns simulation reset state"""
+    def fps(self) -> float:
+        """Returns FPS"""
         with QMutexLocker(self.__mutex):
-            return self.__reset_demanded
+            return self.__fps
+    
+    @fps.setter
+    def fps(self, fps : float) -> None:
+        """Sets FPS"""
+        with QMutexLocker(self.__mutex):
+            self.__fps = fps
 
-    def reset(self) -> None:
-        """Resets simulation to its start state"""
+    @property
+    def draw_fps(self) -> bool:
+        """Returns FPS display flag"""
         with QMutexLocker(self.__mutex):
-            self.__reset_demanded = True
+            return self.__draw_fps
 
-    def apply_reset(self) -> None:
-        """Sets back simulation reset state"""
+    def toggle_draw_fps(self) -> None:
+        """Toggles FPS display"""
         with QMutexLocker(self.__mutex):
-            self.__reset_demanded = False
+            self.__draw_fps = not self.__draw_fps
 
     @property
-    def gui_scale(self) -> float:
-        """Returns GUI scaling factor"""
-        return self.__gui_scale
+    def draw_aircraft(self) -> bool:
+        """Returns aircraft display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_aircraft
+        
+    def toggle_draw_aircraft(self) -> None:
+        """Toggles aircraft display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_aircraft = not self.__draw_aircraft
+
+    @property
+    def draw_grid(self) -> bool:
+        """Returns grid display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_grid
+        
+    def toggle_draw_grid(self) -> None:
+        """Toggles grid display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_grid = not self.__draw_grid
+
+    @property
+    def draw_path(self) -> bool:
+        """Returns path display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_path
+        
+    def toggle_draw_path(self) -> None:
+        """Toggles path display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_path = not self.__draw_path
+
+    @property
+    def draw_speed_vectors(self) -> bool:
+        """Returns speed vector display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_speed_vectors
+        
+    def toggle_draw_speed_vectors(self) -> None:
+        """Toggles speed vector display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_speed_vectors = not self.__draw_speed_vectors
+
+    @property
+    def draw_safezones(self) -> bool:
+        """Returns safezone display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_safezones
+        
+    def toggle_draw_safezones(self) -> None:
+        """Toggles safezone display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_safezones = not self.__draw_safezones
+
+    @property
+    def draw_collision_detection(self) -> bool:
+        """Returns collision detection display flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__draw_collision_detection
+        
+    def toggle_draw_collision_detection(self) -> None:
+        """Toggles collision detection display"""
+        with QMutexLocker(self.__mutex):
+            self.__draw_collision_detection = not self.__draw_collision_detection
+
+    @property
+    def optimize_drawing(self) -> bool:
+        """Returns drawing optimization flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__optimize_drawing
+        
+    def toggle_optimize_drawing(self) -> None:
+        """Toggles drawing optimization"""
+        with QMutexLocker(self.__mutex):
+            self.__optimize_drawing = not self.__optimize_drawing
+
+    @property
+    def follow_aircraft(self) -> bool:
+        """Returns aircraft following flag"""
+        with QMutexLocker(self.__mutex):
+            return self.__follow_aircraft
+        
+    def toggle_follow_aircraft(self) -> None:
+        """Toggles aircraft following"""
+        with QMutexLocker(self.__mutex):
+            self.__follow_aircraft = not self.__follow_aircraft
+
+    @property
+    def focus_aircraft_id(self) -> int:
+        """Returns aircraft id to focus on"""
+        with QMutexLocker(self.__mutex):
+            return self.__focus_aircraft_id
+        
+    def toggle_focus_aircraft(self) -> None:
+        """Toggles aircraft focus"""
+        with QMutexLocker(self.__mutex):
+            self.__focus_aircraft_id = int(not self.__focus_aircraft_id)
+
+    @property
+    def gui_render_threshold(self) -> int:
+        """Returns GUI render threshold"""
+        with QMutexLocker(self.__mutex):
+            return self.__gui_render_threshold
+        
+    @gui_render_threshold.setter
+    def gui_render_threshold(self, gui_render_threshold : int) -> None:
+        """Sets GUI render threshold"""
+        with QMutexLocker(self.__mutex):
+            self.__gui_render_threshold = gui_render_threshold
+
+    @property
+    def aircraft_pixmap(self) -> QPixmap:
+        """Returns aircraft pixmap"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_pixmap
+        
+    @aircraft_pixmap.setter
+    def aircraft_pixmap(self, aircraft_pixmap : QPixmap) -> None:
+        """Sets aircraft pixmap"""
+        with QMutexLocker(self.__mutex):
+            self.__aircraft_pixmap = aircraft_pixmap
+
+    @property
+    def adsb_threshold(self) -> int:
+        """Returns ADS-B threshold"""
+        with QMutexLocker(self.__mutex):
+            return self.__adsb_threshold
+        
+    @adsb_threshold.setter
+    def adsb_threshold(self, adsb_threshold : int) -> None:
+        """Sets ADS-B threshold"""
+        with QMutexLocker(self.__mutex):
+            self.__adsb_threshold = adsb_threshold
+
+    @property
+    def simulation_threshold(self) -> float:
+        """Returns simulation threshold"""
+        with QMutexLocker(self.__mutex):
+            return self.__simulation_threshold
+        
+    @property
+    def g_acceleration(self) -> float:
+        """Returns acceleration due to gravity"""
+        with QMutexLocker(self.__mutex):
+            return self.__g_acceleration
+
+    def update_settings(self) -> None:
+        """Updates all state settings"""
+        self.update_render_settings()
+        self.update_simulation_settings()
+        self.update_adsb_settings()
+
+    def update_render_settings(self) -> None:
+        """Updates simulation render state settings"""
+        self.__gui_render_threshold = self.simulation_settings.gui_render_threshold
     
-    @gui_scale.setter
-    def gui_scale(self, value : float) -> None:
-        """Sets GUI scaling factor"""
-        if value > 0.0:
-            self.__gui_scale = value
+    def update_simulation_settings(self) -> None:
+        """Updates simulation physics state settings"""
+        self.__simulation_threshold = self.simulation_settings.simulation_threshold
+        self.__g_acceleration = self.simulation_settings.g_acceleration
+    
+    def update_adsb_settings(self) -> None:
+        """Updates simulation ADS-B state settings"""
+        self.__adsb_threshold = self.simulation_settings.adsb_threshold
+
+    def __del__(self) -> None:
+        self.__mutex.unlock()
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -1,14 +1,14 @@
 """Simulation widget for the main window of the simulation app"""
 
 from copy import copy
 from math import cos, radians, sqrt, degrees, atan2, dist
 from typing import List
 
-from PySide6.QtCore import Qt, QPointF, Signal
+from PySide6.QtCore import Qt, QPointF, Signal, QMutex, QMutexLocker
 from PySide6.QtGui import QPaintEvent, QPainter, QKeyEvent, \
     QMouseEvent, QIcon, QPixmap, QCloseEvent, QVector3D, QPolygonF, QWheelEvent, QColor
 from PySide6.QtWidgets import QWidget, QApplication
 
 from ..aircraft.aircraft import Aircraft
 from ..aircraft.aircraft_fcc import AircraftFCC
 from ..aircraft.aircraft_vehicle import AircraftVehicle
@@ -17,83 +17,190 @@
 
 class SimulationWidget(QWidget):
     """Main widget representing the simulation"""
     stop_signal = Signal(str)
     def __init__(self, aircrafts : List[Aircraft],
                  simulation_fps : SimulationFPS, simulation_state : SimulationSettings) -> None:
         super().__init__()
-        self.aircrafts = aircrafts
-        self.aircraft_vehicles : List[AircraftVehicle] = [
-            aircraft.vehicle for aircraft in self.aircrafts]
-        self.aircraft_fccs : List[AircraftFCC] = [
-            aircraft.fcc for aircraft in self.aircrafts]
-        self.simulation_fps = simulation_fps
-        self.simulation_state = simulation_state
-
-        self.window_width : float = SimulationSettings.resolution[0]
-        self.window_height : float = SimulationSettings.resolution[1]
-        self.screen_offset_x : float = 0.0
-        self.screen_offset_y : float = 0.0
+        self.__mutex : QMutex = QMutex()
+        self.__aircrafts = aircrafts
+        self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
+        self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
+        self.__simulation_fps = simulation_fps
+        self.__simulation_state = simulation_state
+
+        self.__window_width : float = SimulationSettings.resolution[0]
+        self.__window_height : float = SimulationSettings.resolution[1]
+        self.__screen_offset_x : float = 0.0
+        self.__screen_offset_y : float = 0.0
         self.setGeometry(
-            SimulationSettings.screen_resolution.width() / 2 - self.window_width / 2,
-            SimulationSettings.screen_resolution.height() / 2 - self.window_height / 2 - 30,
-            self.window_width,
-            self.window_height)
+            SimulationSettings.screen_resolution.width() / 2 - self.__window_width / 2,
+            SimulationSettings.screen_resolution.height() / 2 - self.__window_height / 2 - 30,
+            self.__window_width,
+            self.__window_height)
         self.setStyleSheet("background-color: white;")
         self.setWindowTitle(QApplication.applicationName() + " " + QApplication.applicationVersion())
 
-        self.icon = QIcon()
-        self.icon.addPixmap(self.generate_icon(), QIcon.Mode.Normal, QIcon.State.Off)
-        self.setWindowIcon(self.icon)
+        self.__icon = QIcon()
+        self.__icon.addPixmap(self.generate_icon(), QIcon.Mode.Normal, QIcon.State.Off)
+        self.setWindowIcon(self.__icon)
 
         self.__moving_view_up : bool = False
         self.__moving_view_down : bool = False
         self.__moving_view_left : bool = False
         self.__moving_view_right : bool = False
         self.__steering_left : bool = False
         self.__steering_right : bool = False
         self.__steering_up : bool = False
         self.__steering_down : bool = False
 
         self.center_offsets()
 
+    @property
+    def aircrafts(self) -> List[Aircraft]:
+        """Returns aircrafts"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircrafts
+        
+    @property
+    def aircraft_vehicles(self) -> List[AircraftVehicle]:
+        """Returns aircraft vehicles"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_vehicles
+        
+    @property
+    def aircraft_fccs(self) -> List[AircraftFCC]:
+        """Returns aircraft fccs"""
+        with QMutexLocker(self.__mutex):
+            return self.__aircraft_fccs
+        
+    @property
+    def simulation_fps(self) -> SimulationFPS:
+        """Returns simulation fps"""
+        with QMutexLocker(self.__mutex):
+            return self.__simulation_fps
+        
+    @property
+    def simulation_state(self) -> SimulationSettings:
+        """Returns simulation state"""
+        with QMutexLocker(self.__mutex):
+            return self.__simulation_state
+        
+    @property
+    def window_width(self) -> float:
+        """Returns window width"""
+        with QMutexLocker(self.__mutex):
+            return self.__window_width
+        
+    @property
+    def window_height(self) -> float:
+        """Returns window height"""
+        with QMutexLocker(self.__mutex):
+            return self.__window_height
+        
+    @property
+    def screen_offset_x(self) -> float:
+        """Returns screen offset x"""
+        with QMutexLocker(self.__mutex):
+            return self.__screen_offset_x
+        
+    @property
+    def screen_offset_y(self) -> float:
+        """Returns screen offset y"""
+        with QMutexLocker(self.__mutex):
+            return self.__screen_offset_y
+        
+    @property
+    def icon(self) -> QIcon:
+        """Returns icon"""
+        with QMutexLocker(self.__mutex):
+            return self.__icon
+        
+    @property
+    def moving_view_up(self) -> bool:
+        """Returns moving view up"""
+        with QMutexLocker(self.__mutex):
+            return self.__moving_view_up
+        
+    @property
+    def moving_view_down(self) -> bool:
+        """Returns moving view down"""
+        with QMutexLocker(self.__mutex):
+            return self.__moving_view_down
+        
+    @property
+    def moving_view_left(self) -> bool:
+        """Returns moving view left"""
+        with QMutexLocker(self.__mutex):
+            return self.__moving_view_left
+        
+    @property
+    def moving_view_right(self) -> bool:
+        """Returns moving view right"""
+        with QMutexLocker(self.__mutex):
+            return self.__moving_view_right
+        
+    @property
+    def steering_left(self) -> bool:
+        """Returns steering left"""
+        with QMutexLocker(self.__mutex):
+            return self.__steering_left
+        
+    @property
+    def steering_right(self) -> bool:
+        """Returns steering right"""
+        with QMutexLocker(self.__mutex):
+            return self.__steering_right
+
+    @property
+    def steering_up(self) -> bool:
+        """Returns steering up"""
+        with QMutexLocker(self.__mutex):
+            return self.__steering_up
+        
+    @property
+    def steering_down(self) -> bool:
+        """Returns steering down"""
+        with QMutexLocker(self.__mutex):
+            return self.__steering_down
+
     def generate_icon(self) -> QPixmap:
         """Returns icon for the main window"""
-        pixmap = QPixmap(self.simulation_state.aircraft_pixmap)
-        painter = QPainter(pixmap)
+        pixmap : QPixmap = QPixmap(self.__simulation_state.aircraft_pixmap)
+        painter : QPainter = QPainter(pixmap)
         painter.setBrush(QColor("white"))
-        painter.drawEllipse(self.simulation_state.aircraft_pixmap.rect())
+        painter.drawEllipse(self.__simulation_state.aircraft_pixmap.rect())
         painter.drawPixmap(
-            self.simulation_state.aircraft_pixmap.width() * 0.125,
-            self.simulation_state.aircraft_pixmap.height() * 0.125,
-            self.simulation_state.aircraft_pixmap.scaled(self.simulation_state.aircraft_pixmap.width() * 0.75,
-            self.simulation_state.aircraft_pixmap.height() * 0.75))
+            self.__simulation_state.aircraft_pixmap.width() * 0.125,
+            self.__simulation_state.aircraft_pixmap.height() * 0.125,
+            self.__simulation_state.aircraft_pixmap.scaled(self.__simulation_state.aircraft_pixmap.width() * 0.75,
+            self.__simulation_state.aircraft_pixmap.height() * 0.75))
         painter.end()
         return pixmap
 
     def draw_aircraft(self, aircraft : AircraftVehicle, scale : float) -> None:
         """Draws given aircraft vehicle"""
         yaw_angle : float = aircraft.yaw_angle
         size : float = aircraft.size * scale
         pixmap : QPixmap
-        if not self.simulation_state.aircraft_pixmap.isNull():
-            pixmap = self.simulation_state.aircraft_pixmap.scaled(
+        if not self.__simulation_state.aircraft_pixmap.isNull():
+            pixmap = self.__simulation_state.aircraft_pixmap.scaled(
                 size * abs(cos(radians(aircraft.roll_angle))),
                 size * abs(cos(radians(aircraft.pitch_angle)))
             )
         else:
             pixmap = QPixmap(
                 size * abs(cos(radians(aircraft.roll_angle))),
                 size * abs(cos(radians(aircraft.pitch_angle))))
             pixmap.fill(Qt.GlobalColor.black)
         painter = QPainter(self)
         painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
         painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform, True)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         painter.translate(QPointF(
             (aircraft.position.x() * scale) + x_offset,
             (aircraft.position.y() * scale) + y_offset))
         painter.rotate(yaw_angle)
         painter.translate(QPointF(
             (- size / 2) - x_offset,
             (- size / 2) - y_offset))
@@ -103,25 +210,25 @@
             size * abs(cos(radians(aircraft.pitch_angle))))
         painter.rotate(-yaw_angle)
         painter.end()
         self.draw_text(aircraft.position, scale, f"Aircraft {aircraft.aircraft_id}")
 
     def draw_destinations(self, aircraft : AircraftVehicle, scale : float) -> None:
         """Draws destinations of given aircraft vehicle"""
-        for idx, destination in enumerate(self.aircraft_fccs[aircraft.aircraft_id].destinations):
+        for idx, destination in enumerate(self.__aircraft_fccs[aircraft.aircraft_id].destinations):
             self.draw_disk(destination, 2.5 / scale, scale)
             self.draw_text(destination, scale, f"Destination {idx} of Aircraft {aircraft.aircraft_id}")
 
     def draw_text(self, point : QVector3D, scale : float, text : str, color : QColor = QColor(0, 0, 0)) -> None:
         """Draws text at given coordinates"""
         painter = QPainter(self)
         painter.setBrush(Qt.BrushStyle.SolidPattern)
         painter.setPen(color)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         if scale != 0:
             painter.drawText(
                 QPointF(
                     ((point.x() + 10) * scale) + x_offset,
                     ((point.y() + 10) * scale) + y_offset),
                 text)
         else:
@@ -132,61 +239,61 @@
                 text)
         painter.end()
 
     def draw_circle(self, point : QVector3D, size : float, scale : float, color : QColor = QColor(0, 0, 0)) -> None:
         """Draws circle at given coordinates (empty)"""
         painter = QPainter(self)
         painter.setPen(color)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         painter.drawEllipse(
             QPointF(
-                point.x() * scale - (size * scale / 2) + x_offset,
-                point.y() * scale - (size * scale / 2) + y_offset),
+                point.x() * scale + x_offset,
+                point.y() * scale + y_offset),
             float(size * scale),
             float(size * scale))
         painter.end()
     
     def draw_disk(self, point : QVector3D, size : float, scale : float, color : QColor = QColor(0, 0, 0)) -> None:
         """Draws disk at given coordinates (full)"""
         painter = QPainter(self)
         painter.setBrush(Qt.BrushStyle.SolidPattern)
         painter.setPen(color)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         painter.drawEllipse(
             QPointF(
-                point.x() * scale - (size * scale / 2) + x_offset,
-                point.y() * scale - (size * scale / 2) + y_offset),
+                point.x() * scale + x_offset,
+                point.y() * scale + y_offset),
             float(size * scale),
             float(size * scale))
         painter.end()
 
     def draw_line(self, point1 : QVector3D, point2 : QVector3D, scale : float, color : QColor = QColor(0, 0, 0)) -> None:
         """Draws line connecting given points"""
         painter = QPainter(self)
         painter.setBrush(Qt.BrushStyle.SolidPattern)
         painter.setPen(color)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         painter.drawLine(
             int((point1.x() * scale) + x_offset),
             int((point1.y() * scale) + y_offset),
             int((point2.x() * scale) + x_offset),
             int((point2.y() * scale) + y_offset))
         painter.end()
 
     def draw_vector(self, point1 : QVector3D, point2 : QVector3D, scale : float, color : QColor = QColor(0, 0, 0)) -> None:
         """Draws vector pointing from first to second point"""
         self.draw_line(point1, point2, scale, color)
         painter = QPainter(self)
         painter.setBrush(Qt.BrushStyle.SolidPattern)
         painter.setPen(color)
-        x_offset = self.screen_offset_x * scale
-        y_offset = self.screen_offset_y * scale
+        x_offset = self.__screen_offset_x * scale
+        y_offset = self.__screen_offset_y * scale
         angle = degrees(atan2(point1.x() - point2.x(), point1.y() - point2.y()))
         arrowhead_size = SimulationSettings.screen_resolution.width() / 400 * scale
         arrowhead_height = arrowhead_size * sqrt(3) / 2
         polygon = QPolygonF()
         polygon.append(
             QPointF(
                 (point2.x() * scale - arrowhead_size / 2) + x_offset,
@@ -212,98 +319,98 @@
         painter.end()
     
     def draw_collision_detection(self, scale : float) -> None:
         """Draws collision detection elements for the aircrafts"""
         detected_conflict : bool = False
         predicted_collision : bool = False
         time_to_closest_approach : float = 0.0
-        if self.simulation_state.collision:
-            self.draw_text(QVector3D(self.window_width - 70, 10, 0), 0, "COLLISION", QColor(255, 0, 0))
+        if self.__simulation_state.collision:
+            self.draw_text(QVector3D(self.__window_width - 70, 10, 0), 0, "COLLISION", QColor(255, 0, 0))
             return
-        for aircraft in self.aircraft_vehicles:
-            relative_position = aircraft.position - self.aircraft_vehicles[1 - aircraft.aircraft_id].position
-            speed_difference : QVector3D = aircraft.speed - self.aircraft_vehicles[1 - aircraft.aircraft_id].speed
+        for aircraft in self.__aircraft_vehicles:
+            relative_position = aircraft.position - self.__aircraft_vehicles[1 - aircraft.aircraft_id].position
+            speed_difference : QVector3D = aircraft.speed - self.__aircraft_vehicles[1 - aircraft.aircraft_id].speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             if time_to_closest_approach > 0:
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
-                collision_distance = aircraft.size / 2 + self.aircraft_vehicles[1 - aircraft.aircraft_id].size / 2
-                unresolved_region = self.simulation_state.minimum_separation - miss_distance_vector.length()
+                collision_distance = aircraft.size / 2 + self.__aircraft_vehicles[1 - aircraft.aircraft_id].size / 2
+                unresolved_region = self.__simulation_state.minimum_separation - miss_distance_vector.length()
                 collision_region = collision_distance - miss_distance_vector.length()
                 if miss_distance_vector.length() == 0:
-                    self.draw_text(QVector3D(self.window_width - 200, 10, 0), 0, "DETECTED HEAD-ON COLLISION", QColor(255, 0, 255))
+                    self.draw_text(QVector3D(self.__window_width - 200, 10, 0), 0, "DETECTED HEAD-ON COLLISION", QColor(255, 0, 255))
                     predicted_collision = True
                     detected_conflict = True
                 elif collision_region > 0:
-                    self.draw_text(QVector3D(self.window_width - 140, 10, 0), 0, "DETECTED COLLISION", QColor(255, 0, 0))
+                    self.draw_text(QVector3D(self.__window_width - 140, 10, 0), 0, "DETECTED COLLISION", QColor(255, 0, 0))
                     self.draw_vector(
-                        self.aircraft_vehicles[1 - aircraft.aircraft_id].position,
-                        self.aircraft_vehicles[1 - aircraft.aircraft_id].position + miss_distance_vector,
+                        self.__aircraft_vehicles[1 - aircraft.aircraft_id].position,
+                        self.__aircraft_vehicles[1 - aircraft.aircraft_id].position + miss_distance_vector,
                         scale,
                         QColor(0, 0, 255))
                     predicted_collision = True
                     detected_conflict = True
                 elif unresolved_region > 0:
-                    self.draw_text(QVector3D(self.window_width - 140, 10, 0), 0, "DETECTED CONFLICT")
+                    self.draw_text(QVector3D(self.__window_width - 140, 10, 0), 0, "DETECTED CONFLICT")
                     self.draw_vector(
-                        self.aircraft_vehicles[1 - aircraft.aircraft_id].position,
-                        self.aircraft_vehicles[1 - aircraft.aircraft_id].position + miss_distance_vector,
+                        self.__aircraft_vehicles[1 - aircraft.aircraft_id].position,
+                        self.__aircraft_vehicles[1 - aircraft.aircraft_id].position + miss_distance_vector,
                         scale,
                         QColor(0, 0, 255))
                     detected_conflict = True
-                if self.aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution is not None:
+                if self.__aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution is not None:
                     self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach, scale)
-                    self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach + self.aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution, scale, QColor(30, 255, 30))
+                    self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach + self.__aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution, scale, QColor(30, 255, 30))
         if predicted_collision:
-            aircraft = self.aircraft_vehicles[0]
+            aircraft = self.__aircraft_vehicles[0]
             collision_location = aircraft.position + aircraft.speed * time_to_closest_approach
             self.draw_circle(collision_location, 2.5 / scale, scale, QColor(255, 0, 0))
-        relative_distance = dist(self.aircraft_vehicles[0].position.toTuple(), self.aircraft_vehicles[1].position.toTuple())
-        if relative_distance < self.simulation_state.minimum_separation:
+        relative_distance = dist(self.__aircraft_vehicles[0].position.toTuple(), self.__aircraft_vehicles[1].position.toTuple())
+        if relative_distance < self.__simulation_state.minimum_separation:
             if detected_conflict:
-                self.draw_text(QVector3D(self.window_width - 260, 30, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
+                self.draw_text(QVector3D(self.__window_width - 260, 30, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.__simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
             else:
-                self.draw_text(QVector3D(self.window_width - 260, 10, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
+                self.draw_text(QVector3D(self.__window_width - 260, 10, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.__simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
     
     def draw_grid(self, x_offset : float, y_offset : float, scale : float) -> None:
         """Draws grid on the screen"""
         # todo: use offsets
-        for x in range(0, int(self.window_width / scale - x_offset / 100), 100): # vertical lines
+        for x in range(0, int(self.__window_width / scale - x_offset / 100), 100): # vertical lines
             self.draw_line(
                 QVector3D(x - x_offset / 100, 0 - y_offset, 0),
-                QVector3D(x - x_offset / 100, self.window_height / scale - y_offset, 0),
+                QVector3D(x - x_offset / 100, self.__window_height / scale - y_offset, 0),
                 scale,
                 QColor(40, 40, 40))
-        for y in range(0, int(self.window_height / scale), 100): # horizontal lines
+        for y in range(0, int(self.__window_height / scale), 100): # horizontal lines
             self.draw_line(
                 QVector3D(- x_offset, y - y_offset / 100, 0),
-                QVector3D(self.window_width / scale - x_offset, y - y_offset / 100, 0),
+                QVector3D(self.__window_width / scale - x_offset, y - y_offset / 100, 0),
                 scale,
                 QColor(40, 40, 40))
 
     def update_moving_offsets(self) -> None:
         """Updates screen offsets based on current input"""
-        scale : float = self.simulation_state.gui_scale
+        scale : float = self.__simulation_state.gui_scale
         if self.__moving_view_up:
-            self.screen_offset_y += 10.0 / scale
+            self.__screen_offset_y += 10.0 / scale
         if self.__moving_view_down:
-            self.screen_offset_y -= 10.0 / scale
+            self.__screen_offset_y -= 10.0 / scale
         if self.__moving_view_left:
-            self.screen_offset_x += 10.0 / scale
+            self.__screen_offset_x += 10.0 / scale
         if self.__moving_view_right:
-            self.screen_offset_x -= 10.0 / scale
+            self.__screen_offset_x -= 10.0 / scale
 
     def update_steering(self) -> None:
         """Updates aircraft steering based on current input"""
         if self.aircrafts[0] and (self.__steering_up or self.__steering_down or self.__steering_left or self.__steering_right):
             if sum([self.__steering_up, self.__steering_down, self.__steering_left, self.__steering_right]) >= 3:
                 return
-            self.aircraft_fccs[0].ignore_destinations = True
+            self.__aircraft_fccs[0].ignore_destinations = True
             target_yaw_angle : float | None = None
             if self.__steering_up and self.__steering_left:
                 target_yaw_angle = -45.0
             elif self.__steering_up and self.__steering_right:
                 target_yaw_angle = 45.0
             elif self.__steering_down and self.__steering_left:
                 target_yaw_angle = -135.0
@@ -314,111 +421,113 @@
             elif self.__steering_down:
                 target_yaw_angle = 180.0
             elif self.__steering_left:
                 target_yaw_angle = -90.0
             elif self.__steering_right:
                 target_yaw_angle = 90.0
             if target_yaw_angle is not None:
-                self.aircraft_fccs[0].target_yaw_angle = target_yaw_angle
+                self.__aircraft_fccs[0].target_yaw_angle = target_yaw_angle
 
     def center_offsets(self) -> None:
         """Updates screen offsets centering on selected aircraft"""
-        scale : float = self.simulation_state.gui_scale
-        id = self.simulation_state.focus_aircraft_id
-        self.screen_offset_x = (self.window_width / 2.0) / scale - self.aircraft_vehicles[id].position.x()
-        self.screen_offset_y = (self.window_height / 2.0) / scale - self.aircraft_vehicles[id].position.y()
+        scale : float = self.__simulation_state.gui_scale
+        id = self.__simulation_state.focus_aircraft_id
+        self.__screen_offset_x = (self.__window_width / 2.0) / scale - self.__aircraft_vehicles[id].position.x()
+        self.__screen_offset_y = (self.__window_height / 2.0) / scale - self.__aircraft_vehicles[id].position.y()
 
     def update_resolutions(self) -> None:
         """Updates bounding box resolution"""
-        self.window_width = self.width()
-        self.window_height = self.height()
+        self.__window_width = self.width()
+        self.__window_height = self.height()
 
     def zoom(self, factor : float) -> None:
         """Zooms in/out the simulation render"""
-        if self.simulation_state.gui_scale + factor >= 2:
-            self.simulation_state.gui_scale = 2
+        if self.__simulation_state.gui_scale + factor >= 3:
+            self.__simulation_state.gui_scale = 3
             return
-        while factor > 0 and factor > 2 * self.simulation_state.gui_scale:
+        while factor > 0 and factor > 2 * self.__simulation_state.gui_scale:
             factor /= 2
-        while factor < 0 and self.simulation_state.gui_scale + factor <= 0:
+        while factor < 0 and self.__simulation_state.gui_scale + factor <= 0:
             factor /= 2
-        old_scale : float = self.simulation_state.gui_scale
-        self.simulation_state.gui_scale += factor
-        scale : float = self.simulation_state.gui_scale
-        self.screen_offset_x = self.screen_offset_x * (old_scale / scale)
-        self.screen_offset_y = self.screen_offset_y * (old_scale / scale)
+        old_scale : float = self.__simulation_state.gui_scale
+        self.__simulation_state.gui_scale += factor
+        scale : float = self.__simulation_state.gui_scale
+        self.__screen_offset_x = self.__screen_offset_x * (old_scale / scale)
+        self.__screen_offset_y = self.__screen_offset_y * (old_scale / scale)
 
     def paintEvent(self, event : QPaintEvent) -> None:
         """Qt method painting the aircrafts"""
-        self.simulation_fps.count_frame()
-        scale : float = self.simulation_state.gui_scale
+        self.__simulation_fps.count_frame()
+        scale : float = self.__simulation_state.gui_scale
         self.update_steering()
-        if not self.simulation_state.follow_aircraft:
+        if not self.__simulation_state.follow_aircraft:
             self.update_moving_offsets()
         else:
             self.center_offsets()
 
-        if self.simulation_state.draw_fps:
-            self.draw_text(QVector3D(10, 10, 0), 0, "FPS: " + "{:.2f}".format(self.simulation_state.fps))
-        if self.simulation_state.draw_grid:
-            self.draw_grid(self.screen_offset_x, self.screen_offset_y, scale)
+        if self.__simulation_state.draw_fps:
+            self.draw_text(QVector3D(10, 10, 0), 0, "FPS: " + "{:.2f}".format(self.__simulation_state.fps))
+        if self.__simulation_state.draw_grid:
+            self.draw_grid(self.__screen_offset_x, self.__screen_offset_y, scale)
 
-        if self.simulation_state.optimize_drawing:
+        if self.__simulation_state.optimize_drawing:
             anything_to_draw : bool = False
-            geometric_center : QVector3D = self.aircraft_vehicles[0].position + self.aircraft_vehicles[1].position / 2
-            if (geometric_center.x() * scale + 300) + self.screen_offset_x * scale >= 0 and \
-                (geometric_center.y() * scale + 200) + self.screen_offset_y * scale >= 0 and \
-                (geometric_center.x() * scale - 300) + self.screen_offset_x * scale <= self.window_width and \
-                (geometric_center.y() * scale - 200) + self.screen_offset_y * scale <= self.window_height:
+            geometric_center : QVector3D = self.__aircraft_vehicles[0].position + self.__aircraft_vehicles[1].position / 2
+            if (geometric_center.x() * scale + 300) + self.__screen_offset_x * scale >= 0 and \
+                (geometric_center.y() * scale + 200) + self.__screen_offset_y * scale >= 0 and \
+                (geometric_center.x() * scale - 300) + self.__screen_offset_x * scale <= self.__window_width and \
+                (geometric_center.y() * scale - 200) + self.__screen_offset_y * scale <= self.__window_height:
                 anything_to_draw = True
             if not anything_to_draw:
-                for aircraft in self.aircraft_vehicles:
-                    if (aircraft.position.x() * scale) + self.screen_offset_x * scale >= 0 and \
-                        (aircraft.position.y() * scale) + self.screen_offset_y * scale >= 0 and \
-                        (aircraft.position.x() * scale) + self.screen_offset_x * scale <= self.window_width and \
-                        (aircraft.position.y() * scale) + self.screen_offset_y * scale <= self.window_height:
+                for aircraft in self.__aircraft_vehicles:
+                    if (aircraft.position.x() * scale) + self.__screen_offset_x * scale >= 0 and \
+                        (aircraft.position.y() * scale) + self.__screen_offset_y * scale >= 0 and \
+                        (aircraft.position.x() * scale) + self.__screen_offset_x * scale <= self.__window_width and \
+                        (aircraft.position.y() * scale) + self.__screen_offset_y * scale <= self.__window_height:
                         anything_to_draw = True
                         break
             if not anything_to_draw:
                 return super().paintEvent(event)
 
-        if self.simulation_state.draw_collision_detection:
+        if self.__simulation_state.draw_collision_detection:
             self.draw_collision_detection(scale)
-        for aircraft in self.aircraft_vehicles:
-            if self.simulation_state.draw_aircraft:
+        for aircraft in self.__aircraft_vehicles:
+            if self.__simulation_state.draw_aircraft:
                 self.draw_aircraft(aircraft, scale)
                 self.draw_destinations(aircraft, scale)
-            if self.simulation_state.draw_speed_vectors:
+            if self.__simulation_state.draw_speed_vectors:
                 self.draw_vector(aircraft.position, aircraft.position + aircraft.speed, scale)
+            if self.__simulation_state.draw_safezones:
+                self.draw_circle(aircraft.position, self.__simulation_state.minimum_separation, scale)
         return super().paintEvent(event)
 
     def mousePressEvent(self, event: QMouseEvent) -> None:
         """Qt method controlling single click mouse input"""
-        scale : float = self.simulation_state.gui_scale
+        scale : float = self.__simulation_state.gui_scale
         click_x : int = event.pos().x()
         click_y : int = event.pos().y()
-        real_x : float = click_x / scale - self.screen_offset_x
-        real_y : float = click_y / scale - self.screen_offset_y
+        real_x : float = click_x / scale - self.__screen_offset_x
+        real_y : float = click_y / scale - self.__screen_offset_y
         print(
             "click: physical coords: x: " + "{:.2f}".format(real_x) +
             "; y: " + "{:.2f}".format(real_y) +
             " | window coords: x: " + "{:.2f}".format(click_x) +
             "; y: " + "{:.2f}".format(click_y))
         if event.button() == Qt.MouseButton.LeftButton:
-            self.aircraft_fccs[0].add_first_destination(QVector3D(
+            self.__aircraft_fccs[0].add_first_destination(QVector3D(
                 real_x,
                 real_y,
                 1000.0))
         elif event.button() == Qt.MouseButton.RightButton:
-            self.aircraft_fccs[0].add_last_destination(QVector3D(
+            self.__aircraft_fccs[0].add_last_destination(QVector3D(
                 real_x,
                 real_y,
                 1000.0))
         elif event.button() == Qt.MouseButton.MiddleButton:
-            self.aircraft_vehicles[0].position = QVector3D(
+            self.__aircraft_vehicles[0].position = QVector3D(
                 real_x,
                 real_y,
                 1000.0)
         return super().mousePressEvent(event)
     
     def mouseReleaseEvent(self, event: QMouseEvent) -> None:
         """Qt method controlling mouse release input"""
@@ -440,40 +549,45 @@
     def keyPressEvent(self, event: QKeyEvent) -> None:
         """Qt method controlling keyboard input"""
         if event.key() == Qt.Key.Key_Escape:
             self.close()
         elif event.key() == Qt.Key.Key_Slash:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
-            self.simulation_state.toggle_pause()
+            self.__simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
-            self.simulation_state.reset()
+            print("Resetting simulation...")
+            self.__simulation_state.reset()
             self.center_offsets()
+        elif event.key() == Qt.Key.Key_F:
+            self.__simulation_state.toggle_fps()
         elif event.key() == Qt.Key.Key_Plus:
             self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
             self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
-            self.simulation_state.toggle_adsb_report()
+            self.__simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
-            self.aircraft_fccs[0].target_speed -= 10.0
+            self.__aircraft_fccs[0].accelerate(-10.0)
         elif event.key() == Qt.Key.Key_F3:
-            self.aircraft_fccs[0].target_speed += 10.0
+            self.__aircraft_fccs[0].accelerate(10.0)
         elif event.key() == Qt.Key.Key_O:
-            self.simulation_state.toggle_first_causing_collision()
+            self.__simulation_state.toggle_first_cause_collision()
         elif event.key() == Qt.Key.Key_P:
-            self.simulation_state.toggle_second_causing_collision()
+            self.__simulation_state.toggle_second_cause_collision()
         elif event.key() == Qt.Key.Key_T:
-            self.simulation_state.avoid_collisions = not self.simulation_state.avoid_collisions
+            self.__simulation_state.toggle_avoid_collisions()
         elif event.key() == Qt.Key.Key_N:
-            self.simulation_state.follow_aircraft = not self.simulation_state.follow_aircraft
+            self.__simulation_state.toggle_follow_aircraft()
         elif event.key() == Qt.Key.Key_M:
-            self.simulation_state.focus_aircraft_id = int(not self.simulation_state.focus_aircraft_id)
+            self.__simulation_state.toggle_focus_aircraft()
+        elif event.key() == Qt.Key.Key_Z:
+            self.__simulation_state.toggle_draw_safezones()
         elif event.key() == Qt.Key.Key_Left:
             self.__moving_view_left = True
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = True
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = True
         elif event.key() == Qt.Key.Key_Down:
@@ -487,26 +601,26 @@
                 self.__steering_up = True
             elif event.key() == Qt.Key.Key_S:
                 self.__steering_down = True
         return super().keyPressEvent(event)
     
     def keyReleaseEvent(self, event: QKeyEvent) -> None:
         """Qt method controlling keyboard input"""
-        if event.key() == Qt.Key.Key_Slash and event.isAutoRepeat() and self.simulation_state.is_paused:
-            self.simulation_state.toggle_pause()
+        if event.key() == Qt.Key.Key_Slash and event.isAutoRepeat() and self.__simulation_state.is_paused:
+            self.__simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_Left:
             self.__moving_view_left = False
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = False
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = False
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = False
         if self.aircrafts[0]:
-            self.aircraft_fccs[0].ignore_destinations = False
+            self.__aircraft_fccs[0].ignore_destinations = False
             if event.key() == Qt.Key.Key_A:
                 self.__steering_left = False
             elif event.key() == Qt.Key.Key_D:
                 self.__steering_right = False
             elif event.key() == Qt.Key.Key_W:
                 self.__steering_up = False
             elif event.key() == Qt.Key.Key_S:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -326,15 +326,15 @@
             print("Set target avoiding collision: " + "{:.2f}".format(target_avoiding.x()) + " " + "{:.2f}".format(target_avoiding.y()) + " " + "{:.2f}".format(target_avoiding.z()))
             self.add_first_destination(target_avoiding)
 
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         with QMutexLocker(self.__mutex):
             if self.__evade_maneuver:
-                logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
+                logging.info("Aircraft %s reset evade maneuver", self.__aircraft.aircraft_id)
                 self.__evade_maneuver = False
                 #self.vector_sharing_resolution = None
 
     def find_best_roll_angle(self, current_yaw_angle: float, target_yaw_angle: float) -> float:
         """Finds best roll angle for the targeted yaw angle"""
         difference = (target_yaw_angle - current_yaw_angle + 180) % 360 - 180
         if abs(difference) < 0.001:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -1,12 +1,13 @@
 """Simulation module"""
 
 import csv
 import logging
 import datetime
+from copy import copy
 from typing import List
 from pathlib import Path
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QCloseEvent, QVector3D
 from PySide6.QtWidgets import QMainWindow
 
@@ -15,14 +16,15 @@
 from ..simulation.simulation_settings import SimulationSettings
 from ..simulation.simulation_physics import SimulationPhysics
 from ..simulation.simulation_state import SimulationState
 from ..simulation.simulation_render import SimulationRender
 from ..simulation.simulation_widget import SimulationWidget
 from ..simulation.simulation_adsb import SimulationADSB
 from ..simulation.simulation_fps import SimulationFPS
+from ..simulation.simulation_data import SimulationData
 
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 10_000_000) -> None: # 10_000_000 ms = 10_000 s = 2h 46m 40s
         super().__init__()
         SimulationSettings().__init__()
@@ -90,57 +92,123 @@
         self.simulation_physics.start(priority = QThread.Priority.TimeCriticalPriority)
         self.simulation_adsb.start(priority = QThread.Priority.NormalPriority)
         self.simulation_fps.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.show()
         self.simulation_render.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.stop_signal.connect(self.stop)
     
-    def run_headless(self, aircrafts : List[Aircraft] | None = None, avoid_collisions : bool = False) -> None:
+    def run_headless(self, avoid_collisions : bool = False, aircrafts : List[Aircraft] | None = None) -> None:
         """Executes simulation without GUI"""
         logging.info("Starting headless simulation")
         if aircrafts is None or aircrafts == []:
             self.setup_debug_aircrafts()
         else:
             self.setup_aircrafts(aircrafts)
+        simulation_data : SimulationData = SimulationData()
+        simulation_data.aircraft_1_initial_position = copy(self.aircrafts[0].vehicle.position)
+        simulation_data.aircraft_2_initial_position = copy(self.aircrafts[1].vehicle.position)
+        simulation_data.aircraft_1_initial_roll_angle = copy(self.aircrafts[0].vehicle.roll_angle)
+        simulation_data.aircraft_2_initial_roll_angle = copy(self.aircrafts[1].vehicle.roll_angle)
+        simulation_data.collision = False
+
         self.state = SimulationState(SimulationSettings(), is_realtime = False, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
         time_step : int = int(self.state.simulation_threshold)
         adsb_step : int = int(self.state.adsb_threshold)
         partial_time_counter : int = adsb_step
         for time in range(0, int(self.simulation_time / self.state.simulation_threshold), time_step):
-            print(time)
             self.simulation_physics.cycle(time_step)
             if partial_time_counter >= adsb_step:
                 self.simulation_adsb.cycle()
                 partial_time_counter = 0
             partial_time_counter += time_step
             if self.state.collision:
+                simulation_data.collision = True
                 break
+        simulation_data.minimal_miss_distance = copy(self.simulation_adsb.minimal_miss_distance)
+        simulation_data.aircraft_1_final_position = copy(self.aircrafts[0].vehicle.position)
+        simulation_data.aircraft_2_final_position = copy(self.aircrafts[1].vehicle.position)
         self.stop()
+        return simulation_data
     
     def run_tests(self, test_number : int = 10) -> None:
         """Runs simulation tests"""
         if test_number < 1:
             test_number = 10
         logging.info("Running simulation tests")
         start_timestamp = QTime.currentTime()
         #list_of_aircrafts : List[List[Aircraft]] = self.generate_test_aircrafts(test_number) # todo
+        export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
+        try:
+            Path("logs/data").mkdir(parents=True, exist_ok=True)
+        except:
+            return
+        file = open(f"logs/data/simulation-{export_time}.csv", "w")
+        writer = csv.writer(file)
+        writer.writerow([
+            "test_id",
+            "aircraft_1_init_pos_x",
+            "aircraft_1_init_pos_y",
+            "aircraft_1_init_pos_z",
+            "aircraft_2_init_pos_x",
+            "aircraft_2_init_pos_y",
+            "aircraft_2_init_pos_z",
+            "aircraft_1_final_pos_x_if_no_avoidance",
+            "aircraft_1_final_pos_y_if_no_avoidance",
+            "aircraft_1_final_pos_z_if_no_avoidance",
+            "aircraft_2_final_pos_x_if_no_avoidance",
+            "aircraft_2_final_pos_y_if_no_avoidance",
+            "aircraft_2_final_pos_z_if_no_avoidance",
+            "aircraft_1_final_pos_x_if_avoidance",
+            "aircraft_1_final_pos_y_if_avoidance",
+            "aircraft_1_final_pos_z_if_avoidance",
+            "aircraft_2_final_pos_x_if_avoidance",
+            "aircraft_2_final_pos_y_if_avoidance",
+            "aircraft_2_final_pos_z_if_avoidance",
+            "collision_if_no_avoidance",
+            "collision_if_avoidance",
+            "minimal_miss_distance_if_no_avoidance",
+            "minimal_miss_distance_if_avoidance"])
         for i in range(0, test_number, 1):
             logging.info("Test %d - no collision avoidance", i)
-            # self.run_headless(aircrafts = list_of_aircrafts[i], avoid_collisions = False)
-            self.run_headless()
-            # self.export_results()
+            # self.run_headless(avoid_collisions = True, aircrafts = list_of_aircrafts[i])
+            simulation_data_no_avoidance : SimulationData = self.run_headless()
             self.state = None
 
             logging.info("Test %d - collision avoidance", i)
-            # self.run_headless(aircrafts = list_of_aircrafts[i], avoid_collisions = True)
-            self.run_headless()
-            # self.export_results()
+            # self.run_headless(avoid_collisions = True, aircrafts = list_of_aircrafts[i])
+            simulation_data_avoidance : SimulationData = self.run_headless(avoid_collisions = True)
             self.state = None
+
+            writer.writerow([
+                i,
+                simulation_data_no_avoidance.aircraft_1_initial_position.x(),
+                simulation_data_no_avoidance.aircraft_1_initial_position.y(),
+                simulation_data_no_avoidance.aircraft_1_initial_position.z(),
+                simulation_data_no_avoidance.aircraft_2_initial_position.x(),
+                simulation_data_no_avoidance.aircraft_2_initial_position.y(),
+                simulation_data_no_avoidance.aircraft_2_initial_position.z(),
+                simulation_data_no_avoidance.aircraft_1_final_position.x(),
+                simulation_data_no_avoidance.aircraft_1_final_position.y(),
+                simulation_data_no_avoidance.aircraft_1_final_position.z(),
+                simulation_data_no_avoidance.aircraft_2_final_position.x(),
+                simulation_data_no_avoidance.aircraft_2_final_position.y(),
+                simulation_data_no_avoidance.aircraft_2_final_position.z(),
+                simulation_data_avoidance.aircraft_1_final_position.x(),
+                simulation_data_avoidance.aircraft_1_final_position.y(),
+                simulation_data_avoidance.aircraft_1_final_position.z(),
+                simulation_data_avoidance.aircraft_2_final_position.x(),
+                simulation_data_avoidance.aircraft_2_final_position.y(),
+                simulation_data_avoidance.aircraft_2_final_position.z(),
+                simulation_data_no_avoidance.collision,
+                simulation_data_avoidance.collision,
+                simulation_data_no_avoidance.minimal_miss_distance,
+                simulation_data_avoidance.minimal_miss_distance])
+        file.close()
         real_time : float = start_timestamp.msecsTo(QTime.currentTime()) / 1000
         print("Total time elapsed: " + "{:.2f}".format(real_time) + "s")
         logging.info("Total time elapsed: %ss", "{:.2f}".format(real_time))
     
     def stop(self) -> None:
         """Stops simulation"""
         if self.headless:
@@ -229,25 +297,36 @@
                     speed = QVector3D(70, 0.1, 0)),
                 Aircraft(
                     position = QVector3D(5000, 500, 1000),
                     speed = QVector3D(-50, 0, 0)),
             ]
         elif test_case == 2:
             aircrafts : List[Aircraft] = [
-                Aircraft( # avoidance test
+                Aircraft( # avoidance test slow
                     position = QVector3D(0, 0, 1000),
                     speed = QVector3D(30, -30, 0),
                     initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                 Aircraft(
                     position = QVector3D(0, -100_000, 1000),
                     speed = QVector3D(30, 29, 0),
                     initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
             ]
         elif test_case == 3:
             aircrafts : List[Aircraft] = [
+                Aircraft( # avoidance test
+                    position = QVector3D(0, 0, 1000),
+                    speed = QVector3D(150, -150, 0),
+                    initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
+                Aircraft(
+                    position = QVector3D(0, -100_000, 1000),
+                    speed = QVector3D(150, 145, 0),
+                    initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
+            ]
+        elif test_case == 4:
+            aircrafts : List[Aircraft] = [
                 Aircraft( # avoidance test fast
                     position = QVector3D(0, 0, 1000),
                     speed = QVector3D(300, -300, 0),
                     initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                 Aircraft(
                     position = QVector3D(0, -100_000, 1000),
                     speed = QVector3D(300, 290, 0),
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -19,14 +19,15 @@
     def __init__(self, parent : QMainWindow, aircrafts : List[Aircraft], simulation_state : SimulationState) -> None:
         super(SimulationADSB, self).__init__(parent)
         self.__aircrafts = aircrafts
         self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
         self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
         self.__simulation_state = simulation_state
         self.__adsb_cycles : int = 0
+        self.__minimal_miss_distance : float = float("inf")
         
     @property
     def aircrafts(self) -> List[Aircraft]:
         """Returns aircrafts"""
         return self.__aircrafts
     
     @property
@@ -52,14 +53,24 @@
         return self.__adsb_cycles
     
     def count_adsb_cycles(self) -> None:
         """Increments ADS-B cycle counter"""
         self.__adsb_cycles += 1
         self.simulation_state.adsb_cycles = self.adsb_cycles
 
+    @property
+    def minimal_miss_distance(self) -> float:
+        """Returns minimal miss distance"""
+        return self.__minimal_miss_distance
+    
+    @minimal_miss_distance.setter
+    def minimal_miss_distance(self, minimal_miss_distance : float) -> None:
+        """Sets minimal miss distance"""
+        self.__minimal_miss_distance = minimal_miss_distance
+
     def run(self) -> None:
         """Runs ADS-B simulation thread with precise timeout"""
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.cycle()
             self.msleep(max(0, self.simulation_state.adsb_threshold - start_timestamp.msecsTo(QTime.currentTime())))
         return super().run()
@@ -81,17 +92,18 @@
             for aircraft in self.aircraft_vehicles:
                 fcc : AircraftFCC = self.aircraft_fccs[aircraft.aircraft_id]
 
                 # path
                 fcc.append_visited()
 
                 # console destination reach time
-                if fcc.destination and self.simulation_state.adsb_report:
+                if fcc.destination is not None and self.simulation_state.adsb_report:
                     time_to_reaching_destination : float = (QVector3D.dotProduct(fcc.destination - aircraft.position, aircraft.speed) / QVector3D.dotProduct(aircraft.speed, aircraft.speed))
                     print(f"Aircraft {aircraft.aircraft_id} will reach its destination in " + "{:.2f}".format(time_to_reaching_destination) + " (" + "{:.1f}".format(time_to_reaching_destination / 60) + " minutes or " + "{:.1f}".format(time_to_reaching_destination / 3600) + " hours)")
+                    print("Collision avoidance: " + str(self.simulation_state.avoid_collisions))
 
                 # console report output
                 if self.simulation_state.adsb_report and aircraft.aircraft_id == 0 and self.simulation_state.is_realtime:
                     self.print_adsb_report(aircraft)
 
                 # safe zone occupancy check
                 if relative_position.length() < self.simulation_state.minimum_separation:
@@ -111,14 +123,17 @@
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
 
+                if miss_distance_vector.length() < self.__minimal_miss_distance:
+                    self.__minimal_miss_distance = miss_distance_vector.length()
+
                 if miss_distance_vector.length() == 0:
                     print("Head-on collision detected")
                     logging.info("Head-on collision detected")
 
                 # resolve confict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -71,14 +71,15 @@
 
     def run(self) -> None:
         """Runs physics simulation thread"""
         self.mark_start_time()
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.cycle(self.simulation_state.simulation_threshold)
+            self.test_speed()
             self.msleep(max(0, (self.simulation_state.simulation_threshold) - start_timestamp.msecsTo(QTime.currentTime())))
         self.mark_stop_time()
         return super().run()
     
     def mark_start_time(self) -> None:
         """Marks start time of the simulation"""
         self.__global_start_timestamp = QTime.currentTime()
@@ -198,7 +199,25 @@
                 delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
 
                 new_yaw_angle : float = 0.0
                 new_yaw_angle = current_yaw_angle + delta_yaw_angle
 
                 aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
                 aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
+
+    def test_speed(self) -> None:
+        """Tests speed"""
+        for aircraft in self.aircraft_vehicles:
+            speed : float = aircraft.absolute_speed
+            absolute_speed : float = sqrt(aircraft.speed.x() ** 2 + aircraft.speed.y() ** 2 + aircraft.speed.z() ** 2)
+            horizontal_speed : float = sqrt(aircraft.speed.x() ** 2 + aircraft.speed.y() ** 2)
+            vertical_speed : float = abs(aircraft.speed.z())
+            geometrical_speed : float = sqrt(horizontal_speed ** 2 + vertical_speed ** 2)
+            assert abs(speed - absolute_speed) < 0.0001
+            assert abs(horizontal_speed - aircraft.horizontal_speed) < 0.0001
+            assert abs(vertical_speed - aircraft.vertical_speed) < 0.0001
+            assert abs(geometrical_speed - speed) < 0.0001
+            assert speed > 0.0
+            assert horizontal_speed > 0.0
+            assert geometrical_speed > 0.0
+            assert geometrical_speed >= horizontal_speed
+            assert geometrical_speed >= vertical_speed
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py

```diff
@@ -6,21 +6,19 @@
 from PySide6.QtGui import QVector3D
 
 from .aircraft_vehicle import AircraftVehicle
 from .aircraft_fcc import AircraftFCC
 
 class Aircraft(QObject):
     """Main aircraft class"""
-    
-    __current_id : int = 0
 
-    def __init__(self, position : QVector3D, speed : QVector3D, initial_target : QVector3D | None = None, initial_roll_angle : float = 0.0) -> None:
+    def __init__(self, aircraft_id : int, position : QVector3D, speed : QVector3D, initial_target : QVector3D | None = None, initial_roll_angle : float = 0.0) -> None:
         super().__init__()
         self.__mutex : QMutex = QMutex()
-        self.__aircraft_id = self.__obtain_id()
+        self.__aircraft_id = aircraft_id
         self.__vehicle = AircraftVehicle(self.__aircraft_id, position=position, speed=speed, initial_roll_angle=initial_roll_angle)
         self.__fcc = AircraftFCC(self.__aircraft_id, initial_target, self.__vehicle)
         self.__initial_position = copy(position)
         self.__initial_speed = copy(speed)
         self.__initial_roll_angle = initial_roll_angle
     
     @property
@@ -49,26 +47,13 @@
         
     @property
     def initial_roll_angle(self) -> float:
         """Returns initial roll angle"""
         with QMutexLocker(self.__mutex):
             return self.__initial_roll_angle
 
-    def __obtain_id(self) -> int:
-        """Gets unique id for the aircraft"""
-        with QMutexLocker(self.__mutex):
-            aircraft_id = Aircraft.__current_id
-            Aircraft.__current_id += 1
-            return aircraft_id
-    
-    def __reset_current_id(self) -> None:
-        """Resets current id"""
-        with QMutexLocker(self.__mutex):
-            Aircraft.__current_id = 0
-
     def reset(self) -> None:
         """Resets aircraft to initial state"""
-        self.__reset_current_id()
         self.__vehicle.speed = copy(self.initial_speed)
         self.__vehicle.position = copy(self.initial_position)
         self.__vehicle.roll_angle = copy(self.initial_roll_angle)
         self.__vehicle.reset_distance_covered()
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -183,32 +183,32 @@
     def check_new_destination(self, destination : QVector3D, first : bool) -> QVector3D | None:
         """Checks if the given destination is already in the destinations list"""
         if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
             raise TypeError("Destination coordinates must be int or float.")
         if len(self.destinations) > 0 and first:
             if dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
                 print("Attempted to stack same destination")
-                logging.warning(f"Attempted to stack same destination: {destination}")
+                logging.warning("Attempted to stack the same destination: (%s, %s, %s)", destination.x(), destination.y(), destination.z())
                 return None
         elif len(self.destinations) > 0 and not first:
             if dist(destination.toTuple(), self.destinations[len(self.destinations) - 1].toTuple()) < 1.0:
                 print("Attempted to stack same destination")
-                logging.warning(f"Attempted to stack same destination: {destination}")
+                logging.warning("Attempted to stack the same destination: (%s, %s, %s)", destination.x(), destination.y(), destination.z())
                 return None
         if destination.z() < 500:
             if destination.z() < 0:
                 print("Attempted to set destination below ground")
-                logging.warning(f"Attempted to set destination below ground: {destination}")
+                logging.warning("Attempted to set destination below ground: (%s, %s, %s)", destination.x(), destination.y(), destination.z())
             else:
                 print("Attempted to set destination too low")
-                logging.warning(f"Attempted to set destination too low: {destination}")
+                logging.warning("Attempted to set destination too low: (%s, %s, %s)", destination.x(), destination.y(), destination.z())
             destination = QVector3D(destination.x(), destination.y(), 500)
         elif destination.z() > 10000:
             print("Attempted to set destination too high")
-            logging.warning(f"Attempted to set destination too high: {destination}")
+            logging.warning("Attempted to set destination too high: (%s, %s, %s)", destination.x(), destination.y(), destination.z())
             destination = QVector3D(destination.x(), destination.y(), 10000)
         return destination
 
     def add_last_destination(self, destination : QVector3D) -> None:
         """Appends the given location (QVector3D) to the end of the destinations list."""
         destination : QVector3D = self.check_new_destination(destination, False)
         if destination is not None:
@@ -428,27 +428,30 @@
         self.update_target_roll_angle()      
 
     def reset(self) -> None:
         """Resets aircraft flight control computer"""
         self.destinations.clear()
         self.destinations_history.clear()
         self.visited.clear()
-        if self.initial_target is not None:
-            self.add_first_destination(self.initial_target)
         self.__target_yaw_angle = 0.0
         self.__target_roll_angle = 0.0
         self.__target_pitch_angle = 0.0
         self.__evade_maneuver = False
         self.__vector_sharing_resolution = None
         self.__safe_zone_occupied = False
         self.__autopilot = True
         self.__ignore_destinations = False
         self.__is_turning_right = False
         self.__is_turning_left = False
 
+    def load_initial_destination(self) -> None:
+        """Loads initial destination"""
+        if self.initial_target is not None:
+            self.add_first_destination(self.initial_target)
+
     def __str__(self) -> str:
         return f"AircraftFCC: {self.aircraft_id}"
     
     def __repr__(self) -> str:
         return f"AircraftFCC: {self.aircraft_id}"
     
     def __del__(self) -> None:
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -1,15 +1,20 @@
 """Simulation module"""
 
 import csv
 import logging
 import datetime
+import pandas as pd
+import matplotlib.pyplot as plt
 from copy import copy
 from typing import List
 from pathlib import Path
+from numpy import random, ndarray, mean
+from math import dist, sin, cos, radians
+from matplotlib.ticker import MaxNLocator
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QCloseEvent, QVector3D
 from PySide6.QtWidgets import QMainWindow
 
 from ..aircraft.aircraft import Aircraft
 from ..aircraft.aircraft_fcc import AircraftFCC
@@ -21,23 +26,54 @@
 from ..simulation.simulation_adsb import SimulationADSB
 from ..simulation.simulation_fps import SimulationFPS
 from ..simulation.simulation_data import SimulationData
 
 class Simulation(QMainWindow):
     """Main simulation App"""
 
-    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 10_000_000) -> None: # 10_000_000 ms = 10_000 s = 2h 46m 40s
+    __current_id : int = 0
+
+    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 75_000_000) -> None: # 75_000_000 ms = 75_000 s = 20.83 h
         super().__init__()
         SimulationSettings().__init__()
+        self.__simulation_id = self.obtain_simulation_id()
+        self.__hash = self.obtain_simulation_hash()
         self.__headless : bool = headless
         self.__tests : bool = tests
         self.__simulation_time : int = simulation_time
         self.__aircrafts : List[Aircraft] | None = None
         self.__state : SimulationState | None = None
-        self.run()
+        self.__imported_from_data : bool = False
+        self.__simulation_data : SimulationData | None = None
+
+    @staticmethod
+    def obtain_simulation_id() -> int:
+        """Obtains new simulation id"""
+        simulation_id : int = Simulation.__current_id
+        Simulation.__current_id += 1
+        return simulation_id
+    
+    @property
+    def simulation_id(self) -> int:
+        """Returns simulation id"""
+        return self.__simulation_id
+    
+    @staticmethod
+    def obtain_simulation_hash() -> str:
+        """Obtains new simulation hash"""
+        export_time : str = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
+        hash_value : int = 0
+        for char in export_time:
+            hash_value = (hash_value * 31 + ord(char)) % 2**32
+        return hash_value
+    
+    @property
+    def hash(self) -> str:
+        """Returns simulation hash"""
+        return self.__hash
 
     @property
     def headless(self) -> bool:
         """Returns headless flag"""
         return self.__headless
     
     @property
@@ -60,158 +96,562 @@
         """Returns simulation state"""
         return self.__state
     
     @state.setter
     def state(self, state : SimulationState) -> None:
         """Sets simulation state"""
         self.__state = state
+
+    @property
+    def imported_from_data(self) -> bool:
+        """Returns imported from data flag"""
+        return self.__imported_from_data
+    
+    @imported_from_data.setter
+    def imported_from_data(self, imported : bool) -> None:
+        """Sets imported from data flag"""
+        self.__imported_from_data = imported
+
+    @property
+    def simulation_data(self) -> SimulationData:
+        """Returns simulation data"""
+        return self.__simulation_data
+    
+    @simulation_data.setter
+    def simulation_data(self, data : SimulationData) -> None:
+        """Sets simulation data"""
+        self.__simulation_data = data
     
     def run(self) -> None:
         """Executes simulation"""
         if self.state is not None:
             print("Another instance already running")
             return
         if self.headless:
             if self.tests:
                 self.run_tests()
             else:
                 self.run_headless()
         else:
             self.run_gui()
 
-    def run_gui(self) -> None:
+    def run_gui(self, avoid_collisions : bool = False, load_lastest_data_file : bool = True) -> None:
         """Executes realtime simulation"""
+        if load_lastest_data_file:
+            self.load_latest_simulation_data_file()
         if self.aircrafts is None or self.aircrafts == []:
             self.setup_debug_aircrafts()
         logging.info("Starting realtime simulation")
-        self.state = SimulationState(SimulationSettings(), is_realtime = True)
+        self.state = SimulationState(SimulationSettings(), is_realtime = True, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
         self.simulation_fps = SimulationFPS(self, self.state)
         self.simulation_widget = SimulationWidget(self.aircrafts, self.simulation_fps, self.state)
         self.simulation_render = SimulationRender(self, self.simulation_widget, self.state)
         self.simulation_physics.start(priority = QThread.Priority.TimeCriticalPriority)
         self.simulation_adsb.start(priority = QThread.Priority.NormalPriority)
         self.simulation_fps.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.show()
         self.simulation_render.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.stop_signal.connect(self.stop)
     
-    def run_headless(self, avoid_collisions : bool = False, aircrafts : List[Aircraft] | None = None) -> None:
+    def run_headless(self, avoid_collisions : bool = False, aircrafts : List[Aircraft] | None = None, test_index : int | None = None) -> SimulationData:
         """Executes simulation without GUI"""
         logging.info("Starting headless simulation")
-        if aircrafts is None or aircrafts == []:
+        if aircrafts is not None:
+            self.setup_aircrafts(aircrafts)
+        elif self.aircrafts is None or self.aircrafts == []:
             self.setup_debug_aircrafts()
         else:
-            self.setup_aircrafts(aircrafts)
+            assert len(self.aircrafts) > 0
         simulation_data : SimulationData = SimulationData()
         simulation_data.aircraft_1_initial_position = copy(self.aircrafts[0].vehicle.position)
         simulation_data.aircraft_2_initial_position = copy(self.aircrafts[1].vehicle.position)
+        simulation_data.aircraft_1_initial_speed = copy(self.aircrafts[0].vehicle.speed)
+        simulation_data.aircraft_2_initial_speed = copy(self.aircrafts[1].vehicle.speed)
+        simulation_data.aircraft_1_initial_target = copy(self.aircrafts[0].fcc.destination)
+        simulation_data.aircraft_2_initial_target = copy(self.aircrafts[1].fcc.destination)
         simulation_data.aircraft_1_initial_roll_angle = copy(self.aircrafts[0].vehicle.roll_angle)
         simulation_data.aircraft_2_initial_roll_angle = copy(self.aircrafts[1].vehicle.roll_angle)
         simulation_data.collision = False
 
         self.state = SimulationState(SimulationSettings(), is_realtime = False, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
+        self.simulation_adsb.reset_destinations()
         time_step : int = int(self.state.simulation_threshold)
         adsb_step : int = int(self.state.adsb_threshold)
         partial_time_counter : int = adsb_step
         for time in range(0, int(self.simulation_time / self.state.simulation_threshold), time_step):
             self.simulation_physics.cycle(time_step)
             if partial_time_counter >= adsb_step:
                 self.simulation_adsb.cycle()
                 partial_time_counter = 0
             partial_time_counter += time_step
+            if self.simulation_adsb.relative_distance > self.state.minimum_separation * 3 and self.simulation_adsb.minimal_relative_distance < self.state.minimum_separation:
+                logging.info("Headless simulation stopping due to aircrafts too far apart")
+                break
+            if not self.aircrafts[0].fcc.destination and not self.aircrafts[1].fcc.destination:
+                logging.info("Headless simulation stopping due to no other destinations set")
+                break
             if self.state.collision:
+                logging.info("Headless simulation stopping due to collision detected")
                 simulation_data.collision = True
                 break
-        simulation_data.minimal_miss_distance = copy(self.simulation_adsb.minimal_miss_distance)
+        simulation_data.minimal_relative_distance = copy(self.simulation_adsb.minimal_relative_distance)
         simulation_data.aircraft_1_final_position = copy(self.aircrafts[0].vehicle.position)
         simulation_data.aircraft_2_final_position = copy(self.aircrafts[1].vehicle.position)
+        simulation_data.aircraft_1_final_speed = copy(self.aircrafts[0].vehicle.speed)
+        simulation_data.aircraft_2_final_speed = copy(self.aircrafts[1].vehicle.speed)
+        if self.imported_from_data:
+            self.check_simulation_data_correctness()
+        if test_index is not None:
+            self.export_visited_locations(test_index = test_index)
+        else:
+            self.export_visited_locations()
         self.stop()
         return simulation_data
     
-    def run_tests(self, test_number : int = 10) -> None:
+    def generate_test_aircrafts(self) -> List[List[Aircraft]]:
+        """Generates test cases"""
+        logging.info("Generating test cases")
+        list_of_lists : List[List[Aircraft]] = []
+
+        test_minimal_altitude : int = 1000
+        test_maximal_altitude : int = 7000
+        test_minimal_speed : int = 30
+        test_maximal_speed : int = 100
+        test_start_aircrafts_relative_distance : int = 10_000 # distance between aircrafts headed to test collision target
+        test_minimal_course_difference : float = 1.0
+        test_maximal_course_difference : float = 179.0
+        test_minimal_trigonometric_value : float = 0.00001
+        test_course_difference_count : int = 170
+        test_random_collision_course_differences : List[float] = random.uniform(test_minimal_course_difference, test_maximal_course_difference, test_course_difference_count).tolist()
+        test_random_collision_course_differences.sort(reverse = False)
+
+        # equal speeds, equal distances to cover, both climbing or both descending
+        for angle in test_random_collision_course_differences:
+            aircraft_init_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
+            aircraft_target_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
+            aircraft_collision_height : float = mean([aircraft_init_height, aircraft_target_height])
+            test_collision_target : QVector3D = QVector3D(0, 0, aircraft_collision_height)
+            test_collision_target_flat : QVector3D = QVector3D(0, 0, aircraft_init_height)
+            aircraft_absolute_speed : float = random.uniform(test_minimal_speed, test_maximal_speed)
+            sin_value : float = sin(radians(angle))
+            cos_value : float = cos(radians(angle))
+            if abs(sin_value) < test_minimal_trigonometric_value:
+                continue
+            if abs(cos_value) < test_minimal_trigonometric_value:
+                continue
+            distance_to_collision : float = test_start_aircrafts_relative_distance / sin_value # projected onto 2d plane
+
+            aircraft_1_position : QVector3D = QVector3D(
+                0,
+                -distance_to_collision,
+                aircraft_init_height)
+            aircraft_1_target : QVector3D = QVector3D(
+                0,
+                100 * distance_to_collision,
+                aircraft_target_height)
+            aircraft_1_speed : QVector3D = QVector3D(
+                0,
+                aircraft_absolute_speed,
+                0)
+            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.1
+            assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.1
+            
+            # rotate angle to get circle equation
+            sin_value = sin(radians(90 - angle))
+            cos_value = cos(radians(90 - angle))
+            aircraft_2_position : QVector3D = QVector3D(
+                distance_to_collision * cos_value,
+                -distance_to_collision * sin_value,
+                aircraft_1_position.z())
+            aircraft_2_target : QVector3D = QVector3D(
+                100 * -distance_to_collision * cos_value,
+                100 * distance_to_collision * sin_value,
+                aircraft_1_target.z())
+            aircraft_2_speed : QVector3D = QVector3D(
+                -aircraft_absolute_speed * cos_value,
+                aircraft_absolute_speed * sin_value,
+                aircraft_1_speed.z())
+
+            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.1
+            assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.1
+
+            aircrafts : List[Aircraft] = [
+                Aircraft(
+                    aircraft_id = 0,
+                    position = aircraft_1_position,
+                    speed = aircraft_1_speed,
+                    initial_target = aircraft_1_target),
+                Aircraft(
+                    aircraft_id = 1,
+                    position = aircraft_2_position,
+                    speed = aircraft_2_speed,
+                    initial_target = aircraft_2_target)
+            ]
+            list_of_lists.append(aircrafts)
+
+        # todo: generate more random parameters for test cases
+
+        if len(list_of_lists) == 0:
+            for i in range (0, 30, 1):
+                list_of_aircrafts : List[Aircraft] = []
+                aircraft : Aircraft = Aircraft( # detection test
+                    aircraft_id = 0,
+                    position = QVector3D(-800, 4000, 1000),
+                    speed = QVector3D(60, -60, 0),
+                    initial_target = QVector3D(51_900, -50_000, 10000)) # 51.9 km, -50 km
+                list_of_aircrafts.append(aircraft)
+                aircraft = Aircraft(
+                    aircraft_id = 1,
+                    position = QVector3D(4000, 6000, 1000),
+                    speed = QVector3D(0, -85, 0),
+                    initial_target = QVector3D(900, -1_001_300, 1000)) # 0.9 km, -1001.3 km
+                list_of_aircrafts.append(aircraft)
+                list_of_lists.append(list_of_aircrafts)
+
+        return list_of_lists
+    
+    def generate_consistent_list_of_aircraft_lists(self) -> List[List[Aircraft]]:
+        """Returns predefined list of aircraft lists"""
+        list_of_lists : List[List[Aircraft]] = []
+        test_average_aircraft_size : float = 20.0
+
+        # head-on testing
+        list_of_lists.append([ # chase test
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -20_000, 1000),
+                speed = QVector3D(0, 100, 0),
+                initial_target = QVector3D(0, 2_000_000, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, -10_000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(0, 2_000_000, 1000))
+        ])
+        list_of_lists.append([ # full angle collision, equal speeds
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -5000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(0, 500_000, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, 5000, 1000),
+                speed = QVector3D(0, -50, 0),
+                initial_target = QVector3D(0, -500_000, 1000))
+        ])
+        list_of_lists.append([ # full angle collision
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -5000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(0, 500_000, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, 10000, 1000),
+                speed = QVector3D(0, -100, 0),
+                initial_target = QVector3D(0, -500_000, 1000))
+        ])
+
+        # collision testing
+        list_of_lists.append([ # chase test
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -20_000, 1000),
+                speed = QVector3D(0, 100, 0),
+                initial_target = QVector3D(test_average_aircraft_size / 4.0, 2_000_000 + test_average_aircraft_size / 4.0, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, -10_000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(-test_average_aircraft_size / 4.0, 2_000_000 - test_average_aircraft_size / 4.0, 1000))
+        ])
+        list_of_lists.append([ # full angle collision, equal speeds
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -5000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, 5000, 1000),
+                speed = QVector3D(0, -50, 0),
+                initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
+        ])
+        list_of_lists.append([ # full angle collision
+            Aircraft(
+                aircraft_id = 0,
+                position = QVector3D(0, -5000, 1000),
+                speed = QVector3D(0, 50, 0),
+                initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
+            Aircraft(
+                aircraft_id = 1,
+                position = QVector3D(0, 10000, 1000),
+                speed = QVector3D(0, -100, 0),
+                initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
+        ])
+        return list_of_lists
+    
+    def run_tests(self, begin_with_default_set : bool = True, test_number : int = 10) -> None:
         """Runs simulation tests"""
-        if test_number < 1:
-            test_number = 10
+        if test_number < 3:
+            logging.info("Changing simulation tests to 3 test cases due to too low test number")
+            test_number = 3
+        elif test_number > 100:
+            logging.info("Changing simulation tests to 100 test cases due to too high test number")
+            test_number = 100
         logging.info("Running simulation tests")
+        list_of_const_lists : List[List[Aircraft]] | None = None
+        list_of_lists : List[List[Aircraft]] | None = None
+        if begin_with_default_set:
+            list_of_const_lists = self.generate_consistent_list_of_aircraft_lists()
+            consistent_tests_count : int = len(list_of_const_lists)
+            if test_number - consistent_tests_count > 0:
+                test_number -= consistent_tests_count
+            
+        list_of_lists = self.generate_test_aircrafts()
+        lists_count : int = len(list_of_lists)
+
+        if lists_count > test_number:
+            random_indices : ndarray | None = None
+            random_indices = random.choice(lists_count, test_number, replace = False)
+            random_indices : List[int] = random_indices.tolist()
+            random_indices_set : set = set(random_indices)
+            random_indices = []
+            while random_indices_set:
+                random_indices.append(random_indices_set.pop())
+            random_indices.sort(reverse = False)
+            assert len(random_indices) <= test_number
+            list_of_lists = [list_of_lists[i] for i in random_indices]
+            lists_count = len(list_of_lists)
+
+        if begin_with_default_set:
+            list_of_lists = list_of_const_lists + list_of_lists
+            lists_count = len(list_of_lists)
+            test_number = lists_count
+        logging.info("Test cases to process: %d", test_number)
+
         start_timestamp = QTime.currentTime()
-        #list_of_aircrafts : List[List[Aircraft]] = self.generate_test_aircrafts(test_number) # todo
         export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
         try:
-            Path("logs/data").mkdir(parents=True, exist_ok=True)
+            Path("data").mkdir(parents=True, exist_ok=True)
         except:
+            logging.error("Failed to create data directory")
             return
-        file = open(f"logs/data/simulation-{export_time}.csv", "w")
+        file = None
+        filename_iterator : int = 1
+        if Path(f"data/simulation-{export_time}.csv").exists():
+            while Path(f"data/simulation-{export_time}-{filename_iterator}.csv").exists():
+                filename_iterator += 1
+            file = open(f"data/simulation-{export_time}-{filename_iterator}.csv", "w")
+        else:
+            file = open(f"data/simulation-{export_time}.csv", "w")
         writer = csv.writer(file)
         writer.writerow([
             "test_id",
             "aircraft_1_init_pos_x",
             "aircraft_1_init_pos_y",
             "aircraft_1_init_pos_z",
             "aircraft_2_init_pos_x",
             "aircraft_2_init_pos_y",
             "aircraft_2_init_pos_z",
+            "aircraft_1_init_speed_x",
+            "aircraft_1_init_speed_y",
+            "aircraft_1_init_speed_z",
+            "aircraft_2_init_speed_x",
+            "aircraft_2_init_speed_y",
+            "aircraft_2_init_speed_z",
+            "aircraft_1_init_target_x",
+            "aircraft_1_init_target_y",
+            "aircraft_1_init_target_z",
+            "aircraft_2_init_target_x",
+            "aircraft_2_init_target_y",
+            "aircraft_2_init_target_z",
             "aircraft_1_final_pos_x_if_no_avoidance",
             "aircraft_1_final_pos_y_if_no_avoidance",
             "aircraft_1_final_pos_z_if_no_avoidance",
             "aircraft_2_final_pos_x_if_no_avoidance",
             "aircraft_2_final_pos_y_if_no_avoidance",
             "aircraft_2_final_pos_z_if_no_avoidance",
             "aircraft_1_final_pos_x_if_avoidance",
             "aircraft_1_final_pos_y_if_avoidance",
             "aircraft_1_final_pos_z_if_avoidance",
             "aircraft_2_final_pos_x_if_avoidance",
             "aircraft_2_final_pos_y_if_avoidance",
             "aircraft_2_final_pos_z_if_avoidance",
+            "aircraft_1_final_speed_x_if_no_avoidance",
+            "aircraft_1_final_speed_y_if_no_avoidance",
+            "aircraft_1_final_speed_z_if_no_avoidance",
+            "aircraft_2_final_speed_x_if_no_avoidance",
+            "aircraft_2_final_speed_y_if_no_avoidance",
+            "aircraft_2_final_speed_z_if_no_avoidance",
+            "aircraft_1_final_speed_x_if_avoidance",
+            "aircraft_1_final_speed_y_if_avoidance",
+            "aircraft_1_final_speed_z_if_avoidance",
+            "aircraft_2_final_speed_x_if_avoidance",
+            "aircraft_2_final_speed_y_if_avoidance",
+            "aircraft_2_final_speed_z_if_avoidance",
             "collision_if_no_avoidance",
             "collision_if_avoidance",
-            "minimal_miss_distance_if_no_avoidance",
-            "minimal_miss_distance_if_avoidance"])
+            "minimal_relative_distance_if_no_avoidance",
+            "minimal_relative_distance_if_avoidance"])
+        file.close()
+        file = open(f"data/simulation-{export_time}.csv", "a")
+        writer = csv.writer(file)
+        
         for i in range(0, test_number, 1):
             logging.info("Test %d - no collision avoidance", i)
-            # self.run_headless(avoid_collisions = True, aircrafts = list_of_aircrafts[i])
-            simulation_data_no_avoidance : SimulationData = self.run_headless()
+            aircrafts : List[Aircraft] = list_of_lists[i]
+            print("Current test pair aircrafts count: ", len(aircrafts))
+            simulation_data_no_avoidance : SimulationData = self.run_headless(
+                avoid_collisions = False,
+                aircrafts = aircrafts,
+                test_index = i)
             self.state = None
 
             logging.info("Test %d - collision avoidance", i)
-            # self.run_headless(avoid_collisions = True, aircrafts = list_of_aircrafts[i])
-            simulation_data_avoidance : SimulationData = self.run_headless(avoid_collisions = True)
+            simulation_data_avoidance : SimulationData = self.run_headless(
+                avoid_collisions = True,
+                aircrafts = aircrafts,
+                test_index = i)
             self.state = None
 
             writer.writerow([
                 i,
                 simulation_data_no_avoidance.aircraft_1_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.y(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.z(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.y(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.z(),
+                simulation_data_no_avoidance.aircraft_1_initial_speed.x(),
+                simulation_data_no_avoidance.aircraft_1_initial_speed.y(),
+                simulation_data_no_avoidance.aircraft_1_initial_speed.z(),
+                simulation_data_no_avoidance.aircraft_2_initial_speed.x(),
+                simulation_data_no_avoidance.aircraft_2_initial_speed.y(),
+                simulation_data_no_avoidance.aircraft_2_initial_speed.z(),
+                simulation_data_no_avoidance.aircraft_1_initial_target.x(),
+                simulation_data_no_avoidance.aircraft_1_initial_target.y(),
+                simulation_data_no_avoidance.aircraft_1_initial_target.z(),
+                simulation_data_no_avoidance.aircraft_2_initial_target.x(),
+                simulation_data_no_avoidance.aircraft_2_initial_target.y(),
+                simulation_data_no_avoidance.aircraft_2_initial_target.z(),
                 simulation_data_no_avoidance.aircraft_1_final_position.x(),
                 simulation_data_no_avoidance.aircraft_1_final_position.y(),
                 simulation_data_no_avoidance.aircraft_1_final_position.z(),
                 simulation_data_no_avoidance.aircraft_2_final_position.x(),
                 simulation_data_no_avoidance.aircraft_2_final_position.y(),
                 simulation_data_no_avoidance.aircraft_2_final_position.z(),
                 simulation_data_avoidance.aircraft_1_final_position.x(),
                 simulation_data_avoidance.aircraft_1_final_position.y(),
                 simulation_data_avoidance.aircraft_1_final_position.z(),
                 simulation_data_avoidance.aircraft_2_final_position.x(),
                 simulation_data_avoidance.aircraft_2_final_position.y(),
                 simulation_data_avoidance.aircraft_2_final_position.z(),
+                simulation_data_no_avoidance.aircraft_1_final_speed.x(),
+                simulation_data_no_avoidance.aircraft_1_final_speed.y(),
+                simulation_data_no_avoidance.aircraft_1_final_speed.z(),
+                simulation_data_no_avoidance.aircraft_2_final_speed.x(),
+                simulation_data_no_avoidance.aircraft_2_final_speed.y(),
+                simulation_data_no_avoidance.aircraft_2_final_speed.z(),
+                simulation_data_avoidance.aircraft_1_final_speed.x(),
+                simulation_data_avoidance.aircraft_1_final_speed.y(),
+                simulation_data_avoidance.aircraft_1_final_speed.z(),
+                simulation_data_avoidance.aircraft_2_final_speed.x(),
+                simulation_data_avoidance.aircraft_2_final_speed.y(),
+                simulation_data_avoidance.aircraft_2_final_speed.z(),
                 simulation_data_no_avoidance.collision,
                 simulation_data_avoidance.collision,
-                simulation_data_no_avoidance.minimal_miss_distance,
-                simulation_data_avoidance.minimal_miss_distance])
+                simulation_data_no_avoidance.minimal_relative_distance,
+                simulation_data_avoidance.minimal_relative_distance])
+            file.close()
+            file = open(f"data/simulation-{export_time}.csv", "a")
+            writer = csv.writer(file)
         file.close()
         real_time : float = start_timestamp.msecsTo(QTime.currentTime()) / 1000
         print("Total time elapsed: " + "{:.2f}".format(real_time) + "s")
+        print("Average time per test: " + "{:.2f}".format(real_time / test_number) + "s")
         logging.info("Total time elapsed: %ss", "{:.2f}".format(real_time))
+
+    def load_latest_simulation_data_file(self) -> bool:
+        """Loads latest simulation data from file"""
+        logging.info("Loading latest simulation data")
+        found_good_file : bool = False
+        latest_file_path : str | None = None
+        list_of_paths : List[Path] | None = None
+        list_length : int | None = None
+        try:
+            latest_file_path = max(Path("data").iterdir(), key = lambda p: p.stat().st_ctime)
+            list_of_paths = list(Path("data").iterdir())
+            list_of_paths.sort(key = lambda x: x.stat().st_ctime, reverse = False)
+            list_length = len(list_of_paths)
+        except:
+            logging.error("Failed to load latest simulation data")
+            return False
+        iterator : int = 1
+        while not found_good_file:
+            try:
+                file = open(latest_file_path, "r")
+                reader = csv.reader(file)
+                lines_count : int = 0
+                for line in reader:
+                    lines_count += 1
+                if lines_count > 1:
+                    found_good_file = True
+                    break
+            except:
+                pass
+            latest_file_path = list_of_paths[list_length - 1 - iterator]
+            iterator += 1
+        if found_good_file:
+            return self.load_simulation_data_from_file(latest_file_path)
+        else:
+            return False
+
+    def load_simulation_data_from_file(self, file_path : str, test_id : int = 0, avoid_collisions : bool = False) -> bool:
+        """Loads simulation data from file"""
+        logging.info("Loading simulation data from file %s", file_path)
+        self.__aircrafts = []
+        try:
+            file = open(file_path, "r")
+            reader = csv.reader(file)
+            for i, row in enumerate(reader):
+                if i == test_id + 1:
+                    simulation_data : SimulationData = SimulationData()
+                    assert len(row) == 47
+                    assert row[0] == str(test_id)
+                    simulation_data.aircraft_1_initial_position = QVector3D(float(row[1]), float(row[2]), float(row[3]))
+                    simulation_data.aircraft_2_initial_position = QVector3D(float(row[4]), float(row[5]), float(row[6]))
+                    simulation_data.aircraft_1_initial_speed = QVector3D(float(row[7]), float(row[8]), float(row[9]))
+                    simulation_data.aircraft_2_initial_speed = QVector3D(float(row[10]), float(row[11]), float(row[12]))
+                    simulation_data.aircraft_1_initial_target = QVector3D(float(row[13]), float(row[14]), float(row[15]))
+                    simulation_data.aircraft_2_initial_target = QVector3D(float(row[16]), float(row[17]), float(row[18]))
+                    if not avoid_collisions:
+                        simulation_data.aircraft_1_final_position = QVector3D(float(row[19]), float(row[20]), float(row[21]))
+                        simulation_data.aircraft_2_final_position = QVector3D(float(row[22]), float(row[23]), float(row[24]))
+                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[31]), float(row[32]), float(row[33]))
+                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[34]), float(row[35]), float(row[36]))
+                        simulation_data.collision = row[43] == "True"
+                        simulation_data.minimal_relative_distance = float(row[45])
+                    else:
+                        simulation_data.aircraft_1_final_position = QVector3D(float(row[25]), float(row[26]), float(row[27]))
+                        simulation_data.aircraft_2_final_position = QVector3D(float(row[28]), float(row[29]), float(row[30]))
+                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[37]), float(row[38]), float(row[39]))
+                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[40]), float(row[41]), float(row[42]))
+                        simulation_data.collision = row[44] == "True"
+                        simulation_data.minimal_relative_distance = float(row[46])
+                    self.import_simulation_data(simulation_data)
+                    return True
+        except:
+            logging.error("Failed to load simulation data from file")
+            return False
     
     def stop(self) -> None:
         """Stops simulation"""
         if self.headless:
             self.stop_headless_simulation()
         else:
             self.stop_realtime_simulation()
@@ -272,85 +712,229 @@
         if self.aircrafts is not None:
             self.aircrafts.remove(aircraft)
 
     def setup_aircrafts(self, aircrafts : List[Aircraft]) -> None:
         """Sets up aircrafts list"""
         self.__aircrafts = aircrafts
 
-    def setup_debug_aircrafts(self) -> None:
+    def setup_debug_aircrafts(self, test_case : int = 0) -> None:
         """Sets up debug aircrafts list"""
-        test_case : int = 3
         if test_case == 0:
             aircrafts : List[Aircraft] = [
                 Aircraft( # detection test
+                    aircraft_id = 0,
                     position = QVector3D(-800, 4000, 1000),
                     speed = QVector3D(60, -60, 0),
                     initial_target = QVector3D(51_900, -50_000, 10000)),
                 Aircraft(
+                    aircraft_id = 1,
                     position = QVector3D(4000, 6000, 1000),
                     speed = QVector3D(0, -85, 0),
                     initial_target = QVector3D(900, -1_001_300, 1000)),
             ]
         elif test_case == 1:
             aircrafts : List[Aircraft] = [
                 Aircraft( # almost head on
+                    aircraft_id = 0,
                     position = QVector3D(-3000, 500, 1000),
                     speed = QVector3D(70, 0.1, 0)),
                 Aircraft(
+                    aircraft_id = 1,
                     position = QVector3D(5000, 500, 1000),
                     speed = QVector3D(-50, 0, 0)),
             ]
         elif test_case == 2:
             aircrafts : List[Aircraft] = [
                 Aircraft( # avoidance test slow
+                    aircraft_id = 0,
                     position = QVector3D(0, 0, 1000),
                     speed = QVector3D(30, -30, 0),
                     initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                 Aircraft(
+                    aircraft_id = 1,
                     position = QVector3D(0, -100_000, 1000),
                     speed = QVector3D(30, 29, 0),
                     initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
             ]
         elif test_case == 3:
             aircrafts : List[Aircraft] = [
                 Aircraft( # avoidance test
+                    aircraft_id = 0,
                     position = QVector3D(0, 0, 1000),
                     speed = QVector3D(150, -150, 0),
                     initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                 Aircraft(
+                    aircraft_id = 1,
                     position = QVector3D(0, -100_000, 1000),
                     speed = QVector3D(150, 145, 0),
                     initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
             ]
         elif test_case == 4:
             aircrafts : List[Aircraft] = [
                 Aircraft( # avoidance test fast
+                    aircraft_id = 0,
                     position = QVector3D(0, 0, 1000),
                     speed = QVector3D(300, -300, 0),
                     initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                 Aircraft(
+                    aircraft_id = 1,
                     position = QVector3D(0, -100_000, 1000),
                     speed = QVector3D(300, 290, 0),
                     initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
             ]
+        elif test_case == 5:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # chase test
+                    aircraft_id = 0,
+                    position = QVector3D(0, -1000, 1000),
+                    speed = QVector3D(0, 50, 0),
+                    initial_target = QVector3D(0, 0, 1000)), # 0 km, 0 km
+                Aircraft(
+                    aircraft_id = 1,
+                    position = QVector3D(0, -2000, 1000),
+                    speed = QVector3D(0, 100, 0),
+                    initial_target = QVector3D(0, 0, 1000)), # 0 km, 0 km
+            ]
+        elif test_case == 6:
+            aircrafts : List[Aircraft] = [
+                Aircraft( # full angle collision
+                    aircraft_id = 0,
+                    position = QVector3D(0, -1000, 1000),
+                    speed = QVector3D(0, 50, 0),
+                    initial_target = QVector3D(0, 0, 1000)), # 0 km, 0 km
+                Aircraft(
+                    aircraft_id = 1,
+                    position = QVector3D(0, 1000, 1000),
+                    speed = QVector3D(0, -50, 0),
+                    initial_target = QVector3D(0, 0, 1000)), # 0 km, 0 km
+            ]
+        elif test_case == 7:
+            aircrafts : List[Aircraft] = [
+                Aircraft(
+                    aircraft_id = 0,
+                    position = QVector3D(0, -5000, 1000),
+                    speed = QVector3D(0, 50, 0),
+                    initial_target = QVector3D(0, 0, 1000)),
+                Aircraft(
+                    aircraft_id = 1,
+                    position = QVector3D(0, 5000, 1000),
+                    speed = QVector3D(0, -50, 0),
+                    initial_target = QVector3D(0, 0, 1000))
+            ]
+        else:
+            aircrafts : List[Aircraft] = []
         self.setup_aircrafts(aircrafts)
 
-    def export_visited_locations(self) -> None:
+    def import_simulation_data(self, data : SimulationData) -> None:
+        """Imports simulation data"""
+        if self.aircrafts is not None and self.aircrafts != []:
+            print("Aircrafts already set, cannot import simulation data")
+            return
+        self.__imported_from_data = True
+        self.__simulation_data = data
+        self.__aircrafts = [
+            Aircraft(
+                aircraft_id = 0,
+                position = data.aircraft_1_initial_position,
+                speed = data.aircraft_1_initial_speed,
+                initial_target = data.aircraft_1_initial_target,
+                initial_roll_angle = data.aircraft_1_initial_roll_angle),
+            Aircraft(
+                aircraft_id = 1,
+                position = data.aircraft_2_initial_position,
+                speed = data.aircraft_2_initial_speed,
+                initial_target = data.aircraft_2_initial_target,
+                initial_roll_angle = data.aircraft_2_initial_roll_angle),
+        ]
+        logging.info("Simulation data imported successfully")
+
+    def check_simulation_data_correctness(self) -> bool | None:
+        if not self.__imported_from_data or self.__simulation_data is None or self.aircrafts is None or self.aircrafts == []:
+            return None
+        logging.info("Checking simulation data correctness...")
+        assert len(self.aircrafts) == 2
+        assert dist(self.aircrafts[0].vehicle.position.toTuple(), self.__simulation_data.aircraft_1_final_position.toTuple()) < 0.1
+        assert dist(self.aircrafts[1].vehicle.position.toTuple(), self.__simulation_data.aircraft_2_final_position.toTuple()) < 0.1
+        assert dist(self.aircrafts[0].vehicle.speed.toTuple(), self.__simulation_data.aircraft_1_final_speed.toTuple()) < 0.1
+        assert dist(self.aircrafts[1].vehicle.speed.toTuple(), self.__simulation_data.aircraft_2_final_speed.toTuple()) < 0.1
+        assert abs(self.aircrafts[0].vehicle.speed.length() - self.__simulation_data.aircraft_1_final_speed.length()) < 0.1
+        assert abs(self.aircrafts[1].vehicle.speed.length() - self.__simulation_data.aircraft_2_final_speed.length()) < 0.1
+        assert abs(self.simulation_adsb.minimal_relative_distance - self.__simulation_data.minimal_relative_distance) < 0.1
+        logging.info("Simulation data correctness checked successfully ✅")
+        return True
+
+    def export_visited_locations(self, test_index : int | None = None) -> None:
         """Exports aircrafts visited location lists"""
-        export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
         aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
-        for aircraft in aircraft_fccs:
-            try:
-                Path("logs/visited").mkdir(parents=True, exist_ok=True)
-            except:
-                return
-            file = open(f"logs/visited/visited-aircraft-{aircraft.aircraft_id}-{export_time}.csv", "w")
-            writer = csv.writer(file)
-            writer.writerow(["x","y","z"])
-            for position in aircraft.visited:
-                writer.writerow([("{:.2f}".format(position.x())),("{:.2f}".format(position.y())),("{:.2f}".format(position.z()))])
+
+        plt.set_loglevel("error")
+        plt.figure()
+        plt.suptitle("Aircraft paths visualization")
+        plt.title("author: Miłosz Maculewicz")
+        plt.subplots_adjust(left = 0.15, right = 0.85, top = 0.85, bottom = 0.15)
+        plt.subplots_adjust(hspace = 0.5, wspace = 0.5)
+        plt.grid(True)
+        plt.xlabel("x")
+        plt.ylabel("y")
+        plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))
+        plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True))
+
+        x_minimum : float = float("inf")
+        x_maximum : float = float("-inf")
+        y_minimum : float = float("inf")
+        y_maximum : float = float("-inf")
+        colors = ["b", "g", "r", "c", "m", "y", "k"]
+
+        export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
+        try:
+            Path("logs/visited").mkdir(parents=True, exist_ok=True)
+            Path("path-visual").mkdir(parents=True, exist_ok=True)
+            if test_index is not None:
+                Path(f"path-visual/simulation-{self.simulation_id}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
+            else:
+                Path(f"path-visual/simulation-{self.simulation_id}-{self.hash}").mkdir(parents=True, exist_ok=True)
+        except:
+            logging.error("Failed to create directories for visited logs")
+            return
+
+        aircraft_1_init = []
+        aircraft_2_init = []
+
+        for i, aircraft in enumerate(aircraft_fccs):
+            file_name = f"logs/visited/visited-aircraft-{aircraft.aircraft_id}-{export_time}"
+            with open(f"{file_name}.csv", "w") as file:
+                writer = csv.writer(file)
+                writer.writerow(["x","y","z"])
+                for position in aircraft.visited:
+                    x_minimum = min(x_minimum, position.x())
+                    x_maximum = max(x_maximum, position.x())
+                    y_minimum = min(y_minimum, position.y())
+                    y_maximum = max(y_maximum, position.y())
+                    writer.writerow([("{:.2f}".format(position.x())),("{:.2f}".format(position.y())),("{:.2f}".format(position.z()))])
+                    
+            df = pd.read_csv(f"{file_name}.csv")
+            plt.scatter(df["x"], df["y"], color=colors[i % len(colors)], s = 5)
+            plt.plot(df["x"], df["y"], color=colors[i % len(colors)])
+
+            if not df.empty:
+                if i == 0:
+                    aircraft_1_init = [df.iloc[0]["x"],  df.iloc[0]["y"]]
+                elif i == 1:
+                    aircraft_2_init = [df.iloc[0]["x"],  df.iloc[0]["y"]]
+
+        x_spectrum : float = x_maximum - x_minimum
+        y_spectrum : float = y_maximum - y_minimum
+        plt.xlim(x_minimum - x_spectrum, x_maximum + x_spectrum)
+        plt.ylim(y_minimum - y_spectrum, y_maximum + y_spectrum)
+        plt.text(aircraft_1_init[0] + 0.05 * x_spectrum, aircraft_1_init[1] - 0.05 * y_spectrum, f"Initial position\nof Aircraft 1", color = colors[0 % len(colors)], fontsize = 9, ha = "left")
+        plt.text(aircraft_2_init[0] + 0.05 * x_spectrum, aircraft_2_init[1] - 0.05 * y_spectrum, f"Initial position\nof Aircraft 2", color = colors[1 % len(colors)], fontsize = 9, ha = "left")
+        if test_index is not None:
+            plt.savefig(f"path-visual/simulation-{self.simulation_id}-{test_index}-{self.hash}/path-visual-{export_time}.png")
+        else:
+            plt.savefig(f"path-visual/simulation-{self.simulation_id}-{self.hash}/path-visual-{export_time}.png")
+        plt.close()
     
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
         self.stop()
         event.accept()
         return super().closeEvent(event)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -19,15 +19,15 @@
     def __init__(self, parent : QMainWindow, aircrafts : List[Aircraft], simulation_state : SimulationState) -> None:
         super(SimulationADSB, self).__init__(parent)
         self.__aircrafts = aircrafts
         self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
         self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
         self.__simulation_state = simulation_state
         self.__adsb_cycles : int = 0
-        self.__minimal_miss_distance : float = float("inf")
+        self.__minimal_relative_distance : float = float("inf")
         
     @property
     def aircrafts(self) -> List[Aircraft]:
         """Returns aircrafts"""
         return self.__aircrafts
     
     @property
@@ -54,22 +54,27 @@
     
     def count_adsb_cycles(self) -> None:
         """Increments ADS-B cycle counter"""
         self.__adsb_cycles += 1
         self.simulation_state.adsb_cycles = self.adsb_cycles
 
     @property
-    def minimal_miss_distance(self) -> float:
+    def minimal_relative_distance(self) -> float:
         """Returns minimal miss distance"""
-        return self.__minimal_miss_distance
+        return self.__minimal_relative_distance
     
-    @minimal_miss_distance.setter
-    def minimal_miss_distance(self, minimal_miss_distance : float) -> None:
+    @minimal_relative_distance.setter
+    def minimal_relative_distance(self, minimal_relative_distance : float) -> None:
         """Sets minimal miss distance"""
-        self.__minimal_miss_distance = minimal_miss_distance
+        self.__minimal_relative_distance = minimal_relative_distance
+
+    @property
+    def relative_distance(self) -> float:
+        """Returns relative distance between aircrafts"""
+        return (self.aircraft_vehicles[0].position - self.aircraft_vehicles[1].position).length()
 
     def run(self) -> None:
         """Runs ADS-B simulation thread with precise timeout"""
         while not self.isInterruptionRequested():
             start_timestamp = QTime.currentTime()
             self.cycle()
             self.msleep(max(0, self.simulation_state.adsb_threshold - start_timestamp.msecsTo(QTime.currentTime())))
@@ -85,16 +90,30 @@
             self.simulation_state.update_adsb_settings()
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
             
+            if relative_position.length() < self.__minimal_relative_distance:
+                self.__minimal_relative_distance = relative_position.length()
+            print("Minimal relative distance: " + "{:.2f}".format(self.__minimal_relative_distance) + "m")
+            
+            fcc : AircraftFCC | None = None
             for aircraft in self.aircraft_vehicles:
-                fcc : AircraftFCC = self.aircraft_fccs[aircraft.aircraft_id]
+                try:
+                    fcc = self.aircraft_fccs[aircraft.aircraft_id]
+                except IndexError:
+                    logging.error("Aircraft flight control computer %d not found", aircraft.aircraft_id)
+                    print(f"Aircraft flight control computer {aircraft.aircraft_id} not found")
+                    if len(self.aircraft_fccs) == 2:
+                        if aircraft.aircraft_id % 2 == 0:
+                            fcc = self.aircraft_fccs[0]
+                        else:
+                            fcc = self.aircraft_fccs[1]
 
                 # path
                 fcc.append_visited()
 
                 # console destination reach time
                 if fcc.destination is not None and self.simulation_state.adsb_report:
                     time_to_reaching_destination : float = (QVector3D.dotProduct(fcc.destination - aircraft.position, aircraft.speed) / QVector3D.dotProduct(aircraft.speed, aircraft.speed))
@@ -113,53 +132,51 @@
                             self.simulation_state.avoid_collisions = True
                     print("Safe zone occupied")
                 else:
                     if fcc.safe_zone_occupied:
                         fcc.safe_zone_occupied = False
                         self.simulation_state.avoid_collisions = False
                     print("Safe zone free")
-                    return
+                    continue
 
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
 
-                if miss_distance_vector.length() < self.__minimal_miss_distance:
-                    self.__minimal_miss_distance = miss_distance_vector.length()
-
-                if miss_distance_vector.length() == 0:
+                if miss_distance_vector.length() == 0 and self.simulation_state.avoid_collisions:
                     print("Head-on collision detected")
                     logging.info("Head-on collision detected")
 
                 # resolve confict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
                     print("Conflict condition detected")
-                    if self.simulation_state.avoid_collisions:
+                    if self.simulation_state.avoid_collisions and relative_position.length() < self.simulation_state.minimum_separation:
                         for aircraft in self.aircraft_fccs:
                             if not aircraft.evade_maneuver:
+                                logging.info("Conflict condition resolution with relative distance: " + "{:.2f}".format(relative_position.length()) + "m")
                                 aircraft.apply_evade_maneuver(
                                     opponent_speed = self.aircraft_vehicles[1 - aircraft.aircraft_id].speed,
                                     miss_distance_vector = miss_distance_vector,
                                     unresolved_region = unresolved_region,
                                     time_to_closest_approach = time_to_closest_approach)
                     print("Relative distance: "+ "{:.2f}".format(relative_position.length()) + "m")
 
                 # probable collision
                 collision_distance = aircraft_vehicle_1.size / 2 + aircraft_vehicle_2.size / 2
                 collision_region = collision_distance - miss_distance_vector.length()
                 if collision_region > 0:
                     print("Collision detected")
             else:
                 for aircraft in self.aircraft_fccs:
-                    if aircraft.evade_maneuver:
+                    if aircraft.evade_maneuver and not aircraft.safe_zone_occupied:
                         aircraft.reset_evade_maneuver()
 
     def print_adsb_report(self, aircraft : AircraftVehicle) -> None:
         """Prints ADS-B report for the aircraft to the console"""
         fcc = self.aircraft_fccs[aircraft.aircraft_id]
         turning_direction = "Not turning"
         if fcc.is_turning_left:
@@ -217,7 +234,12 @@
         horizontal_speed = sqrt(aircraft.speed.x() ** 2 + aircraft.speed.y() ** 2)
         vertical_speed = abs(aircraft.speed.z())
         geometrical_speed = sqrt(horizontal_speed ** 2 + vertical_speed ** 2)
         print("absolute speed: " + "{:.2f}".format(absolute_speed) +
             "; horizontal speed: " + "{:.2f}".format(horizontal_speed) +
             "; vertical speed: " + "{:.2f}".format(vertical_speed) +
             "; geometrical speed: " + "{:.2f}".format(geometrical_speed))
+
+    def reset_destinations(self) -> None:
+        """Resets destination for all aircrafts"""
+        for aircraft in self.aircraft_fccs:
+            aircraft.load_initial_destination()
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py

```diff
@@ -1,26 +1,31 @@
 """Simulation data module"""
 
 from PySide6.QtCore import QObject
 from PySide6.QtGui import QVector3D
 
-
 class SimulationData(QObject):
     """Simulation data class"""
 
     def __init__(self) -> None:
         super().__init__()
         self.__aircraft_1_initial_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_final_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_final_position : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_1_initial_speed : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_2_initial_speed : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_1_final_speed : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_2_final_speed : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_1_initial_target : QVector3D = QVector3D(0, 0, 0)
+        self.__aircraft_2_initial_target : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_roll_angle : float = 0.0
         self.__aircraft_2_initial_roll_angle : float = 0.0
         self.__collision : bool | None = None
-        self.__minimal_miss_distance : float | None = None
+        self.__minimal_relative_distance : float | None = None
 
     @property
     def aircraft_1_initial_position(self) -> QVector3D:
         """Returns aircraft 1 initial position"""
         return self.__aircraft_1_initial_position
     
     @aircraft_1_initial_position.setter
@@ -55,14 +60,74 @@
     
     @aircraft_2_final_position.setter
     def aircraft_2_final_position(self, position : QVector3D) -> None:
         """Sets aircraft 2 final position"""
         self.__aircraft_2_final_position = position
 
     @property
+    def aircraft_1_initial_speed(self) -> QVector3D:
+        """Returns aircraft 1 initial speed"""
+        return self.__aircraft_1_initial_speed
+    
+    @aircraft_1_initial_speed.setter
+    def aircraft_1_initial_speed(self, speed : QVector3D) -> None:
+        """Sets aircraft 1 initial speed"""
+        self.__aircraft_1_initial_speed = speed
+
+    @property
+    def aircraft_2_initial_speed(self) -> QVector3D:
+        """Returns aircraft 2 initial speed"""
+        return self.__aircraft_2_initial_speed
+    
+    @aircraft_2_initial_speed.setter
+    def aircraft_2_initial_speed(self, speed : QVector3D) -> None:
+        """Sets aircraft 2 initial speed"""
+        self.__aircraft_2_initial_speed = speed
+
+    @property
+    def aircraft_1_final_speed(self) -> QVector3D:
+        """Returns aircraft 1 final speed"""
+        return self.__aircraft_1_final_speed
+    
+    @aircraft_1_final_speed.setter
+    def aircraft_1_final_speed(self, speed : QVector3D) -> None:
+        """Sets aircraft 1 final speed"""
+        self.__aircraft_1_final_speed = speed
+
+    @property
+    def aircraft_2_final_speed(self) -> QVector3D:
+        """Returns aircraft 2 final speed"""
+        return self.__aircraft_2_final_speed
+    
+    @aircraft_2_final_speed.setter
+    def aircraft_2_final_speed(self, speed : QVector3D) -> None:
+        """Sets aircraft 2 final speed"""
+        self.__aircraft_2_final_speed = speed
+
+    @property
+    def aircraft_1_initial_target(self) -> QVector3D:
+        """Returns aircraft 1 initial target"""
+        return self.__aircraft_1_initial_target
+    
+    @aircraft_1_initial_target.setter
+    def aircraft_1_initial_target(self, target : QVector3D) -> None:
+        """Sets aircraft 1 initial target"""
+        self.__aircraft_1_initial_target = target
+
+    @property
+    def aircraft_2_initial_target(self) -> QVector3D:
+        """Returns aircraft 2 initial target"""
+        return self.__aircraft_2_initial_target
+    
+    @aircraft_2_initial_target.setter
+    def aircraft_2_initial_target(self, target : QVector3D) -> None:
+        """Sets aircraft 2 initial target"""
+        self.__aircraft_2_initial_target = target
+
+    @property
     def aircraft_1_initial_roll_angle(self) -> float:
         """Returns aircraft 1 initial roll angle"""
         return self.__aircraft_1_initial_roll_angle
     
     @aircraft_1_initial_roll_angle.setter
     def aircraft_1_initial_roll_angle(self, roll_angle : float) -> None:
         """Sets aircraft 1 initial roll angle"""
@@ -85,26 +150,26 @@
     
     @collision.setter
     def collision(self, collision : bool) -> None:
         """Sets collision"""
         self.__collision = collision
 
     @property
-    def minimal_miss_distance(self) -> float | None:
+    def minimal_relative_distance(self) -> float | None:
         """Returns minimal miss distance"""
-        return self.__minimal_miss_distance
+        return self.__minimal_relative_distance
     
-    @minimal_miss_distance.setter
-    def minimal_miss_distance(self, distance : float) -> None:
+    @minimal_relative_distance.setter
+    def minimal_relative_distance(self, distance : float) -> None:
         """Sets minimal miss distance"""
-        self.__minimal_miss_distance = distance
+        self.__minimal_relative_distance = distance
 
     def reset(self) -> None:
         """Resets simulation data"""
         self.__aircraft_1_initial_position = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_position = QVector3D(0, 0, 0)
         self.__aircraft_1_final_position = QVector3D(0, 0, 0)
         self.__aircraft_2_final_position = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_roll_angle = 0.0
         self.__aircraft_2_initial_roll_angle = 0.0
         self.__collision = False
-        self.__minimal_miss_distance = 0.0
+        self.__minimal_relative_distance = 0.0
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -167,26 +167,29 @@
             aircraft.roll_angle = (1.0 / (aircraft.roll_dynamic_delay / elapsed_time)) * (fcc.target_roll_angle - aircraft.roll_angle)
 
             # pitch angle
             current_pitch_angle : float = aircraft.pitch_angle
             target_pitch_angle : float = copy(fcc.target_pitch_angle)
             if not abs(current_pitch_angle - target_pitch_angle) < 0.001 and current_pitch_angle < 90.0 and current_pitch_angle > -90.0:
                 delta_pitch_angle : float = (1.0 / (aircraft.pitch_dynamic_delay / elapsed_time)) * (target_pitch_angle - aircraft.pitch_angle)
+                delta_pitch_angle = abs(delta_pitch_angle) # temporary
                 new_pitch_angle : float = current_pitch_angle
                 if target_pitch_angle > 0:
                     if target_pitch_angle > current_pitch_angle:
                         new_pitch_angle = current_pitch_angle + delta_pitch_angle
                     else:
                         new_pitch_angle = current_pitch_angle - delta_pitch_angle
                 else: # target_pitch_angle < 0
                     if target_pitch_angle < current_pitch_angle:
                         new_pitch_angle = current_pitch_angle + delta_pitch_angle
                     else:
                         new_pitch_angle = current_pitch_angle - delta_pitch_angle
 
+                if new_pitch_angle > 45.0 or new_pitch_angle < -45.0:
+                    new_pitch_angle = current_pitch_angle
                 current_speed : float = aircraft.absolute_speed
                 new_speed_z = current_speed * sin(radians(new_pitch_angle))
                 aircraft.speed = QVector3D(
                     aircraft.speed.x(),
                     aircraft.speed.y(),
                     new_speed_z)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py

```diff
@@ -1,20 +1,21 @@
 """Simulation settings"""
 
 from PySide6.QtCore import QSize
 
 class SimulationSettings:
     """Settings for the simulation"""
 
-    screen_resolution : QSize
+    screen_resolution : QSize | None = None
     resolution : tuple
     g_acceleration : float = 9.81
     simulation_frequency : float = 100.0
     simulation_threshold : float = 1000.0 / simulation_frequency
     gui_render_frequency : float = 100.0
     gui_render_threshold : float =  1000.0 / gui_render_frequency
     adsb_threshold : float = 1000.0
 
     @classmethod
     def __init__(cls) -> None:
         """Initialises Settings using screen resolution"""
-        cls.resolution = (int(cls.screen_resolution.width() * 0.6), int(cls.screen_resolution.height() * 0.75))
+        if cls.screen_resolution is not None:
+            cls.resolution = (int(cls.screen_resolution.width() * 0.6), int(cls.screen_resolution.height() * 0.75))
```

## build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -364,18 +364,21 @@
                     self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach + self.__aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution, scale, QColor(30, 255, 30))
         if predicted_collision:
             aircraft = self.__aircraft_vehicles[0]
             collision_location = aircraft.position + aircraft.speed * time_to_closest_approach
             self.draw_circle(collision_location, 2.5 / scale, scale, QColor(255, 0, 0))
         relative_distance = dist(self.__aircraft_vehicles[0].position.toTuple(), self.__aircraft_vehicles[1].position.toTuple())
         if relative_distance < self.__simulation_state.minimum_separation:
+            if not self.simulation_state.avoid_collisions:
+                self.draw_text(QVector3D(10, self.__window_height - 10, 0), 0, "Press T to avoid collisions", QColor(255, 0, 0))
+
+            separation_height : float = 10
             if detected_conflict:
-                self.draw_text(QVector3D(self.__window_width - 260, 30, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.__simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
-            else:
-                self.draw_text(QVector3D(self.__window_width - 260, 10, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.__simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
+                separation_height = 30
+            self.draw_text(QVector3D(self.__window_width - 260, separation_height, 0), 0, f"MINIMUM SEPARATION EXCEEDED BY {int(self.__simulation_state.minimum_separation - relative_distance)}", QColor(255, 0, 0))
     
     def draw_grid(self, x_offset : float, y_offset : float, scale : float) -> None:
         """Draws grid on the screen"""
         # todo: use offsets
         for x in range(0, int(self.__window_width / scale - x_offset / 100), 100): # vertical lines
             self.draw_line(
                 QVector3D(x - x_offset / 100, 0 - y_offset, 0),
```

## build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py

```diff
@@ -1,29 +1,32 @@
 """Aircraft class module"""
 
+import logging
+
 from copy import copy
 
 from PySide6.QtCore import QObject, QMutex, QMutexLocker
 from PySide6.QtGui import QVector3D
 
 from .aircraft_vehicle import AircraftVehicle
 from .aircraft_fcc import AircraftFCC
 
 class Aircraft(QObject):
     """Main aircraft class"""
 
     def __init__(self, aircraft_id : int, position : QVector3D, speed : QVector3D, initial_target : QVector3D | None = None, initial_roll_angle : float = 0.0) -> None:
         super().__init__()
         self.__mutex : QMutex = QMutex()
-        self.__aircraft_id = aircraft_id
-        self.__vehicle = AircraftVehicle(self.__aircraft_id, position=position, speed=speed, initial_roll_angle=initial_roll_angle)
-        self.__fcc = AircraftFCC(self.__aircraft_id, initial_target, self.__vehicle)
+        self.__aircraft_id : int = aircraft_id
+        self.__vehicle : AircraftVehicle = AircraftVehicle(self.__aircraft_id, position=position, speed=speed, initial_roll_angle=initial_roll_angle)
+        self.__fcc : AircraftFCC = AircraftFCC(self.__aircraft_id, initial_target, self.__vehicle)
         self.__initial_position = copy(position)
-        self.__initial_speed = copy(speed)
-        self.__initial_roll_angle = initial_roll_angle
+        self.__initial_target : QVector3D = copy(initial_target)
+        self.__initial_speed : QVector3D = copy(speed)
+        self.__initial_roll_angle : float = initial_roll_angle
     
     @property
     def vehicle(self) -> AircraftVehicle:
         """Returns aircraft vehicle"""
         with QMutexLocker(self.__mutex):
             return self.__vehicle
     
@@ -34,26 +37,32 @@
             return self.__fcc
     
     @property
     def initial_position(self) -> QVector3D:
         """Returns initial position"""
         with QMutexLocker(self.__mutex):
             return self.__initial_position
+        
+    @property
+    def initial_target(self) -> QVector3D:
+        """Returns initial target"""
+        with QMutexLocker(self.__mutex):
+            return self.__initial_target
     
     @property
     def initial_speed(self) -> QVector3D:
         """Returns initial speed"""
         with QMutexLocker(self.__mutex):
             return self.__initial_speed
         
     @property
     def initial_roll_angle(self) -> float:
         """Returns initial roll angle"""
         with QMutexLocker(self.__mutex):
             return self.__initial_roll_angle
 
     def reset(self) -> None:
-        """Resets aircraft to initial state"""
+        """Resets the aircraft to initial state"""
         self.__vehicle.speed = copy(self.initial_speed)
         self.__vehicle.position = copy(self.initial_position)
         self.__vehicle.roll_angle = copy(self.initial_roll_angle)
         self.__vehicle.reset_distance_covered()
```

## build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -2,16 +2,16 @@
 
 import csv
 import logging
 import datetime
 import pandas as pd
 import matplotlib.pyplot as plt
 from copy import copy
-from typing import List
 from pathlib import Path
+from typing import List, Tuple
 from numpy import random, ndarray, mean
 from math import dist, sin, cos, radians
 from matplotlib.ticker import MaxNLocator
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QCloseEvent, QVector3D
 from PySide6.QtWidgets import QMainWindow
@@ -28,15 +28,15 @@
 from ..simulation.simulation_data import SimulationData
 
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     __current_id : int = 0
 
-    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 75_000_000) -> None: # 75_000_000 ms = 75_000 s = 20.83 h
+    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 86_400_000) -> None: # 86_400_000 = 86_400 s = 24h
         super().__init__()
         SimulationSettings().__init__()
         self.__simulation_id = self.obtain_simulation_id()
         self.__hash = self.obtain_simulation_hash()
         self.__headless : bool = headless
         self.__tests : bool = tests
         self.__simulation_time : int = simulation_time
@@ -150,24 +150,25 @@
         self.simulation_physics.start(priority = QThread.Priority.TimeCriticalPriority)
         self.simulation_adsb.start(priority = QThread.Priority.NormalPriority)
         self.simulation_fps.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.show()
         self.simulation_render.start(priority = QThread.Priority.NormalPriority)
         self.simulation_widget.stop_signal.connect(self.stop)
     
-    def run_headless(self, avoid_collisions : bool = False, aircrafts : List[Aircraft] | None = None, test_index : int | None = None) -> SimulationData:
+    def run_headless(self, avoid_collisions : bool = False, aircrafts : List[Aircraft] | None = None, test_index : int | None = None, aircraft_angle : float | None = None) -> SimulationData:
         """Executes simulation without GUI"""
         logging.info("Starting headless simulation")
         if aircrafts is not None:
             self.setup_aircrafts(aircrafts)
         elif self.aircrafts is None or self.aircrafts == []:
             self.setup_debug_aircrafts()
         else:
             assert len(self.aircrafts) > 0
         simulation_data : SimulationData = SimulationData()
+        simulation_data.aircraft_angle = aircraft_angle
         simulation_data.aircraft_1_initial_position = copy(self.aircrafts[0].vehicle.position)
         simulation_data.aircraft_2_initial_position = copy(self.aircrafts[1].vehicle.position)
         simulation_data.aircraft_1_initial_speed = copy(self.aircrafts[0].vehicle.speed)
         simulation_data.aircraft_2_initial_speed = copy(self.aircrafts[1].vehicle.speed)
         simulation_data.aircraft_1_initial_target = copy(self.aircrafts[0].fcc.destination)
         simulation_data.aircraft_2_initial_target = copy(self.aircrafts[1].fcc.destination)
         simulation_data.aircraft_1_initial_roll_angle = copy(self.aircrafts[0].vehicle.roll_angle)
@@ -201,36 +202,37 @@
         simulation_data.aircraft_1_final_position = copy(self.aircrafts[0].vehicle.position)
         simulation_data.aircraft_2_final_position = copy(self.aircrafts[1].vehicle.position)
         simulation_data.aircraft_1_final_speed = copy(self.aircrafts[0].vehicle.speed)
         simulation_data.aircraft_2_final_speed = copy(self.aircrafts[1].vehicle.speed)
         if self.imported_from_data:
             self.check_simulation_data_correctness()
         if test_index is not None:
-            self.export_visited_locations(test_index = test_index)
+            self.export_visited_locations(simulation_data = simulation_data, test_index = test_index)
         else:
             self.export_visited_locations()
         self.stop()
         return simulation_data
     
-    def generate_test_aircrafts(self) -> List[List[Aircraft]]:
-        """Generates test cases"""
+    def generate_test_aircrafts(self) -> List[Tuple[List[Aircraft], float]]:
+        """Generates test cases consisting of list of lists of aircrafts and angle between them"""
         logging.info("Generating test cases")
-        list_of_lists : List[List[Aircraft]] = []
+        list_of_lists : List[Tuple[List[Aircraft], float]] = []
 
         test_minimal_altitude : int = 1000
-        test_maximal_altitude : int = 7000
-        test_minimal_speed : int = 30
-        test_maximal_speed : int = 100
+        test_maximal_altitude : int = 5000
+        test_minimal_speed : int = 40
+        test_maximal_speed : int = 130
         test_start_aircrafts_relative_distance : int = 10_000 # distance between aircrafts headed to test collision target
-        test_minimal_course_difference : float = 1.0
-        test_maximal_course_difference : float = 179.0
-        test_minimal_trigonometric_value : float = 0.00001
-        test_course_difference_count : int = 170
+        test_minimal_course_difference : float = 0.5
+        test_maximal_course_difference : float = 179.5
+        test_minimal_trigonometric_value : float = 0.0001
+        test_course_difference_count : int = 400
         test_random_collision_course_differences : List[float] = random.uniform(test_minimal_course_difference, test_maximal_course_difference, test_course_difference_count).tolist()
         test_random_collision_course_differences.sort(reverse = False)
+        logging.info("Randomly generated angles: %s", test_random_collision_course_differences)
 
         # equal speeds, equal distances to cover, both climbing or both descending
         for angle in test_random_collision_course_differences:
             aircraft_init_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
             aircraft_target_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
             aircraft_collision_height : float = mean([aircraft_init_height, aircraft_target_height])
             test_collision_target : QVector3D = QVector3D(0, 0, aircraft_collision_height)
@@ -252,16 +254,16 @@
                 0,
                 100 * distance_to_collision,
                 aircraft_target_height)
             aircraft_1_speed : QVector3D = QVector3D(
                 0,
                 aircraft_absolute_speed,
                 0)
-            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.1
-            assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.1
+            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.05
+            assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.05
             
             # rotate angle to get circle equation
             sin_value = sin(radians(90 - angle))
             cos_value = cos(radians(90 - angle))
             aircraft_2_position : QVector3D = QVector3D(
                 distance_to_collision * cos_value,
                 -distance_to_collision * sin_value,
@@ -271,163 +273,171 @@
                 100 * distance_to_collision * sin_value,
                 aircraft_1_target.z())
             aircraft_2_speed : QVector3D = QVector3D(
                 -aircraft_absolute_speed * cos_value,
                 aircraft_absolute_speed * sin_value,
                 aircraft_1_speed.z())
 
-            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.1
-            assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.1
+            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.05
+            assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.05
 
             aircrafts : List[Aircraft] = [
                 Aircraft(
                     aircraft_id = 0,
                     position = aircraft_1_position,
                     speed = aircraft_1_speed,
                     initial_target = aircraft_1_target),
                 Aircraft(
                     aircraft_id = 1,
                     position = aircraft_2_position,
                     speed = aircraft_2_speed,
                     initial_target = aircraft_2_target)
             ]
-            list_of_lists.append(aircrafts)
+            list_of_lists.append([aircrafts, angle])
 
         # todo: generate more random parameters for test cases
 
         if len(list_of_lists) == 0:
             for i in range (0, 30, 1):
+                angle : float = 30.0
                 list_of_aircrafts : List[Aircraft] = []
                 aircraft : Aircraft = Aircraft( # detection test
                     aircraft_id = 0,
                     position = QVector3D(-800, 4000, 1000),
                     speed = QVector3D(60, -60, 0),
                     initial_target = QVector3D(51_900, -50_000, 10000)) # 51.9 km, -50 km
                 list_of_aircrafts.append(aircraft)
                 aircraft = Aircraft(
                     aircraft_id = 1,
                     position = QVector3D(4000, 6000, 1000),
                     speed = QVector3D(0, -85, 0),
                     initial_target = QVector3D(900, -1_001_300, 1000)) # 0.9 km, -1001.3 km
                 list_of_aircrafts.append(aircraft)
-                list_of_lists.append(list_of_aircrafts)
+                list_of_lists.append(list_of_aircrafts, angle)
 
         return list_of_lists
     
-    def generate_consistent_list_of_aircraft_lists(self) -> List[List[Aircraft]]:
+    def generate_consistent_list_of_aircraft_lists(self) -> List[Tuple[List[Aircraft], float]]:
         """Returns predefined list of aircraft lists"""
-        list_of_lists : List[List[Aircraft]] = []
+        list_of_lists : List[Tuple[List[Aircraft], float]] = []
         test_average_aircraft_size : float = 20.0
 
         # head-on testing
-        list_of_lists.append([ # chase test
+        aircrafts = [ # chase test
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -20_000, 1000),
                 speed = QVector3D(0, 100, 0),
                 initial_target = QVector3D(0, 2_000_000, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, -10_000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(0, 2_000_000, 1000))
-        ])
-        list_of_lists.append([ # full angle collision, equal speeds
+        ]
+        list_of_lists.append([aircrafts, 0.0])
+        aircrafts = [ # full angle collision, equal speeds
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(0, 500_000, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 5000, 1000),
                 speed = QVector3D(0, -50, 0),
                 initial_target = QVector3D(0, -500_000, 1000))
-        ])
-        list_of_lists.append([ # full angle collision
+        ]
+        list_of_lists.append([aircrafts, 180.0])
+        aircrafts = [ # full angle collision
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(0, 500_000, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 10000, 1000),
                 speed = QVector3D(0, -100, 0),
                 initial_target = QVector3D(0, -500_000, 1000))
-        ])
+        ]
+        list_of_lists.append([aircrafts, 180.0])
 
         # collision testing
-        list_of_lists.append([ # chase test
+        aircrafts = [ # chase test
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -20_000, 1000),
                 speed = QVector3D(0, 100, 0),
                 initial_target = QVector3D(test_average_aircraft_size / 4.0, 2_000_000 + test_average_aircraft_size / 4.0, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, -10_000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(-test_average_aircraft_size / 4.0, 2_000_000 - test_average_aircraft_size / 4.0, 1000))
-        ])
-        list_of_lists.append([ # full angle collision, equal speeds
+        ]
+        list_of_lists.append([aircrafts, 0.001])
+        aircrafts = [ # full angle collision, equal speeds
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 5000, 1000),
                 speed = QVector3D(0, -50, 0),
                 initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
-        ])
-        list_of_lists.append([ # full angle collision
+        ]
+        list_of_lists.append([aircrafts, 180.001])
+        aircrafts = [ # full angle collision
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
                 initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 10000, 1000),
                 speed = QVector3D(0, -100, 0),
                 initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
-        ])
+        ]
+        list_of_lists.append([aircrafts, 180.001])
         return list_of_lists
     
-    def run_tests(self, begin_with_default_set : bool = True, test_number : int = 10) -> None:
+    def run_tests(self, begin_with_default_set : bool = True, test_number : int = 15) -> None:
         """Runs simulation tests"""
         if test_number < 3:
             logging.info("Changing simulation tests to 3 test cases due to too low test number")
             test_number = 3
         elif test_number > 100:
             logging.info("Changing simulation tests to 100 test cases due to too high test number")
             test_number = 100
         logging.info("Running simulation tests")
-        list_of_const_lists : List[List[Aircraft]] | None = None
-        list_of_lists : List[List[Aircraft]] | None = None
+        list_of_const_lists : List[Tuple[List[Aircraft], float]] | None = None
+        list_of_lists : List[Tuple[List[Aircraft], float]] | None = None
         if begin_with_default_set:
             list_of_const_lists = self.generate_consistent_list_of_aircraft_lists()
             consistent_tests_count : int = len(list_of_const_lists)
             if test_number - consistent_tests_count > 0:
                 test_number -= consistent_tests_count
             
         list_of_lists = self.generate_test_aircrafts()
         lists_count : int = len(list_of_lists)
 
         if lists_count > test_number:
             random_indices : ndarray | None = None
-            random_indices = random.choice(lists_count, test_number, replace = False)
-            random_indices : List[int] = random_indices.tolist()
+            random_indices = random.choice(lists_count, test_number - 1, replace = False)
+            random_indices : List[int] = [0] + random_indices.tolist() # we specifically want to include first test
             random_indices_set : set = set(random_indices)
             random_indices = []
             while random_indices_set:
                 random_indices.append(random_indices_set.pop())
             random_indices.sort(reverse = False)
+            logging.info("Randomly selected aircraft pair indices: %s", random_indices)
             assert len(random_indices) <= test_number
             list_of_lists = [list_of_lists[i] for i in random_indices]
             lists_count = len(list_of_lists)
 
         if begin_with_default_set:
             list_of_lists = list_of_const_lists + list_of_lists
             lists_count = len(list_of_lists)
@@ -448,14 +458,15 @@
                 filename_iterator += 1
             file = open(f"data/simulation-{export_time}-{filename_iterator}.csv", "w")
         else:
             file = open(f"data/simulation-{export_time}.csv", "w")
         writer = csv.writer(file)
         writer.writerow([
             "test_id",
+            "aircraft_angle",
             "aircraft_1_init_pos_x",
             "aircraft_1_init_pos_y",
             "aircraft_1_init_pos_z",
             "aircraft_2_init_pos_x",
             "aircraft_2_init_pos_y",
             "aircraft_2_init_pos_z",
             "aircraft_1_init_speed_x",
@@ -500,31 +511,36 @@
             "minimal_relative_distance_if_avoidance"])
         file.close()
         file = open(f"data/simulation-{export_time}.csv", "a")
         writer = csv.writer(file)
         
         for i in range(0, test_number, 1):
             logging.info("Test %d - no collision avoidance", i)
-            aircrafts : List[Aircraft] = list_of_lists[i]
+            aircraft_tuple : List[List[Aircraft], float] = list_of_lists[i]
+            aircrafts : List[Aircraft] = aircraft_tuple[0]
+            angle : float = aircraft_tuple[1]
             print("Current test pair aircrafts count: ", len(aircrafts))
             simulation_data_no_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = False,
                 aircrafts = aircrafts,
-                test_index = i)
+                test_index = i,
+                aircraft_angle = angle)
             self.state = None
 
             logging.info("Test %d - collision avoidance", i)
             simulation_data_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = True,
                 aircrafts = aircrafts,
-                test_index = i)
+                test_index = i,
+                aircraft_angle = angle)
             self.state = None
 
             writer.writerow([
                 i,
+                angle,
                 simulation_data_no_avoidance.aircraft_1_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.y(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.z(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.y(),
                 simulation_data_no_avoidance.aircraft_2_initial_position.z(),
                 simulation_data_no_avoidance.aircraft_1_initial_speed.x(),
@@ -579,37 +595,46 @@
     def load_latest_simulation_data_file(self) -> bool:
         """Loads latest simulation data from file"""
         logging.info("Loading latest simulation data")
         found_good_file : bool = False
         latest_file_path : str | None = None
         list_of_paths : List[Path] | None = None
         list_length : int | None = None
-        try:
-            latest_file_path = max(Path("data").iterdir(), key = lambda p: p.stat().st_ctime)
-            list_of_paths = list(Path("data").iterdir())
-            list_of_paths.sort(key = lambda x: x.stat().st_ctime, reverse = False)
-            list_length = len(list_of_paths)
-        except:
-            logging.error("Failed to load latest simulation data")
+        if not Path("data").exists():
+            logging.error("No data directory found")
             return False
-        iterator : int = 1
-        while not found_good_file:
+        if Path("data/simulation.csv").exists():
+            latest_file_path = Path("data/simulation.csv")
+            list_of_paths = [latest_file_path]
+            list_length = 1
+            found_good_file = True
+        else:
             try:
-                file = open(latest_file_path, "r")
-                reader = csv.reader(file)
-                lines_count : int = 0
-                for line in reader:
-                    lines_count += 1
-                if lines_count > 1:
-                    found_good_file = True
-                    break
+                latest_file_path = max(Path("data").iterdir(), key = lambda p: p.stat().st_ctime)
+                list_of_paths = list(Path("data").iterdir())
+                list_of_paths.sort(key = lambda x: x.stat().st_ctime, reverse = False)
+                list_length = len(list_of_paths)
             except:
-                pass
-            latest_file_path = list_of_paths[list_length - 1 - iterator]
-            iterator += 1
+                logging.error("Failed to load latest simulation data")
+                return False
+            iterator : int = 1
+            while not found_good_file:
+                try:
+                    file = open(latest_file_path, "r")
+                    reader = csv.reader(file)
+                    lines_count : int = 0
+                    for line in reader:
+                        lines_count += 1
+                    if lines_count > 1:
+                        found_good_file = True
+                        break
+                except:
+                    pass
+                latest_file_path = list_of_paths[list_length - 1 - iterator]
+                iterator += 1
         if found_good_file:
             return self.load_simulation_data_from_file(latest_file_path)
         else:
             return False
 
     def load_simulation_data_from_file(self, file_path : str, test_id : int = 0, avoid_collisions : bool = False) -> bool:
         """Loads simulation data from file"""
@@ -617,36 +642,37 @@
         self.__aircrafts = []
         try:
             file = open(file_path, "r")
             reader = csv.reader(file)
             for i, row in enumerate(reader):
                 if i == test_id + 1:
                     simulation_data : SimulationData = SimulationData()
-                    assert len(row) == 47
+                    assert len(row) == 48
                     assert row[0] == str(test_id)
-                    simulation_data.aircraft_1_initial_position = QVector3D(float(row[1]), float(row[2]), float(row[3]))
-                    simulation_data.aircraft_2_initial_position = QVector3D(float(row[4]), float(row[5]), float(row[6]))
-                    simulation_data.aircraft_1_initial_speed = QVector3D(float(row[7]), float(row[8]), float(row[9]))
-                    simulation_data.aircraft_2_initial_speed = QVector3D(float(row[10]), float(row[11]), float(row[12]))
-                    simulation_data.aircraft_1_initial_target = QVector3D(float(row[13]), float(row[14]), float(row[15]))
-                    simulation_data.aircraft_2_initial_target = QVector3D(float(row[16]), float(row[17]), float(row[18]))
+                    simulation_data.aircraft_angle = float(row[1])
+                    simulation_data.aircraft_1_initial_position = QVector3D(float(row[2]), float(row[3]), float(row[4]))
+                    simulation_data.aircraft_2_initial_position = QVector3D(float(row[5]), float(row[6]), float(row[7]))
+                    simulation_data.aircraft_1_initial_speed = QVector3D(float(row[8]), float(row[9]), float(row[10]))
+                    simulation_data.aircraft_2_initial_speed = QVector3D(float(row[11]), float(row[12]), float(row[13]))
+                    simulation_data.aircraft_1_initial_target = QVector3D(float(row[14]), float(row[15]), float(row[16]))
+                    simulation_data.aircraft_2_initial_target = QVector3D(float(row[17]), float(row[18]), float(row[19]))
                     if not avoid_collisions:
-                        simulation_data.aircraft_1_final_position = QVector3D(float(row[19]), float(row[20]), float(row[21]))
-                        simulation_data.aircraft_2_final_position = QVector3D(float(row[22]), float(row[23]), float(row[24]))
-                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[31]), float(row[32]), float(row[33]))
-                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[34]), float(row[35]), float(row[36]))
-                        simulation_data.collision = row[43] == "True"
-                        simulation_data.minimal_relative_distance = float(row[45])
-                    else:
-                        simulation_data.aircraft_1_final_position = QVector3D(float(row[25]), float(row[26]), float(row[27]))
-                        simulation_data.aircraft_2_final_position = QVector3D(float(row[28]), float(row[29]), float(row[30]))
-                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[37]), float(row[38]), float(row[39]))
-                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[40]), float(row[41]), float(row[42]))
+                        simulation_data.aircraft_1_final_position = QVector3D(float(row[20]), float(row[21]), float(row[22]))
+                        simulation_data.aircraft_2_final_position = QVector3D(float(row[23]), float(row[24]), float(row[25]))
+                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[32]), float(row[33]), float(row[34]))
+                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[35]), float(row[36]), float(row[37]))
                         simulation_data.collision = row[44] == "True"
                         simulation_data.minimal_relative_distance = float(row[46])
+                    else:
+                        simulation_data.aircraft_1_final_position = QVector3D(float(row[26]), float(row[27]), float(row[28]))
+                        simulation_data.aircraft_2_final_position = QVector3D(float(row[29]), float(row[30]), float(row[31]))
+                        simulation_data.aircraft_1_final_speed = QVector3D(float(row[38]), float(row[39]), float(row[40]))
+                        simulation_data.aircraft_2_final_speed = QVector3D(float(row[41]), float(row[42]), float(row[43]))
+                        simulation_data.collision = row[45] == "True"
+                        simulation_data.minimal_relative_distance = float(row[47])
                     self.import_simulation_data(simulation_data)
                     return True
         except:
             logging.error("Failed to load simulation data from file")
             return False
     
     def stop(self) -> None:
@@ -710,14 +736,15 @@
     def remove_aircraft(self, aircraft : Aircraft) -> None:
         """Removes aircraft from simulation"""
         if self.aircrafts is not None:
             self.aircrafts.remove(aircraft)
 
     def setup_aircrafts(self, aircrafts : List[Aircraft]) -> None:
         """Sets up aircrafts list"""
+        del self.__aircrafts
         self.__aircrafts = aircrafts
 
     def setup_debug_aircrafts(self, test_case : int = 0) -> None:
         """Sets up debug aircrafts list"""
         if test_case == 0:
             aircrafts : List[Aircraft] = [
                 Aircraft( # detection test
@@ -858,83 +885,91 @@
         assert dist(self.aircrafts[1].vehicle.speed.toTuple(), self.__simulation_data.aircraft_2_final_speed.toTuple()) < 0.1
         assert abs(self.aircrafts[0].vehicle.speed.length() - self.__simulation_data.aircraft_1_final_speed.length()) < 0.1
         assert abs(self.aircrafts[1].vehicle.speed.length() - self.__simulation_data.aircraft_2_final_speed.length()) < 0.1
         assert abs(self.simulation_adsb.minimal_relative_distance - self.__simulation_data.minimal_relative_distance) < 0.1
         logging.info("Simulation data correctness checked successfully ✅")
         return True
 
-    def export_visited_locations(self, test_index : int | None = None) -> None:
+    def export_visited_locations(self, simulation_data : SimulationData | None = None, test_index : int | None = None) -> None:
         """Exports aircrafts visited location lists"""
         aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
 
         plt.set_loglevel("error")
         plt.figure()
-        plt.suptitle("Aircraft paths visualization")
-        plt.title("author: Miłosz Maculewicz")
+        plt.title("Aircraft paths visualization")
         plt.subplots_adjust(left = 0.15, right = 0.85, top = 0.85, bottom = 0.15)
         plt.subplots_adjust(hspace = 0.5, wspace = 0.5)
         plt.grid(True)
         plt.xlabel("x")
         plt.ylabel("y")
         plt.gca().xaxis.set_major_locator(MaxNLocator(integer=True))
         plt.gca().yaxis.set_major_locator(MaxNLocator(integer=True))
 
         x_minimum : float = float("inf")
         x_maximum : float = float("-inf")
         y_minimum : float = float("inf")
         y_maximum : float = float("-inf")
         colors = ["b", "g", "r", "c", "m", "y", "k"]
 
+        export_date = datetime.datetime.now().strftime("%Y-%m-%d")
         export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
         try:
             Path("logs/visited").mkdir(parents=True, exist_ok=True)
             Path("path-visual").mkdir(parents=True, exist_ok=True)
+            Path(f"path-visual/{export_date}").mkdir(parents=True, exist_ok=True)
             if test_index is not None:
-                Path(f"path-visual/simulation-{self.simulation_id}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                Path(f"path-visual/{export_date}/simulation-{self.simulation_id}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
             else:
-                Path(f"path-visual/simulation-{self.simulation_id}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                Path(f"path-visual/{export_date}/simulation-{self.simulation_id}-{self.hash}").mkdir(parents=True, exist_ok=True)
         except:
             logging.error("Failed to create directories for visited logs")
             return
 
-        aircraft_1_init = []
-        aircraft_2_init = []
-
         for i, aircraft in enumerate(aircraft_fccs):
             file_name = f"logs/visited/visited-aircraft-{aircraft.aircraft_id}-{export_time}"
             with open(f"{file_name}.csv", "w") as file:
                 writer = csv.writer(file)
                 writer.writerow(["x","y","z"])
                 for position in aircraft.visited:
                     x_minimum = min(x_minimum, position.x())
                     x_maximum = max(x_maximum, position.x())
                     y_minimum = min(y_minimum, position.y())
                     y_maximum = max(y_maximum, position.y())
                     writer.writerow([("{:.2f}".format(position.x())),("{:.2f}".format(position.y())),("{:.2f}".format(position.z()))])
                     
             df = pd.read_csv(f"{file_name}.csv")
-            plt.scatter(df["x"], df["y"], color=colors[i % len(colors)], s = 5)
+            plt.scatter(df["x"], df["y"], color=colors[i % len(colors)], s = 2)
             plt.plot(df["x"], df["y"], color=colors[i % len(colors)])
 
-            if not df.empty:
-                if i == 0:
-                    aircraft_1_init = [df.iloc[0]["x"],  df.iloc[0]["y"]]
-                elif i == 1:
-                    aircraft_2_init = [df.iloc[0]["x"],  df.iloc[0]["y"]]
-
-        x_spectrum : float = x_maximum - x_minimum
-        y_spectrum : float = y_maximum - y_minimum
-        plt.xlim(x_minimum - x_spectrum, x_maximum + x_spectrum)
-        plt.ylim(y_minimum - y_spectrum, y_maximum + y_spectrum)
-        plt.text(aircraft_1_init[0] + 0.05 * x_spectrum, aircraft_1_init[1] - 0.05 * y_spectrum, f"Initial position\nof Aircraft 1", color = colors[0 % len(colors)], fontsize = 9, ha = "left")
-        plt.text(aircraft_2_init[0] + 0.05 * x_spectrum, aircraft_2_init[1] - 0.05 * y_spectrum, f"Initial position\nof Aircraft 2", color = colors[1 % len(colors)], fontsize = 9, ha = "left")
+        x_range : float = x_maximum - x_minimum
+        y_range : float = y_maximum - y_minimum
+        plt.xlim(x_minimum - x_range / 2, x_maximum + x_range / 2)
+        plt.ylim(y_minimum - y_range / 2, y_maximum + y_range / 2)
+
+        if simulation_data is not None:
+            import matplotlib.patches as mpatches
+            aircraft_1_init = [simulation_data.aircraft_1_initial_position.x(), simulation_data.aircraft_1_initial_position.y()]
+            aircraft_2_init = [simulation_data.aircraft_2_initial_position.x(), simulation_data.aircraft_2_initial_position.y()]
+            plt.text(aircraft_1_init[0] + 0.05 * x_range, aircraft_1_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 1", color = colors[0 % len(colors)], fontsize = 9, ha = "left")
+            plt.text(aircraft_2_init[0] + 0.05 * x_range, aircraft_2_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 2", color = colors[1 % len(colors)], fontsize = 9, ha = "left")
+            if simulation_data.collision:
+                aircraft_final = [simulation_data.aircraft_1_final_position.x(), simulation_data.aircraft_1_final_position.y()]
+                plt.text(aircraft_final[0] + 0.05 * x_range, aircraft_final[1] - 0.05 * y_range, "Collision", color = "r", fontsize = 9, ha = "left")
+            angle_patch = mpatches.Patch(
+                color = "none",
+                label = "Init angle: " + "{:.3f}".format(simulation_data.aircraft_angle))
+            min_relative_dist_patch = mpatches.Patch(
+                color = "none",
+                label = "Min relative dist: " + "{:.3f}".format(simulation_data.minimal_relative_distance))
+            plt.legend(handles=[angle_patch, min_relative_dist_patch])
+        
         if test_index is not None:
-            plt.savefig(f"path-visual/simulation-{self.simulation_id}-{test_index}-{self.hash}/path-visual-{export_time}.png")
+            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id}-{test_index}-{self.hash}/path-visual-{export_time}.png")
         else:
-            plt.savefig(f"path-visual/simulation-{self.simulation_id}-{self.hash}/path-visual-{export_time}.png")
+            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id}-{self.hash}/path-visual-{export_time}.png")
         plt.close()
     
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
         self.stop()
         event.accept()
         return super().closeEvent(event)
```

## build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -56,15 +56,18 @@
         """Increments ADS-B cycle counter"""
         self.__adsb_cycles += 1
         self.simulation_state.adsb_cycles = self.adsb_cycles
 
     @property
     def minimal_relative_distance(self) -> float:
         """Returns minimal miss distance"""
-        return self.__minimal_relative_distance
+        if self.__simulation_state.collision:
+            return 0
+        else:
+            return self.__minimal_relative_distance
     
     @minimal_relative_distance.setter
     def minimal_relative_distance(self, minimal_relative_distance : float) -> None:
         """Sets minimal miss distance"""
         self.__minimal_relative_distance = minimal_relative_distance
 
     @property
```

## build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py

```diff
@@ -4,14 +4,15 @@
 from PySide6.QtGui import QVector3D
 
 class SimulationData(QObject):
     """Simulation data class"""
 
     def __init__(self) -> None:
         super().__init__()
+        self.__aircraft_angle : float = 0.0
         self.__aircraft_1_initial_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_final_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_final_position : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_speed : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_speed : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_final_speed : QVector3D = QVector3D(0, 0, 0)
@@ -20,14 +21,24 @@
         self.__aircraft_2_initial_target : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_roll_angle : float = 0.0
         self.__aircraft_2_initial_roll_angle : float = 0.0
         self.__collision : bool | None = None
         self.__minimal_relative_distance : float | None = None
 
     @property
+    def aircraft_angle(self) -> float:
+        """Returns initial angle between aircrafts"""
+        return self.__aircraft_angle
+    
+    @aircraft_angle.setter
+    def aircraft_angle(self, angle : float) -> None:
+        """Sets initial angle between aircrafts"""
+        self.__aircraft_angle = angle
+
+    @property
     def aircraft_1_initial_position(self) -> QVector3D:
         """Returns aircraft 1 initial position"""
         return self.__aircraft_1_initial_position
     
     @aircraft_1_initial_position.setter
     def aircraft_1_initial_position(self, position : QVector3D) -> None:
         """Sets aircraft 1 initial position"""
```

## build/lib/build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py

```diff
@@ -102,18 +102,18 @@
     def move(self, dx : float, dy : float, dz : float = 0.0) -> None:
         """Applies position deltas for the vehicle"""
         with QMutexLocker(self.__mutex):
             self.__position.setX(self.__position.x() + dx)
             self.__position.setY(self.__position.y() + dy)
             self.__position.setZ(self.__position.z() + dz)
     
-    def roll(self, dy) -> None:
+    def roll(self, d_angle) -> None:
         """Applies roll angle delta of the aircraft"""
         with QMutexLocker(self.__mutex):
-            self.__roll_angle += dy
+            self.__roll_angle += d_angle
     
     @property
     def absolute_speed(self) -> float:
         """Returns absolute speed"""
         with QMutexLocker(self.__mutex):
             return self.__speed.length()
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -130,17 +130,17 @@
             if self.tests:
                 self.run_tests()
             else:
                 self.run_headless()
         else:
             self.run_gui()
 
-    def run_gui(self, avoid_collisions : bool = False, load_lastest_data_file : bool = True) -> None:
+    def run_gui(self, avoid_collisions : bool = False, load_latest_data_file : bool = True) -> None:
         """Executes realtime simulation"""
-        if load_lastest_data_file:
+        if load_latest_data_file:
             self.load_latest_simulation_data_file()
         if self.aircrafts is None or self.aircrafts == []:
             self.setup_debug_aircrafts()
         logging.info("Starting realtime simulation")
         self.state = SimulationState(SimulationSettings(), is_realtime = True, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
@@ -693,15 +693,15 @@
         self.simulation_adsb.requestInterruption()
         self.simulation_render.requestInterruption()
         self.simulation_fps.requestInterruption()
         self.simulation_physics.quit()
         self.simulation_physics.wait()
 
         if self.state.is_paused:
-            self.state.append_paused_time()
+            self.state.append_time_paused()
         simulated_time : float = self.state.physics_cycles / (1000 / self.state.simulation_threshold)
         real_time_pauses : float = self.simulation_physics.global_start_timestamp.msecsTo(self.simulation_physics.global_stop_timestamp) / 1000
         real_time : float = real_time_pauses - (self.state.time_paused / 1000)
         print("Time simulated: " + "{:.2f}".format(simulated_time) + "s")
         if real_time == real_time_pauses:
             print("Time elapsed: " + "{:.2f}".format(real_time) + "s")
         else:
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -149,15 +149,15 @@
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
 
                 if miss_distance_vector.length() == 0 and self.simulation_state.avoid_collisions:
                     print("Head-on collision detected")
                     logging.info("Head-on collision detected")
 
-                # resolve confict condition
+                # resolve conflict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
                     print("Conflict condition detected")
                     if self.simulation_state.avoid_collisions and relative_position.length() < self.simulation_state.minimum_separation:
                         for aircraft in self.aircraft_fccs:
                             if not aircraft.evade_maneuver:
                                 logging.info("Conflict condition resolution with relative distance: " + "{:.2f}".format(relative_position.length()) + "m")
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py

```diff
@@ -12,10 +12,10 @@
     simulation_threshold : float = 1000.0 / simulation_frequency
     gui_render_frequency : float = 100.0
     gui_render_threshold : float =  1000.0 / gui_render_frequency
     adsb_threshold : float = 1000.0
 
     @classmethod
     def __init__(cls) -> None:
-        """Initialises Settings using screen resolution"""
+        """Initializes Settings using screen resolution"""
         if cls.screen_resolution is not None:
             cls.resolution = (int(cls.screen_resolution.width() * 0.6), int(cls.screen_resolution.height() * 0.75))
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -48,15 +48,15 @@
             else:
                 self.__gui_scale : float = 0.75
             self.__draw_fps : bool = True
             self.__draw_aircraft : bool = True
             self.__draw_grid : bool = False
             self.__draw_path : bool = True
             self.__draw_speed_vectors : bool = True
-            self.__draw_safezones : bool = True
+            self.__draw_safe_zones : bool = True
             self.__draw_collision_detection : bool = True
             self.__optimize_drawing : bool = False
             self.__follow_aircraft : bool = False
             self.__focus_aircraft_id : int = 0
 
             # assets
             self.__aircraft_pixmap : QPixmap = QPixmap()
@@ -140,15 +140,15 @@
         """Sets pause state"""
         with QMutexLocker(self.__mutex):
             self.__is_paused = is_paused
         
     def toggle_pause(self) -> None:
         """Pauses the simulation"""
         if self.is_paused:
-            self.append_paused_time()
+            self.append_time_paused()
             self.is_paused = False
         else:
             if not self.is_running:
                 return
             self.pause_start_timestamp = QTime.currentTime()
             self.is_paused = True
     
@@ -188,15 +188,15 @@
         
     @pause_start_timestamp.setter
     def pause_start_timestamp(self, pause_start_timestamp : QTime | None) -> None:
         """Sets pause start timestamp"""
         with QMutexLocker(self.__mutex):
             self.__pause_start_timestamp = pause_start_timestamp
         
-    def append_paused_time(self) -> None:
+    def append_time_paused(self) -> None:
         """Appends time elapsed during recent pause"""
         with QMutexLocker(self.__mutex):
             if self.__pause_start_timestamp is not None:
                 self.__time_paused += self.__pause_start_timestamp.msecsTo(QTime.currentTime())
     
     @property
     def time_paused(self) -> int:
@@ -208,20 +208,20 @@
     def time_paused(self, time_paused : int) -> None:
         """Sets time paused"""
         with QMutexLocker(self.__mutex):
             self.__time_paused = time_paused
     
     @property
     def adsb_report(self) -> None:
-        """Returns ADS-B commandline info reporting flag"""
+        """Returns ADS-B command-line info reporting flag"""
         with QMutexLocker(self.__mutex):
             return self.__adsb_report
 
     def toggle_adsb_report(self) -> None:
-        """Toggles ADS-B commandline info report"""
+        """Toggles ADS-B command-line info report"""
         with QMutexLocker(self.__mutex):
             self.__adsb_report = not self.__adsb_report
 
     @property
     def collision(self) -> bool:
         """Returns collision state"""
         with QMutexLocker(self.__mutex):
@@ -234,26 +234,26 @@
     
     @property
     def first_cause_collision(self) -> bool:
         """Returns causing collision state"""
         with QMutexLocker(self.__mutex):
             return self.__first_cause_collision
     
-    def toggle_first_causing_collision(self) -> None:
+    def toggle_first_cause_collision(self) -> None:
         """Toggles causing collision state"""
         with QMutexLocker(self.__mutex):
             self.__first_cause_collision = not self.__first_cause_collision
     
     @property
     def second_cause_collision(self) -> bool:
         """Returns causing collision state"""
         with QMutexLocker(self.__mutex):
             return self.__second_cause_collision
     
-    def toggle_second_causing_collision(self) -> None:
+    def toggle_second_cause_collision(self) -> None:
         """Toggles causing collision state"""
         with QMutexLocker(self.__mutex):
             self.__second_cause_collision = not self.__second_cause_collision
 
     @property
     def gui_scale(self) -> float:
         """Returns GUI scaling factor"""
@@ -330,23 +330,23 @@
         
     def toggle_draw_speed_vectors(self) -> None:
         """Toggles speed vector display"""
         with QMutexLocker(self.__mutex):
             self.__draw_speed_vectors = not self.__draw_speed_vectors
 
     @property
-    def draw_safezones(self) -> bool:
-        """Returns safezone display flag"""
+    def draw_safe_zones(self) -> bool:
+        """Returns safe_zone display flag"""
         with QMutexLocker(self.__mutex):
-            return self.__draw_safezones
+            return self.__draw_safe_zones
         
-    def toggle_draw_safezones(self) -> None:
-        """Toggles safezone display"""
+    def toggle_draw_safe_zones(self) -> None:
+        """Toggles safe_zone display"""
         with QMutexLocker(self.__mutex):
-            self.__draw_safezones = not self.__draw_safezones
+            self.__draw_safe_zones = not self.__draw_safe_zones
 
     @property
     def draw_collision_detection(self) -> bool:
         """Returns collision detection display flag"""
         with QMutexLocker(self.__mutex):
             return self.__draw_collision_detection
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -44,18 +44,18 @@
         self.__icon.addPixmap(self.generate_icon(), QIcon.Mode.Normal, QIcon.State.Off)
         self.setWindowIcon(self.__icon)
 
         self.__moving_view_up : bool = False
         self.__moving_view_down : bool = False
         self.__moving_view_left : bool = False
         self.__moving_view_right : bool = False
-        self.__steering_left : bool = False
-        self.__steering_right : bool = False
         self.__steering_up : bool = False
         self.__steering_down : bool = False
+        self.__steering_left : bool = False
+        self.__steering_right : bool = False
 
         self.center_offsets()
 
     @property
     def aircrafts(self) -> List[Aircraft]:
         """Returns aircrafts"""
         with QMutexLocker(self.__mutex):
@@ -495,15 +495,15 @@
             self.draw_collision_detection(scale)
         for aircraft in self.__aircraft_vehicles:
             if self.__simulation_state.draw_aircraft:
                 self.draw_aircraft(aircraft, scale)
                 self.draw_destinations(aircraft, scale)
             if self.__simulation_state.draw_speed_vectors:
                 self.draw_vector(aircraft.position, aircraft.position + aircraft.speed, scale)
-            if self.__simulation_state.draw_safezones:
+            if self.__simulation_state.draw_safe_zones:
                 self.draw_circle(aircraft.position, self.__simulation_state.minimum_separation, scale)
         return super().paintEvent(event)
 
     def mousePressEvent(self, event: QMouseEvent) -> None:
         """Qt method controlling single click mouse input"""
         scale : float = self.__simulation_state.gui_scale
         click_x : int = event.pos().x()
@@ -582,15 +582,15 @@
         elif event.key() == Qt.Key.Key_T:
             self.__simulation_state.toggle_avoid_collisions()
         elif event.key() == Qt.Key.Key_N:
             self.__simulation_state.toggle_follow_aircraft()
         elif event.key() == Qt.Key.Key_M:
             self.__simulation_state.toggle_focus_aircraft()
         elif event.key() == Qt.Key.Key_Z:
-            self.__simulation_state.toggle_draw_safezones()
+            self.__simulation_state.toggle_draw_safe_zones()
         elif event.key() == Qt.Key.Key_Left:
             self.__moving_view_left = True
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = True
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = True
         elif event.key() == Qt.Key.Key_Down:
```

## build/lib/build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## build/lib/uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -281,18 +281,18 @@
     def evade_maneuver(self) -> bool:
         """Returns evade maneuver state"""
         with QMutexLocker(self.__mutex):
             return self.__evade_maneuver
 
     def apply_evade_maneuver(self, opponent_speed : QVector3D, miss_distance_vector : QVector3D, unresolved_region : float, time_to_closest_approach : float) -> None:
         """Applies evade maneuver"""
-        print(str(self.aircraft.aircraft_id) + ": opponent speed: " + "{:.2f}".format(opponent_speed.x()) + " " + "{:.2f}".format(opponent_speed.y()) + " " + "{:.2f}".format(opponent_speed.z()))
-        print(str(self.aircraft.aircraft_id) + ": miss distance vector: " + "{:.2f}".format(miss_distance_vector.x()) + " " + "{:.2f}".format(miss_distance_vector.y()) + " " + "{:.2f}".format(miss_distance_vector.z()))
-        print(str(self.aircraft.aircraft_id) + ": unresolved region: " + "{:.2f}".format(unresolved_region))
-        print(str(self.aircraft.aircraft_id) + ": time to closest approach: " + "{:.2f}".format(time_to_closest_approach))
+        print("FCC " + str(self.aircraft.aircraft_id) + ": Opponent speed: (" + "{:.2f}".format(opponent_speed.x()) + ", " + "{:.2f}".format(opponent_speed.y()) + ", " + "{:.2f}".format(opponent_speed.z()) + ")")
+        print("FCC " + str(self.aircraft.aircraft_id) + ": Miss distance vector: (" + "{:.2f}".format(miss_distance_vector.x()) + ", " + "{:.2f}".format(miss_distance_vector.y()) + ", " + "{:.2f}".format(miss_distance_vector.z()) + ")")
+        print("FCC " + str(self.aircraft.aircraft_id) + ": Unresolved region: " + "{:.2f}".format(unresolved_region))
+        print("FCC " + str(self.aircraft.aircraft_id) + ": Time to closest approach: " + "{:.2f}".format(time_to_closest_approach))
 
         if self.__evade_maneuver:
             logging.warning("Another evade maneuver in progress")
         else:
             print(f"Aircraft {self.aircraft.aircraft_id} applying evade maneuver")
             logging.info("Aircraft %s applying evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = True
@@ -314,20 +314,20 @@
                 pass
             else:
                 self.vector_sharing_resolution : QVector3D | None = None
                 if self.aircraft_id == 0:
                     self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * -(miss_distance_vector)) / ((self.aircraft.speed.length() + opponent_speed.length()) * miss_distance_vector.length())
                 elif self.aircraft_id == 1:
                     self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * miss_distance_vector) / ((opponent_speed.length() + self.aircraft.speed.length()) * miss_distance_vector.length())
-                print("Vector sharing resolution: " + "{:.2f}".format(self.vector_sharing_resolution.x()) + " " + "{:.2f}".format(self.vector_sharing_resolution.y()) + " " + "{:.2f}".format(self.vector_sharing_resolution.z()))
+                print("Vector sharing resolution: (" + "{:.2f}".format(self.vector_sharing_resolution.x()) + ", " + "{:.2f}".format(self.vector_sharing_resolution.y()) + ", " + "{:.2f}".format(self.vector_sharing_resolution.z()) + ")")
                 modified_speed_vector : QVector3D = (self.aircraft.speed * time_to_closest_approach + self.vector_sharing_resolution)
                 unit_vector : QVector3D = modified_speed_vector.normalized()
                 target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
             
-            print("Set target avoiding collision: " + "{:.2f}".format(target_avoiding.x()) + " " + "{:.2f}".format(target_avoiding.y()) + " " + "{:.2f}".format(target_avoiding.z()))
+            print("Set target avoiding collision: (" + "{:.2f}".format(target_avoiding.x()) + ", " + "{:.2f}".format(target_avoiding.y()) + ", " + "{:.2f}".format(target_avoiding.z()) + ")")
             self.add_first_destination(target_avoiding)
 
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         with QMutexLocker(self.__mutex):
             if self.__evade_maneuver:
                 logging.info("Aircraft %s reset evade maneuver", self.__aircraft.aircraft_id)
@@ -438,14 +438,19 @@
         self.__evade_maneuver = False
         self.__vector_sharing_resolution = None
         self.__safe_zone_occupied = False
         self.__autopilot = True
         self.__ignore_destinations = False
         self.__is_turning_right = False
         self.__is_turning_left = False
+        
+    def clear_destinations(self) -> None:
+        """Clears destinations list"""
+        with QMutexLocker(self.__mutex):
+            self.__destinations.clear()
 
     def load_initial_destination(self) -> None:
         """Loads initial destination"""
         if self.initial_target is not None:
             self.add_first_destination(self.initial_target)
 
     def __str__(self) -> str:
```

## build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -1,18 +1,20 @@
 """Simulation module"""
 
 import csv
 import logging
 import datetime
 import pandas as pd
 import matplotlib.pyplot as plt
+import matplotlib.patches as mpatches
+
 from copy import copy
 from pathlib import Path
 from typing import List, Tuple
-from numpy import random, ndarray, mean
+from numpy import random, ndarray
 from math import dist, sin, cos, radians
 from matplotlib.ticker import MaxNLocator
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QCloseEvent, QVector3D
 from PySide6.QtWidgets import QMainWindow
 
@@ -28,27 +30,34 @@
 from ..simulation.simulation_data import SimulationData
 
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     __current_id : int = 0
 
-    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 86_400_000) -> None: # 86_400_000 = 86_400 s = 24h
+    def __init__(self, headless : bool = False, tests : bool = False, simulation_time : int = 1_209_600_000) -> None: # 1_209_600_000 ms = 1_209_600 s = 336 h = 14 days
+        """Initializes simulation"""
         super().__init__()
         SimulationSettings().__init__()
         self.__simulation_id = self.obtain_simulation_id()
         self.__hash = self.obtain_simulation_hash()
         self.__headless : bool = headless
         self.__tests : bool = tests
         self.__simulation_time : int = simulation_time
         self.__aircrafts : List[Aircraft] | None = None
         self.__state : SimulationState | None = None
         self.__imported_from_data : bool = False
         self.__simulation_data : SimulationData | None = None
 
+        self.__simulation_physics : SimulationPhysics | None = None
+        self.__simulation_adsb : SimulationADSB | None = None
+        self.__simulation_fps : SimulationFPS | None = None
+        self.__simulation_widget : SimulationWidget | None = None
+        self.__simulation_render : SimulationRender | None = None
+
     @staticmethod
     def obtain_simulation_id() -> int:
         """Obtains new simulation id"""
         simulation_id : int = Simulation.__current_id
         Simulation.__current_id += 1
         return simulation_id
     
@@ -116,14 +125,64 @@
         """Returns simulation data"""
         return self.__simulation_data
     
     @simulation_data.setter
     def simulation_data(self, data : SimulationData) -> None:
         """Sets simulation data"""
         self.__simulation_data = data
+
+    @property
+    def simulation_physics(self) -> SimulationPhysics:
+        """Returns simulation physics"""
+        return self.__simulation_physics
+    
+    @simulation_physics.setter
+    def simulation_physics(self, physics : SimulationPhysics) -> None:
+        """Sets simulation physics"""
+        self.__simulation_physics = physics
+
+    @property
+    def simulation_adsb(self) -> SimulationADSB:
+        """Returns simulation adsb"""
+        return self.__simulation_adsb
+    
+    @simulation_adsb.setter
+    def simulation_adsb(self, adsb : SimulationADSB) -> None:
+        """Sets simulation adsb"""
+        self.__simulation_adsb = adsb
+
+    @property
+    def simulation_fps(self) -> SimulationFPS:
+        """Returns simulation fps"""
+        return self.__simulation_fps
+    
+    @simulation_fps.setter
+    def simulation_fps(self, fps : SimulationFPS) -> None:
+        """Sets simulation fps"""
+        self.__simulation_fps = fps
+
+    @property
+    def simulation_widget(self) -> SimulationWidget:
+        """Returns simulation widget"""
+        return self.__simulation_widget
+    
+    @simulation_widget.setter
+    def simulation_widget(self, widget : SimulationWidget) -> None:
+        """Sets simulation widget"""
+        self.__simulation_widget = widget
+
+    @property
+    def simulation_render(self) -> SimulationRender:
+        """Returns simulation render"""
+        return self.__simulation_render
+
+    @simulation_render.setter
+    def simulation_render(self, render : SimulationRender) -> None:
+        """Sets simulation render"""
+        self.__simulation_render = render
     
     def run(self) -> None:
         """Executes simulation"""
         if self.state is not None:
             print("Another instance already running")
             return
         if self.headless:
@@ -199,14 +258,15 @@
                 simulation_data.collision = True
                 break
         simulation_data.minimal_relative_distance = copy(self.simulation_adsb.minimal_relative_distance)
         simulation_data.aircraft_1_final_position = copy(self.aircrafts[0].vehicle.position)
         simulation_data.aircraft_2_final_position = copy(self.aircrafts[1].vehicle.position)
         simulation_data.aircraft_1_final_speed = copy(self.aircrafts[0].vehicle.speed)
         simulation_data.aircraft_2_final_speed = copy(self.aircrafts[1].vehicle.speed)
+        simulation_data.miss_distance_at_closest_approach = copy(self.simulation_adsb.miss_distance_at_closest_approach)
         if self.imported_from_data:
             self.check_simulation_data_correctness()
         if test_index is not None:
             self.export_visited_locations(simulation_data = simulation_data, test_index = test_index)
         else:
             self.export_visited_locations()
         self.stop()
@@ -230,17 +290,15 @@
         test_random_collision_course_differences.sort(reverse = False)
         logging.info("Randomly generated angles: %s", test_random_collision_course_differences)
 
         # equal speeds, equal distances to cover, both climbing or both descending
         for angle in test_random_collision_course_differences:
             aircraft_init_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
             aircraft_target_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
-            aircraft_collision_height : float = mean([aircraft_init_height, aircraft_target_height])
-            test_collision_target : QVector3D = QVector3D(0, 0, aircraft_collision_height)
-            test_collision_target_flat : QVector3D = QVector3D(0, 0, aircraft_init_height)
+            test_collision_target_projected : QVector3D = QVector3D(0, 0, aircraft_init_height)
             aircraft_absolute_speed : float = random.uniform(test_minimal_speed, test_maximal_speed)
             sin_value : float = sin(radians(angle))
             cos_value : float = cos(radians(angle))
             if abs(sin_value) < test_minimal_trigonometric_value:
                 continue
             if abs(cos_value) < test_minimal_trigonometric_value:
                 continue
@@ -254,16 +312,16 @@
                 0,
                 100 * distance_to_collision,
                 aircraft_target_height)
             aircraft_1_speed : QVector3D = QVector3D(
                 0,
                 aircraft_absolute_speed,
                 0)
-            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.05
-            assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.05
+            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_projected.toTuple()) - distance_to_collision) < 0.1
+            assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.1
             
             # rotate angle to get circle equation
             sin_value = sin(radians(90 - angle))
             cos_value = cos(radians(90 - angle))
             aircraft_2_position : QVector3D = QVector3D(
                 distance_to_collision * cos_value,
                 -distance_to_collision * sin_value,
@@ -273,16 +331,16 @@
                 100 * distance_to_collision * sin_value,
                 aircraft_1_target.z())
             aircraft_2_speed : QVector3D = QVector3D(
                 -aircraft_absolute_speed * cos_value,
                 aircraft_absolute_speed * sin_value,
                 aircraft_1_speed.z())
 
-            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_flat.toTuple()) - distance_to_collision) < 0.05
-            assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.05
+            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_projected.toTuple()) - distance_to_collision) < 0.1
+            assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.1
 
             aircrafts : List[Aircraft] = [
                 Aircraft(
                     aircraft_id = 0,
                     position = aircraft_1_position,
                     speed = aircraft_1_speed,
                     initial_target = aircraft_1_target),
@@ -400,16 +458,17 @@
                 position = QVector3D(0, 10000, 1000),
                 speed = QVector3D(0, -100, 0),
                 initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
         ]
         list_of_lists.append([aircrafts, 180.001])
         return list_of_lists
     
-    def run_tests(self, begin_with_default_set : bool = True, test_number : int = 15) -> None:
+    def run_tests(self, begin_with_default_set : bool = True, test_number : int = 20) -> None:
         """Runs simulation tests"""
+        SimulationSettings.set_simulation_frequency(10.0)
         if test_number < 3:
             logging.info("Changing simulation tests to 3 test cases due to too low test number")
             test_number = 3
         elif test_number > 100:
             logging.info("Changing simulation tests to 100 test cases due to too high test number")
             test_number = 100
         logging.info("Running simulation tests")
@@ -419,19 +478,20 @@
             list_of_const_lists = self.generate_consistent_list_of_aircraft_lists()
             consistent_tests_count : int = len(list_of_const_lists)
             if test_number - consistent_tests_count > 0:
                 test_number -= consistent_tests_count
             
         list_of_lists = self.generate_test_aircrafts()
         lists_count : int = len(list_of_lists)
+        print("Generated list of pairs: ", lists_count)
 
         if lists_count > test_number:
             random_indices : ndarray | None = None
-            random_indices = random.choice(lists_count, test_number - 1, replace = False)
-            random_indices : List[int] = [0] + random_indices.tolist() # we specifically want to include first test
+            random_indices = random.choice(lists_count, test_number - 2, replace = False)
+            random_indices : List[int] = [0] + random_indices.tolist() + [lists_count - 1] # we specifically want to include first and last test
             random_indices_set : set = set(random_indices)
             random_indices = []
             while random_indices_set:
                 random_indices.append(random_indices_set.pop())
             random_indices.sort(reverse = False)
             logging.info("Randomly selected aircraft pair indices: %s", random_indices)
             assert len(random_indices) <= test_number
@@ -504,38 +564,46 @@
             "aircraft_1_final_speed_z_if_avoidance",
             "aircraft_2_final_speed_x_if_avoidance",
             "aircraft_2_final_speed_y_if_avoidance",
             "aircraft_2_final_speed_z_if_avoidance",
             "collision_if_no_avoidance",
             "collision_if_avoidance",
             "minimal_relative_distance_if_no_avoidance",
-            "minimal_relative_distance_if_avoidance"])
+            "minimal_relative_distance_if_avoidance",
+            "miss_distance_at_closest_approach_if_no_avoidance",
+            "miss_distance_at_closest_approach_if_avoidance"])
         file.close()
         file = open(f"data/simulation-{export_time}.csv", "a")
         writer = csv.writer(file)
         
         for i in range(0, test_number, 1):
+            print("Test " + str(i) + " - no collision avoidance")
             logging.info("Test %d - no collision avoidance", i)
             aircraft_tuple : List[List[Aircraft], float] = list_of_lists[i]
             aircrafts : List[Aircraft] = aircraft_tuple[0]
             angle : float = aircraft_tuple[1]
             print("Current test pair aircrafts count: ", len(aircrafts))
             simulation_data_no_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = False,
                 aircrafts = aircrafts,
                 test_index = i,
                 aircraft_angle = angle)
+            if not simulation_data_no_avoidance.collision:
+                logging.info("Test %d - no collision avoidance - no collision detected, marking ❌", i)
             self.state = None
 
+            print("Test " + str(i) + " - collision avoidance")
             logging.info("Test %d - collision avoidance", i)
             simulation_data_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = True,
                 aircrafts = aircrafts,
                 test_index = i,
                 aircraft_angle = angle)
+            if not simulation_data_avoidance.collision:
+                logging.info("Test %d - collision avoidance - no collision detected, success ✔️", i)
             self.state = None
 
             writer.writerow([
                 i,
                 angle,
                 simulation_data_no_avoidance.aircraft_1_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.y(),
@@ -578,15 +646,17 @@
                 simulation_data_avoidance.aircraft_1_final_speed.z(),
                 simulation_data_avoidance.aircraft_2_final_speed.x(),
                 simulation_data_avoidance.aircraft_2_final_speed.y(),
                 simulation_data_avoidance.aircraft_2_final_speed.z(),
                 simulation_data_no_avoidance.collision,
                 simulation_data_avoidance.collision,
                 simulation_data_no_avoidance.minimal_relative_distance,
-                simulation_data_avoidance.minimal_relative_distance])
+                simulation_data_avoidance.minimal_relative_distance,
+                simulation_data_no_avoidance.miss_distance_at_closest_approach,
+                simulation_data_avoidance.miss_distance_at_closest_approach])
             file.close()
             file = open(f"data/simulation-{export_time}.csv", "a")
             writer = csv.writer(file)
         file.close()
         real_time : float = start_timestamp.msecsTo(QTime.currentTime()) / 1000
         print("Total time elapsed: " + "{:.2f}".format(real_time) + "s")
         print("Average time per test: " + "{:.2f}".format(real_time / test_number) + "s")
@@ -642,15 +712,15 @@
         self.__aircrafts = []
         try:
             file = open(file_path, "r")
             reader = csv.reader(file)
             for i, row in enumerate(reader):
                 if i == test_id + 1:
                     simulation_data : SimulationData = SimulationData()
-                    assert len(row) == 48
+                    assert len(row) == 50
                     assert row[0] == str(test_id)
                     simulation_data.aircraft_angle = float(row[1])
                     simulation_data.aircraft_1_initial_position = QVector3D(float(row[2]), float(row[3]), float(row[4]))
                     simulation_data.aircraft_2_initial_position = QVector3D(float(row[5]), float(row[6]), float(row[7]))
                     simulation_data.aircraft_1_initial_speed = QVector3D(float(row[8]), float(row[9]), float(row[10]))
                     simulation_data.aircraft_2_initial_speed = QVector3D(float(row[11]), float(row[12]), float(row[13]))
                     simulation_data.aircraft_1_initial_target = QVector3D(float(row[14]), float(row[15]), float(row[16]))
@@ -658,21 +728,29 @@
                     if not avoid_collisions:
                         simulation_data.aircraft_1_final_position = QVector3D(float(row[20]), float(row[21]), float(row[22]))
                         simulation_data.aircraft_2_final_position = QVector3D(float(row[23]), float(row[24]), float(row[25]))
                         simulation_data.aircraft_1_final_speed = QVector3D(float(row[32]), float(row[33]), float(row[34]))
                         simulation_data.aircraft_2_final_speed = QVector3D(float(row[35]), float(row[36]), float(row[37]))
                         simulation_data.collision = row[44] == "True"
                         simulation_data.minimal_relative_distance = float(row[46])
+                        if str(row[48]) == "nan":
+                            simulation_data.miss_distance_at_closest_approach = None
+                        else:
+                            simulation_data.miss_distance_at_closest_approach = float(row[48])
                     else:
                         simulation_data.aircraft_1_final_position = QVector3D(float(row[26]), float(row[27]), float(row[28]))
                         simulation_data.aircraft_2_final_position = QVector3D(float(row[29]), float(row[30]), float(row[31]))
                         simulation_data.aircraft_1_final_speed = QVector3D(float(row[38]), float(row[39]), float(row[40]))
                         simulation_data.aircraft_2_final_speed = QVector3D(float(row[41]), float(row[42]), float(row[43]))
                         simulation_data.collision = row[45] == "True"
                         simulation_data.minimal_relative_distance = float(row[47])
+                        if str(row[49]) == "nan":
+                            simulation_data.miss_distance_at_closest_approach = None
+                        else:
+                            simulation_data.miss_distance_at_closest_approach = float(row[49])
                     self.import_simulation_data(simulation_data)
                     return True
         except:
             logging.error("Failed to load simulation data from file")
             return False
     
     def stop(self) -> None:
@@ -874,23 +952,49 @@
         ]
         logging.info("Simulation data imported successfully")
 
     def check_simulation_data_correctness(self) -> bool | None:
         if not self.__imported_from_data or self.__simulation_data is None or self.aircrafts is None or self.aircrafts == []:
             return None
         logging.info("Checking simulation data correctness...")
+        # [ ] Fix case when loaded data simulated in low frequency and tested in high accuracy
+        position_accuracy : float = 200.0
+        speed_accuracy : float = 5.0
+        displacement_accuracy : float = 5.0
+        simulation_frequency = SimulationSettings.simulation_frequency
+        if simulation_frequency >= 100.0:
+            position_accuracy : float = 0.1
+            speed_accuracy : float = 0.1
+            displacement_accuracy : float = 1.0
+        elif simulation_frequency >= 70.0:
+            position_accuracy : float = 10.0
+            speed_accuracy : float = 0.5
+            displacement_accuracy : float = 5.0
+        elif simulation_frequency >= 50.0:
+            position_accuracy : float = 20.0
+            speed_accuracy : float = 0.6
+            displacement_accuracy : float = 6.0
+        elif simulation_frequency >= 30.0:
+            position_accuracy : float = 25.0
+            speed_accuracy : float = 0.75
+            displacement_accuracy : float = 7.5
+        elif simulation_frequency >= 10.0:
+            position_accuracy : float = 50.0
+            speed_accuracy : float = 1.0
+            displacement_accuracy : float = 10.0
+            
         assert len(self.aircrafts) == 2
-        assert dist(self.aircrafts[0].vehicle.position.toTuple(), self.__simulation_data.aircraft_1_final_position.toTuple()) < 0.1
-        assert dist(self.aircrafts[1].vehicle.position.toTuple(), self.__simulation_data.aircraft_2_final_position.toTuple()) < 0.1
-        assert dist(self.aircrafts[0].vehicle.speed.toTuple(), self.__simulation_data.aircraft_1_final_speed.toTuple()) < 0.1
-        assert dist(self.aircrafts[1].vehicle.speed.toTuple(), self.__simulation_data.aircraft_2_final_speed.toTuple()) < 0.1
-        assert abs(self.aircrafts[0].vehicle.speed.length() - self.__simulation_data.aircraft_1_final_speed.length()) < 0.1
-        assert abs(self.aircrafts[1].vehicle.speed.length() - self.__simulation_data.aircraft_2_final_speed.length()) < 0.1
-        assert abs(self.simulation_adsb.minimal_relative_distance - self.__simulation_data.minimal_relative_distance) < 0.1
-        logging.info("Simulation data correctness checked successfully ✅")
+        assert dist(self.aircrafts[0].vehicle.position.toTuple(), self.__simulation_data.aircraft_1_final_position.toTuple()) < position_accuracy
+        assert dist(self.aircrafts[1].vehicle.position.toTuple(), self.__simulation_data.aircraft_2_final_position.toTuple()) < position_accuracy
+        assert dist(self.aircrafts[0].vehicle.speed.toTuple(), self.__simulation_data.aircraft_1_final_speed.toTuple()) < speed_accuracy
+        assert dist(self.aircrafts[1].vehicle.speed.toTuple(), self.__simulation_data.aircraft_2_final_speed.toTuple()) < speed_accuracy
+        assert abs(self.aircrafts[0].vehicle.speed.length() - self.__simulation_data.aircraft_1_final_speed.length()) < speed_accuracy
+        assert abs(self.aircrafts[1].vehicle.speed.length() - self.__simulation_data.aircraft_2_final_speed.length()) < speed_accuracy
+        assert abs(self.simulation_adsb.minimal_relative_distance - self.__simulation_data.minimal_relative_distance) < displacement_accuracy
+        logging.info("Simulation data correctness checked successfully ✔️")
         return True
 
     def export_visited_locations(self, simulation_data : SimulationData | None = None, test_index : int | None = None) -> None:
         """Exports aircrafts visited location lists"""
         aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
 
         plt.set_loglevel("error")
@@ -913,17 +1017,17 @@
         export_date = datetime.datetime.now().strftime("%Y-%m-%d")
         export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
         try:
             Path("logs/visited").mkdir(parents=True, exist_ok=True)
             Path("path-visual").mkdir(parents=True, exist_ok=True)
             Path(f"path-visual/{export_date}").mkdir(parents=True, exist_ok=True)
             if test_index is not None:
-                Path(f"path-visual/{export_date}/simulation-{self.simulation_id}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                Path(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
             else:
-                Path(f"path-visual/{export_date}/simulation-{self.simulation_id}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                Path(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{self.hash}").mkdir(parents=True, exist_ok=True)
         except:
             logging.error("Failed to create directories for visited logs")
             return
 
         for i, aircraft in enumerate(aircraft_fccs):
             file_name = f"logs/visited/visited-aircraft-{aircraft.aircraft_id}-{export_time}"
             with open(f"{file_name}.csv", "w") as file:
@@ -938,19 +1042,20 @@
                     
             df = pd.read_csv(f"{file_name}.csv")
             plt.scatter(df["x"], df["y"], color=colors[i % len(colors)], s = 2)
             plt.plot(df["x"], df["y"], color=colors[i % len(colors)])
 
         x_range : float = x_maximum - x_minimum
         y_range : float = y_maximum - y_minimum
-        plt.xlim(x_minimum - x_range / 2, x_maximum + x_range / 2)
-        plt.ylim(y_minimum - y_range / 2, y_maximum + y_range / 2)
+        if x_range != 0:
+            plt.xlim(x_minimum - x_range / 2, x_maximum + x_range / 2)
+        if y_range != 0:    
+            plt.ylim(y_minimum - y_range / 2, y_maximum + y_range / 2)
 
         if simulation_data is not None:
-            import matplotlib.patches as mpatches
             aircraft_1_init = [simulation_data.aircraft_1_initial_position.x(), simulation_data.aircraft_1_initial_position.y()]
             aircraft_2_init = [simulation_data.aircraft_2_initial_position.x(), simulation_data.aircraft_2_initial_position.y()]
             plt.text(aircraft_1_init[0] + 0.05 * x_range, aircraft_1_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 1", color = colors[0 % len(colors)], fontsize = 9, ha = "left")
             plt.text(aircraft_2_init[0] + 0.05 * x_range, aircraft_2_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 2", color = colors[1 % len(colors)], fontsize = 9, ha = "left")
             if simulation_data.collision:
                 aircraft_final = [simulation_data.aircraft_1_final_position.x(), simulation_data.aircraft_1_final_position.y()]
                 plt.text(aircraft_final[0] + 0.05 * x_range, aircraft_final[1] - 0.05 * y_range, "Collision", color = "r", fontsize = 9, ha = "left")
@@ -959,17 +1064,17 @@
                 label = "Init angle: " + "{:.3f}".format(simulation_data.aircraft_angle))
             min_relative_dist_patch = mpatches.Patch(
                 color = "none",
                 label = "Min relative dist: " + "{:.3f}".format(simulation_data.minimal_relative_distance))
             plt.legend(handles=[angle_patch, min_relative_dist_patch])
         
         if test_index is not None:
-            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id}-{test_index}-{self.hash}/path-visual-{export_time}.png")
+            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{test_index}-{self.hash}/path-visual-{export_time}.png")
         else:
-            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id}-{self.hash}/path-visual-{export_time}.png")
+            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{self.hash}/path-visual-{export_time}.png")
         plt.close()
     
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
         self.stop()
         event.accept()
         return super().closeEvent(event)
```

## build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -1,10 +1,11 @@
 """Simulation ADS-B system simulation thread module"""
 
 import logging
+import numpy as np
 from typing import List
 from math import sqrt
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QVector3D
 from PySide6.QtWidgets import QMainWindow
 
@@ -20,14 +21,16 @@
         super(SimulationADSB, self).__init__(parent)
         self.__aircrafts = aircrafts
         self.__aircraft_vehicles : List[AircraftVehicle] = [aircraft.vehicle for aircraft in self.aircrafts]
         self.__aircraft_fccs : List[AircraftFCC] = [aircraft.fcc for aircraft in self.aircrafts]
         self.__simulation_state = simulation_state
         self.__adsb_cycles : int = 0
         self.__minimal_relative_distance : float = float("inf")
+        self.__is_silent : bool = True
+        self.__miss_distance_at_closest_approach : float | np.nan = np.nan
         
     @property
     def aircrafts(self) -> List[Aircraft]:
         """Returns aircrafts"""
         return self.__aircrafts
     
     @property
@@ -65,14 +68,34 @@
         else:
             return self.__minimal_relative_distance
     
     @minimal_relative_distance.setter
     def minimal_relative_distance(self, minimal_relative_distance : float) -> None:
         """Sets minimal miss distance"""
         self.__minimal_relative_distance = minimal_relative_distance
+        
+    @property
+    def is_silent(self) -> bool:
+        """Returns silent mode flag"""
+        return self.__is_silent
+    
+    @is_silent.setter
+    def is_silent(self, is_silent : bool) -> None:
+        """Sets silent mode flag"""
+        self.__is_silent = is_silent
+        
+    @property
+    def miss_distance_at_closest_approach(self) -> float:
+        """Returns miss distance at closest approach"""
+        return self.__miss_distance_at_closest_approach
+    
+    @miss_distance_at_closest_approach.setter
+    def miss_distance_at_closest_approach(self, miss_distance_at_closest_approach : float) -> None:
+        """Sets miss distance at closest approach"""
+        self.__miss_distance_at_closest_approach = miss_distance_at_closest_approach
 
     @property
     def relative_distance(self) -> float:
         """Returns relative distance between aircrafts"""
         return (self.aircraft_vehicles[0].position - self.aircraft_vehicles[1].position).length()
 
     def run(self) -> None:
@@ -91,92 +114,104 @@
         if not self.simulation_state.is_paused:
             self.count_adsb_cycles()
             self.simulation_state.update_adsb_settings()
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
-            print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
+            if not self.is_silent:
+                print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
             
             if relative_position.length() < self.__minimal_relative_distance:
                 self.__minimal_relative_distance = relative_position.length()
-            print("Minimal relative distance: " + "{:.2f}".format(self.__minimal_relative_distance) + "m")
+            if not self.is_silent:
+                print("Minimal relative distance: " + "{:.2f}".format(self.__minimal_relative_distance) + "m")
             
             fcc : AircraftFCC | None = None
             for aircraft in self.aircraft_vehicles:
                 try:
                     fcc = self.aircraft_fccs[aircraft.aircraft_id]
                 except IndexError:
                     logging.error("Aircraft flight control computer %d not found", aircraft.aircraft_id)
-                    print(f"Aircraft flight control computer {aircraft.aircraft_id} not found")
+                    if not self.is_silent:
+                        print(f"Aircraft flight control computer {aircraft.aircraft_id} not found")
                     if len(self.aircraft_fccs) == 2:
                         if aircraft.aircraft_id % 2 == 0:
                             fcc = self.aircraft_fccs[0]
                         else:
                             fcc = self.aircraft_fccs[1]
 
                 # path
                 fcc.append_visited()
 
                 # console destination reach time
                 if fcc.destination is not None and self.simulation_state.adsb_report:
                     time_to_reaching_destination : float = (QVector3D.dotProduct(fcc.destination - aircraft.position, aircraft.speed) / QVector3D.dotProduct(aircraft.speed, aircraft.speed))
-                    print(f"Aircraft {aircraft.aircraft_id} will reach its destination in " + "{:.2f}".format(time_to_reaching_destination) + " (" + "{:.1f}".format(time_to_reaching_destination / 60) + " minutes or " + "{:.1f}".format(time_to_reaching_destination / 3600) + " hours)")
-                    print("Collision avoidance: " + str(self.simulation_state.avoid_collisions))
+                    if not self.is_silent:
+                        print(f"Aircraft {aircraft.aircraft_id} will reach its destination in " + "{:.2f}".format(time_to_reaching_destination) + " (" + "{:.1f}".format(time_to_reaching_destination / 60) + " minutes or " + "{:.1f}".format(time_to_reaching_destination / 3600) + " hours)")
+                        print("Collision avoidance: " + str(self.simulation_state.avoid_collisions))
 
                 # console report output
-                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0 and self.simulation_state.is_realtime:
-                    self.print_adsb_report(aircraft)
+                if self.simulation_state.adsb_report and aircraft.aircraft_id == self.__simulation_state.focused_aircraft_id and self.simulation_state.is_realtime:
+                    if not self.is_silent:
+                        self.print_adsb_report(aircraft)
 
                 # safe zone occupancy check
                 if relative_position.length() < self.simulation_state.minimum_separation:
                     if not fcc.safe_zone_occupied:
                         fcc.safe_zone_occupied = True
                         if not self.simulation_state.override_avoid_collisions:
                             self.simulation_state.avoid_collisions = True
-                    print("Safe zone occupied")
+                    if not self.is_silent:
+                        print("Safe zone occupied")
                 else:
                     if fcc.safe_zone_occupied:
                         fcc.safe_zone_occupied = False
                         self.simulation_state.avoid_collisions = False
-                    print("Safe zone free")
+                    if not self.is_silent:
+                        print("Safe zone free")
                     continue
 
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
-                print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
+                if not self.is_silent:
+                    print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m (" + "{:.2f}".format(self.aircraft_vehicles[0].size / 2 + self.aircraft_vehicles[1].size / 2) + "m is collision distance)")
 
                 if miss_distance_vector.length() == 0 and self.simulation_state.avoid_collisions:
-                    print("Head-on collision detected")
                     logging.info("Head-on collision detected")
+                    if not self.is_silent:
+                        print("Head-on collision detected")
 
                 # resolve conflict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
-                    print("Conflict condition detected")
+                    if not self.is_silent:
+                        print("Conflict condition detected")
                     if self.simulation_state.avoid_collisions and relative_position.length() < self.simulation_state.minimum_separation:
                         for aircraft in self.aircraft_fccs:
                             if not aircraft.evade_maneuver:
                                 logging.info("Conflict condition resolution with relative distance: " + "{:.2f}".format(relative_position.length()) + "m")
+                                self.miss_distance_at_closest_approach = miss_distance_vector.length()
                                 aircraft.apply_evade_maneuver(
                                     opponent_speed = self.aircraft_vehicles[1 - aircraft.aircraft_id].speed,
                                     miss_distance_vector = miss_distance_vector,
                                     unresolved_region = unresolved_region,
                                     time_to_closest_approach = time_to_closest_approach)
-                    print("Relative distance: "+ "{:.2f}".format(relative_position.length()) + "m")
+                    if not self.is_silent:
+                        print("Relative distance: "+ "{:.2f}".format(relative_position.length()) + "m")
 
                 # probable collision
                 collision_distance = aircraft_vehicle_1.size / 2 + aircraft_vehicle_2.size / 2
                 collision_region = collision_distance - miss_distance_vector.length()
-                if collision_region > 0:
-                    print("Collision detected")
+                if collision_region > 0 and not self.is_silent:
+                        print("Collision detected")
             else:
                 for aircraft in self.aircraft_fccs:
                     if aircraft.evade_maneuver and not aircraft.safe_zone_occupied:
                         aircraft.reset_evade_maneuver()
 
     def print_adsb_report(self, aircraft : AircraftVehicle) -> None:
         """Prints ADS-B report for the aircraft to the console"""
@@ -241,8 +276,9 @@
             "; horizontal speed: " + "{:.2f}".format(horizontal_speed) +
             "; vertical speed: " + "{:.2f}".format(vertical_speed) +
             "; geometrical speed: " + "{:.2f}".format(geometrical_speed))
 
     def reset_destinations(self) -> None:
         """Resets destination for all aircrafts"""
         for aircraft in self.aircraft_fccs:
+            aircraft.clear_destinations()
             aircraft.load_initial_destination()
```

## build/lib/uav_collision_avoidance/src/simulation/simulation_data.py

```diff
@@ -19,14 +19,15 @@
         self.__aircraft_2_final_speed : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_target : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_target : QVector3D = QVector3D(0, 0, 0)
         self.__aircraft_1_initial_roll_angle : float = 0.0
         self.__aircraft_2_initial_roll_angle : float = 0.0
         self.__collision : bool | None = None
         self.__minimal_relative_distance : float | None = None
+        self.__miss_distance_at_closest_approach : float | None = None
 
     @property
     def aircraft_angle(self) -> float:
         """Returns initial angle between aircrafts"""
         return self.__aircraft_angle
     
     @aircraft_angle.setter
@@ -169,14 +170,24 @@
         """Returns minimal miss distance"""
         return self.__minimal_relative_distance
     
     @minimal_relative_distance.setter
     def minimal_relative_distance(self, distance : float) -> None:
         """Sets minimal miss distance"""
         self.__minimal_relative_distance = distance
+        
+    @property
+    def miss_distance_at_closest_approach(self) -> float | None:
+        """Returns miss distance at closest approach"""
+        return self.__miss_distance_at_closest_approach
+    
+    @miss_distance_at_closest_approach.setter
+    def miss_distance_at_closest_approach(self, distance : float) -> None:
+        """Sets miss distance at closest approach"""
+        self.__miss_distance_at_closest_approach = distance
 
     def reset(self) -> None:
         """Resets simulation data"""
         self.__aircraft_1_initial_position = QVector3D(0, 0, 0)
         self.__aircraft_2_initial_position = QVector3D(0, 0, 0)
         self.__aircraft_1_final_position = QVector3D(0, 0, 0)
         self.__aircraft_2_final_position = QVector3D(0, 0, 0)
```

## build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py

```diff
@@ -4,18 +4,24 @@
 
 class SimulationSettings:
     """Settings for the simulation"""
 
     screen_resolution : QSize | None = None
     resolution : tuple
     g_acceleration : float = 9.81
-    simulation_frequency : float = 100.0
+    simulation_frequency : float = 100.0 # Hz
     simulation_threshold : float = 1000.0 / simulation_frequency
-    gui_render_frequency : float = 100.0
+    gui_render_frequency : float = 100.0 # Hz, fps
     gui_render_threshold : float =  1000.0 / gui_render_frequency
     adsb_threshold : float = 1000.0
 
     @classmethod
     def __init__(cls) -> None:
         """Initializes Settings using screen resolution"""
         if cls.screen_resolution is not None:
             cls.resolution = (int(cls.screen_resolution.width() * 0.6), int(cls.screen_resolution.height() * 0.75))
+
+    @classmethod
+    def set_simulation_frequency(cls, frequency : float) -> None:
+        """Sets the simulation frequency"""
+        cls.simulation_frequency = frequency
+        cls.simulation_threshold = 1000.0 / frequency
```

## build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -27,14 +27,15 @@
         self.__reset_demanded : bool = False
         self.__pause_start_timestamp : QTime | None = None
         self.__time_paused : int = 0 # ms
         self.__adsb_report : bool = True
         self.__collision : bool = False
         self.__first_cause_collision : bool = False
         self.__second_cause_collision : bool = False
+        self.__focused_aircraft_id : int = 0
         self.update_settings()
 
         # render state
         self.__fps : float = 0.0
         if is_realtime:
             override_gui_scale : bool = True
             if not override_gui_scale:
@@ -52,15 +53,14 @@
             self.__draw_grid : bool = False
             self.__draw_path : bool = True
             self.__draw_speed_vectors : bool = True
             self.__draw_safe_zones : bool = True
             self.__draw_collision_detection : bool = True
             self.__optimize_drawing : bool = False
             self.__follow_aircraft : bool = False
-            self.__focus_aircraft_id : int = 0
 
             # assets
             self.__aircraft_pixmap : QPixmap = QPixmap()
             if not self.__aircraft_pixmap.load("assets/aircraft.png"):
                 try:
                     Path("assets").mkdir(parents=True, exist_ok=True)
                     urlretrieve(
@@ -374,23 +374,23 @@
         
     def toggle_follow_aircraft(self) -> None:
         """Toggles aircraft following"""
         with QMutexLocker(self.__mutex):
             self.__follow_aircraft = not self.__follow_aircraft
 
     @property
-    def focus_aircraft_id(self) -> int:
+    def focused_aircraft_id(self) -> int:
         """Returns aircraft id to focus on"""
         with QMutexLocker(self.__mutex):
-            return self.__focus_aircraft_id
+            return self.__focused_aircraft_id
         
     def toggle_focus_aircraft(self) -> None:
         """Toggles aircraft focus"""
         with QMutexLocker(self.__mutex):
-            self.__focus_aircraft_id = int(not self.__focus_aircraft_id)
+            self.__focused_aircraft_id = int(not self.__focused_aircraft_id)
 
     @property
     def gui_render_threshold(self) -> int:
         """Returns GUI render threshold"""
         with QMutexLocker(self.__mutex):
             return self.__gui_render_threshold
```

## build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -362,14 +362,17 @@
                 if self.__aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution is not None:
                     self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach, scale)
                     self.draw_vector(aircraft.position, aircraft.position + aircraft.speed * time_to_closest_approach + self.__aircraft_fccs[aircraft.aircraft_id].vector_sharing_resolution, scale, QColor(30, 255, 30))
         if predicted_collision:
             aircraft = self.__aircraft_vehicles[0]
             collision_location = aircraft.position + aircraft.speed * time_to_closest_approach
             self.draw_circle(collision_location, 2.5 / scale, scale, QColor(255, 0, 0))
+            aircraft = self.__aircraft_vehicles[1]
+            collision_location = aircraft.position + aircraft.speed * time_to_closest_approach
+            self.draw_circle(collision_location, 2.5 / scale, scale, QColor(255, 0, 0))
         relative_distance = dist(self.__aircraft_vehicles[0].position.toTuple(), self.__aircraft_vehicles[1].position.toTuple())
         if relative_distance < self.__simulation_state.minimum_separation:
             if not self.simulation_state.avoid_collisions:
                 self.draw_text(QVector3D(10, self.__window_height - 10, 0), 0, "Press T to avoid collisions", QColor(255, 0, 0))
 
             separation_height : float = 10
             if detected_conflict:
@@ -402,18 +405,19 @@
         if self.__moving_view_left:
             self.__screen_offset_x += 10.0 / scale
         if self.__moving_view_right:
             self.__screen_offset_x -= 10.0 / scale
 
     def update_steering(self) -> None:
         """Updates aircraft steering based on current input"""
-        if self.aircrafts[0] and (self.__steering_up or self.__steering_down or self.__steering_left or self.__steering_right):
+        focused_aircraft_id = self.simulation_state.focused_aircraft_id
+        if self.aircrafts[focused_aircraft_id] and (self.__steering_up or self.__steering_down or self.__steering_left or self.__steering_right):
             if sum([self.__steering_up, self.__steering_down, self.__steering_left, self.__steering_right]) >= 3:
                 return
-            self.__aircraft_fccs[0].ignore_destinations = True
+            self.__aircraft_fccs[focused_aircraft_id].ignore_destinations = True
             target_yaw_angle : float | None = None
             if self.__steering_up and self.__steering_left:
                 target_yaw_angle = -45.0
             elif self.__steering_up and self.__steering_right:
                 target_yaw_angle = 45.0
             elif self.__steering_down and self.__steering_left:
                 target_yaw_angle = -135.0
@@ -424,20 +428,20 @@
             elif self.__steering_down:
                 target_yaw_angle = 180.0
             elif self.__steering_left:
                 target_yaw_angle = -90.0
             elif self.__steering_right:
                 target_yaw_angle = 90.0
             if target_yaw_angle is not None:
-                self.__aircraft_fccs[0].target_yaw_angle = target_yaw_angle
+                self.__aircraft_fccs[focused_aircraft_id].target_yaw_angle = target_yaw_angle
 
     def center_offsets(self) -> None:
-        """Updates screen offsets centering on selected aircraft"""
+        """Updates screen offsets centering on focused aircraft"""
         scale : float = self.__simulation_state.gui_scale
-        id = self.__simulation_state.focus_aircraft_id
+        id = self.__simulation_state.focused_aircraft_id
         self.__screen_offset_x = (self.__window_width / 2.0) / scale - self.__aircraft_vehicles[id].position.x()
         self.__screen_offset_y = (self.__window_height / 2.0) / scale - self.__aircraft_vehicles[id].position.y()
 
     def update_resolutions(self) -> None:
         """Updates bounding box resolution"""
         self.__window_width = self.width()
         self.__window_height = self.height()
@@ -487,14 +491,18 @@
                         (aircraft.position.x() * scale) + self.__screen_offset_x * scale <= self.__window_width and \
                         (aircraft.position.y() * scale) + self.__screen_offset_y * scale <= self.__window_height:
                         anything_to_draw = True
                         break
             if not anything_to_draw:
                 return super().paintEvent(event)
 
+        if self.__simulation_state.focused_aircraft_id == 0:
+            self.draw_text(QVector3D(self.__window_width - 120, self.__window_height - 10, 0), 0, "Selected Aircraft 0", QColor(0, 0, 255))
+        elif self.__simulation_state.focused_aircraft_id == 1:
+            self.draw_text(QVector3D(self.__window_width - 120, self.__window_height - 10, 0), 0, "Selected Aircraft 1", QColor(0, 0, 255))
         if self.__simulation_state.draw_collision_detection:
             self.draw_collision_detection(scale)
         for aircraft in self.__aircraft_vehicles:
             if self.__simulation_state.draw_aircraft:
                 self.draw_aircraft(aircraft, scale)
                 self.draw_destinations(aircraft, scale)
             if self.__simulation_state.draw_speed_vectors:
@@ -511,26 +519,27 @@
         real_x : float = click_x / scale - self.__screen_offset_x
         real_y : float = click_y / scale - self.__screen_offset_y
         print(
             "click: physical coords: x: " + "{:.2f}".format(real_x) +
             "; y: " + "{:.2f}".format(real_y) +
             " | window coords: x: " + "{:.2f}".format(click_x) +
             "; y: " + "{:.2f}".format(click_y))
+        focused_aircraft_id = self.simulation_state.focused_aircraft_id
         if event.button() == Qt.MouseButton.LeftButton:
-            self.__aircraft_fccs[0].add_first_destination(QVector3D(
+            self.__aircraft_fccs[focused_aircraft_id].add_first_destination(QVector3D(
                 real_x,
                 real_y,
                 1000.0))
         elif event.button() == Qt.MouseButton.RightButton:
-            self.__aircraft_fccs[0].add_last_destination(QVector3D(
+            self.__aircraft_fccs[focused_aircraft_id].add_last_destination(QVector3D(
                 real_x,
                 real_y,
                 1000.0))
         elif event.button() == Qt.MouseButton.MiddleButton:
-            self.__aircraft_vehicles[0].position = QVector3D(
+            self.__aircraft_vehicles[focused_aircraft_id].position = QVector3D(
                 real_x,
                 real_y,
                 1000.0)
         return super().mousePressEvent(event)
     
     def mouseReleaseEvent(self, event: QMouseEvent) -> None:
         """Qt method controlling mouse release input"""
@@ -547,14 +556,15 @@
             self.zoom(0.03125)
         else:
             self.zoom(-0.03125)
         return super().wheelEvent(event)
 
     def keyPressEvent(self, event: QKeyEvent) -> None:
         """Qt method controlling keyboard input"""
+        focused_aircraft_id = self.simulation_state.focused_aircraft_id
         if event.key() == Qt.Key.Key_Escape:
             self.close()
         elif event.key() == Qt.Key.Key_Slash:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.__simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
@@ -568,17 +578,17 @@
         elif event.key() == Qt.Key.Key_Plus:
             self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
             self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
             self.__simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
-            self.__aircraft_fccs[0].accelerate(-10.0)
+            self.__aircraft_fccs[focused_aircraft_id].accelerate(-10.0)
         elif event.key() == Qt.Key.Key_F3:
-            self.__aircraft_fccs[0].accelerate(10.0)
+            self.__aircraft_fccs[focused_aircraft_id].accelerate(10.0)
         elif event.key() == Qt.Key.Key_O:
             self.__simulation_state.toggle_first_cause_collision()
         elif event.key() == Qt.Key.Key_P:
             self.__simulation_state.toggle_second_cause_collision()
         elif event.key() == Qt.Key.Key_T:
             self.__simulation_state.toggle_avoid_collisions()
         elif event.key() == Qt.Key.Key_N:
@@ -591,15 +601,15 @@
             self.__moving_view_left = True
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = True
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = True
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = True
-        if self.aircrafts[0]:
+        if self.aircrafts[focused_aircraft_id]:
             if event.key() == Qt.Key.Key_A:
                 self.__steering_left = True
             elif event.key() == Qt.Key.Key_D:
                 self.__steering_right = True
             elif event.key() == Qt.Key.Key_W:
                 self.__steering_up = True
             elif event.key() == Qt.Key.Key_S:
@@ -614,16 +624,17 @@
             self.__moving_view_left = False
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = False
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = False
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = False
-        if self.aircrafts[0]:
-            self.__aircraft_fccs[0].ignore_destinations = False
+        focused_aircraft_id = self.simulation_state.focused_aircraft_id
+        if self.aircrafts[focused_aircraft_id]:
+            self.__aircraft_fccs[focused_aircraft_id].ignore_destinations = False
             if event.key() == Qt.Key.Key_A:
                 self.__steering_left = False
             elif event.key() == Qt.Key.Key_D:
                 self.__steering_right = False
             elif event.key() == Qt.Key.Key_W:
                 self.__steering_up = False
             elif event.key() == Qt.Key.Key_S:
```

## tests/test_headless.py

```diff
@@ -5,15 +5,15 @@
 from . import Simulation, SimulationSettings
 
 def test_headless():
         with pytest.raises(SystemExit) as e:
             main("headless")
         assert e.value.code == 0
 
-test_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+test_path : str = "data/simulation-2024-06-02-17-52-28.csv"
 lowest_frequency_tested : int = 10
 highest_frequency_tested : int = 100
 
 @pytest.fixture
 def tester(request):
     """Creates headless testing object"""
     return TestHeadless(request.param)
```

## uav_collision_avoidance/main.py

```diff
@@ -59,25 +59,25 @@
     logging.info("%s %s", app.applicationName(), app.applicationVersion())
     sim : Simulation | None = None
     if len(args) > 0 or arg is not None:
         if args[0] == "realtime" or args[0] == "default" or args[0] == "gui":
             if len(get_monitors()) == 0:
                 logging.warning("Launching GUI Application without monitors detected")
             sim = Simulation()
-            if len(args) > 1:
+            if len(args) >= 2:
                 file_path : str = args[1]
                 test_id : int = 0
                 avoid_collisions : bool = False
-                if len(args) >= 2:
-                    test_id = int(args[2])
                 if len(args) >= 3:
-                    avoidance : str = str(args[2])
+                    test_id = int(args[2])
+                if len(args) >= 4:
+                    avoidance : str = str(args[3])
                     if avoidance == "true" or avoidance == "True" or avoidance == "t" or avoidance == "T" or avoidance == "yes" or avoidance == "1":
                         avoid_collisions = True
-                if len(args) > 4:
+                if len(args) >= 5:
                     print(f"Invalid arguments: {args}")
                     logging.warning("Invalid arguments: %s", args)
                 sim.load_simulation_data_from_file(file_path = file_path, test_id = test_id, avoid_collisions = avoid_collisions)
                 sim.run_gui(avoid_collisions = avoid_collisions, load_latest_data_file = False)
             else:
                 sim.run()
             sys.exit(app.exec())
@@ -91,15 +91,15 @@
             if len(args) > 1 and int(args[1]) > 0:
                 sim.run_tests(test_number = int(args[1]))
             else:
                 sim.run()
             QApplication.shutdown(app)
             sys.exit(0)
         elif args[0] == "load":
-            file_path : str = "data/simulation-2024-05-28-17-03-42.csv"
+            file_path : str = "data/simulation-2024-06-02-17-52-28.csv"
             test_id : int = 0
             if len(args) > 1:
                 file_path = args[1]
                 if len(args) == 2:
                     test_id = int(args[2])
                 if len(args) > 3:
                     print(f"Invalid arguments: {args}")
@@ -121,27 +121,27 @@
                 process = multiprocessing.Process(target=run_simulation_tests, args=(i,))
                 process.start()
                 processes.append(process)
             for process in processes:
                 process.join()
         elif args[0] == "help" and len(args) > 1:
             if args[1] == "realtime":
-                print("Usage: uav_collision_avoidance realtime")
+                print("Usage: uav_collision_avoidance realtime [file_path] [test_index] [collision_avoidance]")
                 print("Description: Runs the simulation in real-time with GUI")
                 sys.exit(0)
             elif args[1] == "headless":
                 print("Usage: uav_collision_avoidance headless")
                 print("Description: Runs the simulation in headless mode without GUI")
                 sys.exit(0)
             elif args[1] == "tests":
                 print("Usage: uav_collision_avoidance tests [test_number]")
                 print("Description: Runs the simulation multiple times in headless mode without GUI defaulting to 10 times")
                 sys.exit(0)
             elif args[1] == "load":
-                print("Usage: uav_collision_avoidance load [file_path]")
+                print("Usage: uav_collision_avoidance load [file_path] [test_index]")
                 print("Description: Loads a simulation data file and runs the simulation in headless mode without GUI, defaults to example data file")
                 sys.exit(0)
             elif args[1] == "ongoing":
                 print("Usage: uav_collision_avoidance ongoing")
                 print("Description: Runs the simulation tests indefinitely")
                 sys.exit(0)
             elif args[1] == "help":
```

## uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -1,22 +1,23 @@
 """Simulation module"""
 
 import csv
 import logging
 import datetime
+import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 import matplotlib.patches as mpatches
 
 from copy import copy
 from pathlib import Path
 from typing import List, Tuple
 from numpy import random, ndarray
-from math import dist, sin, cos, radians
 from matplotlib.ticker import MaxNLocator
+from math import dist, sin, cos, radians, sqrt
 
 from PySide6.QtCore import QThread, QTime
 from PySide6.QtGui import QCloseEvent, QVector3D
 from PySide6.QtWidgets import QMainWindow
 
 from ..aircraft.aircraft import Aircraft
 from ..aircraft.aircraft_fcc import AircraftFCC
@@ -220,22 +221,22 @@
             self.setup_aircrafts(aircrafts)
         elif self.aircrafts is None or self.aircrafts == []:
             self.setup_debug_aircrafts()
         else:
             assert len(self.aircrafts) > 0
         simulation_data : SimulationData = SimulationData()
         simulation_data.aircraft_angle = aircraft_angle
-        simulation_data.aircraft_1_initial_position = copy(self.aircrafts[0].vehicle.position)
-        simulation_data.aircraft_2_initial_position = copy(self.aircrafts[1].vehicle.position)
-        simulation_data.aircraft_1_initial_speed = copy(self.aircrafts[0].vehicle.speed)
-        simulation_data.aircraft_2_initial_speed = copy(self.aircrafts[1].vehicle.speed)
-        simulation_data.aircraft_1_initial_target = copy(self.aircrafts[0].fcc.destination)
-        simulation_data.aircraft_2_initial_target = copy(self.aircrafts[1].fcc.destination)
-        simulation_data.aircraft_1_initial_roll_angle = copy(self.aircrafts[0].vehicle.roll_angle)
-        simulation_data.aircraft_2_initial_roll_angle = copy(self.aircrafts[1].vehicle.roll_angle)
+        simulation_data.aircraft_1_initial_position = copy(self.aircrafts[0].initial_position)
+        simulation_data.aircraft_2_initial_position = copy(self.aircrafts[1].initial_position)
+        simulation_data.aircraft_1_initial_speed = copy(self.aircrafts[0].initial_speed)
+        simulation_data.aircraft_2_initial_speed = copy(self.aircrafts[1].initial_speed)
+        simulation_data.aircraft_1_initial_target = copy(self.aircrafts[0].initial_target)
+        simulation_data.aircraft_2_initial_target = copy(self.aircrafts[1].initial_target)
+        simulation_data.aircraft_1_initial_roll_angle = copy(self.aircrafts[0].initial_roll_angle)
+        simulation_data.aircraft_2_initial_roll_angle = copy(self.aircrafts[1].initial_roll_angle)
         simulation_data.collision = False
 
         self.state = SimulationState(SimulationSettings(), is_realtime = False, avoid_collisions = avoid_collisions)
         self.simulation_physics = SimulationPhysics(self, self.aircrafts, self.state)
         self.simulation_adsb = SimulationADSB(self, self.aircrafts, self.state)
         self.simulation_adsb.reset_destinations()
         time_step : int = int(self.state.simulation_threshold)
@@ -290,37 +291,56 @@
         test_random_collision_course_differences.sort(reverse = False)
         logging.info("Randomly generated angles: %s", test_random_collision_course_differences)
 
         # equal speeds, equal distances to cover, both climbing or both descending
         for angle in test_random_collision_course_differences:
             aircraft_init_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
             aircraft_target_height : float = random.uniform(test_minimal_altitude, test_maximal_altitude)
-            test_collision_target_projected : QVector3D = QVector3D(0, 0, aircraft_init_height)
             aircraft_absolute_speed : float = random.uniform(test_minimal_speed, test_maximal_speed)
-            sin_value : float = sin(radians(angle))
-            cos_value : float = cos(radians(angle))
+            
+            if angle < 90.0:
+                sin_value : float = sin(radians(angle))
+                cos_value : float = cos(radians(angle))
+            elif angle > 90.0:
+                sin_value = sin(radians(180 - angle))
+                cos_value = cos(radians(180 - angle))
+            
+            if sin_value == 0.0:
+                continue
             if abs(sin_value) < test_minimal_trigonometric_value:
                 continue
             if abs(cos_value) < test_minimal_trigonometric_value:
                 continue
-            distance_to_collision : float = test_start_aircrafts_relative_distance / sin_value # projected onto 2d plane
+            
+            distance_to_collision : float = 0.0
+            if 90 - angle > 0.001: # acute angled triangle
+                distance_to_collision = sqrt((test_start_aircrafts_relative_distance ** 2) / (2 * (1 - cos_value))) / 1.0
+                logging.info("Distance to collision: %f", distance_to_collision)
+            elif abs(90 - angle) < 0.001: # right angled triangle
+                distance_to_collision = test_start_aircrafts_relative_distance / sqrt(2)
+                logging.info("Distance to collision: %f, right angle", distance_to_collision)
+            elif 90 - angle < -0.001: # obtuse angled triangle
+                distance_to_collision = sqrt((test_start_aircrafts_relative_distance ** 2) / (2 * (1 + cos_value))) / 1.0
+                logging.info("Distance to collision: %f", distance_to_collision)
+            else:
+                logging.error("Invalid angle value: %f", angle)
+                continue
 
             aircraft_1_position : QVector3D = QVector3D(
                 0,
                 -distance_to_collision,
                 aircraft_init_height)
             aircraft_1_target : QVector3D = QVector3D(
                 0,
                 100 * distance_to_collision,
                 aircraft_target_height)
             aircraft_1_speed : QVector3D = QVector3D(
                 0,
                 aircraft_absolute_speed,
                 0)
-            assert abs(dist(aircraft_1_position.toTuple(), test_collision_target_projected.toTuple()) - distance_to_collision) < 0.1
             assert abs(aircraft_1_speed.length() - aircraft_absolute_speed) < 0.1
             
             # rotate angle to get circle equation
             sin_value = sin(radians(90 - angle))
             cos_value = cos(radians(90 - angle))
             aircraft_2_position : QVector3D = QVector3D(
                 distance_to_collision * cos_value,
@@ -331,17 +351,23 @@
                 100 * distance_to_collision * sin_value,
                 aircraft_1_target.z())
             aircraft_2_speed : QVector3D = QVector3D(
                 -aircraft_absolute_speed * cos_value,
                 aircraft_absolute_speed * sin_value,
                 aircraft_1_speed.z())
 
-            assert abs(dist(aircraft_2_position.toTuple(), test_collision_target_projected.toTuple()) - distance_to_collision) < 0.1
             assert abs(aircraft_2_speed.length() - aircraft_absolute_speed) < 0.1
 
+            calculated_relative_distance_projected : float = dist(aircraft_1_position.toTuple(), aircraft_2_position.toTuple())
+            calculated_relative_distance : float = aircraft_1_position.distanceToPoint(aircraft_2_position)
+            logging.info("Relative distance between aircrafts: %fm (3D %fm) with angle: %f", calculated_relative_distance_projected, calculated_relative_distance, angle)
+            assert abs(aircraft_1_position.distanceToPoint(aircraft_2_position) - test_start_aircrafts_relative_distance) < test_start_aircrafts_relative_distance / 2 # for 10 km, actual 15 km is accepted
+            if abs(90 - angle) < 0.001:
+                assert abs(distance_to_collision - test_start_aircrafts_relative_distance / sqrt(2)) < 0.1
+            
             aircrafts : List[Aircraft] = [
                 Aircraft(
                     aircraft_id = 0,
                     position = aircraft_1_position,
                     speed = aircraft_1_speed,
                     initial_target = aircraft_1_target),
                 Aircraft(
@@ -422,57 +448,57 @@
 
         # collision testing
         aircrafts = [ # chase test
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -20_000, 1000),
                 speed = QVector3D(0, 100, 0),
-                initial_target = QVector3D(test_average_aircraft_size / 4.0, 2_000_000 + test_average_aircraft_size / 4.0, 1000)),
+                initial_target = QVector3D(test_average_aircraft_size * 3, 2_000_000 + test_average_aircraft_size * 3, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, -10_000, 1000),
                 speed = QVector3D(0, 50, 0),
-                initial_target = QVector3D(-test_average_aircraft_size / 4.0, 2_000_000 - test_average_aircraft_size / 4.0, 1000))
+                initial_target = QVector3D(-test_average_aircraft_size * 3, 2_000_000 - test_average_aircraft_size * 3, 1000))
         ]
         list_of_lists.append([aircrafts, 0.001])
         aircrafts = [ # full angle collision, equal speeds
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
-                initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
+                initial_target = QVector3D(test_average_aircraft_size * 3, 500_000 + test_average_aircraft_size * 3, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 5000, 1000),
                 speed = QVector3D(0, -50, 0),
-                initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
+                initial_target = QVector3D(-test_average_aircraft_size * 3, -500_000 - test_average_aircraft_size * 3, 1000))
         ]
         list_of_lists.append([aircrafts, 180.001])
         aircrafts = [ # full angle collision
             Aircraft(
                 aircraft_id = 0,
                 position = QVector3D(0, -5000, 1000),
                 speed = QVector3D(0, 50, 0),
-                initial_target = QVector3D(test_average_aircraft_size / 4.0, 500_000 + test_average_aircraft_size / 4.0, 1000)),
+                initial_target = QVector3D(test_average_aircraft_size * 3, 500_000 + test_average_aircraft_size * 3, 1000)),
             Aircraft(
                 aircraft_id = 1,
                 position = QVector3D(0, 10000, 1000),
                 speed = QVector3D(0, -100, 0),
-                initial_target = QVector3D(-test_average_aircraft_size / 4.0, -500_000 - test_average_aircraft_size / 4.0, 1000))
+                initial_target = QVector3D(-test_average_aircraft_size * 3, -500_000 - test_average_aircraft_size * 3, 1000))
         ]
         list_of_lists.append([aircrafts, 180.001])
         return list_of_lists
     
     def run_tests(self, begin_with_default_set : bool = True, test_number : int = 20) -> None:
         """Runs simulation tests"""
         SimulationSettings.set_simulation_frequency(10.0)
         if test_number < 3:
             logging.info("Changing simulation tests to 3 test cases due to too low test number")
             test_number = 3
-        elif test_number > 100:
+        elif test_number > 200:
             logging.info("Changing simulation tests to 100 test cases due to too high test number")
             test_number = 100
         logging.info("Running simulation tests")
         list_of_const_lists : List[Tuple[List[Aircraft], float]] | None = None
         list_of_lists : List[Tuple[List[Aircraft], float]] | None = None
         if begin_with_default_set:
             list_of_const_lists = self.generate_consistent_list_of_aircraft_lists()
@@ -575,36 +601,56 @@
         file = open(f"data/simulation-{export_time}.csv", "a")
         writer = csv.writer(file)
         
         for i in range(0, test_number, 1):
             print("Test " + str(i) + " - no collision avoidance")
             logging.info("Test %d - no collision avoidance", i)
             aircraft_tuple : List[List[Aircraft], float] = list_of_lists[i]
-            aircrafts : List[Aircraft] = aircraft_tuple[0]
+            aircrafts : List[Aircraft] = copy(aircraft_tuple[0])
             angle : float = aircraft_tuple[1]
             print("Current test pair aircrafts count: ", len(aircrafts))
             simulation_data_no_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = False,
                 aircrafts = aircrafts,
                 test_index = i,
                 aircraft_angle = angle)
             if not simulation_data_no_avoidance.collision:
                 logging.info("Test %d - no collision avoidance - no collision detected, marking ❌", i)
             self.state = None
 
             print("Test " + str(i) + " - collision avoidance")
             logging.info("Test %d - collision avoidance", i)
+            aircrafts = copy(aircraft_tuple[0])
             simulation_data_avoidance : SimulationData = self.run_headless(
                 avoid_collisions = True,
                 aircrafts = aircrafts,
                 test_index = i,
                 aircraft_angle = angle)
             if not simulation_data_avoidance.collision:
                 logging.info("Test %d - collision avoidance - no collision detected, success ✔️", i)
             self.state = None
+            
+            assert simulation_data_no_avoidance.aircraft_1_initial_position.x() == simulation_data_avoidance.aircraft_1_initial_position.x()
+            assert simulation_data_no_avoidance.aircraft_1_initial_position.y() == simulation_data_avoidance.aircraft_1_initial_position.y()
+            assert simulation_data_no_avoidance.aircraft_1_initial_position.z() == simulation_data_avoidance.aircraft_1_initial_position.z()
+            assert simulation_data_no_avoidance.aircraft_2_initial_position.x() == simulation_data_avoidance.aircraft_2_initial_position.x()
+            assert simulation_data_no_avoidance.aircraft_2_initial_position.y() == simulation_data_avoidance.aircraft_2_initial_position.y()
+            assert simulation_data_no_avoidance.aircraft_2_initial_position.z() == simulation_data_avoidance.aircraft_2_initial_position.z()
+            assert simulation_data_no_avoidance.aircraft_1_initial_speed.x() == simulation_data_avoidance.aircraft_1_initial_speed.x()
+            assert simulation_data_no_avoidance.aircraft_1_initial_speed.y() == simulation_data_avoidance.aircraft_1_initial_speed.y()
+            assert simulation_data_no_avoidance.aircraft_1_initial_speed.z() == simulation_data_avoidance.aircraft_1_initial_speed.z()
+            assert simulation_data_no_avoidance.aircraft_2_initial_speed.x() == simulation_data_avoidance.aircraft_2_initial_speed.x()
+            assert simulation_data_no_avoidance.aircraft_2_initial_speed.y() == simulation_data_avoidance.aircraft_2_initial_speed.y()
+            assert simulation_data_no_avoidance.aircraft_2_initial_speed.z() == simulation_data_avoidance.aircraft_2_initial_speed.z()
+            assert simulation_data_no_avoidance.aircraft_1_initial_target.x() == simulation_data_avoidance.aircraft_1_initial_target.x()
+            assert simulation_data_no_avoidance.aircraft_1_initial_target.y() == simulation_data_avoidance.aircraft_1_initial_target.y()
+            assert simulation_data_no_avoidance.aircraft_1_initial_target.z() == simulation_data_avoidance.aircraft_1_initial_target.z()
+            assert simulation_data_no_avoidance.aircraft_2_initial_target.x() == simulation_data_avoidance.aircraft_2_initial_target.x()
+            assert simulation_data_no_avoidance.aircraft_2_initial_target.y() == simulation_data_avoidance.aircraft_2_initial_target.y()
+            assert simulation_data_no_avoidance.aircraft_2_initial_target.z() == simulation_data_avoidance.aircraft_2_initial_target.z()
 
             writer.writerow([
                 i,
                 angle,
                 simulation_data_no_avoidance.aircraft_1_initial_position.x(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.y(),
                 simulation_data_no_avoidance.aircraft_1_initial_position.z(),
@@ -814,15 +860,15 @@
     def remove_aircraft(self, aircraft : Aircraft) -> None:
         """Removes aircraft from simulation"""
         if self.aircrafts is not None:
             self.aircrafts.remove(aircraft)
 
     def setup_aircrafts(self, aircrafts : List[Aircraft]) -> None:
         """Sets up aircrafts list"""
-        del self.__aircrafts
+        self.__aircrafts = None
         self.__aircrafts = aircrafts
 
     def setup_debug_aircrafts(self, test_case : int = 0) -> None:
         """Sets up debug aircrafts list"""
         if test_case == 0:
             aircrafts : List[Aircraft] = [
                 Aircraft( # detection test
@@ -1012,22 +1058,24 @@
         x_maximum : float = float("-inf")
         y_minimum : float = float("inf")
         y_maximum : float = float("-inf")
         colors = ["b", "g", "r", "c", "m", "y", "k"]
 
         export_date = datetime.datetime.now().strftime("%Y-%m-%d")
         export_time = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
+        simulation_path : str = ""
         try:
             Path("logs/visited").mkdir(parents=True, exist_ok=True)
             Path("path-visual").mkdir(parents=True, exist_ok=True)
             Path(f"path-visual/{export_date}").mkdir(parents=True, exist_ok=True)
             if test_index is not None:
-                Path(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{test_index}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                simulation_path = f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{test_index:02d}-{self.hash}"
             else:
-                Path(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{self.hash}").mkdir(parents=True, exist_ok=True)
+                simulation_path = f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{self.hash}"
+            Path(simulation_path).mkdir(parents=True, exist_ok=True)
         except:
             logging.error("Failed to create directories for visited logs")
             return
 
         for i, aircraft in enumerate(aircraft_fccs):
             file_name = f"logs/visited/visited-aircraft-{aircraft.aircraft_id}-{export_time}"
             with open(f"{file_name}.csv", "w") as file:
@@ -1037,44 +1085,53 @@
                     x_minimum = min(x_minimum, position.x())
                     x_maximum = max(x_maximum, position.x())
                     y_minimum = min(y_minimum, position.y())
                     y_maximum = max(y_maximum, position.y())
                     writer.writerow([("{:.2f}".format(position.x())),("{:.2f}".format(position.y())),("{:.2f}".format(position.z()))])
                     
             df = pd.read_csv(f"{file_name}.csv")
-            plt.scatter(df["x"], df["y"], color=colors[i % len(colors)], s = 2)
-            plt.plot(df["x"], df["y"], color=colors[i % len(colors)])
-
-        x_range : float = x_maximum - x_minimum
-        y_range : float = y_maximum - y_minimum
-        if x_range != 0:
-            plt.xlim(x_minimum - x_range / 2, x_maximum + x_range / 2)
-        if y_range != 0:    
-            plt.ylim(y_minimum - y_range / 2, y_maximum + y_range / 2)
+            x_points = np.array(df["x"])
+            y_points = np.array(df["y"])
+            plt.scatter(x_points, y_points, color=colors[i % len(colors)], s = 2)
+            plt.plot(x_points, y_points, color=colors[i % len(colors)])
+
+        x_range : float = abs(x_maximum - x_minimum)
+        y_range : float = abs(y_maximum - y_minimum)
+        y_range_min = y_minimum - y_range * 0.4
+        y_range_max = y_maximum + y_range * 0.4
+        y_range_abs = abs(y_range_max - y_range_min)
+        if y_range_min != y_range_max:
+            plt.ylim(y_range_min - y_range_abs / 2, y_range_max + y_range_abs / 2)
 
         if simulation_data is not None:
             aircraft_1_init = [simulation_data.aircraft_1_initial_position.x(), simulation_data.aircraft_1_initial_position.y()]
             aircraft_2_init = [simulation_data.aircraft_2_initial_position.x(), simulation_data.aircraft_2_initial_position.y()]
-            plt.text(aircraft_1_init[0] + 0.05 * x_range, aircraft_1_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 1", color = colors[0 % len(colors)], fontsize = 9, ha = "left")
-            plt.text(aircraft_2_init[0] + 0.05 * x_range, aircraft_2_init[1] - 0.05 * y_range, "Initial position\nof Aircraft 2", color = colors[1 % len(colors)], fontsize = 9, ha = "left")
+            plt.annotate("Initial position\nof Aircraft 1", color = colors[0 % len(colors)], xy=(aircraft_1_init[0], aircraft_1_init[1]), xytext=(aircraft_1_init[0] + 0.25 * x_range, aircraft_1_init[1] + 0.05 * y_range), arrowprops=dict(facecolor="black", arrowstyle="->"))
+            plt.annotate("Initial position\nof Aircraft 2", color = colors[1 % len(colors)], xy=(aircraft_2_init[0], aircraft_2_init[1]), xytext=(aircraft_2_init[0] + 0.25 * x_range, aircraft_2_init[1] + 0.05 * y_range), arrowprops=dict(facecolor="black", arrowstyle="->"))
             if simulation_data.collision:
                 aircraft_final = [simulation_data.aircraft_1_final_position.x(), simulation_data.aircraft_1_final_position.y()]
-                plt.text(aircraft_final[0] + 0.05 * x_range, aircraft_final[1] - 0.05 * y_range, "Collision", color = "r", fontsize = 9, ha = "left")
+                plt.annotate("Collision", color="red", xy=(aircraft_final[0], aircraft_final[1]), xytext=(aircraft_final[0] + 0.25 * x_range, aircraft_final[1] + 0.05 * y_range), arrowprops=dict(facecolor="red", arrowstyle="->"))
+                plt.scatter(aircraft_final[0], aircraft_final[1], color="red", s=10)
             angle_patch = mpatches.Patch(
                 color = "none",
                 label = "Init angle: " + "{:.3f}".format(simulation_data.aircraft_angle))
             min_relative_dist_patch = mpatches.Patch(
                 color = "none",
                 label = "Min relative dist: " + "{:.3f}".format(simulation_data.minimal_relative_distance))
             plt.legend(handles=[angle_patch, min_relative_dist_patch])
         
-        if test_index is not None:
-            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{test_index}-{self.hash}/path-visual-{export_time}.png")
-        else:
-            plt.savefig(f"path-visual/{export_date}/simulation-{self.simulation_id:02d}-{self.hash}/path-visual-{export_time}.png")
+        y_ticks = plt.gca().get_yticks()
+        plt.gca().set_xticks(y_ticks)
+        plt.xticks(fontsize=7)
+        plt.yticks(fontsize=7)
+        plt.gca().set_aspect("equal", adjustable="box")
+        plt.savefig(f"{simulation_path}/path-visual-{export_time}.png")
         plt.close()
+        
+        with open(f"{simulation_path}/README.md", "a+") as readme_file:
+            readme_file.write(f"![](path-visual-{export_time}.png)\n")
     
     def closeEvent(self, event: QCloseEvent) -> None:
         """Qt method performed on the main window close event"""
         self.stop()
         event.accept()
         return super().closeEvent(event)
```

## Comparing `uav_collision_avoidance-0.8.6.dist-info/METADATA` & `uav_collision_avoidance-0.8.9.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: uav-collision-avoidance
-Version: 0.8.6
+Version: 0.8.9
 Summary: UAV collision avoidance simulation
 Author-email: mldxo <miloszmaculewicz@gmail.com>
 Project-URL: Homepage, https://github.com/mldxo/uav-collision-avoidance
 Project-URL: Issues, https://github.com/mldxo/uav-collision-avoidance/issues
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
@@ -34,15 +34,15 @@
 [![PyPI version](https://badge.fury.io/py/uav-collision-avoidance.svg)](https://badge.fury.io/py/uav-collision-avoidance)
 
 [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/mldxo/uav-collision-avoidance)
 
 Python project regarding implementation of two UAVs simulation with collision avoidance system based on geometrical approach.
 
 - [Github](https://github.com/mldxo/uav-collision-avoidance)
-- [PyPi](https://pypi.org/project/uav-collision-avoidance)
+- [PyPI](https://pypi.org/project/uav-collision-avoidance)
 
 ## Research work
 
 ### Introduction
 
 `UAV Collision Avoidance` is my Bachelor's thesis project meeting problem of UAVs safe cooperation in the 3D space. Project implements functional physics calculations, scalable GUI, realistic ADS-B probable collision avoidance systems and on-board flight planning. Application offers multithreaded realtime simulation presenting simulated aircrafts as well as linearly pre-rendered simulation allowing for quick algorithm effectiveness testing.
 
@@ -70,29 +70,29 @@
 
 Proposed test cases generation and evaluation system is simple and effective. It allows for quick testing of the system's effectiveness in various scenarios. The system can be further developed to include more complex scenarios and additional parameters.
 
 ## Python Project
 
 ### Technologies
 
-Python3[^1] project is wrapped as a PyPi package[^2]. PySide6[^3] (Qt's Python Qt6 library) was used for GUI implementation.
+Python3[^1] project is wrapped as a PyPI package[^2]. PySide6[^3] (Qt's Python Qt6 library) was used for GUI implementation.
 
 ### Structures
 
 Application is built based on two main object types, simulation and aircraft. Simulation is created up to initial settings, allowing for concurrent realtime variant and linear pre-rendering. Aircraft consists of two elements, physical representation of the UAV and Flight Control Computer, which is controlled by the ADS-B thread. Research among the UAV systems was drawn on from second cited paper[^5].
 
 ### App arguments
 
 There are eight possible arguments at the moment:
 - default (no arguments) - runs GUI simulation; avoiding collision can be achieved by pressing T, when aircrafts have their safe zones occupied
-- realtime [file_name] [test_index] [collision_avoidance] - runs GUI simulation; file name can be specified and defaults to latest simulation data found; test index can be specified and defaults to 0; collision avoidance can be specified and defaults to off
+- realtime [file_path] [test_index] [collision_avoidance] - runs GUI simulation; file name can be specified and defaults to latest simulation data found; test index can be specified and defaults to 0; collision avoidance can be specified and defaults to off
 - headless - runs physical simulation with ADS-B and collision avoidance algorithm
 - tests [test_number] - runs full tests comparing effectiveness of collision avoidance algorithm, test number defaults to 15
 - ongoing - runs default test number in parallel comparing effectiveness of collision avoidance algorithm continuously till Ctrl+C
-- load [file_name] [test_index] - loads and conducts headless simulation from file when specified, otherwise loads default example test case from data directory [data](/data); test index can be specified and defaults to 0
+- load [file_path] [test_index] - loads and conducts headless simulation from file when specified, otherwise loads default example test case from data directory [data](/data); test index can be specified and defaults to 0
 - help [argument] - prints help message for the app argument; defaults to all arguments list
 - version - prints version of the app
 
 ### Key shortcuts
 
 Realtime version of the app has several key shortcuts allowing user interaction with the environment.
 
@@ -216,25 +216,26 @@
 - [ ] Rendering: Aircraft centered view optimization
 - [x] Wiki: Documentation
 
 ## Authors
 
 [Miłosz Maculewicz](https://github.com/mldxo)
 
-`© 2024 Miłosz Maculewicz. All rights reserved.`
+## License
+Check [LICENSE](/LICENSE)
 
 ## References
 
 <p align="left">
     <img width="30px" alt="Aircraft icon" style="padding-right:10px;" src="/assets/aircraft.png" />
 </p>
 
 Drone by Anthony Lui from <a href="https://thenounproject.com/browse/icons/term/drone/" target="_blank" title="Drone Icons">Noun Project</a> (CC BY 3.0)
 
 All used references are listed below.
 
 [^1]: [Python3](https://www.python.org/)
-[^2]: [PyPi](https://pypi.org/)
+[^2]: [PyPI](https://pypi.org/)
 [^3]: [PyQt6](https://doc.qt.io/qtforpython-6/)
 [^4]: [UAV Collision Avoidance Based on Geometric Approach](https://ieeexplore.ieee.org/document/4655013/)
 [^5]: [Energy Efficient UAV Flight Control Method in an Environment with Obstacles and Gusts of Wind](https://www.mdpi.com/1638452/)
 [^6]: [Aircraft principal axes](https://en.wikipedia.org/wiki/Aircraft_principal_axes)
```

## Comparing `uav_collision_avoidance-0.8.6.dist-info/RECORD` & `uav_collision_avoidance-0.8.9.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,303 +1,322 @@
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7y-WaszHOstlbNzr3cAqYNZK4F94-lZqwtFX2M3pRQ8,9540
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=GakasXPXcBn-VBRsF2DxUGB_bQF4ngxRAa2KOdsj7kY,8671
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xF-IM-ljjJyc2GWSuiwVVcGzlzirrPhEAv3y8qAWobU,6057
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=6yf0nb_AfOsEmyaea5ywDy2q0N1tgfY_fimis4HG3YY,7112
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=lFwovBDK4mmX3Y6B34v--dv-2975e1va6aAtFQ70Ie4,6110
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=XaPV0vLLQ0PrP1_r9dmJ8BlEkfaQ9dHJROGTjqv4t2Q,23164
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7y-WaszHOstlbNzr3cAqYNZK4F94-lZqwtFX2M3pRQ8,9540
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=GakasXPXcBn-VBRsF2DxUGB_bQF4ngxRAa2KOdsj7kY,8671
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xF-IM-ljjJyc2GWSuiwVVcGzlzirrPhEAv3y8qAWobU,6057
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=6yf0nb_AfOsEmyaea5ywDy2q0N1tgfY_fimis4HG3YY,7112
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=lFwovBDK4mmX3Y6B34v--dv-2975e1va6aAtFQ70Ie4,6110
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=XaPV0vLLQ0PrP1_r9dmJ8BlEkfaQ9dHJROGTjqv4t2Q,23164
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=tTvb9t_vO-ZwMivy5p1M66zx70oEigyd0sVsZQlgeu8,13017
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=PWU65G5kARp5A3saSLI01ieAe2JWgnY0ObmHTrfcF-Y,9630
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xsWQk4Z8GJWhvFC9LIoTznzYBHR88MwsJH50l96mbyE,7072
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=EkTPWUgSrPVfz19RQJAaT09kqYyrkES8P15xLEayVwQ,25822
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=tTvb9t_vO-ZwMivy5p1M66zx70oEigyd0sVsZQlgeu8,13017
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=2SYsOuJQZRFbtfLe5-tIQUVcQahHFozmIfUAtK3atPY,14940
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=PWU65G5kARp5A3saSLI01ieAe2JWgnY0ObmHTrfcF-Y,9630
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xsWQk4Z8GJWhvFC9LIoTznzYBHR88MwsJH50l96mbyE,7072
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=z1PxcQhD6echdvaDRu9O_gLhCvu7bb2ixqBbesHGrkA,9632
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=t_5cGYVMpNkdY4751jeggRKQ_E5yqoRl8y_IBcz2BEw,8427
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=9sfCvqk7_KZPSC7VIzeDEURiHJDA2b9dUefJRTx5rkU,8170
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=EkTPWUgSrPVfz19RQJAaT09kqYyrkES8P15xLEayVwQ,25822
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TI-8V3DznKtmewZWuHKGYIzzZmAolaj89bPGdO1VyIg,6343
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=BcH_2wSJsC_6ind9wDG7OGbciKPiQirR4WxPVdSUWsk,26085
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=2SYsOuJQZRFbtfLe5-tIQUVcQahHFozmIfUAtK3atPY,14940
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=Fkt_i2AGZcmsiitGbLyRqwLhbID-5eR8BdaOC6GgEVQ,15437
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=z1PxcQhD6echdvaDRu9O_gLhCvu7bb2ixqBbesHGrkA,9632
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=t_5cGYVMpNkdY4751jeggRKQ_E5yqoRl8y_IBcz2BEw,8427
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=9sfCvqk7_KZPSC7VIzeDEURiHJDA2b9dUefJRTx5rkU,8170
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=I88UTBnPqwmrZ8aZ-uUftF-28_7P14Dff8IjoiepR_A,8359
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TI-8V3DznKtmewZWuHKGYIzzZmAolaj89bPGdO1VyIg,6343
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=BcH_2wSJsC_6ind9wDG7OGbciKPiQirR4WxPVdSUWsk,26085
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=Fkt_i2AGZcmsiitGbLyRqwLhbID-5eR8BdaOC6GgEVQ,15437
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=z1PxcQhD6echdvaDRu9O_gLhCvu7bb2ixqBbesHGrkA,9632
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=t_5cGYVMpNkdY4751jeggRKQ_E5yqoRl8y_IBcz2BEw,8427
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=I88UTBnPqwmrZ8aZ-uUftF-28_7P14Dff8IjoiepR_A,8359
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TI-8V3DznKtmewZWuHKGYIzzZmAolaj89bPGdO1VyIg,6343
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=BcH_2wSJsC_6ind9wDG7OGbciKPiQirR4WxPVdSUWsk,26085
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=Fkt_i2AGZcmsiitGbLyRqwLhbID-5eR8BdaOC6GgEVQ,15437
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=z1PxcQhD6echdvaDRu9O_gLhCvu7bb2ixqBbesHGrkA,9632
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=t_5cGYVMpNkdY4751jeggRKQ_E5yqoRl8y_IBcz2BEw,8427
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=I88UTBnPqwmrZ8aZ-uUftF-28_7P14Dff8IjoiepR_A,8359
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=23SeHrgKtbezoqGvhVIE_AZbbjrIVj4vHnZOHwshkLc,2581
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=-6-156IixgXQuNUVwRlw24lW-XtVZ8fsVpaUff2gZhQ,21654
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=C_VfEV9bem5Sc5WBkzbOKE5KhCdg_iK-UDZLQEevTb4,7090
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=y6wPXiJ0E5Tc4iSDNdK9Kx3hl_M1doVSeg_xcy1UI4M,11968
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Mmb1oUnLIIuEW-7VlQtxBp7jk_fn_G4eY_3ExSXoUbE,11341
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=sPUa2yy65WO4d77DRqdhbkXJLELF0V9hrKIa707d4C0,9854
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TI-8V3DznKtmewZWuHKGYIzzZmAolaj89bPGdO1VyIg,6343
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=BcH_2wSJsC_6ind9wDG7OGbciKPiQirR4WxPVdSUWsk,26085
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TBbtPf_11O24uy3X4ESEqNh2AwGWPjF9bVMuYFxfUKg,16393
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=mupJrVx0_6OFlPLFOIhTg46sJIuKOY7cnUj1JYQkrGQ,29872
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=23SeHrgKtbezoqGvhVIE_AZbbjrIVj4vHnZOHwshkLc,2581
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=-6-156IixgXQuNUVwRlw24lW-XtVZ8fsVpaUff2gZhQ,21654
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7gypYtcsGCr8Yn8c5pugXZQz_u1nN7fqQHcjICC-sxU,21656
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=C_VfEV9bem5Sc5WBkzbOKE5KhCdg_iK-UDZLQEevTb4,7090
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=y6wPXiJ0E5Tc4iSDNdK9Kx3hl_M1doVSeg_xcy1UI4M,11968
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Mmb1oUnLIIuEW-7VlQtxBp7jk_fn_G4eY_3ExSXoUbE,11341
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=MfWd7yc3yiw7hAsUKTRrHw0VAOriP5RoS9tS8MDa16Q,16524
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=WSkneIdQpHUwG5mfiU7nGzL88Oc0MA7Kliq6aA5G43E,12039
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=lSiq1Qnn5AoInXg7iZyn2BgOKrBvOQUCWRXUE2ZfpJ8,4188
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=sPUa2yy65WO4d77DRqdhbkXJLELF0V9hrKIa707d4C0,9854
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=iY7C_vJN3S1T_PPZvdxodqp0UtxJjmxbGvfMP5n3PoM,10905
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TBbtPf_11O24uy3X4ESEqNh2AwGWPjF9bVMuYFxfUKg,16393
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=mupJrVx0_6OFlPLFOIhTg46sJIuKOY7cnUj1JYQkrGQ,29872
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=23SeHrgKtbezoqGvhVIE_AZbbjrIVj4vHnZOHwshkLc,2581
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7gypYtcsGCr8Yn8c5pugXZQz_u1nN7fqQHcjICC-sxU,21656
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=BbgBaGtCX9mrfYo338jbP-f0BQsiCnTqA_Lb_qzWzSc,2129
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=C_VfEV9bem5Sc5WBkzbOKE5KhCdg_iK-UDZLQEevTb4,7090
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=MfWd7yc3yiw7hAsUKTRrHw0VAOriP5RoS9tS8MDa16Q,16524
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=WSkneIdQpHUwG5mfiU7nGzL88Oc0MA7Kliq6aA5G43E,12039
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=lSiq1Qnn5AoInXg7iZyn2BgOKrBvOQUCWRXUE2ZfpJ8,4188
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=74j3U5flnOF7aF3bPuQFW6gDGg_NPdjcTENMySIrW78,46337
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=qJiUcOj2xrwpUuEdsTOx7IL_5p-LqK5wXMRX8hya62s,13437
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=fHN3-_Bi3lVPgSrmlnCRuF6P7zSyMtZnPNknFSyy1bQ,6819
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=iY7C_vJN3S1T_PPZvdxodqp0UtxJjmxbGvfMP5n3PoM,10905
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=27LL8bIVSHqfSw0baGxPLTQf2EI1vQp3ngYnszHMOz0,746
 build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TBbtPf_11O24uy3X4ESEqNh2AwGWPjF9bVMuYFxfUKg,16393
-build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=mupJrVx0_6OFlPLFOIhTg46sJIuKOY7cnUj1JYQkrGQ,29872
+build/lib/build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=vzrmH3ilOj0TPtKl4vYRt0oBsbDJv7oLZmWP7vl-VBA,29933
 build/lib/build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
-build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=BbgBaGtCX9mrfYo338jbP-f0BQsiCnTqA_Lb_qzWzSc,2129
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=C_VfEV9bem5Sc5WBkzbOKE5KhCdg_iK-UDZLQEevTb4,7090
-build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=74j3U5flnOF7aF3bPuQFW6gDGg_NPdjcTENMySIrW78,46337
-build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=qJiUcOj2xrwpUuEdsTOx7IL_5p-LqK5wXMRX8hya62s,13437
-build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=fHN3-_Bi3lVPgSrmlnCRuF6P7zSyMtZnPNknFSyy1bQ,6819
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=4lbpg3N2XLRzwcmRHQEmU4RMU6nXlI66H0iPINBch_8,48946
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=tHMqdNLn3-25w65S-M4FNlEvle9NdUvD8I_KJXiWx8I,13522
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=GEKt3_hp08UjY8CHTI61gLBpzT1wyNk5_KzG_3_SDhE,7182
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=27LL8bIVSHqfSw0baGxPLTQf2EI1vQp3ngYnszHMOz0,746
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TBbtPf_11O24uy3X4ESEqNh2AwGWPjF9bVMuYFxfUKg,16393
 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=vzrmH3ilOj0TPtKl4vYRt0oBsbDJv7oLZmWP7vl-VBA,29933
 build/lib/build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=C_VfEV9bem5Sc5WBkzbOKE5KhCdg_iK-UDZLQEevTb4,7090
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=4lbpg3N2XLRzwcmRHQEmU4RMU6nXlI66H0iPINBch_8,48946
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=tHMqdNLn3-25w65S-M4FNlEvle9NdUvD8I_KJXiWx8I,13522
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=qPJXdFrFYGZ0ZGNh5ePfDAJH5FU7e-EZWuX0mujVq7c,7100
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=HwHqCxeLvkhc2Pso5qiL3C5S1rUky7LYehFotvpSroE,48944
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=g-Lzv9Imlun2zk5IGRYRATdshR62Fd-k_YdQt4sgSwE,13523
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=GEKt3_hp08UjY8CHTI61gLBpzT1wyNk5_KzG_3_SDhE,7182
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=27LL8bIVSHqfSw0baGxPLTQf2EI1vQp3ngYnszHMOz0,746
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=TBbtPf_11O24uy3X4ESEqNh2AwGWPjF9bVMuYFxfUKg,16393
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=vzrmH3ilOj0TPtKl4vYRt0oBsbDJv7oLZmWP7vl-VBA,29933
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=6CVFTw4SNz_DX8HybBlaDommHGNDuPMds4evrLXLdz8,746
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=CvprBYfaZ5AWqfjdAoWR43lzSppeqEq9yCfN9E-YyyE,16399
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=lekVB7GWwfCHeK7l7hg304tZ1vnpedqRfLX43W8-Vzc,29935
 build/lib/build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=qPJXdFrFYGZ0ZGNh5ePfDAJH5FU7e-EZWuX0mujVq7c,7100
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=HwHqCxeLvkhc2Pso5qiL3C5S1rUky7LYehFotvpSroE,48944
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=g-Lzv9Imlun2zk5IGRYRATdshR62Fd-k_YdQt4sgSwE,13523
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=GEKt3_hp08UjY8CHTI61gLBpzT1wyNk5_KzG_3_SDhE,7182
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=6CVFTw4SNz_DX8HybBlaDommHGNDuPMds4evrLXLdz8,746
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=CvprBYfaZ5AWqfjdAoWR43lzSppeqEq9yCfN9E-YyyE,16399
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=lekVB7GWwfCHeK7l7hg304tZ1vnpedqRfLX43W8-Vzc,29935
 build/lib/build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
 build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=qPJXdFrFYGZ0ZGNh5ePfDAJH5FU7e-EZWuX0mujVq7c,7100
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=HwHqCxeLvkhc2Pso5qiL3C5S1rUky7LYehFotvpSroE,48944
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=g-Lzv9Imlun2zk5IGRYRATdshR62Fd-k_YdQt4sgSwE,13523
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=GEKt3_hp08UjY8CHTI61gLBpzT1wyNk5_KzG_3_SDhE,7182
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=6CVFTw4SNz_DX8HybBlaDommHGNDuPMds4evrLXLdz8,746
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=CvprBYfaZ5AWqfjdAoWR43lzSppeqEq9yCfN9E-YyyE,16399
 build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=lekVB7GWwfCHeK7l7hg304tZ1vnpedqRfLX43W8-Vzc,29935
 build/lib/tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-build/lib/tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+build/lib/tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-build/lib/uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+build/lib/uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
+build/lib/uav_collision_avoidance/docs/conf.py,sha256=Krug0hEWDjkmeqkMGU7m8QUWDcjhe_FZZw1nOPqlk3A,902
 build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
-build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=J4qz1YbBQH-2hcGI3gRMbEP4BFLLHzpWjWl5NmBJuSI,21998
+build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=14vIs_of6hTGgprH6TXBbQaXxbd6Is65HIgTjsbU8BI,22241
 build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=qPJXdFrFYGZ0ZGNh5ePfDAJH5FU7e-EZWuX0mujVq7c,7100
-build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=HwHqCxeLvkhc2Pso5qiL3C5S1rUky7LYehFotvpSroE,48944
-build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=g-Lzv9Imlun2zk5IGRYRATdshR62Fd-k_YdQt4sgSwE,13523
-build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=GEKt3_hp08UjY8CHTI61gLBpzT1wyNk5_KzG_3_SDhE,7182
+build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=0k8Rhxi4d0gOJ0bu3w3TfXNDZLKhGIh-grnHs5D1-Dk,53612
+build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Rjry5qodutLFczMLINN2yj4_UX2GaEg5IGXbIaT7LdY,15131
+build/lib/uav_collision_avoidance/src/simulation/simulation_data.py,sha256=j_Drf6wGZs2JUtMdnRz87tseoVM9uuOYAOI6tNf4r20,7692
 build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
-build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=6CVFTw4SNz_DX8HybBlaDommHGNDuPMds4evrLXLdz8,746
-build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=CvprBYfaZ5AWqfjdAoWR43lzSppeqEq9yCfN9E-YyyE,16399
-build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=lekVB7GWwfCHeK7l7hg304tZ1vnpedqRfLX43W8-Vzc,29935
+build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=xG_1gS1TP6XZcL-bpNK5C09rjTIl-3jL7uS-G78Hi3o,988
+build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=I0kHZ2qYCibgxlQW_3tPOwmS70xN0q0DEEzhqTNw-RE,16405
+build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=drxOkYJDzKzA62jy5bqpridlbdH-fIHWBICps-w5DpI,31060
 tests/__init__.py,sha256=sAA2Hpo-c59D1hnzD2Qo2wYhwLUoomSacsLtWbjPf9E,169
-tests/test_headless.py,sha256=RT6PjxLQ4Z3JdVXG6ltwtPlHi1hyoUl3LDpCkDCl2jM,1604
+tests/test_headless.py,sha256=hggPhTvXp_QsfsLFfICfZUrW4Bd3JoT_Gl93BHnlTGY,1604
 tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
-uav_collision_avoidance/main.py,sha256=DFrpK6y4J1pimayosHFN76P_-uWnBBivkZfJe-jcCZA,7699
+uav_collision_avoidance/main.py,sha256=70wJ9n3ita_GhpJfvnvm2UplrKJzxLHmzvObiNyvZK0,7761
 uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 uav_collision_avoidance/docs/conf.py,sha256=Krug0hEWDjkmeqkMGU7m8QUWDcjhe_FZZw1nOPqlk3A,902
 uav_collision_avoidance/src/aircraft/aircraft.py,sha256=ZfZjT_HtwPq0o3pCAFKOogEjz8LVMLcST1RUaFzcp-Y,2457
 uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=14vIs_of6hTGgprH6TXBbQaXxbd6Is65HIgTjsbU8BI,22241
 uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=qPJXdFrFYGZ0ZGNh5ePfDAJH5FU7e-EZWuX0mujVq7c,7100
-uav_collision_avoidance/src/simulation/simulation.py,sha256=0k8Rhxi4d0gOJ0bu3w3TfXNDZLKhGIh-grnHs5D1-Dk,53612
+uav_collision_avoidance/src/simulation/simulation.py,sha256=sq9dmoA9FmkIexxMimQGioQRUeNNyUpArzZxNtIz_Ys,58313
 uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Rjry5qodutLFczMLINN2yj4_UX2GaEg5IGXbIaT7LdY,15131
 uav_collision_avoidance/src/simulation/simulation_data.py,sha256=j_Drf6wGZs2JUtMdnRz87tseoVM9uuOYAOI6tNf4r20,7692
 uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=GjCbtaO8b_EgyeXDTq-HYkEzkUk43C3B98FXlGyF2IM,2642
 uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=g6pwxCw52A8WqzhTj6G48qpSsKNav58x495hH7saI1g,11104
 uav_collision_avoidance/src/simulation/simulation_render.py,sha256=kuetZego3MlHWVbPuZ_QeiKYqhYvj_-trccDYjkUbM0,1341
 uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=xG_1gS1TP6XZcL-bpNK5C09rjTIl-3jL7uS-G78Hi3o,988
 uav_collision_avoidance/src/simulation/simulation_state.py,sha256=I0kHZ2qYCibgxlQW_3tPOwmS70xN0q0DEEzhqTNw-RE,16405
 uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=drxOkYJDzKzA62jy5bqpridlbdH-fIHWBICps-w5DpI,31060
-uav_collision_avoidance-0.8.6.dist-info/LICENSE,sha256=VCiagDkTdM8_xItFjcyMl-mMsGbzL1CQEXpynU0QLxY,1075
-uav_collision_avoidance-0.8.6.dist-info/METADATA,sha256=AOUb-tmYscRxFroalmegu4Ib0ZudGfoXLixjYOxaqew,11439
-uav_collision_avoidance-0.8.6.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-uav_collision_avoidance-0.8.6.dist-info/entry_points.txt,sha256=fcy0NnMoUjf7wZty5G169lvrCzHpWtJXyQuYsEGyg3k,73
-uav_collision_avoidance-0.8.6.dist-info/top_level.txt,sha256=2WqTi55TQpTJfEs63Ru60vF2HaMFCj4qpjj-tV7o204,80
-uav_collision_avoidance-0.8.6.dist-info/RECORD,,
+uav_collision_avoidance-0.8.9.dist-info/LICENSE,sha256=ogEPNDSH0_dhiv_lT3ifVIdgIzHAqNA_SemnxUfPBJk,7048
+uav_collision_avoidance-0.8.9.dist-info/METADATA,sha256=VN_Fg-QEdnlid40cMTPJPDktMCWpCe-DUGjbgZka5wc,11425
+uav_collision_avoidance-0.8.9.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+uav_collision_avoidance-0.8.9.dist-info/entry_points.txt,sha256=fcy0NnMoUjf7wZty5G169lvrCzHpWtJXyQuYsEGyg3k,73
+uav_collision_avoidance-0.8.9.dist-info/top_level.txt,sha256=2WqTi55TQpTJfEs63Ru60vF2HaMFCj4qpjj-tV7o204,80
+uav_collision_avoidance-0.8.9.dist-info/RECORD,,
```

