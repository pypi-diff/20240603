# Comparing `tmp/smbclientng-1.1-py3-none-any.whl.zip` & `tmp/smbclientng-1.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,22 @@
-Zip file size: 42415 bytes, number of entries: 24
+Zip file size: 49036 bytes, number of entries: 20
 -rw-rw-r--  2.0 unx      210 b- defN 24-May-30 16:36 smbclientng/__init__.py
--rw-rw-r--  2.0 unx     3850 b- defN 24-May-30 16:36 smbclientng/__main__.py
--rw-rw-r--  2.0 unx    15054 b- defN 24-May-30 16:36 smbclientng/core/CommandCompleter.py
--rw-rw-r--  2.0 unx    21989 b- defN 24-May-30 16:36 smbclientng/core/InteractiveShell.py
--rw-rw-r--  2.0 unx     6100 b- defN 24-May-30 16:36 smbclientng/core/LocalFileIO.py
--rw-rw-r--  2.0 unx     1235 b- defN 24-May-30 16:36 smbclientng/core/Module.py
--rw-rw-r--  2.0 unx      392 b- defN 24-May-30 16:36 smbclientng/core/ModuleArgumentParser.py
--rw-rw-r--  2.0 unx    37460 b- defN 24-May-30 16:36 smbclientng/core/SMBSession.py
+-rw-rw-r--  2.0 unx     4798 b- defN 24-Jun-02 18:02 smbclientng/__main__.py
+-rw-rw-r--  2.0 unx    18737 b- defN 24-May-31 19:36 smbclientng/core/CommandCompleter.py
+-rw-rw-r--  2.0 unx     1648 b- defN 24-Jun-02 14:01 smbclientng/core/Config.py
+-rw-rw-r--  2.0 unx    25098 b- defN 24-Jun-02 18:03 smbclientng/core/InteractiveShell.py
+-rw-rw-r--  2.0 unx     6374 b- defN 24-May-31 11:52 smbclientng/core/LocalFileIO.py
+-rw-rw-r--  2.0 unx     1244 b- defN 24-May-31 12:04 smbclientng/core/Module.py
+-rw-rw-r--  2.0 unx     1379 b- defN 24-Jun-02 13:56 smbclientng/core/ModuleArgumentParser.py
+-rw-rw-r--  2.0 unx    44911 b- defN 24-Jun-02 17:38 smbclientng/core/SMBSession.py
 -rw-rw-r--  2.0 unx        0 b- defN 24-May-30 16:36 smbclientng/core/__init__.py
--rw-rw-r--  2.0 unx     6826 b- defN 24-May-30 16:36 smbclientng/core/utils.py
--rw-rw-r--  2.0 unx    11355 b- defN 24-May-30 16:36 smbclientng/modules/Find.py
+-rw-rw-r--  2.0 unx    13125 b- defN 24-Jun-02 13:53 smbclientng/core/utils.py
+-rw-rw-r--  2.0 unx    10433 b- defN 24-Jun-02 17:32 smbclientng/modules/Find.py
+-rw-rw-r--  2.0 unx    13286 b- defN 24-Jun-02 17:37 smbclientng/modules/GPPPasswords.py
 -rw-rw-r--  2.0 unx      165 b- defN 24-May-30 16:36 smbclientng/modules/__init__.py
--rw-rw-r--  2.0 unx      165 b- defN 24-May-30 16:36 smbclientng/tests/__init__.py
--rw-rw-r--  2.0 unx     1596 b- defN 24-May-30 16:36 smbclientng/tests/common.py
--rw-rw-r--  2.0 unx      640 b- defN 24-May-30 16:36 smbclientng/tests/run-tests.py
--rw-rw-r--  2.0 unx      612 b- defN 24-May-30 16:36 smbclientng/tests/test_SMBSession.py
--rw-rw-r--  2.0 unx     1480 b- defN 24-May-30 16:36 smbclientng/tests/test_SMBSession_path_isdir.py
--rw-rw-r--  2.0 unx     1477 b- defN 24-May-30 16:36 smbclientng/tests/test_SMBSession_path_isfile.py
--rw-rw-r--  2.0 unx    35149 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/LICENSE
--rw-rw-r--  2.0 unx      543 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/WHEEL
--rw-rw-r--  2.0 unx       58 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       12 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2087 b- defN 24-May-30 17:22 smbclientng-1.1.dist-info/RECORD
-24 files, 148547 bytes uncompressed, 39001 bytes compressed:  73.7%
+-rw-rw-r--  2.0 unx    35149 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     4565 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       93 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       12 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1710 b- defN 24-Jun-02 18:56 smbclientng-1.2.dist-info/RECORD
+20 files, 183029 bytes uncompressed, 46238 bytes compressed:  74.7%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: smbclientng/__main__.py
 Comment: 
 
 Filename: smbclientng/core/CommandCompleter.py
 Comment: 
 
+Filename: smbclientng/core/Config.py
+Comment: 
+
 Filename: smbclientng/core/InteractiveShell.py
 Comment: 
 
 Filename: smbclientng/core/LocalFileIO.py
 Comment: 
 
 Filename: smbclientng/core/Module.py
@@ -27,47 +30,32 @@
 
 Filename: smbclientng/core/utils.py
 Comment: 
 
 Filename: smbclientng/modules/Find.py
 Comment: 
 
-Filename: smbclientng/modules/__init__.py
-Comment: 
-
-Filename: smbclientng/tests/__init__.py
-Comment: 
-
-Filename: smbclientng/tests/common.py
+Filename: smbclientng/modules/GPPPasswords.py
 Comment: 
 
-Filename: smbclientng/tests/run-tests.py
-Comment: 
-
-Filename: smbclientng/tests/test_SMBSession.py
-Comment: 
-
-Filename: smbclientng/tests/test_SMBSession_path_isdir.py
-Comment: 
-
-Filename: smbclientng/tests/test_SMBSession_path_isfile.py
+Filename: smbclientng/modules/__init__.py
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/LICENSE
+Filename: smbclientng-1.2.dist-info/LICENSE
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/METADATA
+Filename: smbclientng-1.2.dist-info/METADATA
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/WHEEL
+Filename: smbclientng-1.2.dist-info/WHEEL
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/entry_points.txt
+Filename: smbclientng-1.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/top_level.txt
+Filename: smbclientng-1.2.dist-info/top_level.txt
 Comment: 
 
-Filename: smbclientng-1.1.dist-info/RECORD
+Filename: smbclientng-1.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## smbclientng/__main__.py

```diff
@@ -2,34 +2,35 @@
 # -*- coding: utf-8 -*-
 # File name          : __main__.py
 # Author             : Podalirius (@podalirius_)
 # Date created       : 24 may 2024
 
 import argparse
 import sys
-from smbclientng.core.utils import parse_lm_nt_hashes
-from smbclientng.core.SMBSession import SMBSession
+from smbclientng.core.Config import Config
 from smbclientng.core.InteractiveShell import InteractiveShell
+from smbclientng.core.SMBSession import SMBSession
+from smbclientng.core.utils import parse_lm_nt_hashes
 
 
-VERSION = "1.1"
+VERSION = "1.2"
 
 
 def parseArgs():
     print("""               _          _ _            _                    
  ___ _ __ ___ | |__   ___| (_) ___ _ __ | |_      _ __   __ _ 
 / __| '_ ` _ \| '_ \ / __| | |/ _ \ '_ \| __|____| '_ \ / _` |
 \__ \ | | | | | |_) | (__| | |  __/ | | | ||_____| | | | (_| |
 |___/_| |_| |_|_.__/ \___|_|_|\___|_| |_|\__|    |_| |_|\__, |
     by @podalirius_                         %10s  |___/  
     """ % ("v"+VERSION))
 
     parser = argparse.ArgumentParser(add_help=True, description="smbclient-ng, a fast and user friendly way to interact with SMB shares.")
-    parser.add_argument("--debug", dest="debug", action="store_true", default=False, help="Debug mode")
-
+    parser.add_argument("--debug", dest="debug", action="store_true", default=False, help="Debug mode.")
+    parser.add_argument("--no-colors", dest="no_colors", action="store_true", default=False, help="No colors mode.")
     parser.add_argument("--target", action="store", metavar="ip address", required=True, type=str, help="IP Address of the SMB Server to connect to.")  
 
     authconn = parser.add_argument_group("Authentication & connection")
     authconn.add_argument("--kdcHost", dest="kdcHost", action="store", metavar="FQDN KDC", help="FQDN of KDC for Kerberos.")
     authconn.add_argument("-d", "--domain", dest="auth_domain", metavar="DOMAIN", action="store", help="(FQDN) domain to authenticate to")
     authconn.add_argument("-u", "--user", dest="auth_username", metavar="USER", action="store", help="user to authenticate with")
 
@@ -47,14 +48,30 @@
 
     args = parser.parse_args()
 
     return args
 
 
 def main():
+    """
+    Main function to execute the smbclient-ng tool.
+
+    This function handles the command-line arguments, initializes the SMB session,
+    and starts the interactive shell. It also manages the authentication process
+    using either password or hashes, and sets up the session configuration based
+    on the provided command-line options.
+
+    If Kerberos authentication is specified, it ensures that the KDC host is provided.
+    It exits with an error message if necessary conditions are not met for the session
+    to start properly.
+
+    The function also handles debug mode outputs and exits cleanly, providing feedback
+    about the session termination if debug mode is enabled.
+    """
+
     options = parseArgs()
 
     # Parse hashes
     if options.auth_hashes is not None:
         if ":" not in options.auth_hashes:
             options.auth_hashes = ":" + options.auth_hashes
     auth_lm_hash, auth_nt_hash = parse_lm_nt_hashes(options.auth_hashes)
@@ -62,29 +79,33 @@
     # Use AES Authentication key if available
     if options.auth_key is not None:
         options.use_kerberos = True
     if options.use_kerberos is True and options.kdcHost is None:
         print("[!] Specify KDC's Hostname of FQDN using the argument --kdcHost")
         exit()
 
+    config = Config()
+    config.debug = options.debug
+    config.no_colors = options.no_colors
+
     smbSession = SMBSession(
         address=options.target,
         domain=options.auth_domain,
         username=options.auth_username,
         password=options.auth_password,
         lmhash=auth_lm_hash,
         nthash=auth_nt_hash,
         use_kerberos=options.use_kerberos,
-        debug=options.debug
+        config=config
     )
     smbSession.init_smb_session()
 
     shell = InteractiveShell(
         smbSession=smbSession, 
-        debug=options.debug
+        config=config
     )
     shell.run()
 
     if options.debug:
         print("[debug] Exiting the console.")
 
 if __name__ == "__main__":
```

## smbclientng/core/CommandCompleter.py

```diff
@@ -20,118 +20,205 @@
     Attributes:
         smbSession (SMBSession): An instance of SMBSession which maintains the current SMB session.
         commands (dict): A dictionary containing command names as keys and their descriptions and subcommands as values.
 
     Methods:
         __init__(self, smbSession): Initializes the CommandCompleter with an SMBSession.
     """
-    def __init__(self, smbSession):
+
+    commands = {
+        "cd": {
+            "description": [
+                "Change the current working directory.", 
+                "Syntax: 'cd <directory>'"
+            ], 
+            "subcommands": []
+        },
+        "close": {
+            "description": [
+                "Closes the SMB connection to the remote machine.", 
+                "Syntax: 'close'"
+            ], 
+            "subcommands": []
+        },
+        "connect": {
+            "description": [
+                "Connect to the remote machine (useful if connection timed out).", 
+                "Syntax: 'connect'"
+            ], 
+            "subcommands": []
+        },
+        "dir": {
+            "description": [
+                "List the contents of the current working directory.",
+                "Syntax: 'dir'"
+            ], 
+            "subcommands": []
+        },
+        "exit": {
+            "description": [
+                "Exits the smbclient-ng script.",
+                "Syntax: 'exit'"
+            ], 
+            "subcommands": []
+        },
+        "get": {
+            "description": [
+                "Get a remote file.",
+                "Syntax: 'get [-r] <directory or file>'"
+            ], 
+            "subcommands": []
+        },
+        "help": {
+            "description": [
+                "Displays this help message.",
+                "Syntax: 'help'"
+            ], 
+            "subcommands": ["format"]
+        },
+        "info": {
+            "description": [
+                "Get information about the server and or the share.",
+                "Syntax: 'info [server|share]'"
+            ], 
+            "subcommands": ["server", "share"]
+        },
+        "lcd": {
+            "description": [
+                "Changes the current local directory.",
+                "Syntax: 'lcd <directory>'"
+            ], 
+            "subcommands": []
+        },
+        "lls": {
+            "description": [
+                "Lists the contents of the current local directory.", 
+                "Syntax: 'lls'"
+            ],
+            "subcommands": []
+        },
+        "lmkdir": {
+            "description": [
+                "Creates a new local directory.", 
+                "Syntax: 'lmkdir <directory>'"
+            ],
+            "subcommands": []
+        },
+        "lpwd": {
+            "description": [
+                "Shows the current local directory.", 
+                "Syntax: 'lpwd'"
+            ],
+            "subcommands": []
+        },
+        "lrm": {
+            "description": [
+                "Removes a local file.", 
+                "Syntax: 'lrm <file>'"
+            ], 
+            "subcommands": []
+        },
+        "lrmdir": {
+            "description": [
+                "Removes a local directory.", 
+                "Syntax: 'lrmdir <directory>'"
+            ], 
+            "subcommands": []
+        },
+        "ls": {
+            "description": [
+                "List the contents of the current remote working directory.", 
+                "Syntax: 'ls'"
+            ], 
+            "subcommands": []
+        },
+        "ltree": {
+            "description": [
+                "Displays a tree view of the local directories.",
+                "Syntax: 'ltree [directory]'"
+            ], 
+            "subcommands": []
+        },
+        "mkdir": {
+            "description": [
+                "Creates a new remote directory.", 
+                "Syntax: 'mkdir <directory>'"
+            ], 
+            "subcommands": []
+        },
+        "module": {
+            "description": [
+                "Loads a specific module for additional functionalities.",
+                "Syntax: 'module <name>'"
+            ], 
+            "subcommands": []
+        },
+        "put": {
+            "description": [
+                "Put a local file or directory in a remote directory.", 
+                "Syntax: 'put [-r] <directory or file>'"
+            ], 
+            "subcommands": []
+        },
+        "reconnect": {
+            "description": [
+                "Reconnect to the remote machine (useful if connection timed out).", 
+                "Syntax: 'reconnect'"
+            ], 
+            "subcommands": []
+        },
+        "reset": {
+            "description": [
+                "Reset the TTY output, useful if it was broken after printing a binary file on stdout.",
+                "Syntax: 'reset'"
+            ], 
+            "subcommands": []
+        },
+        "rmdir": {
+            "description": [
+                "Removes a remote directory.", 
+                "Syntax: 'rmdir <directory>'"
+            ], 
+            "subcommands": []
+        },
+        "rm": {
+            "description": [
+                "Removes a remote file.", 
+                "Syntax: 'rm <file>'"
+            ], 
+            "subcommands": []
+        },
+        "shares": {
+            "description": [
+                "Lists the SMB shares served by the remote machine.", 
+                "Syntax: 'shares'"
+            ], 
+            "subcommands": []
+        },
+        "use": {
+            "description": [
+                "Use a SMB share.", 
+                "Syntax: 'use <sharename>'"
+            ], 
+            "subcommands": []
+        },
+        "tree": {
+            "description": [
+                "Displays a tree view of the remote directories.",
+                "Syntax: 'tree [directory]'"
+            ], 
+            "subcommands": []
+        },
+    }
+
+    def __init__(self, smbSession, config):
+        # Objects
         self.smbSession = smbSession
-        self.commands = {
-            "cd": {
-                "description": ["Change the current working directory.", "Syntax: 'cd <directory>'"], 
-                "subcommands": []
-            },
-            "close": {
-                "description": ["Closes the SMB connection to the remote machine.", "Syntax: 'close'"], 
-                "subcommands": []
-            },
-            "connect": {
-                "description": ["Connect to the remote machine (useful if connection timed out).", "Syntax: 'Connect'"], 
-                "subcommands": []
-            },
-            "dir": {
-                "description": ["List the contents of the current working directory.", "Syntax: 'dir'"], 
-                "subcommands": []
-            },
-            "exit": {
-                "description": ["Exits the smbclient-ng script.", "Syntax: 'exit'"], 
-                "subcommands": []
-            },
-            "get": {
-                "description": ["Get a remote file.", "Syntax: 'get [-r] <directory or file>'"], 
-                "subcommands": []
-            },
-            "help": {
-                "description": ["Displays this help message.", "Syntax: 'help'"], 
-                "subcommands": ["format"]
-            },
-            "info": {
-                "description": ["Get information about the server and or the share.", "Syntax: 'info [server|share]'"], 
-                "subcommands": ["server", "share"]
-            },
-            "lcd": {
-                "description": ["Changes the current local directory.", "Syntax: 'lcd <directory>'"], 
-                "subcommands": []
-            },
-            "lls": {
-                "description": ["Lists the contents of the current local directory.", "Syntax: 'lls'"], 
-                "subcommands": []
-            },
-            "lmkdir": {
-                "description": ["Creates a new local directory.", "Syntax: 'lmkdir <directory>'"], 
-                "subcommands": []
-            },
-            "lpwd": {
-                "description": ["Shows the current local directory.", "Syntax: 'lpwd'"], 
-                "subcommands": []
-            },
-            "lrm": {
-                "description": ["Removes a local file.", "Syntax: 'lrm <file>'"], 
-                "subcommands": []
-            },
-            "lrmdir": {
-                "description": ["Removes a local directory.", "Syntax: 'lrmdir <directory>'"], 
-                "subcommands": []
-            },
-            "ls": {
-                "description": ["List the contents of the current remote working directory.", "Syntax: 'ls'"], 
-                "subcommands": []
-            },
-            "mkdir": {
-                "description": ["Creates a new remote directory.", "Syntax: 'mkdir <directory>'"], 
-                "subcommands": []
-            },
-            "module": {
-                "description": ["Loads a specific module for additional functionalities.", "Syntax: 'module <name>'"], 
-                "subcommands": []
-            },
-            "put": {
-                "description": ["Put a local file or directory in a remote directory.", "Syntax: 'put [-r] <directory or file>'"], 
-                "subcommands": []
-            },
-            "reconnect": {
-                "description": ["Reconnect to the remote machine (useful if connection timed out).", "Syntax: 'reconnect'"], 
-                "subcommands": []
-            },
-            "reset": {
-                "description": ["Reset the TTY output, useful if it was broken after printing a binary file on stdout.", "Syntax: 'reset'"], 
-                "subcommands": []
-            },
-            "rmdir": {
-                "description": ["Removes a remote directory.", "Syntax: 'rmdir <directory>'"], 
-                "subcommands": []
-            },
-            "rm": {
-                "description": ["Removes a remote file.", "Syntax: 'rm <file>'"], 
-                "subcommands": []
-            },
-            "shares": {
-                "description": ["Lists the SMB shares served by the remote machine.", "Syntax: 'shares'"], 
-                "subcommands": []
-            },
-            "use": {
-                "description": ["Use a SMB share.", "Syntax: use <sharename>"], 
-                "subcommands": []
-            },
-            "tree": {
-                "description": ["Displays a tree view of the nested subfolders.", "Syntax: tree [directory]"], 
-                "subcommands": []
-            },
-        }
+        self.config = config
+        # Pre computing for some commands 
         self.commands["help"]["subcommands"] = ["format"] + list(self.commands.keys())
         self.commands["help"]["subcommands"].remove("help")
 
     def complete(self, text, state):
         """
         Function to handle command completion in the LDAP console.
 
@@ -140,14 +227,15 @@
         Args:
             text (str): The current text input by the user.
             state (int): The current state of completion.
 
         Returns:
             str: The next completion suggestion based on the user"s input state.
         """
+
         if state == 0:
             
             # No text typed yet, need the list of commands available
             if len(text) == 0:
                 self.matches = [s for s in self.commands.keys()]
 
             elif len(text) != 0:
@@ -225,17 +313,16 @@
                             if os.path.sep in remainder.strip():
                                 path = path.split(os.path.sep)[:-1]
                                 path = os.path.sep.join(path)
                             
                             # Current dir
                             if len(path.strip()) == 0:
                                 path = "."
-                            print("path =", path)
+
                             directory_contents = os.listdir(path=path + os.path.sep)
-                            print(directory_contents)
                             matching_entries = []
                             for entry in directory_contents:
                                 if entry not in [".",".."]:
                                     entry_path = path + os.path.sep + entry
                                     if os.path.isdir(entry_path):
                                         matching_entries.append(entry_path + os.path.sep)
                                     else:
@@ -264,50 +351,95 @@
 
         try:
             return self.matches[state] + " "
         except IndexError:
             return None
 
     def print_help(self, command=None):
-        if command != None:
+        """
+        Prints help information for a specific command or all commands if no command is specified.
+
+        This method displays the help information for the command passed as an argument. If no command is specified,
+        it prints the help information for all available commands. The help information includes the command syntax,
+        description, and any subcommands associated with it. This method is designed to provide users with the necessary
+        guidance on how to use the commands in the smbclient-ng shell.
+
+        Args:
+            command (str, optional): The command to display help information for. If None, help for all commands is displayed.
+
+        Returns:
+            None
+        """
+
+        if command is not None:
             if command not in list(self.commands.keys())+["format"]:
                 command = None
-
-        if command != None:
+        
+        # Print help for a specific command
+        if command is not None:
             if command == "format":
                 self.print_help_format()
             else:
                 print("│")
-                command_str = command + " \x1b[90m" + "─"* (15 - len(command)) + "\x1b[0m"
-                if len(self.commands[command]["description"]) == 0:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m  " % command_str)
-                elif len(self.commands[command]["description"]) == 1:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                if self.config.no_colors:
+                    command_str = command + "─"* (15 - len(command))
+                    if len(self.commands[command]["description"]) == 0:
+                        print("│ ■ %s┤  " % command_str)
+                    elif len(self.commands[command]["description"]) == 1:
+                        print("│ ■ %s┤ %s " % (command_str, self.commands[command]["description"][0]))
+                    else:
+                        print("│ ■ %s┤ %s " % (command_str, self.commands[command]["description"][0]))
+                        for line in self.commands[command]["description"][1:]:
+                            print("│ %s│ %s " % (" "*(15+3), line))
                 else:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
-                    for line in self.commands[command]["description"][1:]:
-                        print("│ %s\x1b[90m│\x1b[0m %s " % (" "*(15+3), line))
+                    command_str = command + " \x1b[90m" + "─"* (15 - len(command)) + "\x1b[0m"
+                    if len(self.commands[command]["description"]) == 0:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m  " % command_str)
+                    elif len(self.commands[command]["description"]) == 1:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                    else:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                        for line in self.commands[command]["description"][1:]:
+                            print("│ %s\x1b[90m│\x1b[0m %s " % (" "*(15+2), line))
                 print("│")
-
+        # Generic help
         else:
             print("│")
             commands = sorted(self.commands.keys())
             for command in commands:
-                command_str = command + " \x1b[90m" + "─"* (15 - len(command)) + "\x1b[0m"
-                if len(self.commands[command]["description"]) == 0:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m  " % command_str)
-                elif len(self.commands[command]["description"]) == 1:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                if self.config.no_colors:
+                    command_str = command + "─"* (15 - len(command))
+                    if len(self.commands[command]["description"]) == 0:
+                        print("│ ■ %s┤  " % command_str)
+                    elif len(self.commands[command]["description"]) == 1:
+                        print("│ ■ %s┤ %s " % (command_str, self.commands[command]["description"][0]))
+                    else:
+                        print("│ ■ %s┤ %s " % (command_str, self.commands[command]["description"][0]))
+                        for line in self.commands[command]["description"][1:]:
+                            print("│ %s│ %s " % (" "*(15+2), line))
                 else:
-                    print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
-                    for line in self.commands[command]["description"][1:]:
-                        print("│ %s\x1b[90m│\x1b[0m %s " % (" "*(15+3), line))
+                    command_str = command + " \x1b[90m" + "─"* (15 - len(command)) + "\x1b[0m"
+                    if len(self.commands[command]["description"]) == 0:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m  " % command_str)
+                    elif len(self.commands[command]["description"]) == 1:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                    else:
+                        print("│ ■ %s\x1b[90m┤\x1b[0m %s " % (command_str, self.commands[command]["description"][0]))
+                        for line in self.commands[command]["description"][1:]:
+                            print("│ %s\x1b[90m│\x1b[0m %s " % (" "*(15+3), line))
                 print("│")
 
     def print_help_format(self):
+        """
+        Prints the help information for the 'format' used in remote 'ls' and 'dir' commands.
+
+        This function displays the format of file attributes used in the smbclient-ng shell. It explains the meaning
+        of each character in the file attribute string, such as whether a file is read-only, hidden, or a directory.
+        """
+
         print("File attributes format:\n")
         print("\x1b[1mdachnrst\x1b[0m")
         print("\x1b[90m│││││││└──>\x1b[0m Temporary")
         print("\x1b[90m││││││└───>\x1b[0m System")
         print("\x1b[90m│││││└────>\x1b[0m Read-Only")
         print("\x1b[90m││││└─────>\x1b[0m Normal")
         print("\x1b[90m│││└──────>\x1b[0m Hidden")
```

## smbclientng/core/InteractiveShell.py

```diff
@@ -13,15 +13,15 @@
 import readline
 import shutil
 import sys
 import traceback
 from rich.console import Console
 from rich.table import Table
 from smbclientng.core.CommandCompleter import CommandCompleter
-from smbclientng.core.utils import b_filesize, unix_permissions, windows_ls_entry
+from smbclientng.core.utils import b_filesize, unix_permissions, windows_ls_entry, local_tree
 
 
 ## Decorators
 
 def command_arguments_required(func):
     def wrapper(*args, **kwargs):
         self, arguments,command  = args[0], args[1], args[2]
@@ -71,28 +71,24 @@
         commandCompleterObject (CommandCompleter): Object to handle command completion and help generation.
 
     Methods:
         __init__(self, smbSession, debug=False): Initializes the InteractiveShell with the given SMB session and debug mode.
         run(self): Starts the command line interface loop, processing user input until exit.
     """
     
-    def __init__(self, smbSession, debug=False):
+    def __init__(self, smbSession, config):
+        # Objects
         self.smbSession = smbSession
-        self.debug = debug
-
-        self.smb_share = None
-        self.smb_cwd = ""
-
-        self.modules = {}
-
-        self.commandCompleterObject = CommandCompleter(smbSession=self.smbSession)
+        self.config = config
+        self.commandCompleterObject = CommandCompleter(smbSession=self.smbSession, config=self.config)
         readline.set_completer(self.commandCompleterObject.complete)
         readline.parse_and_bind("tab: complete")
         readline.set_completer_delims("\n")
-
+        # Additional modules
+        self.modules = {}
         self.__load_modules()
 
     def run(self):
         running = True
         while running:
             try:
                 user_input = input(self.__prompt()).strip().split(" ")
@@ -119,15 +115,15 @@
                 print()
 
             except EOFError as e:
                 print()
                 running = False
 
             except Exception as e:
-                if self.debug:
+                if self.config.debug:
                     traceback.print_exc()
                 print("[!] Error: %s" % str(e))
 
     def process_command(self, command, arguments=[]):
         # Skip
         if command.strip() == "":
             pass
@@ -172,27 +168,31 @@
         elif command == "lls":
             self.command_lls(arguments, command)
 
         # Creates a new local directory
         elif command == "lmkdir":
             self.command_lmkdir(arguments, command)
 
+        # Shows the current local directory
+        elif command == "lpwd":
+            self.command_lpwd(arguments, command)
+
         # Removes a local file
         elif command == "lrm":
             self.command_lrm(arguments, command)
 
         # Removes a local directory
         elif command == "lrmdir":
             self.command_lrmdir(arguments, command)
 
         # Shows the current local directory
-        elif command == "lpwd":
-            self.command_lpwd(arguments, command)
+        elif command == "ltree":
+            self.command_ltree(arguments, command)
 
-        # 
+        # Modules
         elif command == "module":
             self.command_module(arguments, command)
 
         # Reconnects the current SMB session
         elif command in ["connect", "reconnect"]:
             self.command_reconnect(arguments, command)
 
@@ -318,28 +318,49 @@
 
     def command_lls(self, arguments, command):
         # Command arguments required   : No
         # Active SMB connection needed : No
         # SMB share needed             : No
 
         if len(arguments) == 0:
-            directory_contents = os.listdir(path='.')
+            path = '.'
         else:
-            directory_contents = os.listdir(path=' '.join(arguments))
-
-        for entryname in sorted(directory_contents):
-            rights_str = unix_permissions(entryname)
-            size_str = b_filesize(os.path.getsize(filename=entryname))
-            date_str = datetime.datetime.fromtimestamp(os.path.getmtime(filename=entryname)).strftime("%Y-%m-%d %H:%M")
+            path = ' '.join(arguments)
 
-            if os.path.isdir(s=entryname):
-                print("%s %10s  %s  \x1b[1;96m%s\x1b[0m%s" % (rights_str, size_str, date_str, entryname, os.path.sep))
+        # lls <directory>
+        if os.path.isdir(path):
+            directory_contents = os.listdir(path=path)
+            for entryname in sorted(directory_contents):
+                path_to_file = path + os.path.sep + entryname
+                rights_str = unix_permissions(path_to_file)
+                size_str = b_filesize(os.path.getsize(filename=path_to_file))
+                date_str = datetime.datetime.fromtimestamp(os.path.getmtime(filename=path_to_file)).strftime("%Y-%m-%d %H:%M")
+
+                if os.path.isdir(s=entryname):
+                    if self.config.no_colors:
+                        print("%s %10s  %s  %s%s" % (rights_str, size_str, date_str, entryname, os.path.sep))
+                    else:
+                        print("%s %10s  %s  \x1b[1;96m%s\x1b[0m%s" % (rights_str, size_str, date_str, entryname, os.path.sep))
+                else:
+                    if self.config.no_colors:
+                        print("%s %10s  %s  %s" % (rights_str, size_str, date_str, entryname))
+                    else:
+                        print("%s %10s  %s  \x1b[1m%s\x1b[0m" % (rights_str, size_str, date_str, entryname))
+        # lls <file>
+        elif os.path.isfile(path):
+            rights_str = unix_permissions(path)
+            size_str = b_filesize(os.path.getsize(filename=path))
+            date_str = datetime.datetime.fromtimestamp(os.path.getmtime(filename=path)).strftime("%Y-%m-%d %H:%M")
+            if self.config.no_colors:
+                print("%s %10s  %s  %s" % (rights_str, size_str, date_str, os.path.basename(path)))
             else:
-                print("%s %10s  %s  \x1b[1m%s\x1b[0m" % (rights_str, size_str, date_str, entryname))
-    
+               print("%s %10s  %s  \x1b[1m%s\x1b[0m" % (rights_str, size_str, date_str, os.path.basename(path))) 
+        else:
+            print("[!] No such file or directory.")
+
     @command_arguments_required
     def command_lmkdir(self, arguments, command):
         # Command arguments required   : Yes
         # Active SMB connection needed : No
         # SMB share needed             : No
 
         path = ' '.join(arguments)
@@ -352,14 +373,21 @@
 
         # Create each dir in the path
         for depth in range(1, len(path)+1):
             tmp_path = os.path.sep.join(path[:depth])
             if not os.path.exists(tmp_path):
                 os.mkdir(path=tmp_path)
 
+    def command_lpwd(self, arguments, command):
+        # Command arguments required   : No
+        # Active SMB connection needed : No
+        # SMB share needed             : No
+
+        print(os.getcwd())
+
     @command_arguments_required
     def command_lrm(self, arguments, command):
         # Command arguments required   : Yes
         # Active SMB connection needed : No
         # SMB share needed             : No
 
         path = ' '.join(arguments)
@@ -388,33 +416,36 @@
                 except Exception as e:
                     print("[!] Error removing directory '%s' : %s" % path)
             else:
                 print("[!] Cannot delete '%s'. It is a file, use 'lrm <file>' instead." % path)
         else:
             print("[!] Path '%s' does not exist." % path)
 
-    def command_lpwd(self, arguments, command):
+    def command_ltree(self, arguments, command):
         # Command arguments required   : No
         # Active SMB connection needed : No
         # SMB share needed             : No
 
-        print(os.getcwd())
+        if len(arguments) == 0:
+            local_tree(path='.', config=self.config)
+        else:
+            local_tree(path=' '.join(arguments), config=self.config)
 
     @active_smb_connection_needed
     @smb_share_is_set
     def command_ls(self, arguments, command):
         # Command arguments required   : No
         # Active SMB connection needed : Yes
         # SMB share needed             : Yes
 
         # Read the files
         directory_contents = self.smbSession.list_contents(path=' '.join(arguments))
 
         for longname in sorted(directory_contents.keys(), key=lambda x:x.lower()):
-            windows_ls_entry(directory_contents[longname])
+            windows_ls_entry(directory_contents[longname], self.config)
             
     @command_arguments_required
     @active_smb_connection_needed
     @smb_share_is_set
     def command_mkdir(self, arguments, command):
         # Command arguments required   : Yes
         # Active SMB connection needed : Yes
@@ -426,15 +457,15 @@
     @command_arguments_required
     @active_smb_connection_needed
     @smb_share_is_set
     def command_module(self, arguments, command):
         module_name = arguments[0]
 
         if module_name in self.modules.keys():
-            module = self.modules[module_name](self.smbSession)
+            module = self.modules[module_name](self.smbSession, self.config)
             module.run(' '.join(arguments[1:]))
         else:
             print("[!] Module '%s' does not exist." % module_name)
 
     @command_arguments_required
     @active_smb_connection_needed
     @smb_share_is_set
@@ -573,43 +604,77 @@
             self.smbSession.set_share(sharename)
         else:
             print("[!] No share named '%s' on '%s'" % (sharename, self.smbSession.address))
 
     # Private functions =======================================================
 
     def __load_modules(self):
+
+
         self.modules.clear()
 
         modules_dir = os.path.normpath(os.path.dirname(__file__) + os.path.sep + ".." + os.path.sep + "modules")
-        if self.debug:
+        if self.config.debug:
             print("[debug] Loading modules from %s ..." % modules_dir)
         sys.path.extend([modules_dir])
 
         for file in os.listdir(modules_dir):
             filepath = os.path.normpath(modules_dir + os.path.sep + file)
             if file.endswith('.py'):
                 if os.path.isfile(filepath) and file not in ["__init__.py"]:
                     try:
                         module_file = import_module('smbclientng.modules.%s' % (file[:-3]))
                         module = module_file.__getattribute__(file[:-3])
                         self.modules[module.name.lower()] = module
                     except AttributeError as e:
                         pass
 
-        if self.debug:
-            print("[debug] modules:", self.modules)
-        
+        if self.config.debug:
+            if len(self.modules.keys()) == 0:
+                print("[debug] Loaded 0 modules.")
+            elif len(self.modules.keys()) == 1:
+                print("[debug] Loaded 1 module:")
+            else:
+                print("[debug] Loaded %d modules:" % len(self.modules.keys()))
+            for modulename in sorted(self.modules.keys()):
+                print("[debug] %s : \"%s\" (%s)" % (self.modules[modulename].name, self.modules[modulename].description, self.modules[modulename]))
+
         if self.commandCompleterObject is not None:
             self.commandCompleterObject.commands["module"]["subcommands"] = list(self.modules.keys())
 
     def __prompt(self):
+        """
+        Prints the command prompt for the interactive shell.
+
+        This method constructs and returns the command prompt string based on the current state of the SMB session.
+        The prompt indicates the connection status with a visual symbol and displays the current working directory
+        or the SMB share path. The prompt appearance changes based on whether colors are enabled in the configuration.
+
+        Returns:
+            str: The formatted command prompt string.
+        """
+
         self.smbSession.ping_smb_session()
         if self.smbSession.connected:
-            connected_dot = "\x1b[1;92m⏺ \x1b[0m"
+            if self.config.no_colors:
+                connected_dot = "[v]"
+            else:
+                connected_dot = "\x1b[1;92m⏺\x1b[0m"
         else:
-            connected_dot = "\x1b[1;91m⏺ \x1b[0m"
+            if self.config.no_colors:
+                connected_dot = "[x]"
+            else:
+                connected_dot = "\x1b[1;91m⏺\x1b[0m"
+        
         if self.smbSession.smb_share is None:
-            str_prompt = "%s[\x1b[1;94m\\\\%s\\\x1b[0m]> " % (connected_dot, self.smbSession.address)
+            if self.config.no_colors:
+                str_prompt = "%s[\\\\%s\\]> " % (connected_dot, self.smbSession.address)
+            else:
+                str_prompt = "%s[\x1b[1;94m\\\\%s\\\x1b[0m]> " % (connected_dot, self.smbSession.address)
         else:
             str_path = "\\\\%s\\%s\\%s" % (self.smbSession.address, self.smbSession.smb_share, self.smbSession.smb_cwd.lstrip(ntpath.sep))
-            str_prompt = "%s[\x1b[1;94m%s\x1b[0m]> " % (connected_dot, str_path)
+            if self.config.no_colors:
+                str_prompt = "%s[%s]> " % (connected_dot, str_path)
+            else:
+                str_prompt = "%s[\x1b[1;94m%s\x1b[0m]> " % (connected_dot, str_path)
+
         return str_prompt
```

## smbclientng/core/LocalFileIO.py

```diff
@@ -23,45 +23,47 @@
 
     Methods:
         __init__(self, mode, path=None, expected_size=None, debug=False): Initializes the LocalFileIO instance.
         write(self, data): Writes data to the file and updates the progress bar if expected size is provided.
         read(self, size): Reads data from the file up to the specified size and updates the progress bar if expected size is provided.
     """
 
-    def __init__(self, mode, path=None, expected_size=None, debug=False):
+    def __init__(self, mode, path=None, expected_size=None, keepRemotePath=False, debug=False):
         super(LocalFileIO, self).__init__()
-
         self.mode = mode
-        self.path = path.replace(ntpath.sep, '/')
+        # Convert remote path format to local operating system path format 
+        self.path = path.replace(ntpath.sep, os.path.sep)
         self.dir = None
         self.debug = False
         self.expected_size = expected_size
+        self.keepRemotePath = keepRemotePath
 
         # Write to local (read remote)
         if self.mode in ["wb"]:
-            self.dir = './' + os.path.dirname(self.path)
+            self.dir = '.' + os.path.sep
+            if keepRemotePath:
+                self.dir += os.path.dirname(self.path)
 
             if not os.path.exists(self.dir):
                 if self.debug:
                     print("[debug] Creating local directory '%s'" % self.dir)
                 os.makedirs(self.dir)
 
             if self.debug:
                 print("[debug] Openning local '%s' with mode '%s'" % (self.path, self.mode))
-
-            self.fd = open(self.path, self.mode)
+            
+            self.fd = open(self.dir + os.path.sep + os.path.basename(self.path), self.mode)
 
         # Write to remote (read local)
         elif self.mode in ["rb"]:
             if ntpath.sep in self.path:
                 self.dir = os.path.dirname(self.path)
 
             if self.debug:
                 print("[debug] Openning local '%s' with mode '%s'" % (self.path, self.mode))
-
             self.fd = open(self.path, self.mode)
 
             if self.expected_size is None:
                 self.expected_size = os.path.getsize(filename=self.path)
 
         # Create progress bar
         if self.expected_size is not None:
```

## smbclientng/core/Module.py

```diff
@@ -16,17 +16,17 @@
     """
 
     name = ""
     description = ""
     smbSession = None
     options = None
 
-    def __init__(self, smbSession):
+    def __init__(self, smbSession, config):
         self.smbSession = smbSession
-        self.options = None
+        self.config = config
 
     def parseArgs(self):
         raise NotImplementedError("Subclasses must implement this method")
 
     def run(self):
         """
         Placeholder method for running the module.
```

## smbclientng/core/ModuleArgumentParser.py

```diff
@@ -4,13 +4,36 @@
 # Author             : Podalirius (@podalirius_)
 # Date created       : 23 may 2024
 
 
 import argparse
 import sys
 
+
 class ModuleArgumentParser(argparse.ArgumentParser):
+    """
+    A custom argument parser for handling module-specific command-line arguments in the smbclientng application.
+
+    This class extends the argparse.ArgumentParser and provides custom error handling specific to the needs of smbclientng modules.
+    It is designed to provide clear and user-friendly command-line interfaces for various modules within the smbclientng suite.
+
+    Attributes:
+        None
+
+    Methods:
+        error(message: str):
+            Overrides the default error handling to provide a more informative error message and display the help text.
+    """
 
     def error(self, message):
+        """
+        Overrides the default error handling of argparse.ArgumentParser to provide a custom error message and help display.
+
+        This method is called when ArgumentParser encounters an error. It writes the error message to stderr,
+        displays the help message, and then exits the program with a status code of 2.
+
+        Args:
+            message (str): The error message to be displayed.
+        """
+
         sys.stderr.write('[!] Error: %s\n' % message)
-        self.print_help()
-        #sys.exit(2)
+        self.print_help()
```

## smbclientng/core/SMBSession.py

```diff
@@ -37,18 +37,18 @@
     Methods:
         __init__(address, domain, username, password, lmhash, nthash, use_kerberos=False, kdcHost=None, debug=False):
             Initializes the SMBSession with the specified parameters.
         init_smb_session():
             Initializes the SMB session by connecting to the server and authenticating using the specified method.
     """
 
-    def __init__(self, address, domain, username, password, lmhash, nthash, use_kerberos=False, kdcHost=None, debug=False):
+    def __init__(self, address, domain, username, password, lmhash, nthash, use_kerberos=False, kdcHost=None, config=None):
         super(SMBSession, self).__init__()
-
-        self.debug = debug
+        # Objects
+        self.config = config
 
         # Target server
         self.address = address
 
         # Credentials
         self.domain = domain
         self.username = username
@@ -78,51 +78,69 @@
 
         The method will print debug information if the `debug` attribute is set to True. Upon successful connection and authentication, it sets the `connected` attribute to True.
 
         Returns:
             bool: True if the connection and authentication are successful, False otherwise.
         """
 
-        if self.debug:
-            print("[debug] [>] Connecting to remote SMB server '%s' ... " % self.address)
-        self.smbClient = impacket.smbconnection.SMBConnection(
-            remoteName=self.address,
-            remoteHost=self.address,
-            sess_port=int(445)
-        )
-
         self.connected = False
-        if self.use_kerberos:
-            if self.debug:
-                print("[debug] [>] Authenticating as '%s\\%s' with kerberos ... " % (self.domain, self.username))
-            self.connected = self.smbClient.kerberosLogin(
-                user=self.username,
-                password=self.password,
-                domain=self.domain,
-                lmhash=self.lmhash,
-                nthash=self.nthash,
-                aesKey=self.aesKey,
-                kdcHost=self.kdcHost
-            )
 
-        else:
-            if self.debug:
-                print("[debug] [>] Authenticating as '%s\\%s' with NTLM ... " % (self.domain, self.username))
-            self.connected = self.smbClient.login(
-                user=self.username,
-                password=self.password,
-                domain=self.domain,
-                lmhash=self.lmhash,
-                nthash=self.nthash
+        if self.config.debug:
+            print("[debug] [>] Connecting to remote SMB server '%s' ... " % self.address)
+        try:
+            self.smbClient = impacket.smbconnection.SMBConnection(
+                remoteName=self.address,
+                remoteHost=self.address,
+                sess_port=int(445)
             )
+        except OSError as err:
+            print("[!] %s" % err)
+            self.smbClient = None
 
-        if self.connected:
-            print("[+] Successfully authenticated to '%s' as '%s\\%s'!" % (self.address, self.domain, self.username))
-        else:
-            print("[!] Failed to authenticate to '%s' as '%s\\%s'!" % (self.address, self.domain, self.username))
+        if self.smbClient is not None:
+            if self.use_kerberos:
+                if self.config.debug:
+                    print("[debug] [>] Authenticating as '%s\\%s' with kerberos ... " % (self.domain, self.username))
+                try:
+                    self.connected = self.smbClient.kerberosLogin(
+                        user=self.username,
+                        password=self.password,
+                        domain=self.domain,
+                        lmhash=self.lmhash,
+                        nthash=self.nthash,
+                        aesKey=self.aesKey,
+                        kdcHost=self.kdcHost
+                    )
+                except impacket.smbconnection.SessionError as err:
+                    if self.config.debug:
+                        traceback.print_exc()
+                    print("[!] Could not login: %s" % err)
+                    self.connected = False
+
+            else:
+                if self.config.debug:
+                    print("[debug] [>] Authenticating as '%s\\%s' with NTLM ... " % (self.domain, self.username))
+                try:
+                    self.connected = self.smbClient.login(
+                        user=self.username,
+                        password=self.password,
+                        domain=self.domain,
+                        lmhash=self.lmhash,
+                        nthash=self.nthash
+                    )
+                except impacket.smbconnection.SessionError as err:
+                    if self.config.debug:
+                        traceback.print_exc()
+                    print("[!] Could not login: %s" % err)
+                    self.connected = False
+
+            if self.connected:
+                print("[+] Successfully authenticated to '%s' as '%s\\%s'!" % (self.address, self.domain, self.username))
+            else:
+                print("[!] Failed to authenticate to '%s' as '%s\\%s'!" % (self.address, self.domain, self.username))
 
         return self.connected
 
     def close_smb_session(self):
         """
         Closes the current SMB session by disconnecting the SMB client.
 
@@ -133,23 +151,71 @@
             Exception: If the SMB client is not initialized or if there's an error during the disconnection process.
         """
 
         if self.smbClient is not None:
             if self.connected:
                 self.smbClient.close()
                 self.connected = False
-                print("[+] SMB connection closed successfully.")
+                if self.config.debug:
+                    print("[+] SMB connection closed successfully.")
             else:
-                print("[!] No active SMB connection to close.")
+                if self.config.debug:
+                    print("[!] No active SMB connection to close.")
         else:
             raise Exception("SMB client is not initialized.")
 
     # Operations
 
-    def get_file(self, path=None):
+    def find(self, paths=[], callback=None):
+        def recurse_action(paths=[], depth=0, callback=None):
+            if callback is None:
+                return []
+            next_directories_to_explore = []
+            for path in paths:
+                remote_smb_path = ntpath.normpath(self.smb_cwd + ntpath.sep + path)
+                entries = []
+                
+                try:
+                    entries = self.smbClient.listPath(
+                        shareName=self.smb_share, 
+                        path=(remote_smb_path + ntpath.sep + '*')
+                    )
+                except impacket.smbconnection.SessionError as err:
+                    continue 
+                # Remove dot names
+                entries = [e for e in entries if e.get_longname() not in [".", ".."]]
+                # Sort the entries ignoring case
+                entries = sorted(entries, key=lambda x:x.get_longname().lower())
+                
+                for entry in entries:
+                    if entry.is_directory():
+                        callback(entry, path + entry.get_longname() + ntpath.sep, depth)
+                    else:
+                        callback(entry, path + entry.get_longname(), depth)
+
+                # Next directories to explore
+                for entry in entries:
+                    if entry.is_directory():
+                        next_directories_to_explore.append(path + entry.get_longname() + ntpath.sep)
+            
+            return next_directories_to_explore
+        # 
+        if callback is not None:
+            depth = 0
+            while len(paths) != 0:
+                paths = recurse_action(
+                    paths=paths,
+                    depth=depth,
+                    callback=callback
+                )
+                depth = depth + 1
+        else:
+            print("[!] SMBSession.find(), callback function cannot be None.")
+
+    def get_file(self, path=None, keepRemotePath=False):
         """
         Retrieves a file from the specified path on the SMB share.
 
         This method attempts to retrieve a file from the given path within the currently connected SMB share.
         If the path points to a directory, it skips the retrieval. It handles file retrieval by creating a local
         file object and writing the contents of the remote file to it using the SMB client's getFile method.
 
@@ -161,24 +227,30 @@
         """
 
         tmp_file_path = self.smb_cwd + ntpath.sep + path
         matches = self.smbClient.listPath(
             shareName=self.smb_share, 
             path=tmp_file_path
         )
+        
         for entry in matches:
             if entry.is_directory():
                 print("[>] Skipping '%s' because it is a directory." % tmp_file_path)
             else:
                 try:
+                    if ntpath.sep in path:
+                        outputfile = ntpath.dirname(path) + ntpath.sep + entry.get_longname()
+                    else:
+                        outputfile = entry.get_longname()
                     f = LocalFileIO(
                         mode="wb", 
-                        path=entry.get_longname(),
+                        path=outputfile,
                         expected_size=entry.get_filesize(), 
-                        debug=self.debug
+                        debug=self.config.debug,
+                        keepRemotePath=keepRemotePath
                     )
                     self.smbClient.getFile(
                         shareName=self.smb_share, 
                         pathName=tmp_file_path, 
                         callback=f.write
                     )
                     f.close()
@@ -219,15 +291,15 @@
                     print("[>] Retrieving files of '%s'" % remote_smb_path)
                 for entry_file in files:
                     if not entry_file.is_directory():
                         f = LocalFileIO(
                             mode="wb",
                             path=remote_smb_path + ntpath.sep + entry_file.get_longname(), 
                             expected_size=entry_file.get_filesize(),
-                            debug=self.debug
+                            debug=self.config.debug
                         )
                         try:
                             self.smbClient.getFile(
                                 shareName=self.smb_share, 
                                 pathName=remote_smb_path + ntpath.sep + entry_file.get_longname(), 
                                 callback=f.write
                             )
@@ -269,45 +341,73 @@
             server (bool): If True, display information about the server.
 
         Returns:
             None
         """
 
         if server:
-            print("[+] Server:")
-            print("  ├─NetBIOS:")
-            print("  │ ├─ \x1b[94mNetBIOS Hostname\x1b[0m \x1b[90m────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerName()))
-            print("  │ └─ \x1b[94mNetBIOS Domain\x1b[0m \x1b[90m──────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDomain()))
-            print("  ├─DNS:")
-            print("  │ ├─ \x1b[94mDNS Hostname\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDNSHostName()))
-            print("  │ └─ \x1b[94mDNS Domain\x1b[0m \x1b[90m──────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDNSDomainName()))
-            print("  ├─OS:")
-            print("  │ ├─ \x1b[94mOS Name\x1b[0m \x1b[90m─────────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerOS()))
-            print("  │ └─ \x1b[94mOS Version\x1b[0m \x1b[90m──────────────\x1b[0m : \x1b[93m%s.%s.%s\x1b[0m" % (self.smbClient.getServerOSMajor(), self.smbClient.getServerOSMinor(), self.smbClient.getServerOSBuild()))
-            print("  ├─Server:")
-            print("  │ ├─ \x1b[94mSigning Required\x1b[0m \x1b[90m────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.isSigningRequired()))
-            print("  │ ├─ \x1b[94mLogin Required\x1b[0m \x1b[90m──────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.isLoginRequired()))
-            print("  │ ├─ \x1b[94mSupports NTLMv2\x1b[0m \x1b[90m─────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.doesSupportNTLMv2()))
-            MaxReadSize = self.smbClient.getIOCapabilities()["MaxReadSize"]
-            print("  │ ├─ \x1b[94mMax size of read chunk\x1b[0m \x1b[90m──\x1b[0m : \x1b[93m%d bytes (%s)\x1b[0m" % (MaxReadSize, b_filesize(MaxReadSize)))
-            MaxWriteSize = self.smbClient.getIOCapabilities()["MaxWriteSize"]
-            print("  │ └─ \x1b[94mMax size of write chunk\x1b[0m \x1b[90m─\x1b[0m : \x1b[93m%d bytes (%s)\x1b[0m" % (MaxWriteSize, b_filesize(MaxWriteSize)))
-            print("  └─")
+            if self.config.no_colors:
+                print("[+] Server:")
+                print("  ├─NetBIOS:")
+                print("  │ ├─ NetBIOS Hostname ──────── : %s" % (self.smbClient.getServerName()))
+                print("  │ └─ NetBIOS Domain ────────── : %s" % (self.smbClient.getServerDomain()))
+                print("  ├─DNS:")
+                print("  │ ├─ DNS Hostname ──────────── : %s" % (self.smbClient.getServerDNSHostName()))
+                print("  │ └─ DNS Domain ────────────── : %s" % (self.smbClient.getServerDNSDomainName()))
+                print("  ├─OS:")
+                print("  │ ├─ OS Name ───────────────── : %s" % (self.smbClient.getServerOS()))
+                print("  │ └─ OS Version ────────────── : %s.%s.%s" % (self.smbClient.getServerOSMajor(), self.smbClient.getServerOSMinor(), self.smbClient.getServerOSBuild()))
+                print("  ├─Server:")
+                print("  │ ├─ Signing Required ──────── : %s" % (self.smbClient.isSigningRequired()))
+                print("  │ ├─ Login Required ────────── : %s" % (self.smbClient.isLoginRequired()))
+                print("  │ ├─ Supports NTLMv2 ───────── : %s" % (self.smbClient.doesSupportNTLMv2()))
+                MaxReadSize = self.smbClient.getIOCapabilities()["MaxReadSize"]
+                print("  │ ├─ Max size of read chunk ── : %d bytes (%s)" % (MaxReadSize, b_filesize(MaxReadSize)))
+                MaxWriteSize = self.smbClient.getIOCapabilities()["MaxWriteSize"]
+                print("  │ └─ Max size of write chunk ─ : %d bytes (%s)" % (MaxWriteSize, b_filesize(MaxWriteSize)))
+                print("  └─")
+            else:
+                print("[+] Server:")
+                print("  ├─NetBIOS:")
+                print("  │ ├─ \x1b[94mNetBIOS Hostname\x1b[0m \x1b[90m────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerName()))
+                print("  │ └─ \x1b[94mNetBIOS Domain\x1b[0m \x1b[90m──────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDomain()))
+                print("  ├─DNS:")
+                print("  │ ├─ \x1b[94mDNS Hostname\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDNSHostName()))
+                print("  │ └─ \x1b[94mDNS Domain\x1b[0m \x1b[90m──────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerDNSDomainName()))
+                print("  ├─OS:")
+                print("  │ ├─ \x1b[94mOS Name\x1b[0m \x1b[90m─────────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.getServerOS()))
+                print("  │ └─ \x1b[94mOS Version\x1b[0m \x1b[90m──────────────\x1b[0m : \x1b[93m%s.%s.%s\x1b[0m" % (self.smbClient.getServerOSMajor(), self.smbClient.getServerOSMinor(), self.smbClient.getServerOSBuild()))
+                print("  ├─Server:")
+                print("  │ ├─ \x1b[94mSigning Required\x1b[0m \x1b[90m────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.isSigningRequired()))
+                print("  │ ├─ \x1b[94mLogin Required\x1b[0m \x1b[90m──────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.isLoginRequired()))
+                print("  │ ├─ \x1b[94mSupports NTLMv2\x1b[0m \x1b[90m─────────\x1b[0m : \x1b[93m%s\x1b[0m" % (self.smbClient.doesSupportNTLMv2()))
+                MaxReadSize = self.smbClient.getIOCapabilities()["MaxReadSize"]
+                print("  │ ├─ \x1b[94mMax size of read chunk\x1b[0m \x1b[90m──\x1b[0m : \x1b[93m%d bytes (%s)\x1b[0m" % (MaxReadSize, b_filesize(MaxReadSize)))
+                MaxWriteSize = self.smbClient.getIOCapabilities()["MaxWriteSize"]
+                print("  │ └─ \x1b[94mMax size of write chunk\x1b[0m \x1b[90m─\x1b[0m : \x1b[93m%d bytes (%s)\x1b[0m" % (MaxWriteSize, b_filesize(MaxWriteSize)))
+                print("  └─")
 
         if share and self.smb_share is not None:
             share_name = self.available_shares.get(self.smb_share.lower(), "")["name"]
             share_comment = self.available_shares.get(self.smb_share.lower(), "")["comment"]
             share_type = self.available_shares.get(self.smb_share.lower(), "")["type"]
             share_type =', '.join([s.replace("STYPE_","") for s in share_type])
             share_rawtype = self.available_shares.get(self.smb_share.lower(), "")["rawtype"]
-            print("\n[+] Share:")
-            print("  ├─ \x1b[94mName\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_name))
-            print("  ├─ \x1b[94mDescription\x1b[0m \x1b[90m─────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_comment))
-            print("  ├─ \x1b[94mType\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_type))
-            print("  └─ \x1b[94mRaw type value\x1b[0m \x1b[90m──\x1b[0m : \x1b[93m%s\x1b[0m" % (share_rawtype))
+            if self.config.no_colors:
+                print("\n[+] Share:")
+                print("  ├─ Name ──────────── : %s" % (share_name))
+                print("  ├─ Description ───── : %s" % (share_comment))
+                print("  ├─ Type ──────────── : %s" % (share_type))
+                print("  └─ Raw type value ── : %s" % (share_rawtype))
+            else:
+                print("\n[+] Share:")
+                print("  ├─ \x1b[94mName\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_name))
+                print("  ├─ \x1b[94mDescription\x1b[0m \x1b[90m─────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_comment))
+                print("  ├─ \x1b[94mType\x1b[0m \x1b[90m────────────\x1b[0m : \x1b[93m%s\x1b[0m" % (share_type))
+                print("  └─ \x1b[94mRaw type value\x1b[0m \x1b[90m──\x1b[0m : \x1b[93m%s\x1b[0m" % (share_rawtype))
 
     def list_contents(self, path=None):
         """
         Lists the contents of a specified directory on the SMB share.
 
         This method retrieves the contents of a directory specified by `shareName` and `path`. If `shareName` or `path`
         is not provided, it defaults to the instance's current SMB share or path. The method returns a dictionary with
@@ -406,15 +506,15 @@
                     if err.getErrorCode() == 0xc0000035:
                         # STATUS_OBJECT_NAME_COLLISION
                         # Remote directory already created, this is normal
                         # Src: https://github.com/fortra/impacket/blob/269ce69872f0e8f2188a80addb0c39fedfa6dcb8/impacket/nt_errors.py#L268C9-L268C19
                         pass
                     else:
                         print("[!] Failed to create directory '%s': %s" % (tmp_path, err))
-                        if self.debug:
+                        if self.config.debug:
                             traceback.print_exc()
         else:
             pass
 
     def path_exists(self, path=None):
         """
         Checks if the specified path exists on the SMB share.
@@ -527,15 +627,14 @@
 
         Returns:
             bool: True if the echo command succeeds (indicating the session is active), False otherwise.
         """
 
         try:
             self.smbClient.getSMBServer().echo()
-            self.connected = True
         except Exception as e:
             self.connected = False
         return self.connected
 
     def put_file(self, localpath=None):
         """
         Uploads a single file to the SMB share.
@@ -551,29 +650,29 @@
         if os.path.exists(localpath):
             if os.path.isfile(localpath):
                 try:
                     localfile = os.path.basename(localpath)
                     f = LocalFileIO(
                         mode="rb", 
                         path=localpath, 
-                        debug=self.debug
+                        debug=self.config.debug
                     )
                     self.smbClient.putFile(
                         shareName=self.smb_share, 
                         pathName=ntpath.normpath(self.smb_cwd + ntpath.sep + localfile + ntpath.sep), 
                         callback=f.read
                     )
                     f.close()
                 except (BrokenPipeError, KeyboardInterrupt) as err:
                     print("[!] Interrupted.")
                     self.close_smb_session()
                     self.init_smb_session()
                 except Exception as err:
                     print("[!] Failed to upload '%s': %s" % (localfile, err))
-                    if self.debug:
+                    if self.config.debug:
                         traceback.print_exc()
             else:
                 print("[!] The specified localpath is a directory. Use 'put -r <directory>' instead.")
         else:
             print("[!] The specified localpath does not exist.")
 
     def put_file_recursively(self, localpath=None):
@@ -608,15 +707,15 @@
                     )
 
                     for local_file_path in local_files[local_dir_path]:
                         try:
                             f = LocalFileIO(
                                 mode="rb", 
                                 path=local_dir_path + os.path.sep + local_file_path, 
-                                debug=self.debug
+                                debug=self.config.debug
                             )
                             self.smbClient.putFile(
                                 shareName=self.smb_share, 
                                 pathName=ntpath.normpath(self.smb_cwd + ntpath.sep + remote_dir_path + ntpath.sep + local_file_path), 
                                 callback=f.read
                             )
                             f.close()
@@ -647,15 +746,15 @@
         try:
             self.smbClient.deleteDirectory(
                 shareName=self.smb_share, 
                 pathName=ntpath.normpath(self.smb_cwd + ntpath.sep + path), 
             )
         except Exception as err:
             print("[!] Failed to remove directory '%s': %s" % (path, err))
-            if self.debug:
+            if self.config.debug:
                 traceback.print_exc()
 
     def rm(self, path=None):
         """
         Removes a file from the SMB share at the specified path.
 
         This method attempts to delete a file located at the given path on the SMB share. If the operation fails,
@@ -668,15 +767,15 @@
         try:
             self.smbClient.deleteFile(
                 shareName=self.smb_share, 
                 pathName=ntpath.normpath(self.smb_cwd + ntpath.sep + path), 
             )
         except Exception as err:
             print("[!] Failed to remove file '%s': %s" % (path, err))
-            if self.debug:
+            if self.config.debug:
                 traceback.print_exc()
 
     def tree(self, path=None):
         """
         Recursively lists the directory structure of the SMB share starting from the specified path.
 
         This function prints a visual representation of the directory tree of the remote SMB share. It uses
@@ -698,77 +797,107 @@
                 entries = self.smbClient.listPath(
                     shareName=self.smb_share, 
                     path=remote_smb_path+'\\*'
                 )
             except impacket.smbconnection.SessionError as err:
                 code, const, text = err.getErrorCode(), err.getErrorString()[0], err.getErrorString()[1]
                 errmsg = "Error 0x%08x (%s): %s" % (code, const, text)
-                print("%s\x1b[1;91m%s\x1b[0m" % (''.join(prompt+[bars[2]]), errmsg))
+                if self.config.no_colors:
+                    print("%s%s" % (''.join(prompt+[bars[2]]), errmsg))
+                else:
+                    print("%s\x1b[1;91m%s\x1b[0m" % (''.join(prompt+[bars[2]]), errmsg))
                 return 
 
             entries = [e for e in entries if e.get_longname() not in [".", ".."]]
             entries = sorted(entries, key=lambda x:x.get_longname())
 
             # 
             if len(entries) > 1:
                 index = 0
                 for entry in entries:
                     index += 1
                     # This is the first entry 
                     if index == 0:
                         if entry.is_directory():
-                            print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
                             recurse_action(
                                 base_dir=base_dir, 
                                 path=path+[entry.get_longname()],
                                 prompt=prompt+["│   "]
                             )
                         else:
-                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry.get_longname()))
 
                     # This is the last entry
                     elif index == len(entries):
                         if entry.is_directory():
-                            print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
                             recurse_action(
                                 base_dir=base_dir, 
                                 path=path+[entry.get_longname()],
                                 prompt=prompt+["    "]
                             )
                         else:
-                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry.get_longname()))
                         
                     # These are entries in the middle
                     else:
                         if entry.is_directory():
-                            print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[1]]), entry.get_longname()))
                             recurse_action(
                                 base_dir=base_dir, 
                                 path=path+[entry.get_longname()],
                                 prompt=prompt+["│   "]
                             )
                         else:
-                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            if self.config.no_colors:
+                                print("%s%s" % (''.join(prompt+[bars[1]]), entry.get_longname()))
+                            else:
+                                print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry.get_longname()))
 
             # 
             elif len(entries) == 1:
                 entry = entries[0]
                 if entry.is_directory():
-                    print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                    if self.config.no_colors:
+                        print("%s%s\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                    else:
+                        print("%s\x1b[1;96m%s\x1b[0m\\" % (''.join(prompt+[bars[2]]), entry.get_longname()))
                     recurse_action(
                         base_dir=base_dir, 
                         path=path+[entry.get_longname()],
                         prompt=prompt+["    "]
                     )
                 else:
-                    print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                    if self.config.no_colors:
+                        print("%s%s" % (''.join(prompt+[bars[2]]), entry.get_longname()))
+                    else:
+                        print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry.get_longname()))
 
         # Entrypoint
         try:
-            print("\x1b[1;96m%s\x1b[0m\\" % path)
+            if self.config.no_colors:
+                print("%s\\" % path)
+            else:
+                print("\x1b[1;96m%s\x1b[0m\\" % path)
             recurse_action(
                 base_dir=self.smb_cwd, 
                 path=[path],
                 prompt=[""]
             )
         except (BrokenPipeError, KeyboardInterrupt) as e:
             print("[!] Interrupted.")
```

## smbclientng/core/utils.py

```diff
@@ -1,22 +1,42 @@
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # File name          : utils.py
 # Author             : Podalirius (@podalirius_)
 # Date created       : 23 may 2024
 
+
+import datetime
 import os
+import ntpath
 import re
 import stat
-import datetime
 
 
-# Extracted from p0dalirius/sectools library
-# Src: https://github.com/p0dalirius/sectools/blob/7bb3f5cb7815ad4d4845713c8739e2e2b0ea4e75/sectools/windows/crypto.py#L11-L24
 def parse_lm_nt_hashes(lm_nt_hashes_string):
+    """
+    Parse the input string containing LM and NT hash values and return them separately.
+
+    This function takes a string containing LM and NT hash values, typically separated by a colon (:).
+    It returns the LM and NT hash values as separate strings. If only one hash value is provided, it is
+    assumed to be the NT hash and the LM hash is set to its default value. If no valid hash values are
+    found, both return values are empty strings.
+
+    Args:
+        lm_nt_hashes_string (str): A string containing LM and NT hash values separated by a colon.
+
+    Returns:
+        tuple: A tuple containing two strings (lm_hash_value, nt_hash_value).
+               - lm_hash_value: The LM hash value or its default if not provided.
+               - nt_hash_value: The NT hash value or its default if not provided.
+    
+    Extracted from p0dalirius/sectools library
+    Src: https://github.com/p0dalirius/sectools/blob/7bb3f5cb7815ad4d4845713c8739e2e2b0ea4e75/sectools/windows/crypto.py#L11-L24
+    """
+
     lm_hash_value, nt_hash_value = "", ""
     if lm_nt_hashes_string is not None:
         matched = re.match("([0-9a-f]{32})?(:)?([0-9a-f]{32})?", lm_nt_hashes_string.strip().lower())
         m_lm_hash, m_sep, m_nt_hash = matched.groups()
         if m_lm_hash is None and m_sep is None and m_nt_hash is None:
             lm_hash_value, nt_hash_value = "", ""
         elif m_lm_hash is None and m_nt_hash is not None:
@@ -38,14 +58,15 @@
 
     Args:
         l (int): The file size in bytes.
 
     Returns:
         str: A string representing the file size in a more readable format, including the appropriate unit.
     """
+
     units = ['B','kB','MB','GB','TB','PB']
     for k in range(len(units)):
         if l < (1024**(k+1)):
             break
     return "%4.2f %s" % (round(l/(1024**(k)),2), units[k])
 
 
@@ -61,14 +82,15 @@
 
     Returns:
         str: A string of length 10 representing the Unix-style permissions (e.g., '-rwxr-xr--').
              The first character is either 'd' (directory), '-' (not a directory), followed by
              three groups of 'r', 'w', 'x' (read, write, execute permissions) for owner, group,
              and others respectively.
     """
+
     mode = os.lstat(entryname).st_mode
     permissions = []
 
     permissions.append('d' if stat.S_ISDIR(mode) else '-')
 
     permissions.append('r' if mode & stat.S_IRUSR else '-')
     permissions.append('w' if mode & stat.S_IWUSR else '-')
@@ -133,26 +155,28 @@
     if (stype_value & known_flags["STYPE_SPECIAL"]) == known_flags["STYPE_SPECIAL"]:
         flags.append("STYPE_SPECIAL")
     if (stype_value & known_flags["STYPE_TEMPORARY"]) == known_flags["STYPE_TEMPORARY"]:
         flags.append("STYPE_TEMPORARY")
     return flags
 
 
-def windows_ls_entry(entry, pathToPrint=None):
+def windows_ls_entry(entry, config, pathToPrint=None):
     """
     This function generates a metadata string based on the attributes of the provided entry object.
     
     Parameters:
         entry (object): An object representing a file or directory entry.
 
     Returns:
         str: A string representing the metadata of the entry, including attributes like directory, archive, compressed, hidden, normal, readonly, system, and temporary.
     """
     
-    if pathToPrint is None:
+    if pathToPrint is not None:
+        pathToPrint = pathToPrint + ntpath.sep + entry.get_longname()
+    else:
         pathToPrint = entry.get_longname()
 
     meta_string = ""
     meta_string += ("d" if entry.is_directory() else "-")
     meta_string += ("a" if entry.is_archive() else "-")
     meta_string += ("c" if entry.is_compressed() else "-")
     meta_string += ("h" if entry.is_hidden() else "-")
@@ -162,10 +186,139 @@
     meta_string += ("t" if entry.is_temporary() else "-")
 
     size_str = b_filesize(entry.get_filesize())
 
     date_str = datetime.datetime.fromtimestamp(entry.get_atime_epoch()).strftime("%Y-%m-%d %H:%M")
     
     if entry.is_directory():
-        print("%s %10s  %s  \x1b[1;96m%s\x1b[0m\\" % (meta_string, size_str, date_str, pathToPrint))
+        if config.no_colors:
+            print("%s %10s  %s  %s\\" % (meta_string, size_str, date_str, pathToPrint))
+        else:
+            print("%s %10s  %s  \x1b[1;96m%s\x1b[0m\\" % (meta_string, size_str, date_str, pathToPrint))
     else:
-        print("%s %10s  %s  \x1b[1m%s\x1b[0m" % (meta_string, size_str, date_str, pathToPrint))
+        if config.no_colors:
+            print("%s %10s  %s  %s" % (meta_string, size_str, date_str, pathToPrint))
+        else:
+            print("%s %10s  %s  \x1b[1m%s\x1b[0m" % (meta_string, size_str, date_str, pathToPrint))
+
+
+def local_tree(path, config):
+    """
+    This function recursively lists the contents of a directory in a tree-like format.
+
+    Parameters:
+        path (str): The path to the directory to list.
+        config (object): Configuration settings which may affect the output, such as whether to use colors.
+
+    Returns:
+        None: This function does not return anything but prints the directory tree to the console.
+    """
+
+    def recurse_action(base_dir="", path=[], prompt=[]):
+        bars = ["│   ", "├── ", "└── "]
+
+        local_path = os.path.normpath(base_dir + os.path.sep + os.path.sep.join(path) + os.path.sep)
+
+        entries = []
+        try:
+            entries = os.listdir(local_path)
+        except Exception as err:
+            if config.no_colors:
+                print("%s%s" % (''.join(prompt+[bars[2]]), err))
+            else:
+                print("%s\x1b[1;91m%s\x1b[0m" % (''.join(prompt+[bars[2]]), err))
+            return 
+
+        entries = sorted(entries)
+
+        # 
+        if len(entries) > 1:
+            index = 0
+            for entry in entries:
+                index += 1
+                # This is the first entry 
+                if index == 0:
+                    if os.path.isdir(local_path + os.path.sep + entry):
+                        if config.no_colors:
+                            print("%s%s%s" % (''.join(prompt+[bars[1]]), entry, os.path.sep))
+                        else:
+                            print("%s\x1b[1;96m%s\x1b[0m%s" % (''.join(prompt+[bars[1]]), entry, os.path.sep))
+                        recurse_action(
+                            base_dir=base_dir, 
+                            path=path+[entry],
+                            prompt=prompt+["│   "]
+                        )
+                    else:
+                        if config.no_colors:
+                            print("%s%s" % (''.join(prompt+[bars[1]]), entry))
+                        else:
+                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry))
+
+                # This is the last entry
+                elif index == len(entries):
+                    if os.path.isdir(local_path + os.path.sep + entry):
+                        if config.no_colors:
+                            print("%s%s%s" % (''.join(prompt+[bars[2]]), entry, os.path.sep))
+                        else:
+                            print("%s\x1b[1;96m%s\x1b[0m%s" % (''.join(prompt+[bars[2]]), entry, os.path.sep))
+                        recurse_action(
+                            base_dir=base_dir, 
+                            path=path+[entry],
+                            prompt=prompt+["    "]
+                        )
+                    else:
+                        if config.no_colors:
+                            print("%s%s" % (''.join(prompt+[bars[2]]), entry))
+                        else:
+                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry))
+                    
+                # These are entries in the middle
+                else:
+                    if os.path.isdir(local_path + os.path.sep + entry):
+                        if config.no_colors:
+                            print("%s%s%s" % (''.join(prompt+[bars[1]]), entry, os.path.sep))
+                        else:
+                            print("%s\x1b[1;96m%s\x1b[0m%s" % (''.join(prompt+[bars[1]]), entry, os.path.sep))
+                        recurse_action(
+                            base_dir=base_dir, 
+                            path=path+[entry],
+                            prompt=prompt+["│   "]
+                        )
+                    else:
+                        if config.no_colors:
+                            print("%s%s" % (''.join(prompt+[bars[1]]), entry))
+                        else:
+                            print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[1]]), entry))
+
+        # 
+        elif len(entries) == 1:
+            entry = entries[0]
+            if os.path.isdir(local_path + os.path.sep + entry):
+                if config.no_colors:
+                    print("%s%s%s" % (''.join(prompt+[bars[2]]), entry, os.path.sep))
+                else:
+                    print("%s\x1b[1;96m%s\x1b[0m%s" % (''.join(prompt+[bars[2]]), entry, os.path.sep))
+                recurse_action(
+                    base_dir=base_dir, 
+                    path=path+[entry],
+                    prompt=prompt+["    "]
+                )
+            else:
+                if config.no_colors:
+                    print("%s%s" % (''.join(prompt+[bars[2]]), entry))
+                else:
+                    print("%s\x1b[1m%s\x1b[0m" % (''.join(prompt+[bars[2]]), entry))
+
+    # Entrypoint
+    try:
+        if config.no_colors:
+            print("%s%s" % (path, os.path.sep))
+        else:
+            print("\x1b[1;96m%s\x1b[0m%s" % (path, os.path.sep))
+        recurse_action(
+            base_dir=os.getcwd(),
+            path=[path],
+            prompt=[""]
+        )
+    except (BrokenPipeError, KeyboardInterrupt) as e:
+        print("[!] Interrupted.")
+
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## smbclientng/modules/Find.py

```diff
@@ -19,38 +19,46 @@
 
     This class provides functionality to search for files based on various criteria in a directory hierarchy.
     """
 
     name = "find"
     description = "Search for files in a directory hierarchy"
 
-    def __init__(self, smbSession):
-        super(Find, self).__init__(smbSession)
-        self.smbSession = smbSession
-
     def parseArgs(self, arguments):
+        """
+        Parses the command line arguments provided to the module.
+
+        This method initializes the argument parser with the module's name and description, and defines all the necessary arguments that the module accepts. It then parses the provided command line arguments based on these definitions.
+
+        Args:
+            arguments (str): A string of command line arguments.
+
+        Returns:
+            ModuleArgumentParser.Namespace | None: The parsed arguments as a Namespace object if successful, None if there are no arguments or help is requested.
+        """
+
         parser = ModuleArgumentParser(prog=self.name, description=self.description)
 
         # Adding positional arguments
         parser.add_argument("paths", metavar="PATH", type=str, nargs="*", default=[], help="The starting point(s) for the search.")
 
-        # Adding tests, actions, and options for expressions (incomplete for brevity)
+        # Adding options for filtering
         parser.add_argument("-name", type=str, help="Base of file name (the path with the leading directories removed).")
         parser.add_argument("-iname", type=str, help="Like -name, but the match is case insensitive.")
         parser.add_argument("-type", type=str, default=None, help="File type (e.g., f for regular file, d for directory).")
         parser.add_argument("-size", type=str, help="File uses n units of space.")
         # parser.add_argument("-mtime", type=str, help="File's data was last modified n*24 hours ago")
         # parser.add_argument("-ctime", type=str, help="File's status was last changed n*24 hours ago")
         # parser.add_argument("-atime", type=str, help="File was last accessed n*24 hours ago")
         
         # Adding actions
         parser.add_argument("-ls", action="store_true", default=False, help="List current file in ls -dils format on standard output.")
         parser.add_argument("-download", action="store_true", default=False, help="List current file in ls -dils format on standard output.")
 
-        # Other options (incomplete for brevity)
+        # Other options
         parser.add_argument("-maxdepth", type=int, help="Descend at most levels (a non-negative integer) levels of directories below the command line arguments.")
         parser.add_argument("-mindepth", type=int, help="Do not apply any tests or actions at levels less than levels (a non-negative integer).")
 
         if len(arguments.strip()) == 0:
             parser.print_help()
             return None
         else:
@@ -59,147 +67,130 @@
         if self.options is not None:
             if len(self.options.paths) == 0:
                 parser.print_help()
                 self.options = None
 
         return self.options
 
-    def __recurse_action(self, paths=[], depth=0):
+    def __find_callback(self, entry, fullpath, depth):
+        # Documentation for __find_callback function
         """
-        Recursively searches for files in a directory hierarchy and prints the results based on specified criteria.
+        This function serves as a callback for the find operation. It applies filters based on the command line arguments
+        and decides whether to print, download, or list the entry in 'ls -dils' format if it matches the specified filters.
 
         Args:
-            base_dir (str): The base directory to start the search from.
-            paths (list): List of paths to search within the base directory.
-            depth (int): The current depth level in the directory hierarchy.
+            entry (SMBEntry): The current file or directory entry being processed.
+            fullpath (str): The full path to the entry.
 
-        Returns:
-            None
+        The function checks against filters such as file name, case sensitivity, file type, and size. If the entry matches
+        the filters, it will perform actions like printing the entry's details, downloading the entry, or listing the entry
+        based on the options provided in the command line arguments.
         """
 
-        next_directories_to_explore = []
-
-        for path in paths:
-            remote_smb_path = ntpath.normpath(self.smbSession.smb_cwd + ntpath.sep + path)
-
-            entries = []
-            try:
-                entries = self.smbSession.smbClient.listPath(
-                    shareName=self.smbSession.smb_share, 
-                    path=(remote_smb_path + ntpath.sep + '*')
-                )
-            except impacket.smbconnection.SessionError as err:
-                continue 
-            # Remove dot names
-            entries = [e for e in entries if e.get_longname() not in [".", ".."]]
-            # Sort the entries ignoring case
-            entries = sorted(entries, key=lambda x:x.get_longname().lower())
-
-            # Match and print results
-            do_print_results = True
-            if self.options.mindepth is not None:
-                if depth < self.options.mindepth:
-                    do_print_results = False
-            if self.options.maxdepth is not None:
-                if depth > self.options.maxdepth:
-                    do_print_results = False
-            
-            if do_print_results:
-                for entry in entries:
-                    do_print_entry = False
-                    # Print directory
-                    if entry.is_directory():
-                        if (self.options.type == 'd' or self.options.type is None):
-                            # No name filtering
-                            if self.options.name is None and self.options.iname is None:
+        # Match and print results
+        do_print_results = True
+        if self.options.mindepth is not None:
+            if depth < self.options.mindepth:
+                do_print_results = False
+        if self.options.maxdepth is not None:
+            if depth > self.options.maxdepth:
+                do_print_results = False
+        
+        if do_print_results:
+            do_print_entry = False
+            # Print directory
+            if entry.is_directory():
+                if (self.options.type == 'd' or self.options.type is None):
+                    # No name filtering
+                    if self.options.name is None and self.options.iname is None:
+                        do_print_entry = True
+                    
+                    # Filtering on names case sensitive
+                    elif self.options.name is not None:
+                        if '*' in self.options.name:
+                            regex = self.options.name
+                            regex = regex.replace('.', '\\.')
+                            regex = regex.replace('*', '.*')
+                            regex = '^' + regex + '$'
+                            if re.match(regex, entry.get_longname()):
                                 do_print_entry = True
-                            
-                            # Filtering on names case sensitive
-                            elif self.options.name is not None:
-                                if '*' in self.options.name:
-                                    regex = self.options.name
-                                    regex = regex.replace('.', '\\.')
-                                    regex = regex.replace('*', '.*')
-                                    regex = '^' + regex + '$'
-                                    if re.match(regex, entry.get_longname()):
-                                        do_print_entry = True
-                                    else:
-                                        do_print_entry = False
-                                else:
-                                    do_print_entry = (entry.get_longname().lower() == self.options.name.lower())
-                            
-                            # Filtering on names case insensitive  
-                            elif self.options.iname is not None:
-                                if '*' in self.options.iname:
-                                    regex = self.options.iname
-                                    regex = regex.replace('.', '\\.')
-                                    regex = regex.replace('*', '.*')
-                                    regex = '^' + regex + '$'
-                                    if re.match(regex, entry.get_longname(), re.IGNORECASE):
-                                        do_print_entry = True
-                                    else:
-                                        do_print_entry = False
-                                else:
-                                    do_print_entry = (entry.get_longname().lower() == self.options.iname.lower())
-                                    
-                    # Print file
-                    else:
-                        if (self.options.type == 'f' or self.options.type is None):
-                            # No name filtering
-                            if self.options.name is None and self.options.iname is None:
+                            else:
+                                do_print_entry = False
+                        else:
+                            do_print_entry = (entry.get_longname().lower() == self.options.name.lower())
+                    
+                    # Filtering on names case insensitive  
+                    elif self.options.iname is not None:
+                        if '*' in self.options.iname:
+                            regex = self.options.iname
+                            regex = regex.replace('.', '\\.')
+                            regex = regex.replace('*', '.*')
+                            regex = '^' + regex + '$'
+                            if re.match(regex, entry.get_longname(), re.IGNORECASE):
                                 do_print_entry = True
+                            else:
+                                do_print_entry = False
+                        else:
+                            do_print_entry = (entry.get_longname().lower() == self.options.iname.lower())
                             
-                            # Filtering on names case sensitive
-                            elif self.options.name is not None:
-                                if '*' in self.options.name:
-                                    regex = self.options.name
-                                    regex = regex.replace('.', '\\.')
-                                    regex = regex.replace('*', '.*')
-                                    regex = '^' + regex + '$'
-                                    if re.match(regex, entry.get_longname()):
-                                        do_print_entry = True
-                                    else:
-                                        do_print_entry = False
-                                else:
-                                    do_print_entry = (entry.get_longname().lower() == self.options.name.lower())
-                            
-                            # Filtering on names case insensitive
-                            elif self.options.iname is not None:
-                                if '*' in self.options.iname:
-                                    regex = self.options.iname
-                                    regex = regex.replace('.', '\\.')
-                                    regex = regex.replace('*', '.*')
-                                    regex = '^' + regex + '$'
-                                    if re.match(regex, entry.get_longname(), re.IGNORECASE):
-                                        do_print_entry = True
-                                    else:
-                                        do_print_entry = False
-                                else:
-                                    do_print_entry = (entry.get_longname().lower() == self.options.iname.lower())
-
-                    if do_print_entry:
-                        if self.options.download:
-                            pass
-                        elif self.options.ls:
-                            if entry.is_directory():
-                                windows_ls_entry(entry, (path + entry.get_longname() + ntpath.sep))
+            # Print file
+            else:
+                if (self.options.type == 'f' or self.options.type is None):
+                    # No name filtering
+                    if self.options.name is None and self.options.iname is None:
+                        do_print_entry = True
+                    
+                    # Filtering on names case sensitive
+                    elif self.options.name is not None:
+                        if '*' in self.options.name:
+                            regex = self.options.name
+                            regex = regex.replace('.', '\\.')
+                            regex = regex.replace('*', '.*')
+                            regex = '^' + regex + '$'
+                            if re.match(regex, entry.get_longname()):
+                                do_print_entry = True
                             else:
-                                windows_ls_entry(entry, (path + entry.get_longname()))
+                                do_print_entry = False
                         else:
-                            if entry.is_directory():
-                                print("%s" % (path + entry.get_longname() + ntpath.sep))
+                            do_print_entry = (entry.get_longname().lower() == self.options.name.lower())
+                    
+                    # Filtering on names case insensitive
+                    elif self.options.iname is not None:
+                        if '*' in self.options.iname:
+                            regex = self.options.iname
+                            regex = regex.replace('.', '\\.')
+                            regex = regex.replace('*', '.*')
+                            regex = '^' + regex + '$'
+                            if re.match(regex, entry.get_longname(), re.IGNORECASE):
+                                do_print_entry = True
                             else:
-                                print("%s" % (path + entry.get_longname()))
+                                do_print_entry = False
+                        else:
+                            do_print_entry = (entry.get_longname().lower() == self.options.iname.lower())
 
-            # Next directories to explore
-            for entry in entries:
-                if entry.is_directory():
-                    next_directories_to_explore.append(path + entry.get_longname() + ntpath.sep)
-        
-        return next_directories_to_explore
+            if do_print_entry:
+                # Actions on matches
+                if self.options.download:
+                    if entry.is_directory():
+                        self.smbSession.get_file_recursively(path=fullpath)
+                    else:
+                        self.smbSession.get_file(path=fullpath, keepRemotePath=True)
+                # Output formats
+                if self.options.ls:
+                    if entry.is_directory():
+                        windows_ls_entry(entry, fullpath)
+                    else:
+                        windows_ls_entry(entry, fullpath)
+                else:
+                    if entry.is_directory():
+                        print("%s" % fullpath)
+                    else:
+                        print("%s" % fullpath)
+                        
+        return None
 
     def run(self, arguments):
         """
         This function recursively searches for files in a directory hierarchy and prints the results based on specified criteria.
 
         Args:
             base_dir (str): The base directory to start the search from.
@@ -216,22 +207,18 @@
             # Entrypoint
             try:
                 next_directories_to_explore = []
                 for path in list(set(self.options.paths)):
                     next_directories_to_explore.append(ntpath.normpath(path) + ntpath.sep)
                 next_directories_to_explore = sorted(list(set(next_directories_to_explore)))
                 
-                depth = 0
-                
-                while len(next_directories_to_explore) != 0:
-                    next_directories_to_explore = self.__recurse_action(
-                        paths=next_directories_to_explore,
-                        depth=depth
-                    )
-                    depth = depth + 1
+                self.smbSession.find(
+                    paths=next_directories_to_explore,
+                    callback=self.__find_callback
+                )
 
             except (BrokenPipeError, KeyboardInterrupt) as e:
                 print("[!] Interrupted.")
                 self.smbSession.close_smb_session()
                 self.smbSession.init_smb_session()
```

## Comparing `smbclientng-1.1.dist-info/LICENSE` & `smbclientng-1.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `smbclientng-1.1.dist-info/RECORD` & `smbclientng-1.2.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,24 +1,20 @@
 smbclientng/__init__.py,sha256=ge9sWNRJ35CuAN81zIFW_xRIzSHCWHsN9oH0iLiPFOs,210
-smbclientng/__main__.py,sha256=NYSzd01t0ahoTA-AWQZNS0vf7XwIVjhavidYwhJ9vJM,3850
-smbclientng/core/CommandCompleter.py,sha256=xMlfe_AdV8Tgo59qUIRAN6SbRhzQylSyh5xbA747sr4,15054
-smbclientng/core/InteractiveShell.py,sha256=yetMkRZYsrCiIgl8AgXd8KDuWuchNE45jhQw5xSW_jw,21989
-smbclientng/core/LocalFileIO.py,sha256=6hRUhx4dQxVokad7pz38BTO8_E1GtSB2UT6B49UpJ3c,6100
-smbclientng/core/Module.py,sha256=cm61mqMnaAifNHj6_dAiMhCPbH5pgLJzGLGM0mFqYnw,1235
-smbclientng/core/ModuleArgumentParser.py,sha256=DozZxCrF2fqq1yg_9YmV94PAmPtVVGAhSZVhZ176Kzs,392
-smbclientng/core/SMBSession.py,sha256=9qteDPEDkU9GjjnT38Akk6UMgqdCa3EFOKSnF2jQKOc,37460
+smbclientng/__main__.py,sha256=Tte-tZAFY_VbS2K8z31y8Gc1QhR3XUSSj62J6FyoKwA,4798
+smbclientng/core/CommandCompleter.py,sha256=fmplYXH80WoM2HH-wBHl-dG4UBlRdRdaoNY0tOl2g1Q,18737
+smbclientng/core/Config.py,sha256=oxW2R0ii-cgkEQcZwae403ApD-BBawjfFrus6_pgENQ,1648
+smbclientng/core/InteractiveShell.py,sha256=OMEkJuagaF7GJfcIZD5fVSV_STcrF8o_lH3CPW_ram8,25098
+smbclientng/core/LocalFileIO.py,sha256=v1Fj7M3E6Dv0KZHY7Jjf4jO_zmgiYpjJ06V09u5rM3I,6374
+smbclientng/core/Module.py,sha256=40r5e7adeVu-GyYiUQnOO3FJJSs_YevNoFJdATY0VNg,1244
+smbclientng/core/ModuleArgumentParser.py,sha256=Oad1GPJjvhytdY5FEI8AoKKtcD5EkdWbylFLzHH2Tpg,1379
+smbclientng/core/SMBSession.py,sha256=K-AufbDSOFFteE-70x15tx97iSDR1xwxqd3onxZemFQ,44911
 smbclientng/core/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-smbclientng/core/utils.py,sha256=Yi6-cHRabyxuA7JSP2Zcc9tMAKhKbF4HuQb-E6lim7Q,6826
-smbclientng/modules/Find.py,sha256=Zd38GeGmbojEVgOwJqWq-lF2sF0Uh3hSBpe41H_qmNU,11355
+smbclientng/core/utils.py,sha256=ys-49MmuxD_SFRxgymXND28NzMjtNSgE0qfY_3WX1jY,13125
+smbclientng/modules/Find.py,sha256=IscLO3Xshp3dILkXCAgGEJ6RcGGpfv6tBXWh8UkK0jo,10433
+smbclientng/modules/GPPPasswords.py,sha256=ffuJv-qCa0aW37s112hytK7CuRI3OVCirI7mYLJOc3Q,13286
 smbclientng/modules/__init__.py,sha256=PXlFYE36_Ji7Hws8kLqhvy91wkCGX-f25e_oSbRbq8s,165
-smbclientng/tests/__init__.py,sha256=PXlFYE36_Ji7Hws8kLqhvy91wkCGX-f25e_oSbRbq8s,165
-smbclientng/tests/common.py,sha256=RioyQuJ1E8BpxjTb7rk8v2c_Tz20RPAyn-ZBcvihzew,1596
-smbclientng/tests/run-tests.py,sha256=YY6MtwrmYWrW-ym42I8FHZ3-nKS_MFmMoNraKXK9Jmw,640
-smbclientng/tests/test_SMBSession.py,sha256=BhXKaWOFDmnyEMqxFDSUBFlIGh5Jbgrld6XNdK9aMq8,612
-smbclientng/tests/test_SMBSession_path_isdir.py,sha256=sCZMqvGMIOHcrt33Djtm1VkvG8vQn80VqKJS8DEwVrc,1480
-smbclientng/tests/test_SMBSession_path_isfile.py,sha256=m0l3NjxJcNWTSHNhjs3T7x4bc3Ai2XHTLx2y896QWzg,1477
-smbclientng-1.1.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-smbclientng-1.1.dist-info/METADATA,sha256=3qzJlAKuRJs1HVXoAEJDw0lMcAYzVDW6jCSJJZRxD7g,543
-smbclientng-1.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-smbclientng-1.1.dist-info/entry_points.txt,sha256=QlsuQ7wGb5cmkUFD0-GEC0cNK4PBB9WHBB-6FWINAMU,58
-smbclientng-1.1.dist-info/top_level.txt,sha256=VJjSdlMZ4x0gS3FT_hseHkmqPRZv2J93r3CeP9aLBa4,12
-smbclientng-1.1.dist-info/RECORD,,
+smbclientng-1.2.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+smbclientng-1.2.dist-info/METADATA,sha256=LG6aI4_hTyjkke_TDnnCQ0Plg4hyfzioDGTbUJtJTyg,4565
+smbclientng-1.2.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+smbclientng-1.2.dist-info/entry_points.txt,sha256=CYBRfSgUSHv3OEQlvlIEiAHM8qw4BSE-qY6B9ZFNrXo,93
+smbclientng-1.2.dist-info/top_level.txt,sha256=VJjSdlMZ4x0gS3FT_hseHkmqPRZv2J93r3CeP9aLBa4,12
+smbclientng-1.2.dist-info/RECORD,,
```

