# Comparing `tmp/nuitka_winsvc-2.2.3.tar.gz` & `tmp/nuitka_winsvc-2.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "nuitka_winsvc-2.2.3.tar", last modified: Mon May 20 02:47:27 2024, max compression
+gzip compressed data, was "nuitka_winsvc-2.3.tar", last modified: Mon Jun  3 02:07:02 2024, max compression
```

## Comparing `nuitka_winsvc-2.2.3.tar` & `nuitka_winsvc-2.3.tar`

### file list

```diff
@@ -1,1842 +1,1843 @@
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:27.278778 nuitka_winsvc-2.2.3/
--rw-rw-rw-   0        0        0      235 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/Changelog.rst
--rw-rw-rw-   0        0        0   152288 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/Developer_Manual.rst
--rw-rw-rw-   0        0        0    11348 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/LICENSE.txt
--rw-rw-rw-   0        0        0     1717 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/MANIFEST.in
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:27.277689 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/
--rw-rw-rw-   0        0        0     4853 2024-05-20 02:47:20.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    78230 2024-05-20 02:47:21.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2024-05-20 02:47:20.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      308 2024-05-20 02:47:20.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0        2 2024-02-05 02:20:24.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0       35 2024-05-20 02:47:20.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/requires.txt
--rw-rw-rw-   0        0        0        7 2024-05-20 02:47:20.000000 nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/top_level.txt
--rw-rw-rw-   0        0        0     4853 2024-05-20 02:47:27.278778 nuitka_winsvc-2.2.3/PKG-INFO
--rw-rw-rw-   0        0        0     2860 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/README.md
--rw-rw-rw-   0        0        0    80812 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/README.rst
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.273268 nuitka_winsvc-2.2.3/bin/
--rw-rw-rw-   0        0        0     1166 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/autoformat-nuitka-source
--rw-rw-rw-   0        0        0     1165 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/check-nuitka-with-pylint
--rw-rw-rw-   0        0        0     1181 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/compare_with_cpython
--rw-rw-rw-   0        0        0     3105 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/compare_with_xml
--rw-rw-rw-   0        0        0     1194 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/measure-construct-performance
--rw-rw-rw-   0        0        0     1716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/nuitka
--rw-rw-rw-   0        0        0     1716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/bin/nuitka-run
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.304507 nuitka_winsvc-2.2.3/doc/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.334769 nuitka_winsvc-2.2.3/doc/Logo/
--rw-rw-rw-   0        0        0     1797 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Horizontal.svg
--rw-rw-rw-   0        0        0     1553 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Symbol.svg
--rw-rw-rw-   0        0        0     1793 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Vertical.svg
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.364298 nuitka_winsvc-2.2.3/doc/images/
--rw-rw-rw-   0        0        0     7585 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Horizontal.png
--rw-rw-rw-   0        0        0     4452 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Symbol.png
--rw-rw-rw-   0        0        0     9828 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Vertical.png
--rw-rw-rw-   0        0        0    33696 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/doc/nuitka-run.1
--rw-rw-rw-   0        0        0    33720 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/doc/nuitka.1
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.381068 nuitka_winsvc-2.2.3/lib/
--rw-rw-rw-   0        0        0     4640 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/lib/hints.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.391067 nuitka_winsvc-2.2.3/misc/
--rwxrwxrwx   0        0        0      924 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/misc/nuitka-run.bat
--rwxrwxrwx   0        0        0     1061 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/misc/nuitka.bat
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.415395 nuitka_winsvc-2.2.3/nuitka/
--rw-rw-rw-   0        0        0     7560 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Builtins.py
--rw-rw-rw-   0        0        0     5787 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/BytecodeCaching.py
--rw-rw-rw-   0        0        0     3800 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Bytecodes.py
--rw-rw-rw-   0        0        0     1855 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/CacheCleanup.py
--rw-rw-rw-   0        0        0    11181 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Constants.py
--rw-rw-rw-   0        0        0     2570 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/Errors.py
--rw-rw-rw-   0        0        0    11098 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/HardImportRegistry.py
--rw-rw-rw-   0        0        0    38106 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/MainControl.py
--rw-rw-rw-   0        0        0     8616 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/ModuleRegistry.py
--rw-rw-rw-   0        0        0    64062 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/OptionParsing.py
--rw-rw-rw-   0        0        0    76125 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/Options.py
--rw-rw-rw-   0        0        0     5432 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/OutputDirectories.py
--rw-rw-rw-   0        0        0    15000 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/PostProcessing.py
--rw-rw-rw-   0        0        0     6805 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/Progress.py
--rw-rw-rw-   0        0        0     9654 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/PythonFlavors.py
--rw-rw-rw-   0        0        0     4093 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/PythonOperators.py
--rw-rw-rw-   0        0        0    14564 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/PythonVersions.py
--rw-rw-rw-   0        0        0     8989 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Serialization.py
--rw-rw-rw-   0        0        0     4703 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/SourceCodeReferences.py
--rw-rw-rw-   0        0        0    13335 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Tracing.py
--rw-rw-rw-   0        0        0     3512 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/TreeXML.py
--rw-rw-rw-   0        0        0    15470 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/Variables.py
--rw-rw-rw-   0        0        0     2466 2024-05-20 02:39:31.000000 nuitka_winsvc-2.2.3/nuitka/Version.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/__init__.py
--rw-rw-rw-   0        0        0     6373 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/__main__.py
--rw-rw-rw-   0        0        0     5604 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/__past__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.441681 nuitka_winsvc-2.2.3/nuitka/build/
--rw-rw-rw-   0        0        0    36409 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/Backend.scons
--rw-rw-rw-   0        0        0     8583 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/CCompilerVersion.scons
--rw-rw-rw-   0        0        0     3486 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/DataComposerInterface.py
--rw-rw-rw-   0        0        0    17786 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/build/Onefile.scons
--rw-rw-rw-   0        0        0    15361 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsCaching.py
--rw-rw-rw-   0        0        0    35818 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsCompilerSettings.py
--rw-rw-rw-   0        0        0     5591 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsHacks.py
--rw-rw-rw-   0        0        0    17868 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsInterface.py
--rw-rw-rw-   0        0        0     2703 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsProgress.py
--rw-rw-rw-   0        0        0    13210 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsSpawn.py
--rw-rw-rw-   0        0        0    27035 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/SconsUtils.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.110921 nuitka_winsvc-2.2.3/nuitka/build/include/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.792606 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/
--rw-rw-rw-   0        0        0     8216 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/allocator.h
--rw-rw-rw-   0        0        0     3499 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/builtins.h
--rw-rw-rw-   0        0        0     5196 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/calling.h
--rw-rw-rw-   0        0        0     2006 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/checkers.h
--rw-rw-rw-   0        0        0     1123 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/checksum_tools.h
--rw-rw-rw-   0        0        0     9333 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_asyncgen.h
--rw-rw-rw-   0        0        0     2460 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_cell.h
--rw-rw-rw-   0        0        0     9233 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_coroutine.h
--rw-rw-rw-   0        0        0    17661 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_frame.h
--rw-rw-rw-   0        0        0     7267 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_function.h
--rw-rw-rw-   0        0        0     9189 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_generator.h
--rw-rw-rw-   0        0        0     1866 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_method.h
--rw-rw-rw-   0        0        0     7688 2024-04-22 02:58:07.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/constants.h
--rw-rw-rw-   0        0        0     1345 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/constants_blob.h
--rw-rw-rw-   0        0        0     1187 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/environment_variables.h
--rw-rw-rw-   0        0        0     1872 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/environment_variables_system.h
--rw-rw-rw-   0        0        0     5302 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/exception_groups.h
--rw-rw-rw-   0        0        0    50867 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/exceptions.h
--rw-rw-rw-   0        0        0     3792 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/filesystem_paths.h
--rw-rw-rw-   0        0        0     6474 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/freelists.h
--rw-rw-rw-   0        0        0    86326 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/hedley.h
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.254327 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/
--rw-rw-rw-   0        0        0     3698 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/attributes.h
--rw-rw-rw-   0        0        0     2692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/boolean.h
--rw-rw-rw-   0        0        0     1233 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/bytearrays.h
--rw-rw-rw-   0        0        0     1164 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/bytes.h
--rw-rw-rw-   0        0        0    11894 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/calling_generated.h
--rw-rw-rw-   0        0        0    13169 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_eq.h
--rw-rw-rw-   0        0        0    10645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_ge.h
--rw-rw-rw-   0        0        0    10644 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_gt.h
--rw-rw-rw-   0        0        0    13169 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_le.h
--rw-rw-rw-   0        0        0    13168 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_lt.h
--rw-rw-rw-   0        0        0    10645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_ne.h
--rw-rw-rw-   0        0        0     1834 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/complex.h
--rw-rw-rw-   0        0        0    13606 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/dictionaries.h
--rw-rw-rw-   0        0        0     1235 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/floats.h
--rw-rw-rw-   0        0        0     4401 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/import_hard.h
--rw-rw-rw-   0        0        0     1827 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/indexes.h
--rw-rw-rw-   0        0        0     3625 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/ints.h
--rw-rw-rw-   0        0        0     9599 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/iterators.h
--rw-rw-rw-   0        0        0     3678 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/lists.h
--rw-rw-rw-   0        0        0     1662 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/lists_generated.h
--rw-rw-rw-   0        0        0     1386 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/mappings.h
--rw-rw-rw-   0        0        0     4671 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations.h
--rw-rw-rw-   0        0        0    12714 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_add.h
--rw-rw-rw-   0        0        0     5692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitand.h
--rw-rw-rw-   0        0        0     5670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitor.h
--rw-rw-rw-   0        0        0     5692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitxor.h
--rw-rw-rw-   0        0        0     5451 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_divmod.h
--rw-rw-rw-   0        0        0     5489 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_floordiv.h
--rw-rw-rw-   0        0        0     5144 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_lshift.h
--rw-rw-rw-   0        0        0     2828 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_matmult.h
--rw-rw-rw-   0        0        0    15807 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_mod.h
--rw-rw-rw-   0        0        0    13239 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_mult.h
--rw-rw-rw-   0        0        0     5820 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_olddiv.h
--rw-rw-rw-   0        0        0     4743 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_pow.h
--rw-rw-rw-   0        0        0     5144 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_rshift.h
--rw-rw-rw-   0        0        0     5853 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_sub.h
--rw-rw-rw-   0        0        0     5467 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_truediv.h
--rw-rw-rw-   0        0        0    20173 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_builtin_types.h
--rw-rw-rw-   0        0        0     8699 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_add.h
--rw-rw-rw-   0        0        0     3796 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitand.h
--rw-rw-rw-   0        0        0     3782 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitor.h
--rw-rw-rw-   0        0        0     3796 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitxor.h
--rw-rw-rw-   0        0        0     4875 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_floordiv.h
--rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_lshift.h
--rw-rw-rw-   0        0        0     2756 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_matmult.h
--rw-rw-rw-   0        0        0    10655 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_mod.h
--rw-rw-rw-   0        0        0     9230 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_mult.h
--rw-rw-rw-   0        0        0     5176 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_olddiv.h
--rw-rw-rw-   0        0        0     4378 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_pow.h
--rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_rshift.h
--rw-rw-rw-   0        0        0     5004 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_sub.h
--rw-rw-rw-   0        0        0     4855 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_truediv.h
--rw-rw-rw-   0        0        0     4072 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/raising.h
--rw-rw-rw-   0        0        0     2367 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/rangeobjects.h
--rw-rw-rw-   0        0        0     1175 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/richcomparisons.h
--rw-rw-rw-   0        0        0     1141 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/sequences.h
--rw-rw-rw-   0        0        0     1054 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/sets.h
--rw-rw-rw-   0        0        0     8750 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/slices.h
--rw-rw-rw-   0        0        0     1363 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/strings.h
--rw-rw-rw-   0        0        0    17975 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/subscripts.h
--rw-rw-rw-   0        0        0     5926 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/tuples.h
--rw-rw-rw-   0        0        0    16773 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helpers.h
--rw-rw-rw-   0        0        0     6050 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/importing.h
--rw-rw-rw-   0        0        0    12979 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/incbin.h
--rw-rw-rw-   0        0        0     1086 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/jit_sources.h
--rw-rw-rw-   0        0        0    16556 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/prelude.h
--rw-rw-rw-   0        0        0     3239 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/printing.h
--rw-rw-rw-   0        0        0     1811 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/python_pgo.h
--rw-rw-rw-   0        0        0     2343 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/safe_string_ops.h
--rw-rw-rw-   0        0        0     3729 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/threading.h
--rw-rw-rw-   0        0        0     3447 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/tracing.h
--rw-rw-rw-   0        0        0     1145 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/type_aliases.h
--rw-rw-rw-   0        0        0     3135 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/unfreezing.h
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.125870 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.261341 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/appdirs/
--rw-rw-rw-   0        0        0     1097 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/appdirs/LICENSE.txt
--rw-rw-rw-   0        0        0    24824 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/appdirs/appdirs.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.264333 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/atomicwrites/
--rw-rw-rw-   0        0        0     1069 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/atomicwrites/LICENSE
--rw-rw-rw-   0        0        0     6794 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/atomicwrites/atomicwrites.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.265327 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/bin/
--rw-rw-rw-   0        0        0     1695 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/bin/scons.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.112869 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.268326 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/
--rw-rw-rw-   0        0        0     1585 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/LICENSE
--rw-rw-rw-   0        0        0       93 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/__init__.py
--rw-rw-rw-   0        0        0    65424 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/caching.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.269326 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/
--rw-rw-rw-   0        0        0     1491 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/LICENSE.txt
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.272326 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/
--rw-rw-rw-   0        0        0      243 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/__init__.py
--rw-rw-rw-   0        0        0     2522 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/ansi.py
--rw-rw-rw-   0        0        0    10517 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/ansitowin32.py
--rw-rw-rw-   0        0        0     1915 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/initialise.py
--rw-rw-rw-   0        0        0     5404 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/win32.py
--rw-rw-rw-   0        0        0     6438 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/winterm.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.273327 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/
--rw-rw-rw-   0        0        0     1359 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/LICENSE
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.284327 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/
--rw-rw-rw-   0        0        0       82 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/__init__.py
--rw-rw-rw-   0        0        0     6859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/compat.py
--rw-rw-rw-   0        0        0     4463 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/fnmatch.py
--rw-rw-rw-   0        0        0     8304 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/impl.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.296328 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/
--rw-rw-rw-   0        0        0     1467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/LICENSE.rst
--rw-rw-rw-   0        0        0       85 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/README.rst
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.313328 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/
--rw-rw-rw-   0        0        0     2423 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/__init__.py
--rw-rw-rw-   0        0        0     2685 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/_compat.py
--rw-rw-rw-   0        0        0     1726 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/_identifier.py
--rw-rw-rw-   0        0        0    12719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/bccache.py
--rw-rw-rw-   0        0        0    65386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/compiler.py
--rw-rw-rw-   0        0        0     1626 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/constants.py
--rw-rw-rw-   0        0        0    12281 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/debug.py
--rw-rw-rw-   0        0        0     1400 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/defaults.py
--rw-rw-rw-   0        0        0    50849 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/environment.py
--rw-rw-rw-   0        0        0     4428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/exceptions.py
--rw-rw-rw-   0        0        0    24500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/ext.py
--rw-rw-rw-   0        0        0    36528 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/filters.py
--rw-rw-rw-   0        0        0     9197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/idtracking.py
--rw-rw-rw-   0        0        0    28559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/lexer.py
--rw-rw-rw-   0        0        0    17473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/loaders.py
--rw-rw-rw-   0        0        0     4340 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/meta.py
--rw-rw-rw-   0        0        0     7308 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/nativetypes.py
--rw-rw-rw-   0        0        0    30853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/nodes.py
--rw-rw-rw-   0        0        0     1722 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/optimizer.py
--rw-rw-rw-   0        0        0    35875 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/parser.py
--rw-rw-rw-   0        0        0    27644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/runtime.py
--rw-rw-rw-   0        0        0    17080 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/sandbox.py
--rw-rw-rw-   0        0        0     4214 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/tests.py
--rw-rw-rw-   0        0        0    20501 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/utils.py
--rw-rw-rw-   0        0        0     3316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/visitor.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.325329 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/
--rw-rw-rw-   0        0        0     1466 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/LICENSE.rst
--rw-rw-rw-   0        0        0       84 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/README.rst
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.339330 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/
--rw-rw-rw-   0        0        0     2616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/__init__.py
--rw-rw-rw-   0        0        0     2685 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_compat.py
--rw-rw-rw-   0        0        0     1726 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_identifier.py
--rw-rw-rw-   0        0        0    12719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/bccache.py
--rw-rw-rw-   0        0        0    65386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/compiler.py
--rw-rw-rw-   0        0        0     1626 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/constants.py
--rw-rw-rw-   0        0        0    12281 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/debug.py
--rw-rw-rw-   0        0        0     1400 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/defaults.py
--rw-rw-rw-   0        0        0    50849 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/environment.py
--rw-rw-rw-   0        0        0     4428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/exceptions.py
--rw-rw-rw-   0        0        0    24500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/ext.py
--rw-rw-rw-   0        0        0    36528 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/filters.py
--rw-rw-rw-   0        0        0     9197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/idtracking.py
--rw-rw-rw-   0        0        0    28559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/lexer.py
--rw-rw-rw-   0        0        0    17474 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/loaders.py
--rw-rw-rw-   0        0        0     4340 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/meta.py
--rw-rw-rw-   0        0        0     7308 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nativetypes.py
--rw-rw-rw-   0        0        0    30853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nodes.py
--rw-rw-rw-   0        0        0     1722 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/optimizer.py
--rw-rw-rw-   0        0        0    35875 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/parser.py
--rw-rw-rw-   0        0        0    27644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/runtime.py
--rw-rw-rw-   0        0        0    17080 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/sandbox.py
--rw-rw-rw-   0        0        0     4214 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/tests.py
--rw-rw-rw-   0        0        0    20501 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/utils.py
--rw-rw-rw-   0        0        0     3316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/visitor.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.120869 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.115870 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.351329 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/
--rw-rw-rw-   0        0        0    47844 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Action.py
--rw-rw-rw-   0        0        0    33996 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Builder.py
--rw-rw-rw-   0        0        0     8083 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/CacheDir.py
--rw-rw-rw-   0        0        0    27693 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Conftest.py
--rw-rw-rw-   0        0        0     6938 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Debug.py
--rw-rw-rw-   0        0        0    17622 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Defaults.py
--rw-rw-rw-   0        0        0    96183 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Environment.py
--rw-rw-rw-   0        0        0     7358 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Errors.py
--rw-rw-rw-   0        0        0    21540 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Executor.py
--rw-rw-rw-   0        0        0    16000 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Job.py
--rw-rw-rw-   0        0        0     9589 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Memoize.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.353331 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/
--rw-rw-rw-   0        0        0     4197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Alias.py
--rw-rw-rw-   0        0        0   121420 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/FS.py
--rw-rw-rw-   0        0        0     4164 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Python.py
--rw-rw-rw-   0        0        0    49503 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.356330 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/
--rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/BoolOption.py
--rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/EnumOption.py
--rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/ListOption.py
--rw-rw-rw-   0        0        0     1965 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PackageOption.py
--rw-rw-rw-   0        0        0     2736 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PathOption.py
--rw-rw-rw-   0        0        0     2614 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/__init__.py
--rw-rw-rw-   0        0        0     8467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/PathList.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.361330 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/
--rw-rw-rw-   0        0        0     9314 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/__init__.py
--rw-rw-rw-   0        0        0     3131 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/aix.py
--rw-rw-rw-   0        0        0     1989 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/cygwin.py
--rw-rw-rw-   0        0        0     2483 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/darwin.py
--rw-rw-rw-   0        0        0     1718 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/hpux.py
--rw-rw-rw-   0        0        0     1605 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/irix.py
--rw-rw-rw-   0        0        0     2170 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/os2.py
--rw-rw-rw-   0        0        0     4179 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/posix.py
--rw-rw-rw-   0        0        0     1882 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/sunos.py
--rw-rw-rw-   0        0        0    15042 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/win32.py
--rw-rw-rw-   0        0        0    39700 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConf.py
--rw-rw-rw-   0        0        0    12950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConsign.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.363330 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/
--rw-rw-rw-   0        0        0     4810 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/C.py
--rw-rw-rw-   0        0        0     3751 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Dir.py
--rw-rw-rw-   0        0        0     3233 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Prog.py
--rw-rw-rw-   0        0        0     2011 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/RC.py
--rw-rw-rw-   0        0        0    14663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.366330 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/
--rw-rw-rw-   0        0        0    14029 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Interactive.py
--rw-rw-rw-   0        0        0    52665 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Main.py
--rw-rw-rw-   0        0        0    40719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConsOptions.py
--rw-rw-rw-   0        0        0    24133 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConscript.py
--rw-rw-rw-   0        0        0    14053 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/__init__.py
--rw-rw-rw-   0        0        0     2305 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Sig.py
--rw-rw-rw-   0        0        0    34903 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Subst.py
--rw-rw-rw-   0        0        0    40510 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Taskmaster.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.403332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/
--rw-rw-rw-   0        0        0     2166 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/386asm.py
--rw-rw-rw-   0        0        0     2433 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/BitKeeper.py
--rw-rw-rw-   0        0        0     2859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/CVS.py
--rw-rw-rw-   0        0        0    18084 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/GettextCommon.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.407331 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/
--rw-rw-rw-   0        0        0     2078 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/__init__.py
--rw-rw-rw-   0        0        0     2004 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/arch.py
--rw-rw-rw-   0        0        0     9248 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/common.py
--rw-rw-rw-   0        0        0     2784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/netframework.py
--rw-rw-rw-   0        0        0    14869 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/sdk.py
--rw-rw-rw-   0        0        0    19499 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vc.py
--rw-rw-rw-   0        0        0    20832 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vs.py
--rw-rw-rw-   0        0        0     3763 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Perforce.py
--rw-rw-rw-   0        0        0     5149 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/PharLapCommon.py
--rw-rw-rw-   0        0        0     2290 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/RCS.py
--rw-rw-rw-   0        0        0     2328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/SCCS.py
--rw-rw-rw-   0        0        0     2657 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Subversion.py
--rw-rw-rw-   0        0        0    31283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/__init__.py
--rw-rw-rw-   0        0        0     2379 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixc++.py
--rw-rw-rw-   0        0        0     2267 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixcc.py
--rw-rw-rw-   0        0        0     2681 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixf77.py
--rw-rw-rw-   0        0        0     2720 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixlink.py
--rw-rw-rw-   0        0        0     2796 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/applelink.py
--rw-rw-rw-   0        0        0     2147 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ar.py
--rw-rw-rw-   0        0        0     2936 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/as.py
--rw-rw-rw-   0        0        0     2935 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/bcc32.py
--rw-rw-rw-   0        0        0     3432 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/c++.py
--rw-rw-rw-   0        0        0     3785 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cc.py
--rw-rw-rw-   0        0        0     2777 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cyglink.py
--rw-rw-rw-   0        0        0     1711 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/default.py
--rw-rw-rw-   0        0        0      142 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/dmd.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.408332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/
--rw-rw-rw-   0        0        0    29618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/__init__.py
--rw-rw-rw-   0        0        0     3428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/filesystem.py
--rw-rw-rw-   0        0        0     2681 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g++.py
--rw-rw-rw-   0        0        0     2433 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g77.py
--rw-rw-rw-   0        0        0     1844 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gas.py
--rw-rw-rw-   0        0        0     3472 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gcc.py
--rw-rw-rw-   0        0        0     4782 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gdc.py
--rw-rw-rw-   0        0        0     2025 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gettext.py
--rw-rw-rw-   0        0        0     2256 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gfortran.py
--rw-rw-rw-   0        0        0     2460 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gnulink.py
--rw-rw-rw-   0        0        0     2639 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpc++.py
--rw-rw-rw-   0        0        0     1810 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpcc.py
--rw-rw-rw-   0        0        0     2333 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hplink.py
--rw-rw-rw-   0        0        0     2140 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icc.py
--rw-rw-rw-   0        0        0     1902 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icl.py
--rw-rw-rw-   0        0        0     2077 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink.py
--rw-rw-rw-   0        0        0     2043 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink32.py
--rw-rw-rw-   0        0        0    18600 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/install.py
--rw-rw-rw-   0        0        0    25816 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/intelc.py
--rw-rw-rw-   0        0        0     3328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/lex.py
--rw-rw-rw-   0        0        0     8394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/link.py
--rw-rw-rw-   0        0        0     3953 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/linkloc.py
--rw-rw-rw-   0        0        0     2309 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/m4.py
--rw-rw-rw-   0        0        0     2945 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/masm.py
--rw-rw-rw-   0        0        0     6919 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mingw.py
--rw-rw-rw-   0        0        0     4381 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgfmt.py
--rw-rw-rw-   0        0        0     4658 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msginit.py
--rw-rw-rw-   0        0        0     4224 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgmerge.py
--rw-rw-rw-   0        0        0     2168 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslib.py
--rw-rw-rw-   0        0        0    13881 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslink.py
--rw-rw-rw-   0        0        0     1804 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mssdk.py
--rw-rw-rw-   0        0        0    11380 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvc.py
--rw-rw-rw-   0        0        0    72761 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvs.py
--rw-rw-rw-   0        0        0     6841 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwcc.py
--rw-rw-rw-   0        0        0     3579 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwld.py
--rw-rw-rw-   0        0        0     2618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/nasm.py
--rw-rw-rw-   0        0        0     4375 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rmic.py
--rw-rw-rw-   0        0        0     2827 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rpcgen.py
--rw-rw-rw-   0        0        0     2513 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgiar.py
--rw-rw-rw-   0        0        0     1991 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgic++.py
--rw-rw-rw-   0        0        0     1819 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgicc.py
--rw-rw-rw-   0        0        0     2123 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgilink.py
--rw-rw-rw-   0        0        0     2502 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunar.py
--rw-rw-rw-   0        0        0     4695 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunc++.py
--rw-rw-rw-   0        0        0     1927 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/suncc.py
--rw-rw-rw-   0        0        0     2349 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunlink.py
--rw-rw-rw-   0        0        0     2473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tar.py
--rw-rw-rw-   0        0        0     5992 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/textfile.py
--rw-rw-rw-   0        0        0     1831 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tlib.py
--rw-rw-rw-   0        0        0     3730 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/wix.py
--rw-rw-rw-   0        0        0    13016 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/xgettext.py
--rw-rw-rw-   0        0        0     3415 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/zip.py
--rw-rw-rw-   0        0        0    48938 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Util.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.411332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/
--rw-rw-rw-   0        0        0     3007 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/BoolVariable.py
--rw-rw-rw-   0        0        0     3784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/EnumVariable.py
--rw-rw-rw-   0        0        0     4380 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/ListVariable.py
--rw-rw-rw-   0        0        0     3557 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PackageVariable.py
--rw-rw-rw-   0        0        0     5612 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PathVariable.py
--rw-rw-rw-   0        0        0    11034 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/__init__.py
--rw-rw-rw-   0        0        0     6824 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Warnings.py
--rw-rw-rw-   0        0        0     1563 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.415331 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/
--rw-rw-rw-   0        0        0     8120 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/__init__.py
--rw-rw-rw-   0        0        0     3596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_builtins.py
--rw-rw-rw-   0        0        0     1818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_collections.py
--rw-rw-rw-   0        0        0     1742 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_dbm.py
--rw-rw-rw-   0        0        0     2465 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_hashlib.py
--rw-rw-rw-   0        0        0     1776 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_io.py
--rw-rw-rw-   0        0        0    19253 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_sets.py
--rw-rw-rw-   0        0        0    44500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_subprocess.py
--rw-rw-rw-   0        0        0    19664 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/cpp.py
--rw-rw-rw-   0        0        0     7509 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/dblite.py
--rw-rw-rw-   0        0        0     2107 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/exitfuncs.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.117870 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.428333 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/
--rw-rw-rw-   0        0        0    53545 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Action.py
--rw-rw-rw-   0        0        0    34985 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Builder.py
--rw-rw-rw-   0        0        0    13596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/CacheDir.py
--rw-rw-rw-   0        0        0    28403 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Conftest.py
--rw-rw-rw-   0        0        0     7533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Debug.py
--rw-rw-rw-   0        0        0    20988 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Defaults.py
--rw-rw-rw-   0        0        0    96818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Environment.py
--rw-rw-rw-   0        0        0     7752 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Errors.py
--rw-rw-rw-   0        0        0    22350 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Executor.py
--rw-rw-rw-   0        0        0    16068 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Job.py
--rw-rw-rw-   0        0        0     9565 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Memoize.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.430333 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/
--rw-rw-rw-   0        0        0     5239 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Alias.py
--rw-rw-rw-   0        0        0   135413 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/FS.py
--rw-rw-rw-   0        0        0     5758 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Python.py
--rw-rw-rw-   0        0        0    63474 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/__init__.py
--rw-rw-rw-   0        0        0     8354 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/PathList.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.436332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/
--rw-rw-rw-   0        0        0    11500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/__init__.py
--rw-rw-rw-   0        0        0     3180 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/aix.py
--rw-rw-rw-   0        0        0     2227 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/cygwin.py
--rw-rw-rw-   0        0        0     2739 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/darwin.py
--rw-rw-rw-   0        0        0     1767 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/hpux.py
--rw-rw-rw-   0        0        0     1654 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/irix.py
--rw-rw-rw-   0        0        0     1460 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/mingw.py
--rw-rw-rw-   0        0        0     2219 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/os2.py
--rw-rw-rw-   0        0        0     4476 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/posix.py
--rw-rw-rw-   0        0        0     1931 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/sunos.py
--rw-rw-rw-   0        0        0     4003 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/virtualenv.py
--rw-rw-rw-   0        0        0    17055 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/win32.py
--rw-rw-rw-   0        0        0    41186 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConf.py
--rw-rw-rw-   0        0        0    13880 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConsign.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.438332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/
--rw-rw-rw-   0        0        0     4853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/C.py
--rw-rw-rw-   0        0        0     3812 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Dir.py
--rw-rw-rw-   0        0        0     3643 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Prog.py
--rw-rw-rw-   0        0        0     2328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/RC.py
--rw-rw-rw-   0        0        0    15053 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.441332 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/
--rw-rw-rw-   0        0        0    13779 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Interactive.py
--rw-rw-rw-   0        0        0    53260 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Main.py
--rw-rw-rw-   0        0        0    39394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConsOptions.py
--rw-rw-rw-   0        0        0    26467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConscript.py
--rw-rw-rw-   0        0        0    14489 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/__init__.py
--rw-rw-rw-   0        0        0    35863 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Subst.py
--rw-rw-rw-   0        0        0    42204 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Taskmaster.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.475392 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/
--rw-rw-rw-   0        0        0     2211 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/386asm.py
--rw-rw-rw-   0        0        0    18207 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/GettextCommon.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.479394 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/
--rw-rw-rw-   0        0        0     2152 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/__init__.py
--rw-rw-rw-   0        0        0     2057 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/arch.py
--rw-rw-rw-   0        0        0    10674 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/common.py
--rw-rw-rw-   0        0        0     2855 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/netframework.py
--rw-rw-rw-   0        0        0    15165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/sdk.py
--rw-rw-rw-   0        0        0    33537 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vc.py
--rw-rw-rw-   0        0        0    21762 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vs.py
--rw-rw-rw-   0        0        0     4464 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/PharLapCommon.py
--rw-rw-rw-   0        0        0    50660 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/__init__.py
--rw-rw-rw-   0        0        0     1667 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixc++.py
--rw-rw-rw-   0        0        0     2316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcc.py
--rw-rw-rw-   0        0        0     2475 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcxx.py
--rw-rw-rw-   0        0        0     2840 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixlink.py
--rw-rw-rw-   0        0        0     8618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/applelink.py
--rw-rw-rw-   0        0        0     2226 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ar.py
--rw-rw-rw-   0        0        0     2978 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/as.py
--rw-rw-rw-   0        0        0     2977 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/bcc32.py
--rw-rw-rw-   0        0        0     1653 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/c++.py
--rw-rw-rw-   0        0        0     3827 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cc.py
--rw-rw-rw-   0        0        0     3389 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clang.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.480393 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangCommon/
--rw-rw-rw-   0        0        0      313 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangCommon/__init__.py
--rw-rw-rw-   0        0        0     3631 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangxx.py
--rw-rw-rw-   0        0        0     3444 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cxx.py
--rw-rw-rw-   0        0        0     8494 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cyglink.py
--rw-rw-rw-   0        0        0     1753 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/default.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.480393 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/
--rw-rw-rw-   0        0        0    29765 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/__init__.py
--rw-rw-rw-   0        0        0     3472 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/filesystem.py
--rw-rw-rw-   0        0        0     1630 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/g++.py
--rw-rw-rw-   0        0        0     1977 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gas.py
--rw-rw-rw-   0        0        0     3686 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gcc.py
--rw-rw-rw-   0        0        0     2580 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gettext_tool.py
--rw-rw-rw-   0        0        0     2948 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gnulink.py
--rw-rw-rw-   0        0        0     2655 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gxx.py
--rw-rw-rw-   0        0        0     1645 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpc++.py
--rw-rw-rw-   0        0        0     1859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcc.py
--rw-rw-rw-   0        0        0     2765 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcxx.py
--rw-rw-rw-   0        0        0     2386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hplink.py
--rw-rw-rw-   0        0        0     2189 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icc.py
--rw-rw-rw-   0        0        0     1944 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icl.py
--rw-rw-rw-   0        0        0     2123 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink.py
--rw-rw-rw-   0        0        0     2085 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink32.py
--rw-rw-rw-   0        0        0    15791 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/install.py
--rw-rw-rw-   0        0        0    26195 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/intelc.py
--rw-rw-rw-   0        0        0    13924 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/link.py
--rw-rw-rw-   0        0        0     4041 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/linkloc.py
--rw-rw-rw-   0        0        0     2351 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/m4.py
--rw-rw-rw-   0        0        0     2987 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/masm.py
--rw-rw-rw-   0        0        0     7808 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mingw.py
--rw-rw-rw-   0        0        0     4956 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgfmt.py
--rw-rw-rw-   0        0        0     5235 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msginit.py
--rw-rw-rw-   0        0        0     4808 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgmerge.py
--rw-rw-rw-   0        0        0     2475 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslib.py
--rw-rw-rw-   0        0        0    14751 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslink.py
--rw-rw-rw-   0        0        0     1847 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mssdk.py
--rw-rw-rw-   0        0        0    12588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvc.py
--rw-rw-rw-   0        0        0    82939 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvs.py
--rw-rw-rw-   0        0        0     6883 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwcc.py
--rw-rw-rw-   0        0        0     3663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwld.py
--rw-rw-rw-   0        0        0     2660 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/nasm.py
--rw-rw-rw-   0        0        0     4904 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rmic.py
--rw-rw-rw-   0        0        0     2877 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rpcgen.py
--rw-rw-rw-   0        0        0     2567 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgiar.py
--rw-rw-rw-   0        0        0     1652 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgic++.py
--rw-rw-rw-   0        0        0     1868 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicc.py
--rw-rw-rw-   0        0        0     2088 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicxx.py
--rw-rw-rw-   0        0        0     2176 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgilink.py
--rw-rw-rw-   0        0        0     2366 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunar.py
--rw-rw-rw-   0        0        0     1658 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunc++.py
--rw-rw-rw-   0        0        0     1976 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncc.py
--rw-rw-rw-   0        0        0     5335 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncxx.py
--rw-rw-rw-   0        0        0     2583 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunlink.py
--rw-rw-rw-   0        0        0     2515 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tar.py
--rw-rw-rw-   0        0        0     6756 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/textfile.py
--rw-rw-rw-   0        0        0     1873 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tlib.py
--rw-rw-rw-   0        0        0     3773 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/wix.py
--rw-rw-rw-   0        0        0    13982 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/xgettext.py
--rw-rw-rw-   0        0        0     3201 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/zip.py
--rw-rw-rw-   0        0        0    53803 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Util.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.483393 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/
--rw-rw-rw-   0        0        0     3064 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/BoolVariable.py
--rw-rw-rw-   0        0        0     3818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/EnumVariable.py
--rw-rw-rw-   0        0        0     4435 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/ListVariable.py
--rw-rw-rw-   0        0        0     3643 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PackageVariable.py
--rw-rw-rw-   0        0        0     5579 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PathVariable.py
--rw-rw-rw-   0        0        0    11655 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/__init__.py
--rw-rw-rw-   0        0        0     6504 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Warnings.py
--rw-rw-rw-   0        0        0     1647 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.484393 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/
--rw-rw-rw-   0        0        0     6869 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/__init__.py
--rw-rw-rw-   0        0        0     1784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/_scons_dbm.py
--rw-rw-rw-   0        0        0    19816 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/cpp.py
--rw-rw-rw-   0        0        0     9002 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/dblite.py
--rw-rw-rw-   0        0        0     2149 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/exitfuncs.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.120869 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.505393 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/
--rw-rw-rw-   0        0        0    56578 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Action.py
--rw-rw-rw-   0        0        0    35213 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Builder.py
--rw-rw-rw-   0        0        0    11061 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/CacheDir.py
--rw-rw-rw-   0        0        0    27408 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Conftest.py
--rw-rw-rw-   0        0        0     7884 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Debug.py
--rw-rw-rw-   0        0        0    21423 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Defaults.py
--rw-rw-rw-   0        0        0    97269 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Environment.py
--rw-rw-rw-   0        0        0     3979 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/EnvironmentValues.py
--rw-rw-rw-   0        0        0     7515 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Errors.py
--rw-rw-rw-   0        0        0    21937 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Executor.py
--rw-rw-rw-   0        0        0    16583 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Job.py
--rw-rw-rw-   0        0        0     9430 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Memoize.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.508394 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/
--rw-rw-rw-   0        0        0     5126 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Alias.py
--rw-rw-rw-   0        0        0   136271 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/FS.py
--rw-rw-rw-   0        0        0     6167 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Python.py
--rw-rw-rw-   0        0        0    63768 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/__init__.py
--rw-rw-rw-   0        0        0     8183 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/PathList.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.515396 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/
--rw-rw-rw-   0        0        0    12836 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/__init__.py
--rw-rw-rw-   0        0        0     3087 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/aix.py
--rw-rw-rw-   0        0        0     2107 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/cygwin.py
--rw-rw-rw-   0        0        0     2630 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/darwin.py
--rw-rw-rw-   0        0        0     1674 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/hpux.py
--rw-rw-rw-   0        0        0     1536 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/irix.py
--rw-rw-rw-   0        0        0     1311 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/mingw.py
--rw-rw-rw-   0        0        0     2076 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/os2.py
--rw-rw-rw-   0        0        0     4356 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/posix.py
--rw-rw-rw-   0        0        0     1805 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/sunos.py
--rw-rw-rw-   0        0        0     3860 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/virtualenv.py
--rw-rw-rw-   0        0        0    14831 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/win32.py
--rw-rw-rw-   0        0        0    41983 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConf.py
--rw-rw-rw-   0        0        0    14673 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConsign.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.518395 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/
--rw-rw-rw-   0        0        0     7394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/C.py
--rw-rw-rw-   0        0        0     4357 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Dir.py
--rw-rw-rw-   0        0        0     3546 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Prog.py
--rw-rw-rw-   0        0        0     1972 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/RC.py
--rw-rw-rw-   0        0        0    15577 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.521396 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/
--rw-rw-rw-   0        0        0    13597 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Interactive.py
--rw-rw-rw-   0        0        0    53509 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Main.py
--rw-rw-rw-   0        0        0    42760 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConsOptions.py
--rw-rw-rw-   0        0        0    26676 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConscript.py
--rw-rw-rw-   0        0        0    14272 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/__init__.py
--rw-rw-rw-   0        0        0    36753 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Subst.py
--rw-rw-rw-   0        0        0    41191 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Taskmaster.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.558395 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/
--rw-rw-rw-   0        0        0     2122 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/386asm.py
--rw-rw-rw-   0        0        0    15570 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/GettextCommon.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.564397 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/
--rw-rw-rw-   0        0        0     2014 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/__init__.py
--rw-rw-rw-   0        0        0     1943 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/arch.py
--rw-rw-rw-   0        0        0    13182 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/common.py
--rw-rw-rw-   0        0        0     2734 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/netframework.py
--rw-rw-rw-   0        0        0    15027 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/sdk.py
--rw-rw-rw-   0        0        0    38783 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vc.py
--rw-rw-rw-   0        0        0    22570 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vs.py
--rw-rw-rw-   0        0        0     4368 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/PharLapCommon.py
--rw-rw-rw-   0        0        0    32724 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/__init__.py
--rw-rw-rw-   0        0        0     1578 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixc++.py
--rw-rw-rw-   0        0        0     2228 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcc.py
--rw-rw-rw-   0        0        0     2386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcxx.py
--rw-rw-rw-   0        0        0     2616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixlink.py
--rw-rw-rw-   0        0        0     7993 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/applelink.py
--rw-rw-rw-   0        0        0     2141 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ar.py
--rw-rw-rw-   0        0        0     1661 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/as.py
--rw-rw-rw-   0        0        0     2893 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/asm.py
--rw-rw-rw-   0        0        0     2889 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/bcc32.py
--rw-rw-rw-   0        0        0     1567 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/c++.py
--rw-rw-rw-   0        0        0     3742 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cc.py
--rw-rw-rw-   0        0        0     3296 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clang.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.565395 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangCommon/
--rw-rw-rw-   0        0        0      343 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangCommon/__init__.py
--rw-rw-rw-   0        0        0     3534 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangxx.py
--rw-rw-rw-   0        0        0     3259 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cxx.py
--rw-rw-rw-   0        0        0     7461 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cyglink.py
--rw-rw-rw-   0        0        0     1663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/default.py
--rw-rw-rw-   0        0        0     3379 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/filesystem.py
--rw-rw-rw-   0        0        0     1544 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/g++.py
--rw-rw-rw-   0        0        0     1891 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gas.py
--rw-rw-rw-   0        0        0     3616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gcc.py
--rw-rw-rw-   0        0        0     2377 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gettext_tool.py
--rw-rw-rw-   0        0        0     2437 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gnulink.py
--rw-rw-rw-   0        0        0     2526 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gxx.py
--rw-rw-rw-   0        0        0     1557 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpc++.py
--rw-rw-rw-   0        0        0     1772 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcc.py
--rw-rw-rw-   0        0        0     2677 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcxx.py
--rw-rw-rw-   0        0        0     2206 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hplink.py
--rw-rw-rw-   0        0        0     2096 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icc.py
--rw-rw-rw-   0        0        0     1851 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icl.py
--rw-rw-rw-   0        0        0     1954 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink.py
--rw-rw-rw-   0        0        0     1995 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink32.py
--rw-rw-rw-   0        0        0    19180 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/install.py
--rw-rw-rw-   0        0        0    25826 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/intelc.py
--rw-rw-rw-   0        0        0     2588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/link.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.579843 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/
--rw-rw-rw-   0        0        0     4649 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/LoadableModule.py
--rw-rw-rw-   0        0        0     7652 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/SharedLibrary.py
--rw-rw-rw-   0        0        0     6064 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/__init__.py
--rw-rw-rw-   0        0        0     3931 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkloc.py
--rw-rw-rw-   0        0        0     2266 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/m4.py
--rw-rw-rw-   0        0        0     2900 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/masm.py
--rw-rw-rw-   0        0        0     8622 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mingw.py
--rw-rw-rw-   0        0        0     4577 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgfmt.py
--rw-rw-rw-   0        0        0     4517 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msginit.py
--rw-rw-rw-   0        0        0     4113 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgmerge.py
--rw-rw-rw-   0        0        0     2387 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslib.py
--rw-rw-rw-   0        0        0    14473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslink.py
--rw-rw-rw-   0        0        0     1752 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mssdk.py
--rw-rw-rw-   0        0        0    12902 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvc.py
--rw-rw-rw-   0        0        0    84784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvs.py
--rw-rw-rw-   0        0        0     6788 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwcc.py
--rw-rw-rw-   0        0        0     3576 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwld.py
--rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/nasm.py
--rw-rw-rw-   0        0        0     4817 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rmic.py
--rw-rw-rw-   0        0        0     2788 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rpcgen.py
--rw-rw-rw-   0        0        0     2479 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgiar.py
--rw-rw-rw-   0        0        0     1563 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgic++.py
--rw-rw-rw-   0        0        0     1780 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicc.py
--rw-rw-rw-   0        0        0     1999 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicxx.py
--rw-rw-rw-   0        0        0     2006 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgilink.py
--rw-rw-rw-   0        0        0     2271 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunar.py
--rw-rw-rw-   0        0        0     1569 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunc++.py
--rw-rw-rw-   0        0        0     1888 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncc.py
--rw-rw-rw-   0        0        0     4879 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncxx.py
--rw-rw-rw-   0        0        0     2419 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunlink.py
--rw-rw-rw-   0        0        0     2429 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tar.py
--rw-rw-rw-   0        0        0     6412 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/textfile.py
--rw-rw-rw-   0        0        0     1786 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tlib.py
--rw-rw-rw-   0        0        0     3687 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/wix.py
--rw-rw-rw-   0        0        0    12548 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/xgettext.py
--rw-rw-rw-   0        0        0     4076 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/zip.py
--rw-rw-rw-   0        0        0    71693 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Util.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.585352 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/
--rw-rw-rw-   0        0        0     6632 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/ConfigureCache.py
--rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/__init__.py
--rw-rw-rw-   0        0        0    15278 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/sconsign.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.588353 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/
--rw-rw-rw-   0        0        0     3134 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/BoolVariable.py
--rw-rw-rw-   0        0        0     3896 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/EnumVariable.py
--rw-rw-rw-   0        0        0     4648 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/ListVariable.py
--rw-rw-rw-   0        0        0     3536 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PackageVariable.py
--rw-rw-rw-   0        0        0     5588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PathVariable.py
--rw-rw-rw-   0        0        0    12708 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/__init__.py
--rw-rw-rw-   0        0        0     6785 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Warnings.py
--rw-rw-rw-   0        0        0      353 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.590352 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/
--rw-rw-rw-   0        0        0     4307 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/__init__.py
--rw-rw-rw-   0        0        0     1644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/_scons_dbm.py
--rw-rw-rw-   0        0        0     3395 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/win32.py
--rw-rw-rw-   0        0        0    21614 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/cpp.py
--rw-rw-rw-   0        0        0     9295 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/dblite.py
--rw-rw-rw-   0        0        0     2032 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/exitfuncs.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.590352 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/
--rw-rw-rw-   0        0        0     1467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/LICENSE.rst
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.604353 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/
--rw-rw-rw-   0        0        0    10126 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/__init__.py
--rw-rw-rw-   0        0        0      558 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_compat.py
--rw-rw-rw-   0        0        0     4690 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_constants.py
--rw-rw-rw-   0        0        0     1873 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_native.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.123869 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.605352 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/
--rw-rw-rw-   0        0        0   107335 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/__init__.py
--rw-rw-rw-   0        0        0      538 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/py31compat.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.124870 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.613898 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/
--rw-rw-rw-   0        0        0     1595 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/__init__.py
--rw-rw-rw-   0        0        0      283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_main.py
--rw-rw-rw-   0        0        0     3687 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_monitor.py
--rw-rw-rw-   0        0        0      283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm.py
--rw-rw-rw-   0        0        0      307 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_notebook.py
--rw-rw-rw-   0        0        0      888 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_pandas.py
--rw-rw-rw-   0        0        0      596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_utils.py
--rw-rw-rw-   0        0        0     1106 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/auto.py
--rw-rw-rw-   0        0        0      857 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/autonotebook.py
--rw-rw-rw-   0        0        0     1376 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/dask.py
--rw-rw-rw-   0        0        0    10790 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/notebook.py
--rw-rw-rw-   0        0        0    57572 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/std.py
--rw-rw-rw-   0        0        0     6948 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/tk.py
--rw-rw-rw-   0        0        0     9726 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/utils.py
--rw-rw-rw-   0        0        0       99 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/version.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.613898 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/
--rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/LICENSE
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.632898 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/
--rw-rw-rw-   0        0        0    13170 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/__init__.py
--rw-rw-rw-   0        0        0     4883 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/composer.py
--rw-rw-rw-   0        0        0    28639 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/constructor.py
--rw-rw-rw-   0        0        0     3851 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/cyaml.py
--rw-rw-rw-   0        0        0     2837 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/dumper.py
--rw-rw-rw-   0        0        0    43006 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/emitter.py
--rw-rw-rw-   0        0        0     2533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/error.py
--rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/events.py
--rw-rw-rw-   0        0        0     2061 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/loader.py
--rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/nodes.py
--rw-rw-rw-   0        0        0    25495 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/parser.py
--rw-rw-rw-   0        0        0     6794 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/reader.py
--rw-rw-rw-   0        0        0    14184 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/representer.py
--rw-rw-rw-   0        0        0     8999 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/resolver.py
--rw-rw-rw-   0        0        0    51277 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/scanner.py
--rw-rw-rw-   0        0        0     4165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/serializer.py
--rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/tokens.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.632898 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/
--rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/LICENSE
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.671904 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/
--rw-rw-rw-   0        0        0     9776 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/__init__.py
--rw-rw-rw-   0        0        0     4921 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/composer.py
--rw-rw-rw-   0        0        0    25145 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/constructor.py
--rw-rw-rw-   0        0        0     3290 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/cyaml.py
--rw-rw-rw-   0        0        0     2719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/dumper.py
--rw-rw-rw-   0        0        0    43298 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/emitter.py
--rw-rw-rw-   0        0        0     2559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/error.py
--rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/events.py
--rw-rw-rw-   0        0        0     1132 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/loader.py
--rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/nodes.py
--rw-rw-rw-   0        0        0    25542 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/parser.py
--rw-rw-rw-   0        0        0     6746 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/reader.py
--rw-rw-rw-   0        0        0    17711 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/representer.py
--rw-rw-rw-   0        0        0     9122 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/resolver.py
--rw-rw-rw-   0        0        0    52446 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/scanner.py
--rw-rw-rw-   0        0        0     4171 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/serializer.py
--rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/tokens.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.671904 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/
--rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/LICENSE
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.685901 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/
--rw-rw-rw-   0        0        0     9607 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/__init__.py
--rw-rw-rw-   0        0        0     4881 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/composer.py
--rw-rw-rw-   0        0        0    25554 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/constructor.py
--rw-rw-rw-   0        0        0     3294 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/cyaml.py
--rw-rw-rw-   0        0        0     2723 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/dumper.py
--rw-rw-rw-   0        0        0    42954 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/emitter.py
--rw-rw-rw-   0        0        0     2533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/error.py
--rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/events.py
--rw-rw-rw-   0        0        0     1138 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/loader.py
--rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/nodes.py
--rw-rw-rw-   0        0        0    25495 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/parser.py
--rw-rw-rw-   0        0        0     6854 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/reader.py
--rw-rw-rw-   0        0        0    14097 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/representer.py
--rw-rw-rw-   0        0        0     8970 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/resolver.py
--rw-rw-rw-   0        0        0    51695 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/scanner.py
--rw-rw-rw-   0        0        0     4165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/serializer.py
--rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/tokens.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.728901 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/
--rw-rw-rw-   0        0        0     1002 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/LICENSE
--rw-rw-rw-   0        0        0    31605 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/crc32.c
--rw-rw-rw-   0        0        0   591749 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/crc32.h
--rw-rw-rw-   0        0        0    16682 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zconf.h
--rw-rw-rw-   0        0        0    96778 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zlib.h
--rw-rw-rw-   0        0        0     7247 2023-12-06 01:19:25.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zutil.h
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.748902 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/
--rw-rw-rw-   0        0        0     1530 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/LICENSE.txt
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.826905 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/
--rw-rw-rw-   0        0        0    18198 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/bitstream.h
--rw-rw-rw-   0        0        0    10157 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/compiler.h
--rw-rw-rw-   0        0        0     4455 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/cpu.h
--rw-rw-rw-   0        0        0     3763 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/debug.h
--rw-rw-rw-   0        0        0    13662 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/entropy_common.c
--rw-rw-rw-   0        0        0     3009 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/error_private.c
--rw-rw-rw-   0        0        0     2441 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/error_private.h
--rw-rw-rw-   0        0        0    34422 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/fse.h
--rw-rw-rw-   0        0        0    14748 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/fse_decompress.c
--rw-rw-rw-   0        0        0    20216 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/huf.h
--rw-rw-rw-   0        0        0    13930 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/mem.h
--rw-rw-rw-   0        0        0    26976 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/xxhash.c
--rw-rw-rw-   0        0        0    11706 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/xxhash.h
--rw-rw-rw-   0        0        0     2728 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_common.c
--rw-rw-rw-   0        0        0     2497 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_deps.h
--rw-rw-rw-   0        0        0     3828 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_errors.h
--rw-rw-rw-   0        0        0    15880 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_internal.h
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:22.839512 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/
--rw-rw-rw-   0        0        0    54982 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/huf_decompress.c
--rw-rw-rw-   0        0        0     9164 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.c
--rw-rw-rw-   0        0        0     1321 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.h
--rw-rw-rw-   0        0        0    80283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress.c
--rw-rw-rw-   0        0        0    66784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.c
--rw-rw-rw-   0        0        0     2253 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.h
--rw-rw-rw-   0        0        0     7906 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_internal.h
--rw-rw-rw-   0        0        0   138334 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/zstd.h
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.807495 nuitka_winsvc-2.2.3/nuitka/build/static_src/
--rw-rw-rw-   0        0        0    83526 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledAsyncgenType.c
--rw-rw-rw-   0        0        0     9142 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCellType.c
--rw-rw-rw-   0        0        0    58846 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCodeHelpers.c
--rw-rw-rw-   0        0        0    72002 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCoroutineType.c
--rw-rw-rw-   0        0        0    40762 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledFrameType.c
--rw-rw-rw-   0        0        0   110213 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledFunctionType.c
--rw-rw-rw-   0        0        0    67599 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledGeneratorType.c
--rw-rw-rw-   0        0        0    56411 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledGeneratorTypeUncompiledIntegration.c
--rw-rw-rw-   0        0        0    22466 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledMethodType.c
--rw-rw-rw-   0        0        0    19054 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersAllocator.c
--rw-rw-rw-   0        0        0    37583 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersAttributes.c
--rw-rw-rw-   0        0        0    23690 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBuiltin.c
--rw-rw-rw-   0        0        0   114017 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBuiltinTypeMethods.c
--rw-rw-rw-   0        0        0     3062 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBytes.c
--rw-rw-rw-   0        0        0    13376 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersCalling.c
--rw-rw-rw-   0        0        0   481627 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersCallingGenerated.c
--rw-rw-rw-   0        0        0     2065 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersChecksumTools.c
--rw-rw-rw-   0        0        0     3051 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersClasses.c
--rw-rw-rw-   0        0        0   318889 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonEq.c
--rw-rw-rw-   0        0        0     4762 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonEqUtils.c
--rw-rw-rw-   0        0        0   314072 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonGe.c
--rw-rw-rw-   0        0        0   313483 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonGt.c
--rw-rw-rw-   0        0        0   317286 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonLe.c
--rw-rw-rw-   0        0        0   316697 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonLt.c
--rw-rw-rw-   0        0        0   315637 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonNe.c
--rw-rw-rw-   0        0        0    36776 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersConstantsBlob.c
--rw-rw-rw-   0        0        0    20243 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDeepcopy.c
--rw-rw-rw-   0        0        0    39785 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDictionaries.c
--rw-rw-rw-   0        0        0    26620 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDictionariesGenerated.c
--rw-rw-rw-   0        0        0     2066 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDumpBacktraces.c
--rw-rw-rw-   0        0        0     2194 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersEnvironmentVariables.c
--rw-rw-rw-   0        0        0     2979 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersEnvironmentVariablesSystem.c
--rw-rw-rw-   0        0        0     7966 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersExceptions.c
--rw-rw-rw-   0        0        0     8349 2024-04-22 02:58:07.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFiles.c
--rw-rw-rw-   0        0        0    28776 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFilesystemPaths.c
--rw-rw-rw-   0        0        0     2455 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFloats.c
--rw-rw-rw-   0        0        0     1803 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersHeapStorage.c
--rw-rw-rw-   0        0        0    16080 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersImport.c
--rw-rw-rw-   0        0        0    16843 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersImportHard.c
--rw-rw-rw-   0        0        0     1815 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersJitSources.c
--rw-rw-rw-   0        0        0    21107 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersLists.c
--rw-rw-rw-   0        0        0    13944 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersListsGenerated.c
--rw-rw-rw-   0        0        0     1669 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersMappings.c
--rw-rw-rw-   0        0        0     3587 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersMatching.c
--rw-rw-rw-   0        0        0   182227 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryAdd.c
--rw-rw-rw-   0        0        0    19904 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryAddUtils.c
--rw-rw-rw-   0        0        0    77972 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitand.c
--rw-rw-rw-   0        0        0    77811 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitor.c
--rw-rw-rw-   0        0        0    77972 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitxor.c
--rw-rw-rw-   0        0        0    68218 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryDivmod.c
--rw-rw-rw-   0        0        0     1265 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryDivmodUtils.c
--rw-rw-rw-   0        0        0    69479 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryFloordiv.c
--rw-rw-rw-   0        0        0     6300 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryInplaceAdd.c
--rw-rw-rw-   0        0        0    83954 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryLshift.c
--rw-rw-rw-   0        0        0    13805 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMatmult.c
--rw-rw-rw-   0        0        0   183867 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMod.c
--rw-rw-rw-   0        0        0   188543 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMult.c
--rw-rw-rw-   0        0        0     3593 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMultUtils.c
--rw-rw-rw-   0        0        0    67184 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryOlddiv.c
--rw-rw-rw-   0        0        0    79484 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryPow.c
--rw-rw-rw-   0        0        0     1052 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryPowUtils.c
--rw-rw-rw-   0        0        0    77854 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryRshift.c
--rw-rw-rw-   0        0        0    70851 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinarySub.c
--rw-rw-rw-   0        0        0    68736 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryTruediv.c
--rw-rw-rw-   0        0        0   151107 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceAdd.c
--rw-rw-rw-   0        0        0     4242 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceAddUtils.c
--rw-rw-rw-   0        0        0    53253 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitand.c
--rw-rw-rw-   0        0        0    53151 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitor.c
--rw-rw-rw-   0        0        0    53253 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitxor.c
--rw-rw-rw-   0        0        0    77119 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceFloordiv.c
--rw-rw-rw-   0        0        0    47857 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceLshift.c
--rw-rw-rw-   0        0        0    17771 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMatmult.c
--rw-rw-rw-   0        0        0   136385 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMod.c
--rw-rw-rw-   0        0        0   142240 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMult.c
--rw-rw-rw-   0        0        0    74749 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceOlddiv.c
--rw-rw-rw-   0        0        0    83262 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplacePow.c
--rw-rw-rw-   0        0        0    45341 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceRshift.c
--rw-rw-rw-   0        0        0    83275 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceSub.c
--rw-rw-rw-   0        0        0    76950 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceTruediv.c
--rw-rw-rw-   0        0        0     3294 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersProfiling.c
--rw-rw-rw-   0        0        0     3840 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersPythonPgo.c
--rw-rw-rw-   0        0        0    18257 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersRaising.c
--rw-rw-rw-   0        0        0     3868 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSafeStrings.c
--rw-rw-rw-   0        0        0     3759 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSequences.c
--rw-rw-rw-   0        0        0     1975 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSlices.c
--rw-rw-rw-   0        0        0    32297 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersStrings.c
--rw-rw-rw-   0        0        0     4181 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersTuples.c
--rw-rw-rw-   0        0        0     6786 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersTypes.c
--rw-rw-rw-   0        0        0    12136 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/InspectPatcher.c
--rw-rw-rw-   0        0        0    54011 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/MainProgram.c
--rw-rw-rw-   0        0        0    63771 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoader.c
--rw-rw-rw-   0        0        0     4827 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderImportlibMetadataDistribution.c
--rw-rw-rw-   0        0        0     6651 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReader.c
--rw-rw-rw-   0        0        0    21896 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReaderFiles.c
--rw-rw-rw-   0        0        0    37074 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/OnefileBootstrap.c
--rw-rw-rw-   0        0        0     8050 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/build/static_src/OnefileSplashScreen.cpp
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.851512 nuitka_winsvc-2.2.3/nuitka/code_generation/
--rw-rw-rw-   0        0        0     6491 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/AsyncgenCodes.py
--rw-rw-rw-   0        0        0    10821 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/AttributeCodes.py
--rw-rw-rw-   0        0        0    21926 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/BinaryOperationHelperDefinitions.py
--rw-rw-rw-   0        0        0     2371 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/BranchCodes.py
--rw-rw-rw-   0        0        0    17006 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/BuiltinCodes.py
--rw-rw-rw-   0        0        0    36111 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CallCodes.py
--rw-rw-rw-   0        0        0     4958 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ClassCodes.py
--rw-rw-rw-   0        0        0    53395 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CodeGeneration.py
--rw-rw-rw-   0        0        0     2408 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CodeHelperSelection.py
--rw-rw-rw-   0        0        0    14320 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CodeHelpers.py
--rw-rw-rw-   0        0        0     5147 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CodeObjectCodes.py
--rw-rw-rw-   0        0        0    17957 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ComparisonCodes.py
--rw-rw-rw-   0        0        0     4479 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ComparisonHelperDefinitions.py
--rw-rw-rw-   0        0        0     7368 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ConditionalCodes.py
--rw-rw-rw-   0        0        0     6901 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ConstantCodes.py
--rw-rw-rw-   0        0        0    34299 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/Contexts.py
--rw-rw-rw-   0        0        0     8589 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CoroutineCodes.py
--rw-rw-rw-   0        0        0     1607 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/CtypesCodes.py
--rw-rw-rw-   0        0        0    28934 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/DictCodes.py
--rw-rw-rw-   0        0        0     2159 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/Emission.py
--rw-rw-rw-   0        0        0     9289 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ErrorCodes.py
--rw-rw-rw-   0        0        0    12983 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/EvalCodes.py
--rw-rw-rw-   0        0        0     9243 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ExceptionCodes.py
--rw-rw-rw-   0        0        0     7384 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ExpressionCTypeSelectionHelpers.py
--rw-rw-rw-   0        0        0     2126 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ExpressionCodes.py
--rw-rw-rw-   0        0        0    17852 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/FrameCodes.py
--rw-rw-rw-   0        0        0    28336 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/FunctionCodes.py
--rw-rw-rw-   0        0        0     7836 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/GeneratorCodes.py
--rw-rw-rw-   0        0        0     6363 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/GlobalConstants.py
--rw-rw-rw-   0        0        0     6985 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/GlobalsLocalsCodes.py
--rw-rw-rw-   0        0        0     1870 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/IdCodes.py
--rw-rw-rw-   0        0        0    14727 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ImportCodes.py
--rw-rw-rw-   0        0        0     1429 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/Indentation.py
--rw-rw-rw-   0        0        0     1574 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/IndexCodes.py
--rw-rw-rw-   0        0        0     1066 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/InjectCCodes.py
--rw-rw-rw-   0        0        0     3567 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/IntegerCodes.py
--rw-rw-rw-   0        0        0    12211 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/IteratorCodes.py
--rw-rw-rw-   0        0        0     1620 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/JitCodes.py
--rw-rw-rw-   0        0        0     2055 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/LabelCodes.py
--rw-rw-rw-   0        0        0     2645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/LineNumberCodes.py
--rw-rw-rw-   0        0        0    15849 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ListCodes.py
--rw-rw-rw-   0        0        0     6658 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/LoaderCodes.py
--rw-rw-rw-   0        0        0    10016 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/LocalsDictCodes.py
--rw-rw-rw-   0        0        0     3174 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/LoopCodes.py
--rw-rw-rw-   0        0        0     1637 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/MatchCodes.py
--rw-rw-rw-   0        0        0     6525 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ModuleCodes.py
--rw-rw-rw-   0        0        0     8224 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/Namify.py
--rw-rw-rw-   0        0        0     1860 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/NetworkxCodes.py
--rw-rw-rw-   0        0        0    12733 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/OperationCodes.py
--rw-rw-rw-   0        0        0    30198 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/PackageResourceCodes.py
--rw-rw-rw-   0        0        0     3054 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/PrintCodes.py
--rw-rw-rw-   0        0        0     5670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/PythonAPICodes.py
--rw-rw-rw-   0        0        0    13251 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/RaisingCodes.py
--rw-rw-rw-   0        0        0     3476 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/Reports.py
--rw-rw-rw-   0        0        0     5267 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/ReturnCodes.py
--rw-rw-rw-   0        0        0     6591 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/SetCodes.py
--rw-rw-rw-   0        0        0    14005 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/SliceCodes.py
--rw-rw-rw-   0        0        0    10087 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/StringCodes.py
--rw-rw-rw-   0        0        0     8302 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/SubscriptCodes.py
--rw-rw-rw-   0        0        0     1939 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/TensorflowCodes.py
--rw-rw-rw-   0        0        0    11208 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/TryCodes.py
--rw-rw-rw-   0        0        0     3840 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/TupleCodes.py
--rw-rw-rw-   0        0        0     2362 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/TypeAliasCodes.py
--rw-rw-rw-   0        0        0    14811 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/VariableCodes.py
--rw-rw-rw-   0        0        0     9155 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/VariableDeclarations.py
--rw-rw-rw-   0        0        0     8129 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/YieldCodes.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.858497 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/
--rw-rw-rw-   0        0        0     6102 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeBases.py
--rw-rw-rw-   0        0        0     3432 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeBooleans.py
--rw-rw-rw-   0        0        0     1837 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeCFloats.py
--rw-rw-rw-   0        0        0     1410 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeCLongs.py
--rw-rw-rw-   0        0        0     3642 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeModuleDictVariables.py
--rw-rw-rw-   0        0        0     5161 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaBooleans.py
--rw-rw-rw-   0        0        0     5243 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaInts.py
--rw-rw-rw-   0        0        0     3988 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaVoids.py
--rw-rw-rw-   0        0        0    19696 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypePyObjectPointers.py
--rw-rw-rw-   0        0        0     2886 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeVoids.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.864497 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/
--rw-rw-rw-   0        0        0     2948 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesAsyncgens.py
--rw-rw-rw-   0        0        0     9455 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesConstants.py
--rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesCoroutines.py
--rw-rw-rw-   0        0        0     2439 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesExceptions.py
--rw-rw-rw-   0        0        0     6483 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesFrames.py
--rw-rw-rw-   0        0        0     3460 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesFunction.py
--rw-rw-rw-   0        0        0     3390 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesGeneratorFunction.py
--rw-rw-rw-   0        0        0     2408 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesIterators.py
--rw-rw-rw-   0        0        0     4534 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesLoader.py
--rw-rw-rw-   0        0        0    23021 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesModules.py
--rw-rw-rw-   0        0        0     6840 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesVariables.py
--rw-rw-rw-   0        0        0     2507 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/TemplateDebugWrapper.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.975929 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/
--rw-rw-rw-   0        0        0    11318 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMethodPositional.c.j2
--rw-rw-rw-   0        0        0     5829 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMixed.c.j2
--rw-rw-rw-   0        0        0    23986 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositional.c.j2
--rw-rw-rw-   0        0        0     5438 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositionalMethodDescr.c.j2
--rw-rw-rw-   0        0        0     1755 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListHinted.c.j2
--rw-rw-rw-   0        0        0     1693 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListSmall.c.j2
--rw-rw-rw-   0        0        0     2706 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperBuiltinMethodOperation.c.j2
--rw-rw-rw-   0        0        0    13624 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperDictionaryCopy.c.j2
--rw-rw-rw-   0        0        0     1894 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperImportHard.c.j2
--rw-rw-rw-   0        0        0     2618 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperLongTools.c.j2
--rw-rw-rw-   0        0        0     1394 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperObjectTools.c.j2
--rw-rw-rw-   0        0        0     7047 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationBinary.c.j2
--rw-rw-rw-   0        0        0    12700 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparison.c.j2
--rw-rw-rw-   0        0        0     4138 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonBytes.c.j2
--rw-rw-rw-   0        0        0     1938 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonFloat.c.j2
--rw-rw-rw-   0        0        0     1968 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonInt.c.j2
--rw-rw-rw-   0        0        0     4081 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonList.c.j2
--rw-rw-rw-   0        0        0     7257 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonLong.c.j2
--rw-rw-rw-   0        0        0     4142 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonStr.c.j2
--rw-rw-rw-   0        0        0     3710 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonTuple.c.j2
--rw-rw-rw-   0        0        0     4447 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonUnicode.c.j2
--rw-rw-rw-   0        0        0    11758 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationInplace.c.j2
--rw-rw-rw-   0        0        0    19167 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsBinary.c.j2
--rw-rw-rw-   0        0        0     2693 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsBytes.c.j2
--rw-rw-rw-   0        0        0     3485 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsCommon.c.j2
--rw-rw-rw-   0        0        0    11336 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsFloat.c.j2
--rw-rw-rw-   0        0        0    15540 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsInt.c.j2
--rw-rw-rw-   0        0        0     2829 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsList.c.j2
--rw-rw-rw-   0        0        0    10395 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsLong.c.j2
--rw-rw-rw-   0        0        0     2407 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsSet.c.j2
--rw-rw-rw-   0        0        0     2870 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsStr.c.j2
--rw-rw-rw-   0        0        0     2834 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsTuple.c.j2
--rw-rw-rw-   0        0        0     3128 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsUnicode.c.j2
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.978929 nuitka_winsvc-2.2.3/nuitka/containers/
--rw-rw-rw-   0        0        0     1467 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/containers/Namedtuples.py
--rw-rw-rw-   0        0        0     6553 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/containers/OrderedDicts.py
--rw-rw-rw-   0        0        0      554 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/nuitka/containers/OrderedSets.py
--rw-rw-rw-   0        0        0     4430 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/containers/OrderedSetsFallback.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/containers/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.980929 nuitka_winsvc-2.2.3/nuitka/distutils/
--rw-rw-rw-   0        0        0     2308 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/distutils/Build.py
--rw-rw-rw-   0        0        0    15025 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/distutils/DistutilCommands.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/distutils/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.982929 nuitka_winsvc-2.2.3/nuitka/finalizations/
--rw-rw-rw-   0        0        0     1258 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/finalizations/Finalization.py
--rw-rw-rw-   0        0        0     6058 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/finalizations/FinalizeMarkups.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/finalizations/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.988929 nuitka_winsvc-2.2.3/nuitka/freezer/
--rw-rw-rw-   0        0        0     7778 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/freezer/DependsExe.py
--rw-rw-rw-   0        0        0     2616 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesCommon.py
--rw-rw-rw-   0        0        0    14396 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesMacOS.py
--rw-rw-rw-   0        0        0     7468 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesPosix.py
--rw-rw-rw-   0        0        0     6698 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesWin32.py
--rw-rw-rw-   0        0        0    11979 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/freezer/ImportDetection.py
--rw-rw-rw-   0        0        0    19236 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/freezer/IncludedDataFiles.py
--rw-rw-rw-   0        0        0    11455 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/freezer/IncludedEntryPoints.py
--rw-rw-rw-   0        0        0    10516 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/nuitka/freezer/Onefile.py
--rw-rw-rw-   0        0        0    12245 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/freezer/Standalone.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/freezer/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:24.992929 nuitka_winsvc-2.2.3/nuitka/importing/
--rw-rw-rw-   0        0        0    11040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/importing/IgnoreListing.py
--rw-rw-rw-   0        0        0     2956 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/importing/ImportCache.py
--rw-rw-rw-   0        0        0     7784 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/importing/ImportResolving.py
--rw-rw-rw-   0        0        0    32895 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/importing/Importing.py
--rw-rw-rw-   0        0        0     4869 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/importing/PreloadedPackages.py
--rw-rw-rw-   0        0        0    18804 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/importing/Recursion.py
--rw-rw-rw-   0        0        0    12787 2024-04-07 02:15:13.000000 nuitka_winsvc-2.2.3/nuitka/importing/StandardLibrary.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/importing/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.040931 nuitka_winsvc-2.2.3/nuitka/nodes/
--rw-rw-rw-   0        0        0     3670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/AsyncgenNodes.py
--rw-rw-rw-   0        0        0     4115 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/AttributeLookupNodes.py
--rw-rw-rw-   0        0        0    13255 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/AttributeNodes.py
--rw-rw-rw-   0        0        0   379568 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/AttributeNodesGenerated.py
--rw-rw-rw-   0        0        0     3856 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinAllNodes.py
--rw-rw-rw-   0        0        0     4131 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinAnyNodes.py
--rw-rw-rw-   0        0        0     2530 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinComplexNodes.py
--rw-rw-rw-   0        0        0     1731 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDecodingNodes.py
--rw-rw-rw-   0        0        0     2760 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDecoratorNodes.py
--rw-rw-rw-   0        0        0     4727 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDictNodes.py
--rw-rw-rw-   0        0        0     4982 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinFormatNodes.py
--rw-rw-rw-   0        0        0     2275 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinHashNodes.py
--rw-rw-rw-   0        0        0     1457 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinInputNodes.py
--rw-rw-rw-   0        0        0     5367 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinIntegerNodes.py
--rw-rw-rw-   0        0        0    12812 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinIteratorNodes.py
--rw-rw-rw-   0        0        0     2029 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinLenNodes.py
--rw-rw-rw-   0        0        0     3639 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinNextNodes.py
--rw-rw-rw-   0        0        0     3787 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinOpenNodes.py
--rw-rw-rw-   0        0        0   246360 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinOperationNodeBasesGenerated.py
--rw-rw-rw-   0        0        0    18648 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinRangeNodes.py
--rw-rw-rw-   0        0        0     9468 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinRefNodes.py
--rw-rw-rw-   0        0        0     3353 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinSumNodes.py
--rw-rw-rw-   0        0        0    13576 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinTypeNodes.py
--rw-rw-rw-   0        0        0     1605 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinVarsNodes.py
--rw-rw-rw-   0        0        0    26146 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/BytesNodes.py
--rw-rw-rw-   0        0        0     6511 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/CallNodes.py
--rw-rw-rw-   0        0        0     1583 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/Checkers.py
--rw-rw-rw-   0        0        0   647748 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ChildrenHavingMixins.py
--rw-rw-rw-   0        0        0     8480 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ClassNodes.py
--rw-rw-rw-   0        0        0     6622 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/CodeObjectSpecs.py
--rw-rw-rw-   0        0        0    21716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ComparisonNodes.py
--rw-rw-rw-   0        0        0    30191 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ConditionalNodes.py
--rw-rw-rw-   0        0        0    47737 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ConstantRefNodes.py
--rw-rw-rw-   0        0        0    12246 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ContainerMakingNodes.py
--rw-rw-rw-   0        0        0     2867 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ContainerOperationNodes.py
--rw-rw-rw-   0        0        0     4614 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/CoroutineNodes.py
--rw-rw-rw-   0        0        0     1746 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/CtypesNodes.py
--rw-rw-rw-   0        0        0    51053 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/DictionaryNodes.py
--rw-rw-rw-   0        0        0     8151 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ExceptionNodes.py
--rw-rw-rw-   0        0        0     7408 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ExecEvalNodes.py
--rw-rw-rw-   0        0        0    45046 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionBases.py
--rw-rw-rw-   0        0        0    55956 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionBasesGenerated.py
--rw-rw-rw-   0        0        0    21311 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionShapeMixins.py
--rw-rw-rw-   0        0        0    12024 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/FrameNodes.py
--rw-rw-rw-   0        0        0     3577 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/FunctionAttributeNodes.py
--rw-rw-rw-   0        0        0    41167 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/FunctionNodes.py
--rw-rw-rw-   0        0        0     5409 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/FutureSpecs.py
--rw-rw-rw-   0        0        0     6288 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/GeneratorNodes.py
--rw-rw-rw-   0        0        0     6961 2024-04-07 02:15:13.000000 nuitka_winsvc-2.2.3/nuitka/nodes/GlobalsLocalsNodes.py
--rw-rw-rw-   0        0        0    98222 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/HardImportNodesGenerated.py
--rw-rw-rw-   0        0        0     5631 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ImportHardNodes.py
--rw-rw-rw-   0        0        0    48286 2024-05-15 06:21:28.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ImportNodes.py
--rw-rw-rw-   0        0        0     2766 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/IndicatorMixins.py
--rw-rw-rw-   0        0        0     1533 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/InjectCNodes.py
--rw-rw-rw-   0        0        0    11519 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/IterationHandles.py
--rw-rw-rw-   0        0        0    11035 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/KeyValuePairNodes.py
--rw-rw-rw-   0        0        0    16821 2024-03-14 05:29:37.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ListOperationNodes.py
--rw-rw-rw-   0        0        0    23177 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/LocalsDictNodes.py
--rw-rw-rw-   0        0        0    15007 2024-03-06 05:39:35.000000 nuitka_winsvc-2.2.3/nuitka/nodes/LocalsScopes.py
--rw-rw-rw-   0        0        0    15995 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/LoopNodes.py
--rw-rw-rw-   0        0        0     1745 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/MatchNodes.py
--rw-rw-rw-   0        0        0     6567 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ModuleAttributeNodes.py
--rw-rw-rw-   0        0        0    32830 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ModuleNodes.py
--rw-rw-rw-   0        0        0     1759 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/NetworkxNodes.py
--rw-rw-rw-   0        0        0    24461 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/NodeBases.py
--rw-rw-rw-   0        0        0    15147 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/NodeMakingHelpers.py
--rw-rw-rw-   0        0        0     5580 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/NodeMetaClasses.py
--rw-rw-rw-   0        0        0    31948 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/OperatorNodes.py
--rw-rw-rw-   0        0        0     8976 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/OperatorNodesUnary.py
--rw-rw-rw-   0        0        0     5228 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/OsSysNodes.py
--rw-rw-rw-   0        0        0    12468 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/OutlineNodes.py
--rw-rw-rw-   0        0        0    34735 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/PackageMetadataNodes.py
--rw-rw-rw-   0        0        0    12289 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/PackageResourceNodes.py
--rw-rw-rw-   0        0        0     3440 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/PrintNodes.py
--rw-rw-rw-   0        0        0     6805 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/ReturnNodes.py
--rw-rw-rw-   0        0        0     4748 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/SideEffectNodes.py
--rw-rw-rw-   0        0        0    12547 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/SliceNodes.py
--rw-rw-rw-   0        0        0    98808 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/StatementBasesGenerated.py
--rw-rw-rw-   0        0        0     9336 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/StatementNodes.py
--rw-rw-rw-   0        0        0    28691 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/StrNodes.py
--rw-rw-rw-   0        0        0     3538 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/StringConcatenationNodes.py
--rw-rw-rw-   0        0        0     8329 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/SubscriptNodes.py
--rw-rw-rw-   0        0        0     1411 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/TensorflowNodes.py
--rw-rw-rw-   0        0        0    17886 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/TryNodes.py
--rw-rw-rw-   0        0        0     2438 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/TypeMatchNodes.py
--rw-rw-rw-   0        0        0    11717 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/TypeNodes.py
--rw-rw-rw-   0        0        0    42396 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/VariableAssignNodes.py
--rw-rw-rw-   0        0        0    10779 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/VariableDelNodes.py
--rw-rw-rw-   0        0        0     4607 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/VariableNameNodes.py
--rw-rw-rw-   0        0        0    31274 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/VariableRefNodes.py
--rw-rw-rw-   0        0        0     4781 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/VariableReleaseNodes.py
--rw-rw-rw-   0        0        0     3937 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/YieldNodes.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.042932 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/
--rw-rw-rw-   0        0        0   157357 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/BuiltinTypeShapes.py
--rw-rw-rw-   0        0        0     4420 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/ControlFlowDescriptions.py
--rw-rw-rw-   0        0        0     5076 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/ShapeMixins.py
--rw-rw-rw-   0        0        0    42509 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/StandardShapes.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/nodes/shapes/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.047933 nuitka_winsvc-2.2.3/nuitka/optimizations/
--rw-rw-rw-   0        0        0     3358 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/BytecodeDemotion.py
--rw-rw-rw-   0        0        0     3953 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/FunctionInlining.py
--rw-rw-rw-   0        0        0     2177 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/Graphs.py
--rw-rw-rw-   0        0        0    10917 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/Optimization.py
--rw-rw-rw-   0        0        0    52575 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/OptimizeBuiltinCalls.py
--rw-rw-rw-   0        0        0     2287 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/Tags.py
--rw-rw-rw-   0        0        0    42800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/TraceCollections.py
--rw-rw-rw-   0        0        0    25799 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/ValueTraces.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/optimizations/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.048941 nuitka_winsvc-2.2.3/nuitka/pgo/
--rw-rw-rw-   0        0        0     4932 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/pgo/PGO.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/pgo/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.049932 nuitka_winsvc-2.2.3/nuitka/plugins/
--rw-rw-rw-   0        0        0    57735 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/PluginBase.py
--rw-rw-rw-   0        0        0    60905 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/Plugins.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.071932 nuitka_winsvc-2.2.3/nuitka/plugins/standard/
--rw-rw-rw-   0        0        0    30813 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/AntiBloatPlugin.py
--rw-rw-rw-   0        0        0     3509 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/ConsiderPyLintAnnotationsPlugin.py
--rw-rw-rw-   0        0        0    10627 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DataFilesPlugin.py
--rw-rw-rw-   0        0        0     5080 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DelvewheelPlugin.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.086817 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin/
--rw-rw-rw-   0        0        0     1646 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin/DillPlugin.c
--rw-rw-rw-   0        0        0     9826 2024-03-25 02:50:30.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin/dill-postLoad.py
--rw-rw-rw-   0        0        0     2679 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin.py
--rw-rw-rw-   0        0        0    16496 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/DllFilesPlugin.py
--rw-rw-rw-   0        0        0     2095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/EnumPlugin.py
--rw-rw-rw-   0        0        0     1938 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/EventletPlugin.py
--rw-rw-rw-   0        0        0     1913 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/GeventPlugin.py
--rw-rw-rw-   0        0        0     4018 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/GiPlugin.py
--rw-rw-rw-   0        0        0     4854 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/GlfwPlugin.py
--rw-rw-rw-   0        0        0    32325 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/ImplicitImports.py
--rw-rw-rw-   0        0        0     5024 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/KivyPlugin.py
--rw-rw-rw-   0        0        0     8824 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/MatplotlibPlugin.py
--rw-rw-rw-   0        0        0     7080 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/MultiprocessingPlugin.py
--rw-rw-rw-   0        0        0     1220 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/NumpyPlugin.py
--rw-rw-rw-   0        0        0     7299 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/OptionsNannyPlugin.py
--rw-rw-rw-   0        0        0     1940 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/PbrPlugin.py
--rw-rw-rw-   0        0        0     4874 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/PkgResourcesPlugin.py
--rw-rw-rw-   0        0        0     7216 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/PmwPlugin.py
--rw-rw-rw-   0        0        0    51929 2024-05-20 02:39:31.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/PySidePyQtPlugin.py
--rw-rw-rw-   0        0        0     3020 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/PywebViewPlugin.py
--rw-rw-rw-   0        0        0     1194 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/TensorflowPlugin.py
--rw-rw-rw-   0        0        0    13878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/TkinterPlugin.py
--rw-rw-rw-   0        0        0     1174 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/TorchPlugin.py
--rw-rw-rw-   0        0        0    12838 2024-04-07 02:15:13.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/TransformersPlugin.py
--rw-rw-rw-   0        0        0     1107 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/TrioPlugin.py
--rw-rw-rw-   0        0        0     5668 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/UpxPlugin.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/__init__.py
--rw-rw-rw-   0        0        0   236681 2024-05-20 02:39:31.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/standard.nuitka-package.config.yml
--rw-rw-rw-   0        0        0     2352 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/stdlib2.nuitka-package.config.yml
--rw-rw-rw-   0        0        0    12392 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/nuitka/plugins/standard/stdlib3.nuitka-package.config.yml
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.100818 nuitka_winsvc-2.2.3/nuitka/reports/
--rw-rw-rw-   0        0        0     2286 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/reports/CompilationReportReader.py
--rw-rw-rw-   0        0        0     2089 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/reports/LicenseReport.rst.j2
--rw-rw-rw-   0        0        0    28897 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/reports/Reports.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/reports/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.106820 nuitka_winsvc-2.2.3/nuitka/specs/
--rw-rw-rw-   0        0        0     5943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinBytesOperationSpecs.py
--rw-rw-rw-   0        0        0     2818 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinDictOperationSpecs.py
--rw-rw-rw-   0        0        0     2573 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinListOperationSpecs.py
--rw-rw-rw-   0        0        0    27022 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinParameterSpecs.py
--rw-rw-rw-   0        0        0     6098 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinStrOperationSpecs.py
--rw-rw-rw-   0        0        0     1190 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinTypeOperationSpecs.py
--rw-rw-rw-   0        0        0     4834 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/specs/BuiltinUnicodeOperationSpecs.py
--rw-rw-rw-   0        0        0     7112 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/specs/HardImportSpecs.py
--rw-rw-rw-   0        0        0    18811 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/specs/ParameterSpecs.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/specs/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.107818 nuitka_winsvc-2.2.3/nuitka/tools/
--rw-rw-rw-   0        0        0     1631 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/Basics.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.108818 nuitka_winsvc-2.2.3/nuitka/tools/commercial/
--rw-rw-rw-   0        0        0      847 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/commercial/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.109818 nuitka_winsvc-2.2.3/nuitka/tools/data_composer/
--rw-rw-rw-   0        0        0    15004 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/data_composer/DataComposer.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/data_composer/__init__.py
--rw-rw-rw-   0        0        0     1338 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/data_composer/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.111818 nuitka_winsvc-2.2.3/nuitka/tools/environments/
--rw-rw-rw-   0        0        0     2481 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/environments/CreateEnvironment.py
--rw-rw-rw-   0        0        0     4198 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/environments/Virtualenv.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/environments/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.112824 nuitka_winsvc-2.2.3/nuitka/tools/general/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/general/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.113819 nuitka_winsvc-2.2.3/nuitka/tools/general/dll_report/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/general/dll_report/__init__.py
--rw-rw-rw-   0        0        0     2352 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/general/dll_report/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.114818 nuitka_winsvc-2.2.3/nuitka/tools/general/find_module/
--rw-rw-rw-   0        0        0     3953 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/general/find_module/FindModuleCode.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/general/find_module/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.115818 nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/
--rw-rw-rw-   0        0        0    12545 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/OnefileCompressor.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/__init__.py
--rw-rw-rw-   0        0        0     1343 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.117694 nuitka_winsvc-2.2.3/nuitka/tools/podman/
--rw-rw-rw-   0        0        0     1905 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/podman/Podman.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/podman/__init__.py
--rw-rw-rw-   0        0        0    11623 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/podman/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.118816 nuitka_winsvc-2.2.3/nuitka/tools/profiler/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/profiler/__init__.py
--rw-rw-rw-   0        0        0     2561 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/profiler/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.120507 nuitka_winsvc-2.2.3/nuitka/tools/scanning/
--rw-rw-rw-   0        0        0     3590 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/scanning/DisplayPackageDLLs.py
--rw-rw-rw-   0        0        0     2314 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/scanning/DisplayPackageData.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/scanning/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.123381 nuitka_winsvc-2.2.3/nuitka/tools/specialize/
--rw-rw-rw-   0        0        0    51703 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/specialize/CTypeDescriptions.py
--rw-rw-rw-   0        0        0     7717 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/specialize/Common.py
--rw-rw-rw-   0        0        0    39747 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/specialize/SpecializeC.py
--rw-rw-rw-   0        0        0    36683 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/specialize/SpecializePython.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/specialize/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.128064 nuitka_winsvc-2.2.3/nuitka/tools/testing/
--rw-rw-rw-   0        0        0    56174 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/Common.py
--rw-rw-rw-   0        0        0     1516 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/Constructs.py
--rw-rw-rw-   0        0        0    10129 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/OutputComparison.py
--rw-rw-rw-   0        0        0     1310 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/Pythons.py
--rw-rw-rw-   0        0        0     8061 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/RuntimeTracing.py
--rw-rw-rw-   0        0        0     5413 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/SearchModes.py
--rw-rw-rw-   0        0        0     3408 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/Valgrind.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.129153 nuitka_winsvc-2.2.3/nuitka/tools/testing/check_reference_counts/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/check_reference_counts/__init__.py
--rw-rw-rw-   0        0        0     3095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/check_reference_counts/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.130734 nuitka_winsvc-2.2.3/nuitka/tools/testing/compare_with_cpython/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/compare_with_cpython/__init__.py
--rw-rw-rw-   0        0        0    29697 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/compare_with_cpython/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.131824 nuitka_winsvc-2.2.3/nuitka/tools/testing/find_sxs_modules/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/find_sxs_modules/__init__.py
--rw-rw-rw-   0        0        0     1980 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/find_sxs_modules/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.132365 nuitka_winsvc-2.2.3/nuitka/tools/testing/measure_construct_performance/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/measure_construct_performance/__init__.py
--rw-rw-rw-   0        0        0     8758 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/measure_construct_performance/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.133470 nuitka_winsvc-2.2.3/nuitka/tools/testing/run_nuitka_tests/
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/run_nuitka_tests/__init__.py
--rw-rw-rw-   0        0        0    35342 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/testing/run_nuitka_tests/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.135030 nuitka_winsvc-2.2.3/nuitka/tools/watch/
--rw-rw-rw-   0        0        0     3543 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/watch/GitHub.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tools/watch/__init__.py
--rw-rw-rw-   0        0        0    21532 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tools/watch/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.152368 nuitka_winsvc-2.2.3/nuitka/tree/
--rw-rw-rw-   0        0        0    50436 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/Building.py
--rw-rw-rw-   0        0        0    75150 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ComplexCallHelperFunctions.py
--rw-rw-rw-   0        0        0     1733 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/Extractions.py
--rw-rw-rw-   0        0        0     2603 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/InternalModule.py
--rw-rw-rw-   0        0        0     1544 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/Operations.py
--rw-rw-rw-   0        0        0     2841 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationAssertStatements.py
--rw-rw-rw-   0        0        0    43887 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationAssignmentStatements.py
--rw-rw-rw-   0        0        0     2981 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationBooleanExpressions.py
--rw-rw-rw-   0        0        0    11746 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationCallExpressions.py
--rw-rw-rw-   0        0        0    15446 2024-03-20 02:57:24.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationClasses.py
--rw-rw-rw-   0        0        0    38202 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationClasses3.py
--rw-rw-rw-   0        0        0     6523 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationComparisonExpressions.py
--rw-rw-rw-   0        0        0    22207 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationContractionExpressions.py
--rw-rw-rw-   0        0        0    11266 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationDictionaryCreation.py
--rw-rw-rw-   0        0        0    14805 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationExecStatements.py
--rw-rw-rw-   0        0        0     7858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationForLoopStatements.py
--rw-rw-rw-   0        0        0    30885 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationFunctionStatements.py
--rw-rw-rw-   0        0        0    14095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationImportStatements.py
--rw-rw-rw-   0        0        0     6630 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationLambdaExpressions.py
--rw-rw-rw-   0        0        0    21311 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationMatchStatements.py
--rw-rw-rw-   0        0        0     2442 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationMultidist.py
--rw-rw-rw-   0        0        0     7608 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationNamespacePackages.py
--rw-rw-rw-   0        0        0     4711 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationPrintStatements.py
--rw-rw-rw-   0        0        0    15606 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationSequenceCreation.py
--rw-rw-rw-   0        0        0     4857 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationSubscriptExpressions.py
--rw-rw-rw-   0        0        0    14948 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationTryExceptStatements.py
--rw-rw-rw-   0        0        0     7014 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationTryFinallyStatements.py
--rw-rw-rw-   0        0        0     5707 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationWhileLoopStatements.py
--rw-rw-rw-   0        0        0    14439 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationWithStatements.py
--rw-rw-rw-   0        0        0     3852 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/ReformulationYieldExpressions.py
--rw-rw-rw-   0        0        0    13488 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/SourceHandling.py
--rw-rw-rw-   0        0        0     3790 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/SyntaxErrors.py
--rw-rw-rw-   0        0        0    23153 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/tree/TreeHelpers.py
--rw-rw-rw-   0        0        0    20465 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/VariableClosure.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/tree/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.169644 nuitka_winsvc-2.2.3/nuitka/utils/
--rw-rw-rw-   0        0        0     3140 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/AppDirs.py
--rw-rw-rw-   0        0        0     4128 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/CStrings.py
--rw-rw-rw-   0        0        0     6394 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/CommandLineOptions.py
--rw-rw-rw-   0        0        0    14983 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Distributions.py
--rw-rw-rw-   0        0        0     6477 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Download.py
--rw-rw-rw-   0        0        0    13368 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Execution.py
--rw-rw-rw-   0        0        0    42167 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/FileOperations.py
--rw-rw-rw-   0        0        0     3753 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Hashing.py
--rw-rw-rw-   0        0        0     2391 2024-05-20 02:39:32.000000 nuitka_winsvc-2.2.3/nuitka/utils/Images.py
--rw-rw-rw-   0        0        0    10334 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Importing.py
--rw-rw-rw-   0        0        0     7884 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/InstalledPythons.py
--rw-rw-rw-   0        0        0     2258 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/InstanceCounters.py
--rw-rw-rw-   0        0        0     4586 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Jinja2.py
--rw-rw-rw-   0        0        0     1271 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Json.py
--rw-rw-rw-   0        0        0     4478 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/MacOSApp.py
--rw-rw-rw-   0        0        0     5092 2024-03-25 02:50:30.000000 nuitka_winsvc-2.2.3/nuitka/utils/MemoryUsage.py
--rw-rw-rw-   0        0        0     9951 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/ModuleNames.py
--rw-rw-rw-   0        0        0     4588 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/ReExecute.py
--rw-rw-rw-   0        0        0     1889 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Rest.py
--rw-rw-rw-   0        0        0    23857 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/SharedLibraries.py
--rw-rw-rw-   0        0        0     3698 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Shebang.py
--rw-rw-rw-   0        0        0     3687 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Signing.py
--rw-rw-rw-   0        0        0     2084 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/SlotMetaClasses.py
--rw-rw-rw-   0        0        0     6603 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/StaticLibraries.py
--rw-rw-rw-   0        0        0     2634 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/ThreadedExecutor.py
--rw-rw-rw-   0        0        0     2798 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Timing.py
--rw-rw-rw-   0        0        0    12705 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/Utils.py
--rw-rw-rw-   0        0        0    10642 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/nuitka/utils/WindowsFileUsage.py
--rw-rw-rw-   0        0        0    19837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/WindowsResources.py
--rw-rw-rw-   0        0        0     7014 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/Yaml.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/nuitka/utils/__init__.py
--rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/pyproject.toml
--rw-rw-rw-   0        0        0       42 2024-05-20 02:47:27.279295 nuitka_winsvc-2.2.3/setup.cfg
--rw-rw-rw-   0        0        0    16351 2024-05-20 02:40:51.000000 nuitka_winsvc-2.2.3/setup.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.170161 nuitka_winsvc-2.2.3/tests/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.724895 nuitka_winsvc-2.2.3/tests/basics/
--rw-rw-rw-   0        0        0     1798 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/AssertsTest.py
--rw-rw-rw-   0        0        0     5966 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/AssignmentsTest.py
--rw-rw-rw-   0        0        0     5910 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/AssignmentsTest32.py
--rw-rw-rw-   0        0        0     4086 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/BranchingTest.py
--rw-rw-rw-   0        0        0     1136 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/BuiltinOverload.py
--rw-rw-rw-   0        0        0     3781 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/BuiltinSuperTest.py
--rw-rw-rw-   0        0        0    17112 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/BuiltinsTest.py
--rw-rw-rw-   0        0        0      898 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ClassMinimalTest.py
--rw-rw-rw-   0        0        0     4796 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ClassesTest.py
--rw-rw-rw-   0        0        0     3446 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ClassesTest32.py
--rw-rw-rw-   0        0        0     1438 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ClassesTest34.py
--rw-rw-rw-   0        0        0     4729 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ComparisonChainsTest.py
--rw-rw-rw-   0        0        0     4672 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ConstantsTest.py
--rw-rw-rw-   0        0        0     1027 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ConstantsTest27.py
--rw-rw-rw-   0        0        0     1661 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/DecoratorsTest.py
--rw-rw-rw-   0        0        0     2349 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/DefaultParametersTest.py
--rw-rw-rw-   0        0        0     1159 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/DoubleDeletionsTest.py
--rw-rw-rw-   0        0        0      838 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/EmptyModuleTest.py
--rw-rw-rw-   0        0        0    14418 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest.py
--rw-rw-rw-   0        0        0      993 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest32.py
--rw-rw-rw-   0        0        0     1490 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest33.py
--rw-rw-rw-   0        0        0     6779 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ExecEvalTest.py
--rw-rw-rw-   0        0        0     1450 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/ExtremeClosureTest.py
--rw-rw-rw-   0        0        0     1689 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/FunctionObjectsTest.py
--rw-rw-rw-   0        0        0    12367 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/FunctionsTest.py
--rw-rw-rw-   0        0        0     3635 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/FunctionsTest32.py
--rw-rw-rw-   0        0        0     2658 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/FunctionsTest_2.py
--rw-rw-rw-   0        0        0      922 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/FutureTest32.py
--rw-rw-rw-   0        0        0     5841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/GeneratorExpressionsTest.py
--rw-rw-rw-   0        0        0     1073 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/GeneratorExpressionsTest_37.py
--rw-rw-rw-   0        0        0     3856 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/GlobalStatementTest.py
--rw-rw-rw-   0        0        0     1318 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/HelloWorldTest_2.py
--rw-rw-rw-   0        0        0     2501 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ImportingTest.py
--rw-rw-rw-   0        0        0     1328 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/InplaceOperationsTest.py
--rw-rw-rw-   0        0        0     4259 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/InspectionTest.py
--rw-rw-rw-   0        0        0     1536 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/InspectionTest_35.py
--rw-rw-rw-   0        0        0     1650 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/InspectionTest_36.py
--rw-rw-rw-   0        0        0     1703 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/LambdasTest.py
--rw-rw-rw-   0        0        0     2763 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/LateClosureAssignmentTest.py
--rw-rw-rw-   0        0        0     2955 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ListContractionsTest.py
--rw-rw-rw-   0        0        0     3361 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/LoopingTest.py
--rw-rw-rw-   0        0        0     1568 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/MainProgramsTest.py
--rw-rw-rw-   0        0        0     1957 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ModuleAttributesTest.py
--rw-rw-rw-   0        0        0     2008 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/OperatorsTest.py
--rw-rw-rw-   0        0        0    14935 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/OrderChecksTest.py
--rw-rw-rw-   0        0        0     1859 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/OrderChecksTest27.py
--rw-rw-rw-   0        0        0     1484 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/OverflowFunctionsTest_2.py
--rw-rw-rw-   0        0        0     5885 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ParameterErrorsTest.py
--rw-rw-rw-   0        0        0     1931 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ParameterErrorsTest32.py
--rw-rw-rw-   0        0        0      895 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/PrintFutureTest.py
--rw-rw-rw-   0        0        0     1444 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/PrintingTest_2.py
--rw-rw-rw-   0        0        0      910 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/RecursionTest.py
--rw-rw-rw-   0        0        0    24798 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest.py
--rw-rw-rw-   0        0        0     2109 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest27.py
--rw-rw-rw-   0        0        0     7869 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest33.py
--rw-rw-rw-   0        0        0     5060 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest35.py
--rw-rw-rw-   0        0        0     5497 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest36.py
--rw-rw-rw-   0        0        0     2932 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ReferencingTest_2.py
--rw-rw-rw-   0        0        0     1662 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/SlotsTest.py
--rw-rw-rw-   0        0        0     1191 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/ThreadedGeneratorsTest.py
--rw-rw-rw-   0        0        0    22998 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest32.py
--rw-rw-rw-   0        0        0     1573 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest35.py
--rw-rw-rw-   0        0        0     1820 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest_2.py
--rw-rw-rw-   0        0        0     2118 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryContinueFinallyTest.py
--rw-rw-rw-   0        0        0     2244 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryExceptContinueTest.py
--rw-rw-rw-   0        0        0     2307 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryExceptFinallyTest.py
--rw-rw-rw-   0        0        0     2336 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryExceptFramesTest.py
--rw-rw-rw-   0        0        0     2874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryReturnFinallyTest.py
--rw-rw-rw-   0        0        0     2360 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/TryYieldFinallyTest.py
--rw-rw-rw-   0        0        0     1125 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/UnicodeTest.py
--rw-rw-rw-   0        0        0     1909 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/UnpackingTest35.py
--rw-rw-rw-   0        0        0     2143 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/VarargsTest.py
--rw-rw-rw-   0        0        0     4913 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/WithStatementsTest.py
--rw-rw-rw-   0        0        0     3103 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/YieldFromTest33.py
--rw-rw-rw-   0        0        0     3851 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/run_all.py
--rw-rw-rw-   0        0        0     2302 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/basics/run_xml.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.748901 nuitka_winsvc-2.2.3/tests/onefile/
--rw-rw-rw-   0        0        0     1341 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/onefile/HelloWorldTest.py
--rw-rw-rw-   0        0        0     1339 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/onefile/KeyboardInterruptTest.py
--rw-rw-rw-   0        0        0     5846 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/onefile/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.856510 nuitka_winsvc-2.2.3/tests/optimizations/
--rw-rw-rw-   0        0        0      991 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/optimizations/ArgumentTypes.py
--rw-rw-rw-   0        0        0     1087 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/AttributesTest.py
--rw-rw-rw-   0        0        0     1053 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/CallsTest.py
--rw-rw-rw-   0        0        0      953 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/ConditionsTest.py
--rw-rw-rw-   0        0        0      941 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/DecodingOperationsTest.py
--rw-rw-rw-   0        0        0     1246 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/FormatStringsTest36.py
--rw-rw-rw-   0        0        0     1183 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/HardImportsTest.py
--rw-rw-rw-   0        0        0     1007 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/HardImportsTest_2.py
--rw-rw-rw-   0        0        0      950 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/optimizations/Iterations.py
--rw-rw-rw-   0        0        0     1292 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/LenTest.py
--rw-rw-rw-   0        0        0     1133 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/MatchingTest310.py
--rw-rw-rw-   0        0        0     2295 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/OperationsTest.py
--rw-rw-rw-   0        0        0     1365 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/optimizations/SubscriptsTest.py
--rw-rw-rw-   0        0        0     8827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/optimizations/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.867526 nuitka_winsvc-2.2.3/tests/packages/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.882511 nuitka_winsvc-2.2.3/tests/packages/package_data_files_embedding/
--rw-rw-rw-   0        0        0     1576 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/package_data_files_embedding/PackageDataFilesEmbedding.py
--rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/package_data_files_embedding/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.890511 nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/
--rw-rw-rw-   0        0        0     2414 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/PackageImportSuccessAfterFailure.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.907511 nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/variable_package/
--rw-rw-rw-   0        0        0      975 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/variable_package/SomeModule.py
--rw-rw-rw-   0        0        0     1201 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/variable_package/__init__.py
--rw-rw-rw-   0        0        0     4138 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.137870 nuitka_winsvc-2.2.3/tests/packages/sub_package/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.932513 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/
--rw-rw-rw-   0        0        0     1262 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/__init__.py
--rw-rw-rw-   0        0        0      940 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/bigkitty.py
--rw-rw-rw-   0        0        0      942 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/smallkitty.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.966067 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/
--rw-rw-rw-   0        0        0      961 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/__init__.py
--rw-rw-rw-   0        0        0     1085 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/hello.py
--rw-rw-rw-   0        0        0      999 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/miau.py
--rw-rw-rw-   0        0        0     1001 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/purr.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.138870 nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.983257 nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/some_package/
--rw-rw-rw-   0        0        0     2368 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/some_package/__init__.py
--rw-rw-rw-   0        0        0      939 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/some_package/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:25.991171 nuitka_winsvc-2.2.3/tests/plugins/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.001959 nuitka_winsvc-2.2.3/tests/plugins/code_signing/
--rw-rw-rw-   0        0        0     1202 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/plugins/code_signing/CodeSigningMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.021062 nuitka_winsvc-2.2.3/tests/plugins/data_files/
--rw-rw-rw-   0        0        0     1474 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/plugins/data_files/DataFilesMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.030046 nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/
--rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/__init__.py
--rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/lala.txt
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.031067 nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/sub_dir/
--rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/sub_dir/lulu.txt
--rw-rw-rw-   0        0        0      309 2024-01-29 03:39:42.000000 nuitka_winsvc-2.2.3/tests/plugins/data_files/test_case.nuitka-package.config.yml
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.033640 nuitka_winsvc-2.2.3/tests/plugins/parameters/
--rw-rw-rw-   0        0        0     1162 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/plugins/parameters/ParametersMain.py
--rw-rw-rw-   0        0        0     2218 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/plugins/parameters/parameter-using-plugin.py
--rw-rw-rw-   0        0        0     3778 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/plugins/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.037621 nuitka_winsvc-2.2.3/tests/programs/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.046621 nuitka_winsvc-2.2.3/tests/programs/absolute_import/
--rw-rw-rw-   0        0        0      899 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/absolute_import/AbsoluteImportMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.086633 nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/
--rw-rw-rw-   0        0        0      828 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/__init__.py
--rw-rw-rw-   0        0        0     1076 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/foobar.py
--rw-rw-rw-   0        0        0      911 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/local.py
--rw-rw-rw-   0        0        0      893 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/util.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.093622 nuitka_winsvc-2.2.3/tests/programs/case_imports1/
--rw-rw-rw-   0        0        0      840 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports1/CasedImportingMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.098622 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/Some_Module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.106622 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/Some_Package/
--rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/Some_Package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.140624 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.146632 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/some_package/
--rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.151631 nuitka_winsvc-2.2.3/tests/programs/case_imports2/
--rw-rw-rw-   0        0        0      840 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports2/CasedImportingMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.159342 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.165338 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/some_package/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.168328 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/Some_Module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.177328 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/Some_Package/
--rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/Some_Package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.188329 nuitka_winsvc-2.2.3/tests/programs/case_imports3/
--rw-rw-rw-   0        0        0     1107 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports3/CasedImportingMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.189329 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/Some_Module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.199329 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/Some_Package/
--rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/Some_Package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.202329 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/Some_Module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.210330 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/Some_Package/
--rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/Some_Package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.216330 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/
--rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/CyclicImportsMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.222330 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/
--rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child1.py
--rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child2.py
--rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.244331 nuitka_winsvc-2.2.3/tests/programs/dash_import/
--rw-rw-rw-   0        0        0      920 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dash_import/DashImportMain.py
--rw-rw-rw-   0        0        0      849 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dash_import/dash-module.py
--rw-rw-rw-   0        0        0      849 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dash_import/plus+module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.251333 nuitka_winsvc-2.2.3/tests/programs/dash_main/
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dash_main/Dash-Main.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.283332 nuitka_winsvc-2.2.3/tests/programs/deep/
--rw-rw-rw-   0        0        0      930 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/DeepProgramMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.303335 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/
--rw-rw-rw-   0        0        0     1012 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/DeepBrother.py
--rw-rw-rw-   0        0        0      941 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/DeepChild.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.364571 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/deep_package/
--rw-rw-rw-   0        0        0      908 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/deep_package/DeepDeepChild.py
--rw-rw-rw-   0        0        0      984 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/deep/some_package/deep_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.367574 nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/
--rw-rw-rw-   0        0        0      826 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/DunderInitImportsMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.381572 nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/package/
--rw-rw-rw-   0        0        0      829 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/package/SubModule.py
--rw-rw-rw-   0        0        0      889 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.390585 nuitka_winsvc-2.2.3/tests/programs/import_variants/
--rw-rw-rw-   0        0        0     1037 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/import_variants/ImportVariationsMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.408583 nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/
--rw-rw-rw-   0        0        0      978 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child1.py
--rw-rw-rw-   0        0        0     1130 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child2.py
--rw-rw-rw-   0        0        0      854 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child3.py
--rw-rw-rw-   0        0        0     1026 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.415577 nuitka_winsvc-2.2.3/tests/programs/main_raises/
--rw-rw-rw-   0        0        0      943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/main_raises/ErrorMain.py
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/main_raises/ErrorRaising.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.431573 nuitka_winsvc-2.2.3/tests/programs/main_raises2/
--rw-rw-rw-   0        0        0     1112 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/main_raises2/ErrorInFunctionMain.py
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/main_raises2/ErrorRaising.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.443573 nuitka_winsvc-2.2.3/tests/programs/module_attributes/
--rw-rw-rw-   0        0        0     1561 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/ModuleAttributesMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.463574 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/
--rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/Nearby1.py
--rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.484575 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/
--rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/Nearby2.py
--rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.504576 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/
--rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/Nearby3.py
--rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.520428 nuitka_winsvc-2.2.3/tests/programs/module_exits/
--rw-rw-rw-   0        0        0      901 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_exits/ErrorExitingModule.py
--rw-rw-rw-   0        0        0      899 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_exits/Main.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.538435 nuitka_winsvc-2.2.3/tests/programs/module_object_replacing/
--rw-rw-rw-   0        0        0     1110 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_object_replacing/ModuleObjectReplacingMain.py
--rw-rw-rw-   0        0        0     1391 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/module_object_replacing/SelfReplacingModule.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.548443 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/
--rw-rw-rw-   0        0        0     1022 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/MultiprocessingUsingMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.580434 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/__init__.py
--rw-rw-rw-   0        0        0      868 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/__main__.py
--rw-rw-rw-   0        0        0     1791 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/entry.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.584435 nuitka_winsvc-2.2.3/tests/programs/named_imports/
--rw-rw-rw-   0        0        0      878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/named_imports/NamedImportsMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.595436 nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/SomeModule.py
--rw-rw-rw-   0        0        0      856 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.600436 nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/sub_package/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/sub_package/SomeModule.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.608448 nuitka_winsvc-2.2.3/tests/programs/package_code/
--rw-rw-rw-   0        0        0      832 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_code/PackageInitCodeMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.620436 nuitka_winsvc-2.2.3/tests/programs/package_code/some_package/
--rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_code/some_package/SomeModule.py
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_code/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.631438 nuitka_winsvc-2.2.3/tests/programs/package_contains_main/
--rw-rw-rw-   0        0        0      821 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_contains_main/PackageContainsMain.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_contains_main/__init__.py
--rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_contains_main/local.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.637436 nuitka_winsvc-2.2.3/tests/programs/package_init_import/
--rw-rw-rw-   0        0        0      855 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_import/PackageInitImportMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.652438 nuitka_winsvc-2.2.3/tests/programs/package_init_import/some_package/
--rw-rw-rw-   0        0        0     1064 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_import/some_package/PackageLocal.py
--rw-rw-rw-   0        0        0     1225 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_import/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.660437 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/
--rw-rw-rw-   0        0        0      821 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/PackageInitIssueMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.669594 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.681602 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/child_package/
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/child_package/SomeModule.py
--rw-rw-rw-   0        0        0      827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/child_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.688595 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/
--rw-rw-rw-   0        0        0      958 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/PackageMissingInitMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.698597 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/
--rw-rw-rw-   0        0        0      997 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.703596 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/sub_package/
--rw-rw-rw-   0        0        0     1009 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/sub_package/some_sub_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.723624 nuitka_winsvc-2.2.3/tests/programs/package_module_collision/
--rw-rw-rw-   0        0        0      933 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_module_collision/PackageAndModuleNamedSameMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.728641 nuitka_winsvc-2.2.3/tests/programs/package_module_collision/Something/
--rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_module_collision/Something/__init__.py
--rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_module_collision/something.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.730625 nuitka_winsvc-2.2.3/tests/programs/package_overload/
--rw-rw-rw-   0        0        0      884 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_overload/Main.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.755625 nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/
--rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/__init__.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/bar.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/bar2.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.763626 nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/
--rw-rw-rw-   0        0        0     3079 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/PackagePreventsSubmoduleMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.775106 nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/some_package/
--rw-rw-rw-   0        0        0     1111 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/some_package/__init__.py
--rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/some_package/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:21.181051 nuitka_winsvc-2.2.3/tests/programs/package_program/
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.783746 nuitka_winsvc-2.2.3/tests/programs/package_program/PackageAsMain/
--rw-rw-rw-   0        0        0      920 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/package_program/PackageAsMain/__init__.py
--rw-rw-rw-   0        0        0     1661 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/package_program/PackageAsMain/__main__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.794759 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/
--rw-rw-rw-   0        0        0     1760 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/PkgUtilIterModulesMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.802746 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.821756 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleC.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleD.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.843364 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleA.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleB.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.853364 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/
--rw-rw-rw-   0        0        0     1328 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/PkgUtilUsageMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.868365 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/
--rw-rw-rw-   0        0        0       13 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/DATA_FILE.txt
--rw-rw-rw-   0        0        0       14 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/DATA_FILE2.txt
--rw-rw-rw-   0        0        0       14 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/DATA_FILE3.txt
--rw-rw-rw-   0        0        0     1585 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/__init__.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.878366 nuitka_winsvc-2.2.3/tests/programs/plugin_import/
--rw-rw-rw-   0        0        0      891 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/plugin_import/PluginImportMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.891367 nuitka_winsvc-2.2.3/tests/programs/plugin_import/some_package/
--rw-rw-rw-   0        0        0      803 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/plugin_import/some_package/__init__.py
--rw-rw-rw-   0        0        0      813 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/plugin_import/some_package/some_module.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.896921 nuitka_winsvc-2.2.3/tests/programs/reimport_main_dynamic/
--rw-rw-rw-   0        0        0      943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/reimport_main_dynamic/ImportItselfDynamicMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.901915 nuitka_winsvc-2.2.3/tests/programs/reimport_main_static/
--rw-rw-rw-   0        0        0      930 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/reimport_main_static/ImportItselfStaticMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.909913 nuitka_winsvc-2.2.3/tests/programs/relative_import/
--rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/relative_import/RelativeImportMain.py
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/relative_import/dircache.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.914915 nuitka_winsvc-2.2.3/tests/programs/resource_reader37/
--rw-rw-rw-   0        0        0     1202 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/resource_reader37/ResourceReaderMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.925914 nuitka_winsvc-2.2.3/tests/programs/resource_reader37/some_package/
--rw-rw-rw-   0        0        0       13 2023-09-05 03:06:57.000000 nuitka_winsvc-2.2.3/tests/programs/resource_reader37/some_package/DATA_FILE.txt
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/resource_reader37/some_package/__init__.py
--rw-rw-rw-   0        0        0     6614 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/programs/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.946915 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/
--rw-rw-rw-   0        0        0     1203 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/StdlibOverloadMain.py
--rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/pyexpat.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.963916 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/
--rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/__init__.py
--rw-rw-rw-   0        0        0      941 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/normal_importing.py
--rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/pyexpat.py
--rw-rw-rw-   0        0        0     1268 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/star_importing.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.976918 nuitka_winsvc-2.2.3/tests/programs/syntax_errors/
--rw-rw-rw-   0        0        0      822 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/syntax_errors/IndentationErroring.py
--rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/syntax_errors/SyntaxErroring.py
--rw-rw-rw-   0        0        0     1111 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/syntax_errors/SyntaxErrorsMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.985968 nuitka_winsvc-2.2.3/tests/programs/unicode_bom/
--rw-rw-rw-   0        0        0      995 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/unicode_bom/UnicodeBomMain.py
--rw-rw-rw-   0        0        0      878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/unicode_bom/unicode_bom.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.986968 nuitka_winsvc-2.2.3/tests/programs/with space/
--rw-rw-rw-   0        0        0      858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/programs/with space/Space Main.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:26.992977 nuitka_winsvc-2.2.3/tests/reflected/
--rw-rw-rw-   0        0        0    14254 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/reflected/compile_itself.py
--rw-rw-rw-   0        0        0     1274 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/run-tests
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:27.110652 nuitka_winsvc-2.2.3/tests/standalone/
--rw-rw-rw-   0        0        0     1090 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/BrotliUsing.py
--rw-rw-rw-   0        0        0     2586 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/CtypesUsing.py
--rw-rw-rw-   0        0        0     1950 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/DateutilsUsing.py
--rw-rw-rw-   0        0        0     1168 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/FlaskUsing.py
--rw-rw-rw-   0        0        0     1307 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/standalone/GiUsing.py
--rw-rw-rw-   0        0        0     1022 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/GlfwUsing.py
--rw-rw-rw-   0        0        0     1216 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/GtkUsing.py
--rw-rw-rw-   0        0        0     1057 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/HexEncodingTest_2.py
--rw-rw-rw-   0        0        0     1118 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/IdnaUsing.py
--rw-rw-rw-   0        0        0     1215 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/LxmlUsing.py
--rw-rw-rw-   0        0        0     1598 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/MatplotlibUsing.py
--rw-rw-rw-   0        0        0     2570 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/MetadataPackagesUsing.py
--rw-rw-rw-   0        0        0     1759 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/NumpyUsing.py
--rw-rw-rw-   0        0        0      979 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/OpenGLUsing.py
--rw-rw-rw-   0        0        0     1479 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PandasUsing.py
--rw-rw-rw-   0        0        0     1098 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PasslibUsing.py
--rw-rw-rw-   0        0        0     1248 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PendulumUsing.py
--rw-rw-rw-   0        0        0     2106 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PkgResourcesRequiresUsing.py
--rw-rw-rw-   0        0        0     1099 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PmwUsing.py
--rw-rw-rw-   0        0        0     1369 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PyQt5Plugins.py
--rw-rw-rw-   0        0        0     1253 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PyQt5SSLSupport.py
--rw-rw-rw-   0        0        0     2198 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PyQt5Using.py
--rw-rw-rw-   0        0        0     1203 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PyQt6Plugins.py
--rw-rw-rw-   0        0        0     2168 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PyQt6Using.py
--rw-rw-rw-   0        0        0     1789 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PySide2Using.py
--rw-rw-rw-   0        0        0     1123 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PySide6Plugins.py
--rw-rw-rw-   0        0        0     1789 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/PySide6Using.py
--rw-rw-rw-   0        0        0     1371 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/RsaUsing.py
--rw-rw-rw-   0        0        0     1227 2024-05-06 03:08:54.000000 nuitka_winsvc-2.2.3/tests/standalone/SetuptoolsUsing_311.py
--rw-rw-rw-   0        0        0     1005 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/ShlibUsing.py
--rw-rw-rw-   0        0        0     1569 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/SocketUsing.py
--rw-rw-rw-   0        0        0     1973 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/TkInterUsing.py
--rw-rw-rw-   0        0        0     3260 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/Urllib3Using.py
--rw-rw-rw-   0        0        0     1232 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/Win32ComUsing.py
--rw-rw-rw-   0        0        0     9912 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/run_all.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:27.118652 nuitka_winsvc-2.2.3/tests/standalone/zip_importer/
--rw-rw-rw-   0        0        0     1296 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/standalone/zip_importer/ZipImporterMain.py
-drwxrwxrwx   0        0        0        0 2024-05-20 02:47:27.269799 nuitka_winsvc-2.2.3/tests/syntax/
--rw-rw-rw-   0        0        0      844 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/AsyncgenReturn36.py
--rw-rw-rw-   0        0        0      818 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/AwaitInModule36.py
--rw-rw-rw-   0        0        0      901 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/BreakWithoutLoop.py
--rw-rw-rw-   0        0        0      824 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/ClassReturn.py
--rw-rw-rw-   0        0        0     1002 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/ClosureDel_2.py
--rw-rw-rw-   0        0        0      882 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/ContinueWithoutLoop.py
--rw-rw-rw-   0        0        0      824 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/DuplicateArgument.py
--rw-rw-rw-   0        0        0     1142 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/ExecWithNesting_2.py
--rw-rw-rw-   0        0        0      858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/FutureBraces.py
--rw-rw-rw-   0        0        0      837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/FutureUnknown.py
--rw-rw-rw-   0        0        0     1073 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/GeneratorExpressions38.py
--rw-rw-rw-   0        0        0      911 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/GeneratorReturn_2.py
--rw-rw-rw-   0        0        0      825 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/GlobalForParameter.py
--rw-rw-rw-   0        0        0     1027 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/Importing32.py
--rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/IndentationError.py
--rw-rw-rw-   0        0        0      947 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/LateFutureImport.py
--rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/MisplacedFutureImport.py
--rw-rw-rw-   0        0        0      832 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/ModuleReturn.py
--rw-rw-rw-   0        0        0      915 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/NonAsciiWithoutEncoding_2.py
--rw-rw-rw-   0        0        0      827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/NonlocalForParameter32.py
--rw-rw-rw-   0        0        0      900 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/NonlocalNotFound32.py
--rw-rw-rw-   0        0        0      939 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/StarImportExtra.py
--rw-rw-rw-   0        0        0      900 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/SyntaxError.py
--rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/TryExceptAllNotLast.py
--rw-rw-rw-   0        0        0      908 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/TryFinallyContinue_37.py
--rw-rw-rw-   0        0        0      808 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/UnpackNoTuple.py
--rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/UnpackTwoStars32.py
--rw-rw-rw-   0        0        0      825 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/YieldFromInModule.py
--rw-rw-rw-   0        0        0      837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/YieldInAsync35.py
--rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/YieldInGenexp38.py
--rw-rw-rw-   0        0        0      813 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/YieldInModule.py
--rw-rw-rw-   0        0        0     2234 2024-03-06 05:39:36.000000 nuitka_winsvc-2.2.3/tests/syntax/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.972622 nuitka_winsvc-2.3/
+-rw-rw-rw-   0        0        0      235 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/Changelog.rst
+-rw-rw-rw-   0        0        0   152287 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/Developer_Manual.rst
+-rw-rw-rw-   0        0        0    11348 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/LICENSE.txt
+-rw-rw-rw-   0        0        0     1717 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/MANIFEST.in
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.970614 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/
+-rw-rw-rw-   0        0        0     4851 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    78271 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0      308 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/entry_points.txt
+-rw-rw-rw-   0        0        0        2 2024-02-05 02:20:24.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0       35 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        7 2024-06-03 02:06:43.000000 nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0     4851 2024-06-03 02:07:02.971623 nuitka_winsvc-2.3/PKG-INFO
+-rw-rw-rw-   0        0        0     2860 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/README.md
+-rw-rw-rw-   0        0        0    80086 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/README.rst
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.175713 nuitka_winsvc-2.3/bin/
+-rw-rw-rw-   0        0        0     1166 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/autoformat-nuitka-source
+-rw-rw-rw-   0        0        0     1165 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/check-nuitka-with-pylint
+-rw-rw-rw-   0        0        0     1181 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/compare_with_cpython
+-rw-rw-rw-   0        0        0     3105 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/compare_with_xml
+-rw-rw-rw-   0        0        0     1194 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/measure-construct-performance
+-rw-rw-rw-   0        0        0     1716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/nuitka
+-rw-rw-rw-   0        0        0     1716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/bin/nuitka-run
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.216660 nuitka_winsvc-2.3/doc/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.253295 nuitka_winsvc-2.3/doc/Logo/
+-rw-rw-rw-   0        0        0     1797 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Horizontal.svg
+-rw-rw-rw-   0        0        0     1553 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Symbol.svg
+-rw-rw-rw-   0        0        0     1793 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Vertical.svg
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.273392 nuitka_winsvc-2.3/doc/images/
+-rw-rw-rw-   0        0        0     7585 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Horizontal.png
+-rw-rw-rw-   0        0        0     4452 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Symbol.png
+-rw-rw-rw-   0        0        0     9828 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Vertical.png
+-rw-rw-rw-   0        0        0    33899 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/doc/nuitka-run.1
+-rw-rw-rw-   0        0        0    33923 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/doc/nuitka.1
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.282271 nuitka_winsvc-2.3/lib/
+-rw-rw-rw-   0        0        0     4640 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/lib/hints.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.301261 nuitka_winsvc-2.3/misc/
+-rwxrwxrwx   0        0        0      924 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/misc/nuitka-run.bat
+-rwxrwxrwx   0        0        0     1061 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/misc/nuitka.bat
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.574603 nuitka_winsvc-2.3/nuitka/
+-rw-rw-rw-   0        0        0     7560 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/Builtins.py
+-rw-rw-rw-   0        0        0     5787 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/BytecodeCaching.py
+-rw-rw-rw-   0        0        0     3891 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/Bytecodes.py
+-rw-rw-rw-   0        0        0     1855 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/CacheCleanup.py
+-rw-rw-rw-   0        0        0    11181 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/Constants.py
+-rw-rw-rw-   0        0        0     2570 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/Errors.py
+-rw-rw-rw-   0        0        0    11126 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/HardImportRegistry.py
+-rw-rw-rw-   0        0        0    38217 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/MainControl.py
+-rw-rw-rw-   0        0        0     8938 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/ModuleRegistry.py
+-rw-rw-rw-   0        0        0    64582 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/OptionParsing.py
+-rw-rw-rw-   0        0        0    78383 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/Options.py
+-rw-rw-rw-   0        0        0     5432 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/OutputDirectories.py
+-rw-rw-rw-   0        0        0    15010 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/PostProcessing.py
+-rw-rw-rw-   0        0        0     6805 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/Progress.py
+-rw-rw-rw-   0        0        0     9654 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/PythonFlavors.py
+-rw-rw-rw-   0        0        0     4093 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/PythonOperators.py
+-rw-rw-rw-   0        0        0    14573 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/PythonVersions.py
+-rw-rw-rw-   0        0        0     9525 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/Serialization.py
+-rw-rw-rw-   0        0        0     4703 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/SourceCodeReferences.py
+-rw-rw-rw-   0        0        0    13335 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/Tracing.py
+-rw-rw-rw-   0        0        0     3512 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/TreeXML.py
+-rw-rw-rw-   0        0        0    15470 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/Variables.py
+-rw-rw-rw-   0        0        0     2464 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/Version.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/__init__.py
+-rw-rw-rw-   0        0        0     6373 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/__main__.py
+-rw-rw-rw-   0        0        0     5604 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/__past__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:44.736614 nuitka_winsvc-2.3/nuitka/build/
+-rw-rw-rw-   0        0        0    37213 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/Backend.scons
+-rw-rw-rw-   0        0        0     8542 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/CCompilerVersion.scons
+-rw-rw-rw-   0        0        0     3486 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/DataComposerInterface.py
+-rw-rw-rw-   0        0        0    17764 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/build/Onefile.scons
+-rw-rw-rw-   0        0        0    15413 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/SconsCaching.py
+-rw-rw-rw-   0        0        0    36223 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/build/SconsCompilerSettings.py
+-rw-rw-rw-   0        0        0     5591 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/SconsHacks.py
+-rw-rw-rw-   0        0        0    18498 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/SconsInterface.py
+-rw-rw-rw-   0        0        0     2703 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/SconsProgress.py
+-rw-rw-rw-   0        0        0    13210 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/SconsSpawn.py
+-rw-rw-rw-   0        0        0    27380 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/SconsUtils.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.621174 nuitka_winsvc-2.3/nuitka/build/include/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.161374 nuitka_winsvc-2.3/nuitka/build/include/nuitka/
+-rw-rw-rw-   0        0        0    10280 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/allocator.h
+-rw-rw-rw-   0        0        0     3499 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/builtins.h
+-rw-rw-rw-   0        0        0     5196 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/calling.h
+-rw-rw-rw-   0        0        0     2006 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/checkers.h
+-rw-rw-rw-   0        0        0     1123 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/checksum_tools.h
+-rw-rw-rw-   0        0        0     9333 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_asyncgen.h
+-rw-rw-rw-   0        0        0     2460 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_cell.h
+-rw-rw-rw-   0        0        0     9233 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_coroutine.h
+-rw-rw-rw-   0        0        0    18671 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_frame.h
+-rw-rw-rw-   0        0        0     7332 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_function.h
+-rw-rw-rw-   0        0        0     9189 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_generator.h
+-rw-rw-rw-   0        0        0     1866 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_method.h
+-rw-rw-rw-   0        0        0     7876 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/constants.h
+-rw-rw-rw-   0        0        0     1345 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/constants_blob.h
+-rw-rw-rw-   0        0        0     1187 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/environment_variables.h
+-rw-rw-rw-   0        0        0     1872 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/environment_variables_system.h
+-rw-rw-rw-   0        0        0     5355 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/exception_groups.h
+-rw-rw-rw-   0        0        0    50907 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/exceptions.h
+-rw-rw-rw-   0        0        0     3792 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/filesystem_paths.h
+-rw-rw-rw-   0        0        0     6774 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/freelists.h
+-rw-rw-rw-   0        0        0    86326 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/hedley.h
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.583230 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/
+-rw-rw-rw-   0        0        0     3698 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/attributes.h
+-rw-rw-rw-   0        0        0     2692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/boolean.h
+-rw-rw-rw-   0        0        0     1233 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/bytearrays.h
+-rw-rw-rw-   0        0        0     1164 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/bytes.h
+-rw-rw-rw-   0        0        0    11894 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/calling_generated.h
+-rw-rw-rw-   0        0        0    13169 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_eq.h
+-rw-rw-rw-   0        0        0    10645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_ge.h
+-rw-rw-rw-   0        0        0    10644 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_gt.h
+-rw-rw-rw-   0        0        0    13169 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_le.h
+-rw-rw-rw-   0        0        0    13168 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_lt.h
+-rw-rw-rw-   0        0        0    10645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_ne.h
+-rw-rw-rw-   0        0        0     1834 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/complex.h
+-rw-rw-rw-   0        0        0    13751 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/dictionaries.h
+-rw-rw-rw-   0        0        0     1235 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/floats.h
+-rw-rw-rw-   0        0        0     4401 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/import_hard.h
+-rw-rw-rw-   0        0        0     1827 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/indexes.h
+-rw-rw-rw-   0        0        0     3625 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/ints.h
+-rw-rw-rw-   0        0        0     9599 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/iterators.h
+-rw-rw-rw-   0        0        0     3763 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/lists.h
+-rw-rw-rw-   0        0        0     1938 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/lists_generated.h
+-rw-rw-rw-   0        0        0     1386 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/mappings.h
+-rw-rw-rw-   0        0        0     4671 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations.h
+-rw-rw-rw-   0        0        0    12714 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_add.h
+-rw-rw-rw-   0        0        0     5692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitand.h
+-rw-rw-rw-   0        0        0     5670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitor.h
+-rw-rw-rw-   0        0        0     5692 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitxor.h
+-rw-rw-rw-   0        0        0     5451 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_divmod.h
+-rw-rw-rw-   0        0        0     5489 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_floordiv.h
+-rw-rw-rw-   0        0        0     5144 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_lshift.h
+-rw-rw-rw-   0        0        0     2828 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_matmult.h
+-rw-rw-rw-   0        0        0    15807 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_mod.h
+-rw-rw-rw-   0        0        0    13239 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_mult.h
+-rw-rw-rw-   0        0        0     5820 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_olddiv.h
+-rw-rw-rw-   0        0        0     4743 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_pow.h
+-rw-rw-rw-   0        0        0     5144 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_rshift.h
+-rw-rw-rw-   0        0        0     5853 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_sub.h
+-rw-rw-rw-   0        0        0     5467 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_truediv.h
+-rw-rw-rw-   0        0        0    20173 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_builtin_types.h
+-rw-rw-rw-   0        0        0     8699 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_add.h
+-rw-rw-rw-   0        0        0     3796 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitand.h
+-rw-rw-rw-   0        0        0     3782 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitor.h
+-rw-rw-rw-   0        0        0     3796 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitxor.h
+-rw-rw-rw-   0        0        0     4875 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_floordiv.h
+-rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_lshift.h
+-rw-rw-rw-   0        0        0     2756 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_matmult.h
+-rw-rw-rw-   0        0        0    10655 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_mod.h
+-rw-rw-rw-   0        0        0     9230 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_mult.h
+-rw-rw-rw-   0        0        0     5176 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_olddiv.h
+-rw-rw-rw-   0        0        0     4378 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_pow.h
+-rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_rshift.h
+-rw-rw-rw-   0        0        0     5004 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_sub.h
+-rw-rw-rw-   0        0        0     4855 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_truediv.h
+-rw-rw-rw-   0        0        0     4072 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/raising.h
+-rw-rw-rw-   0        0        0     2367 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/rangeobjects.h
+-rw-rw-rw-   0        0        0     1175 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/richcomparisons.h
+-rw-rw-rw-   0        0        0     1439 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/sequences.h
+-rw-rw-rw-   0        0        0     1054 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/sets.h
+-rw-rw-rw-   0        0        0     9114 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/slices.h
+-rw-rw-rw-   0        0        0     1363 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/strings.h
+-rw-rw-rw-   0        0        0    12843 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/subscripts.h
+-rw-rw-rw-   0        0        0     6785 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/tuples.h
+-rw-rw-rw-   0        0        0    16773 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/helpers.h
+-rw-rw-rw-   0        0        0     6268 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/importing.h
+-rw-rw-rw-   0        0        0    12979 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/incbin.h
+-rw-rw-rw-   0        0        0     1086 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/jit_sources.h
+-rw-rw-rw-   0        0        0    17369 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/prelude.h
+-rw-rw-rw-   0        0        0     3239 2024-05-15 06:21:28.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/printing.h
+-rw-rw-rw-   0        0        0     1811 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/python_pgo.h
+-rw-rw-rw-   0        0        0     2421 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/safe_string_ops.h
+-rw-rw-rw-   0        0        0     3890 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/threading.h
+-rw-rw-rw-   0        0        0     3447 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/tracing.h
+-rw-rw-rw-   0        0        0     1145 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/type_aliases.h
+-rw-rw-rw-   0        0        0     3135 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/include/nuitka/unfreezing.h
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.629144 nuitka_winsvc-2.3/nuitka/build/inline_copy/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.621672 nuitka_winsvc-2.3/nuitka/build/inline_copy/appdirs/
+-rw-rw-rw-   0        0        0     1097 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/appdirs/LICENSE.txt
+-rw-rw-rw-   0        0        0    24824 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/appdirs/appdirs.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.633522 nuitka_winsvc-2.3/nuitka/build/inline_copy/atomicwrites/
+-rw-rw-rw-   0        0        0     1069 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/atomicwrites/LICENSE
+-rw-rw-rw-   0        0        0     6794 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/atomicwrites/atomicwrites.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.637523 nuitka_winsvc-2.3/nuitka/build/inline_copy/bin/
+-rw-rw-rw-   0        0        0     1695 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/bin/scons.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.622174 nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.671400 nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/
+-rw-rw-rw-   0        0        0     1585 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/LICENSE
+-rw-rw-rw-   0        0        0       93 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/__init__.py
+-rw-rw-rw-   0        0        0    65424 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/caching.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.678398 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/
+-rw-rw-rw-   0        0        0     1491 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/LICENSE.txt
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.703238 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/
+-rw-rw-rw-   0        0        0      243 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/__init__.py
+-rw-rw-rw-   0        0        0     2522 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/ansi.py
+-rw-rw-rw-   0        0        0    10517 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/ansitowin32.py
+-rw-rw-rw-   0        0        0     1915 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/initialise.py
+-rw-rw-rw-   0        0        0     5404 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/win32.py
+-rw-rw-rw-   0        0        0     6438 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/winterm.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.705237 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/
+-rw-rw-rw-   0        0        0     1359 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/LICENSE
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.714162 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/
+-rw-rw-rw-   0        0        0       82 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/__init__.py
+-rw-rw-rw-   0        0        0     6859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/compat.py
+-rw-rw-rw-   0        0        0     4463 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/fnmatch.py
+-rw-rw-rw-   0        0        0     8304 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/impl.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:45.721863 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/
+-rw-rw-rw-   0        0        0     1467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/LICENSE.rst
+-rw-rw-rw-   0        0        0       85 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/README.rst
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.028410 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/
+-rw-rw-rw-   0        0        0     2423 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/__init__.py
+-rw-rw-rw-   0        0        0     2685 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/_compat.py
+-rw-rw-rw-   0        0        0     1726 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/_identifier.py
+-rw-rw-rw-   0        0        0    12719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/bccache.py
+-rw-rw-rw-   0        0        0    65386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/compiler.py
+-rw-rw-rw-   0        0        0     1626 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/constants.py
+-rw-rw-rw-   0        0        0    12281 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/debug.py
+-rw-rw-rw-   0        0        0     1400 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/defaults.py
+-rw-rw-rw-   0        0        0    50849 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/environment.py
+-rw-rw-rw-   0        0        0     4428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/exceptions.py
+-rw-rw-rw-   0        0        0    24500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/ext.py
+-rw-rw-rw-   0        0        0    36528 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/filters.py
+-rw-rw-rw-   0        0        0     9197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/idtracking.py
+-rw-rw-rw-   0        0        0    28559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/lexer.py
+-rw-rw-rw-   0        0        0    17473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/loaders.py
+-rw-rw-rw-   0        0        0     4340 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/meta.py
+-rw-rw-rw-   0        0        0     7308 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/nativetypes.py
+-rw-rw-rw-   0        0        0    30853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/nodes.py
+-rw-rw-rw-   0        0        0     1722 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/optimizer.py
+-rw-rw-rw-   0        0        0    35875 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/parser.py
+-rw-rw-rw-   0        0        0    27644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/runtime.py
+-rw-rw-rw-   0        0        0    17080 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/sandbox.py
+-rw-rw-rw-   0        0        0     4214 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/tests.py
+-rw-rw-rw-   0        0        0    20501 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/utils.py
+-rw-rw-rw-   0        0        0     3316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/visitor.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.043319 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/
+-rw-rw-rw-   0        0        0     1466 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/LICENSE.rst
+-rw-rw-rw-   0        0        0       84 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/README.rst
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.151831 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/
+-rw-rw-rw-   0        0        0     2616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/__init__.py
+-rw-rw-rw-   0        0        0     2685 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_compat.py
+-rw-rw-rw-   0        0        0     1726 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_identifier.py
+-rw-rw-rw-   0        0        0    12719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/bccache.py
+-rw-rw-rw-   0        0        0    65386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/compiler.py
+-rw-rw-rw-   0        0        0     1626 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/constants.py
+-rw-rw-rw-   0        0        0    12281 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/debug.py
+-rw-rw-rw-   0        0        0     1400 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/defaults.py
+-rw-rw-rw-   0        0        0    50849 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/environment.py
+-rw-rw-rw-   0        0        0     4428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/exceptions.py
+-rw-rw-rw-   0        0        0    24500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/ext.py
+-rw-rw-rw-   0        0        0    36528 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/filters.py
+-rw-rw-rw-   0        0        0     9197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/idtracking.py
+-rw-rw-rw-   0        0        0    28559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/lexer.py
+-rw-rw-rw-   0        0        0    17474 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/loaders.py
+-rw-rw-rw-   0        0        0     4340 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/meta.py
+-rw-rw-rw-   0        0        0     7308 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nativetypes.py
+-rw-rw-rw-   0        0        0    30853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nodes.py
+-rw-rw-rw-   0        0        0     1722 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/optimizer.py
+-rw-rw-rw-   0        0        0    35875 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/parser.py
+-rw-rw-rw-   0        0        0    27644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/runtime.py
+-rw-rw-rw-   0        0        0    17080 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/sandbox.py
+-rw-rw-rw-   0        0        0     4214 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/tests.py
+-rw-rw-rw-   0        0        0    20501 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/utils.py
+-rw-rw-rw-   0        0        0     3316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/visitor.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.626509 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.624510 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.240649 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/
+-rw-rw-rw-   0        0        0    47844 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Action.py
+-rw-rw-rw-   0        0        0    33996 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Builder.py
+-rw-rw-rw-   0        0        0     8083 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/CacheDir.py
+-rw-rw-rw-   0        0        0    27693 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Conftest.py
+-rw-rw-rw-   0        0        0     6938 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Debug.py
+-rw-rw-rw-   0        0        0    17622 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Defaults.py
+-rw-rw-rw-   0        0        0    96183 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Environment.py
+-rw-rw-rw-   0        0        0     7358 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Errors.py
+-rw-rw-rw-   0        0        0    21540 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Executor.py
+-rw-rw-rw-   0        0        0    16000 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Job.py
+-rw-rw-rw-   0        0        0     9589 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Memoize.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.243404 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/
+-rw-rw-rw-   0        0        0     4197 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Alias.py
+-rw-rw-rw-   0        0        0   121420 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/FS.py
+-rw-rw-rw-   0        0        0     4164 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Python.py
+-rw-rw-rw-   0        0        0    49503 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.278692 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/
+-rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/BoolOption.py
+-rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/EnumOption.py
+-rw-rw-rw-   0        0        0     1950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/ListOption.py
+-rw-rw-rw-   0        0        0     1965 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PackageOption.py
+-rw-rw-rw-   0        0        0     2736 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PathOption.py
+-rw-rw-rw-   0        0        0     2614 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/__init__.py
+-rw-rw-rw-   0        0        0     8467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/PathList.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.344069 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/
+-rw-rw-rw-   0        0        0     9314 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/__init__.py
+-rw-rw-rw-   0        0        0     3131 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/aix.py
+-rw-rw-rw-   0        0        0     1989 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/cygwin.py
+-rw-rw-rw-   0        0        0     2483 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/darwin.py
+-rw-rw-rw-   0        0        0     1718 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/hpux.py
+-rw-rw-rw-   0        0        0     1605 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/irix.py
+-rw-rw-rw-   0        0        0     2170 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/os2.py
+-rw-rw-rw-   0        0        0     4179 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/posix.py
+-rw-rw-rw-   0        0        0     1882 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/sunos.py
+-rw-rw-rw-   0        0        0    15042 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/win32.py
+-rw-rw-rw-   0        0        0    39700 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConf.py
+-rw-rw-rw-   0        0        0    12950 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConsign.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.366919 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/
+-rw-rw-rw-   0        0        0     4810 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/C.py
+-rw-rw-rw-   0        0        0     3751 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Dir.py
+-rw-rw-rw-   0        0        0     3233 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Prog.py
+-rw-rw-rw-   0        0        0     2011 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/RC.py
+-rw-rw-rw-   0        0        0    14663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.390348 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/
+-rw-rw-rw-   0        0        0    14029 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Interactive.py
+-rw-rw-rw-   0        0        0    52665 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Main.py
+-rw-rw-rw-   0        0        0    40719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConsOptions.py
+-rw-rw-rw-   0        0        0    24133 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConscript.py
+-rw-rw-rw-   0        0        0    14053 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/__init__.py
+-rw-rw-rw-   0        0        0     2305 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Sig.py
+-rw-rw-rw-   0        0        0    34903 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Subst.py
+-rw-rw-rw-   0        0        0    40510 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Taskmaster.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.814019 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/
+-rw-rw-rw-   0        0        0     2166 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/386asm.py
+-rw-rw-rw-   0        0        0     2433 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/BitKeeper.py
+-rw-rw-rw-   0        0        0     2859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/CVS.py
+-rw-rw-rw-   0        0        0    18084 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/GettextCommon.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.895255 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/
+-rw-rw-rw-   0        0        0     2078 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/__init__.py
+-rw-rw-rw-   0        0        0     2004 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/arch.py
+-rw-rw-rw-   0        0        0     9248 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/common.py
+-rw-rw-rw-   0        0        0     2784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/netframework.py
+-rw-rw-rw-   0        0        0    14869 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/sdk.py
+-rw-rw-rw-   0        0        0    19499 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vc.py
+-rw-rw-rw-   0        0        0    20832 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vs.py
+-rw-rw-rw-   0        0        0     3763 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Perforce.py
+-rw-rw-rw-   0        0        0     5149 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/PharLapCommon.py
+-rw-rw-rw-   0        0        0     2290 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/RCS.py
+-rw-rw-rw-   0        0        0     2328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/SCCS.py
+-rw-rw-rw-   0        0        0     2657 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Subversion.py
+-rw-rw-rw-   0        0        0    31283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/__init__.py
+-rw-rw-rw-   0        0        0     2379 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixc++.py
+-rw-rw-rw-   0        0        0     2267 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixcc.py
+-rw-rw-rw-   0        0        0     2681 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixf77.py
+-rw-rw-rw-   0        0        0     2720 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixlink.py
+-rw-rw-rw-   0        0        0     2796 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/applelink.py
+-rw-rw-rw-   0        0        0     2147 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ar.py
+-rw-rw-rw-   0        0        0     2936 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/as.py
+-rw-rw-rw-   0        0        0     2935 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/bcc32.py
+-rw-rw-rw-   0        0        0     3432 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/c++.py
+-rw-rw-rw-   0        0        0     3785 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cc.py
+-rw-rw-rw-   0        0        0     2777 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cyglink.py
+-rw-rw-rw-   0        0        0     1711 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/default.py
+-rw-rw-rw-   0        0        0      142 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/dmd.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.896260 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/
+-rw-rw-rw-   0        0        0    29618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/__init__.py
+-rw-rw-rw-   0        0        0     3428 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/filesystem.py
+-rw-rw-rw-   0        0        0     2681 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g++.py
+-rw-rw-rw-   0        0        0     2433 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g77.py
+-rw-rw-rw-   0        0        0     1844 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gas.py
+-rw-rw-rw-   0        0        0     3472 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gcc.py
+-rw-rw-rw-   0        0        0     4782 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gdc.py
+-rw-rw-rw-   0        0        0     2025 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gettext.py
+-rw-rw-rw-   0        0        0     2256 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gfortran.py
+-rw-rw-rw-   0        0        0     2460 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gnulink.py
+-rw-rw-rw-   0        0        0     2639 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpc++.py
+-rw-rw-rw-   0        0        0     1810 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpcc.py
+-rw-rw-rw-   0        0        0     2333 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hplink.py
+-rw-rw-rw-   0        0        0     2140 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icc.py
+-rw-rw-rw-   0        0        0     1902 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icl.py
+-rw-rw-rw-   0        0        0     2077 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink.py
+-rw-rw-rw-   0        0        0     2043 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink32.py
+-rw-rw-rw-   0        0        0    18600 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/install.py
+-rw-rw-rw-   0        0        0    25816 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/intelc.py
+-rw-rw-rw-   0        0        0     3328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/lex.py
+-rw-rw-rw-   0        0        0     8394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/link.py
+-rw-rw-rw-   0        0        0     3953 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/linkloc.py
+-rw-rw-rw-   0        0        0     2309 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/m4.py
+-rw-rw-rw-   0        0        0     2945 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/masm.py
+-rw-rw-rw-   0        0        0     6919 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mingw.py
+-rw-rw-rw-   0        0        0     4381 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgfmt.py
+-rw-rw-rw-   0        0        0     4658 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msginit.py
+-rw-rw-rw-   0        0        0     4224 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgmerge.py
+-rw-rw-rw-   0        0        0     2168 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslib.py
+-rw-rw-rw-   0        0        0    13881 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslink.py
+-rw-rw-rw-   0        0        0     1804 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mssdk.py
+-rw-rw-rw-   0        0        0    11380 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvc.py
+-rw-rw-rw-   0        0        0    72761 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvs.py
+-rw-rw-rw-   0        0        0     6841 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwcc.py
+-rw-rw-rw-   0        0        0     3579 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwld.py
+-rw-rw-rw-   0        0        0     2618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/nasm.py
+-rw-rw-rw-   0        0        0     4375 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rmic.py
+-rw-rw-rw-   0        0        0     2827 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rpcgen.py
+-rw-rw-rw-   0        0        0     2513 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgiar.py
+-rw-rw-rw-   0        0        0     1991 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgic++.py
+-rw-rw-rw-   0        0        0     1819 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgicc.py
+-rw-rw-rw-   0        0        0     2123 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgilink.py
+-rw-rw-rw-   0        0        0     2502 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunar.py
+-rw-rw-rw-   0        0        0     4695 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunc++.py
+-rw-rw-rw-   0        0        0     1927 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/suncc.py
+-rw-rw-rw-   0        0        0     2349 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunlink.py
+-rw-rw-rw-   0        0        0     2473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tar.py
+-rw-rw-rw-   0        0        0     5992 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/textfile.py
+-rw-rw-rw-   0        0        0     1831 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tlib.py
+-rw-rw-rw-   0        0        0     3730 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/wix.py
+-rw-rw-rw-   0        0        0    13016 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/xgettext.py
+-rw-rw-rw-   0        0        0     3415 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/zip.py
+-rw-rw-rw-   0        0        0    48938 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Util.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.930031 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/
+-rw-rw-rw-   0        0        0     3007 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/BoolVariable.py
+-rw-rw-rw-   0        0        0     3784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/EnumVariable.py
+-rw-rw-rw-   0        0        0     4380 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/ListVariable.py
+-rw-rw-rw-   0        0        0     3557 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PackageVariable.py
+-rw-rw-rw-   0        0        0     5612 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PathVariable.py
+-rw-rw-rw-   0        0        0    11034 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/__init__.py
+-rw-rw-rw-   0        0        0     6824 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Warnings.py
+-rw-rw-rw-   0        0        0     1563 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:46.964052 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/
+-rw-rw-rw-   0        0        0     8120 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/__init__.py
+-rw-rw-rw-   0        0        0     3596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_builtins.py
+-rw-rw-rw-   0        0        0     1818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_collections.py
+-rw-rw-rw-   0        0        0     1742 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_dbm.py
+-rw-rw-rw-   0        0        0     2465 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_hashlib.py
+-rw-rw-rw-   0        0        0     1776 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_io.py
+-rw-rw-rw-   0        0        0    19253 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_sets.py
+-rw-rw-rw-   0        0        0    44500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_subprocess.py
+-rw-rw-rw-   0        0        0    19664 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/cpp.py
+-rw-rw-rw-   0        0        0     7509 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/dblite.py
+-rw-rw-rw-   0        0        0     2107 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/exitfuncs.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.625509 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.041833 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/
+-rw-rw-rw-   0        0        0    53545 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Action.py
+-rw-rw-rw-   0        0        0    34985 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Builder.py
+-rw-rw-rw-   0        0        0    13596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/CacheDir.py
+-rw-rw-rw-   0        0        0    28403 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Conftest.py
+-rw-rw-rw-   0        0        0     7533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Debug.py
+-rw-rw-rw-   0        0        0    20988 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Defaults.py
+-rw-rw-rw-   0        0        0    96818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Environment.py
+-rw-rw-rw-   0        0        0     7752 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Errors.py
+-rw-rw-rw-   0        0        0    22350 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Executor.py
+-rw-rw-rw-   0        0        0    16068 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Job.py
+-rw-rw-rw-   0        0        0     9565 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Memoize.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.075256 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/
+-rw-rw-rw-   0        0        0     5239 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Alias.py
+-rw-rw-rw-   0        0        0   135413 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/FS.py
+-rw-rw-rw-   0        0        0     5758 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Python.py
+-rw-rw-rw-   0        0        0    63474 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/__init__.py
+-rw-rw-rw-   0        0        0     8354 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/PathList.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.135250 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/
+-rw-rw-rw-   0        0        0    11500 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/__init__.py
+-rw-rw-rw-   0        0        0     3180 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/aix.py
+-rw-rw-rw-   0        0        0     2227 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/cygwin.py
+-rw-rw-rw-   0        0        0     2739 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/darwin.py
+-rw-rw-rw-   0        0        0     1767 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/hpux.py
+-rw-rw-rw-   0        0        0     1654 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/irix.py
+-rw-rw-rw-   0        0        0     1460 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/mingw.py
+-rw-rw-rw-   0        0        0     2219 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/os2.py
+-rw-rw-rw-   0        0        0     4476 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/posix.py
+-rw-rw-rw-   0        0        0     1931 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/sunos.py
+-rw-rw-rw-   0        0        0     4003 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/virtualenv.py
+-rw-rw-rw-   0        0        0    17055 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/win32.py
+-rw-rw-rw-   0        0        0    41186 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConf.py
+-rw-rw-rw-   0        0        0    13880 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConsign.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.160299 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/
+-rw-rw-rw-   0        0        0     4853 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/C.py
+-rw-rw-rw-   0        0        0     3812 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Dir.py
+-rw-rw-rw-   0        0        0     3643 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Prog.py
+-rw-rw-rw-   0        0        0     2328 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/RC.py
+-rw-rw-rw-   0        0        0    15053 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.176826 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/
+-rw-rw-rw-   0        0        0    13779 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Interactive.py
+-rw-rw-rw-   0        0        0    53260 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Main.py
+-rw-rw-rw-   0        0        0    39394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConsOptions.py
+-rw-rw-rw-   0        0        0    26467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConscript.py
+-rw-rw-rw-   0        0        0    14489 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/__init__.py
+-rw-rw-rw-   0        0        0    35863 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Subst.py
+-rw-rw-rw-   0        0        0    42204 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Taskmaster.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.576371 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/
+-rw-rw-rw-   0        0        0     2211 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/386asm.py
+-rw-rw-rw-   0        0        0    18207 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/GettextCommon.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.632311 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/
+-rw-rw-rw-   0        0        0     2152 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/__init__.py
+-rw-rw-rw-   0        0        0     2057 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/arch.py
+-rw-rw-rw-   0        0        0    10674 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/common.py
+-rw-rw-rw-   0        0        0     2855 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/netframework.py
+-rw-rw-rw-   0        0        0    15165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/sdk.py
+-rw-rw-rw-   0        0        0    33537 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vc.py
+-rw-rw-rw-   0        0        0    21762 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vs.py
+-rw-rw-rw-   0        0        0     4464 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/PharLapCommon.py
+-rw-rw-rw-   0        0        0    50660 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/__init__.py
+-rw-rw-rw-   0        0        0     1667 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixc++.py
+-rw-rw-rw-   0        0        0     2316 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcc.py
+-rw-rw-rw-   0        0        0     2475 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcxx.py
+-rw-rw-rw-   0        0        0     2840 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixlink.py
+-rw-rw-rw-   0        0        0     8618 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/applelink.py
+-rw-rw-rw-   0        0        0     2226 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ar.py
+-rw-rw-rw-   0        0        0     2978 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/as.py
+-rw-rw-rw-   0        0        0     2977 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/bcc32.py
+-rw-rw-rw-   0        0        0     1653 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/c++.py
+-rw-rw-rw-   0        0        0     3827 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cc.py
+-rw-rw-rw-   0        0        0     3389 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clang.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.633309 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangCommon/
+-rw-rw-rw-   0        0        0      313 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangCommon/__init__.py
+-rw-rw-rw-   0        0        0     3631 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangxx.py
+-rw-rw-rw-   0        0        0     3444 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cxx.py
+-rw-rw-rw-   0        0        0     8494 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cyglink.py
+-rw-rw-rw-   0        0        0     1753 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/default.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.634309 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/
+-rw-rw-rw-   0        0        0    29765 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/__init__.py
+-rw-rw-rw-   0        0        0     3472 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/filesystem.py
+-rw-rw-rw-   0        0        0     1630 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/g++.py
+-rw-rw-rw-   0        0        0     1977 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gas.py
+-rw-rw-rw-   0        0        0     3686 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gcc.py
+-rw-rw-rw-   0        0        0     2580 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gettext_tool.py
+-rw-rw-rw-   0        0        0     2948 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gnulink.py
+-rw-rw-rw-   0        0        0     2655 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gxx.py
+-rw-rw-rw-   0        0        0     1645 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpc++.py
+-rw-rw-rw-   0        0        0     1859 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcc.py
+-rw-rw-rw-   0        0        0     2765 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcxx.py
+-rw-rw-rw-   0        0        0     2386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hplink.py
+-rw-rw-rw-   0        0        0     2189 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icc.py
+-rw-rw-rw-   0        0        0     1944 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icl.py
+-rw-rw-rw-   0        0        0     2123 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink.py
+-rw-rw-rw-   0        0        0     2085 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink32.py
+-rw-rw-rw-   0        0        0    15791 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/install.py
+-rw-rw-rw-   0        0        0    26195 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/intelc.py
+-rw-rw-rw-   0        0        0    13924 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/link.py
+-rw-rw-rw-   0        0        0     4041 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/linkloc.py
+-rw-rw-rw-   0        0        0     2351 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/m4.py
+-rw-rw-rw-   0        0        0     2987 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/masm.py
+-rw-rw-rw-   0        0        0     7808 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mingw.py
+-rw-rw-rw-   0        0        0     4956 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgfmt.py
+-rw-rw-rw-   0        0        0     5235 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msginit.py
+-rw-rw-rw-   0        0        0     4808 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgmerge.py
+-rw-rw-rw-   0        0        0     2475 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslib.py
+-rw-rw-rw-   0        0        0    14751 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslink.py
+-rw-rw-rw-   0        0        0     1847 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mssdk.py
+-rw-rw-rw-   0        0        0    12588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvc.py
+-rw-rw-rw-   0        0        0    82939 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvs.py
+-rw-rw-rw-   0        0        0     6883 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwcc.py
+-rw-rw-rw-   0        0        0     3663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwld.py
+-rw-rw-rw-   0        0        0     2660 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/nasm.py
+-rw-rw-rw-   0        0        0     4904 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rmic.py
+-rw-rw-rw-   0        0        0     2877 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rpcgen.py
+-rw-rw-rw-   0        0        0     2567 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgiar.py
+-rw-rw-rw-   0        0        0     1652 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgic++.py
+-rw-rw-rw-   0        0        0     1868 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicc.py
+-rw-rw-rw-   0        0        0     2088 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicxx.py
+-rw-rw-rw-   0        0        0     2176 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgilink.py
+-rw-rw-rw-   0        0        0     2366 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunar.py
+-rw-rw-rw-   0        0        0     1658 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunc++.py
+-rw-rw-rw-   0        0        0     1976 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncc.py
+-rw-rw-rw-   0        0        0     5335 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncxx.py
+-rw-rw-rw-   0        0        0     2583 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunlink.py
+-rw-rw-rw-   0        0        0     2515 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tar.py
+-rw-rw-rw-   0        0        0     6756 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/textfile.py
+-rw-rw-rw-   0        0        0     1873 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tlib.py
+-rw-rw-rw-   0        0        0     3773 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/wix.py
+-rw-rw-rw-   0        0        0    13982 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/xgettext.py
+-rw-rw-rw-   0        0        0     3201 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/zip.py
+-rw-rw-rw-   0        0        0    53803 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Util.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.673665 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/
+-rw-rw-rw-   0        0        0     3064 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/BoolVariable.py
+-rw-rw-rw-   0        0        0     3818 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/EnumVariable.py
+-rw-rw-rw-   0        0        0     4435 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/ListVariable.py
+-rw-rw-rw-   0        0        0     3643 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PackageVariable.py
+-rw-rw-rw-   0        0        0     5579 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PathVariable.py
+-rw-rw-rw-   0        0        0    11655 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/__init__.py
+-rw-rw-rw-   0        0        0     6504 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Warnings.py
+-rw-rw-rw-   0        0        0     1647 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.674665 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/
+-rw-rw-rw-   0        0        0     6869 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/__init__.py
+-rw-rw-rw-   0        0        0     1784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/_scons_dbm.py
+-rw-rw-rw-   0        0        0    19816 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/cpp.py
+-rw-rw-rw-   0        0        0     9002 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/dblite.py
+-rw-rw-rw-   0        0        0     2149 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/exitfuncs.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.627509 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.880560 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/
+-rw-rw-rw-   0        0        0    56578 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Action.py
+-rw-rw-rw-   0        0        0    35213 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Builder.py
+-rw-rw-rw-   0        0        0    11061 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/CacheDir.py
+-rw-rw-rw-   0        0        0    27408 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Conftest.py
+-rw-rw-rw-   0        0        0     7884 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Debug.py
+-rw-rw-rw-   0        0        0    21423 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Defaults.py
+-rw-rw-rw-   0        0        0    97269 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Environment.py
+-rw-rw-rw-   0        0        0     3979 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/EnvironmentValues.py
+-rw-rw-rw-   0        0        0     7515 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Errors.py
+-rw-rw-rw-   0        0        0    21937 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Executor.py
+-rw-rw-rw-   0        0        0    16583 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Job.py
+-rw-rw-rw-   0        0        0     9430 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Memoize.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:47.938353 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/
+-rw-rw-rw-   0        0        0     5126 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Alias.py
+-rw-rw-rw-   0        0        0   136271 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/FS.py
+-rw-rw-rw-   0        0        0     6167 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Python.py
+-rw-rw-rw-   0        0        0    63768 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/__init__.py
+-rw-rw-rw-   0        0        0     8183 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/PathList.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.040321 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/
+-rw-rw-rw-   0        0        0    12836 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/__init__.py
+-rw-rw-rw-   0        0        0     3087 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/aix.py
+-rw-rw-rw-   0        0        0     2107 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/cygwin.py
+-rw-rw-rw-   0        0        0     2630 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/darwin.py
+-rw-rw-rw-   0        0        0     1674 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/hpux.py
+-rw-rw-rw-   0        0        0     1536 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/irix.py
+-rw-rw-rw-   0        0        0     1311 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/mingw.py
+-rw-rw-rw-   0        0        0     2076 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/os2.py
+-rw-rw-rw-   0        0        0     4356 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/posix.py
+-rw-rw-rw-   0        0        0     1805 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/sunos.py
+-rw-rw-rw-   0        0        0     3860 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/virtualenv.py
+-rw-rw-rw-   0        0        0    14831 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/win32.py
+-rw-rw-rw-   0        0        0    41983 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConf.py
+-rw-rw-rw-   0        0        0    14673 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConsign.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.073847 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/
+-rw-rw-rw-   0        0        0     7394 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/C.py
+-rw-rw-rw-   0        0        0     4357 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Dir.py
+-rw-rw-rw-   0        0        0     3546 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Prog.py
+-rw-rw-rw-   0        0        0     1972 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/RC.py
+-rw-rw-rw-   0        0        0    15577 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.123842 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/
+-rw-rw-rw-   0        0        0    13597 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Interactive.py
+-rw-rw-rw-   0        0        0    53509 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Main.py
+-rw-rw-rw-   0        0        0    42760 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConsOptions.py
+-rw-rw-rw-   0        0        0    26676 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConscript.py
+-rw-rw-rw-   0        0        0    14272 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/__init__.py
+-rw-rw-rw-   0        0        0    36753 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Subst.py
+-rw-rw-rw-   0        0        0    41191 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Taskmaster.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.375247 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/
+-rw-rw-rw-   0        0        0     2122 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/386asm.py
+-rw-rw-rw-   0        0        0    15570 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/GettextCommon.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.408313 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/
+-rw-rw-rw-   0        0        0     2014 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/__init__.py
+-rw-rw-rw-   0        0        0     1943 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/arch.py
+-rw-rw-rw-   0        0        0    13182 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/common.py
+-rw-rw-rw-   0        0        0     2734 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/netframework.py
+-rw-rw-rw-   0        0        0    15027 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/sdk.py
+-rw-rw-rw-   0        0        0    38783 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vc.py
+-rw-rw-rw-   0        0        0    22570 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vs.py
+-rw-rw-rw-   0        0        0     4368 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/PharLapCommon.py
+-rw-rw-rw-   0        0        0    32724 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/__init__.py
+-rw-rw-rw-   0        0        0     1578 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixc++.py
+-rw-rw-rw-   0        0        0     2228 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcc.py
+-rw-rw-rw-   0        0        0     2386 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcxx.py
+-rw-rw-rw-   0        0        0     2616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixlink.py
+-rw-rw-rw-   0        0        0     7993 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/applelink.py
+-rw-rw-rw-   0        0        0     2141 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ar.py
+-rw-rw-rw-   0        0        0     1661 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/as.py
+-rw-rw-rw-   0        0        0     2893 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/asm.py
+-rw-rw-rw-   0        0        0     2889 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/bcc32.py
+-rw-rw-rw-   0        0        0     1567 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/c++.py
+-rw-rw-rw-   0        0        0     3742 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cc.py
+-rw-rw-rw-   0        0        0     3296 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clang.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.409328 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangCommon/
+-rw-rw-rw-   0        0        0      343 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangCommon/__init__.py
+-rw-rw-rw-   0        0        0     3534 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangxx.py
+-rw-rw-rw-   0        0        0     3259 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cxx.py
+-rw-rw-rw-   0        0        0     7461 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cyglink.py
+-rw-rw-rw-   0        0        0     1663 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/default.py
+-rw-rw-rw-   0        0        0     3379 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/filesystem.py
+-rw-rw-rw-   0        0        0     1544 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/g++.py
+-rw-rw-rw-   0        0        0     1891 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gas.py
+-rw-rw-rw-   0        0        0     3616 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gcc.py
+-rw-rw-rw-   0        0        0     2377 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gettext_tool.py
+-rw-rw-rw-   0        0        0     2437 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gnulink.py
+-rw-rw-rw-   0        0        0     2526 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gxx.py
+-rw-rw-rw-   0        0        0     1557 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpc++.py
+-rw-rw-rw-   0        0        0     1772 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcc.py
+-rw-rw-rw-   0        0        0     2677 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcxx.py
+-rw-rw-rw-   0        0        0     2206 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hplink.py
+-rw-rw-rw-   0        0        0     2096 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icc.py
+-rw-rw-rw-   0        0        0     1851 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icl.py
+-rw-rw-rw-   0        0        0     1954 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink.py
+-rw-rw-rw-   0        0        0     1995 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink32.py
+-rw-rw-rw-   0        0        0    19180 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/install.py
+-rw-rw-rw-   0        0        0    25826 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/intelc.py
+-rw-rw-rw-   0        0        0     2588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/link.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.415479 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/
+-rw-rw-rw-   0        0        0     4649 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/LoadableModule.py
+-rw-rw-rw-   0        0        0     7652 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/SharedLibrary.py
+-rw-rw-rw-   0        0        0     6064 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/__init__.py
+-rw-rw-rw-   0        0        0     3931 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkloc.py
+-rw-rw-rw-   0        0        0     2266 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/m4.py
+-rw-rw-rw-   0        0        0     2900 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/masm.py
+-rw-rw-rw-   0        0        0     8622 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mingw.py
+-rw-rw-rw-   0        0        0     4577 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgfmt.py
+-rw-rw-rw-   0        0        0     4517 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msginit.py
+-rw-rw-rw-   0        0        0     4113 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgmerge.py
+-rw-rw-rw-   0        0        0     2387 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslib.py
+-rw-rw-rw-   0        0        0    14473 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslink.py
+-rw-rw-rw-   0        0        0     1752 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mssdk.py
+-rw-rw-rw-   0        0        0    12902 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvc.py
+-rw-rw-rw-   0        0        0    84784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvs.py
+-rw-rw-rw-   0        0        0     6788 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwcc.py
+-rw-rw-rw-   0        0        0     3576 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwld.py
+-rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/nasm.py
+-rw-rw-rw-   0        0        0     4817 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rmic.py
+-rw-rw-rw-   0        0        0     2788 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rpcgen.py
+-rw-rw-rw-   0        0        0     2479 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgiar.py
+-rw-rw-rw-   0        0        0     1563 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgic++.py
+-rw-rw-rw-   0        0        0     1780 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicc.py
+-rw-rw-rw-   0        0        0     1999 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicxx.py
+-rw-rw-rw-   0        0        0     2006 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgilink.py
+-rw-rw-rw-   0        0        0     2271 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunar.py
+-rw-rw-rw-   0        0        0     1569 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunc++.py
+-rw-rw-rw-   0        0        0     1888 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncc.py
+-rw-rw-rw-   0        0        0     4879 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncxx.py
+-rw-rw-rw-   0        0        0     2419 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunlink.py
+-rw-rw-rw-   0        0        0     2429 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tar.py
+-rw-rw-rw-   0        0        0     6412 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/textfile.py
+-rw-rw-rw-   0        0        0     1786 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tlib.py
+-rw-rw-rw-   0        0        0     3687 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/wix.py
+-rw-rw-rw-   0        0        0    12548 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/xgettext.py
+-rw-rw-rw-   0        0        0     4076 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/zip.py
+-rw-rw-rw-   0        0        0    71693 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Util.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.416989 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/
+-rw-rw-rw-   0        0        0     6632 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/ConfigureCache.py
+-rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/__init__.py
+-rw-rw-rw-   0        0        0    15278 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/sconsign.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.427860 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/
+-rw-rw-rw-   0        0        0     3134 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/BoolVariable.py
+-rw-rw-rw-   0        0        0     3896 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/EnumVariable.py
+-rw-rw-rw-   0        0        0     4648 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/ListVariable.py
+-rw-rw-rw-   0        0        0     3536 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PackageVariable.py
+-rw-rw-rw-   0        0        0     5588 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PathVariable.py
+-rw-rw-rw-   0        0        0    12708 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/__init__.py
+-rw-rw-rw-   0        0        0     6785 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Warnings.py
+-rw-rw-rw-   0        0        0      353 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.454302 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/
+-rw-rw-rw-   0        0        0     4307 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/__init__.py
+-rw-rw-rw-   0        0        0     1644 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/_scons_dbm.py
+-rw-rw-rw-   0        0        0     3395 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/win32.py
+-rw-rw-rw-   0        0        0    21614 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/cpp.py
+-rw-rw-rw-   0        0        0     9295 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/dblite.py
+-rw-rw-rw-   0        0        0     2032 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/exitfuncs.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.456294 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/
+-rw-rw-rw-   0        0        0     1467 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/LICENSE.rst
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.464159 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/
+-rw-rw-rw-   0        0        0    10126 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/__init__.py
+-rw-rw-rw-   0        0        0      558 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_compat.py
+-rw-rw-rw-   0        0        0     4690 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_constants.py
+-rw-rw-rw-   0        0        0     1873 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_native.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.629144 nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.469152 nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/
+-rw-rw-rw-   0        0        0   107335 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/__init__.py
+-rw-rw-rw-   0        0        0      538 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/py31compat.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.629144 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.535185 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/
+-rw-rw-rw-   0        0        0     1595 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/__init__.py
+-rw-rw-rw-   0        0        0      283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_main.py
+-rw-rw-rw-   0        0        0     3687 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_monitor.py
+-rw-rw-rw-   0        0        0      283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm.py
+-rw-rw-rw-   0        0        0      307 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_notebook.py
+-rw-rw-rw-   0        0        0      888 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_pandas.py
+-rw-rw-rw-   0        0        0      596 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_utils.py
+-rw-rw-rw-   0        0        0     1106 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/auto.py
+-rw-rw-rw-   0        0        0      857 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/autonotebook.py
+-rw-rw-rw-   0        0        0     1376 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/dask.py
+-rw-rw-rw-   0        0        0    10790 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/notebook.py
+-rw-rw-rw-   0        0        0    57572 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/std.py
+-rw-rw-rw-   0        0        0     6948 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/tk.py
+-rw-rw-rw-   0        0        0     9726 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/utils.py
+-rw-rw-rw-   0        0        0       99 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/version.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.535185 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/
+-rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/LICENSE
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.642690 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/
+-rw-rw-rw-   0        0        0    13170 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/__init__.py
+-rw-rw-rw-   0        0        0     4883 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/composer.py
+-rw-rw-rw-   0        0        0    28639 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/constructor.py
+-rw-rw-rw-   0        0        0     3851 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/cyaml.py
+-rw-rw-rw-   0        0        0     2837 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/dumper.py
+-rw-rw-rw-   0        0        0    43006 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/emitter.py
+-rw-rw-rw-   0        0        0     2533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/error.py
+-rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/events.py
+-rw-rw-rw-   0        0        0     2061 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/loader.py
+-rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/nodes.py
+-rw-rw-rw-   0        0        0    25495 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/parser.py
+-rw-rw-rw-   0        0        0     6794 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/reader.py
+-rw-rw-rw-   0        0        0    14184 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/representer.py
+-rw-rw-rw-   0        0        0     8999 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/resolver.py
+-rw-rw-rw-   0        0        0    51277 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/scanner.py
+-rw-rw-rw-   0        0        0     4165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/serializer.py
+-rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/tokens.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.643689 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/
+-rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/LICENSE
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.702772 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/
+-rw-rw-rw-   0        0        0     9776 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/__init__.py
+-rw-rw-rw-   0        0        0     4921 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/composer.py
+-rw-rw-rw-   0        0        0    25145 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/constructor.py
+-rw-rw-rw-   0        0        0     3290 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/cyaml.py
+-rw-rw-rw-   0        0        0     2719 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/dumper.py
+-rw-rw-rw-   0        0        0    43298 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/emitter.py
+-rw-rw-rw-   0        0        0     2559 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/error.py
+-rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/events.py
+-rw-rw-rw-   0        0        0     1132 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/loader.py
+-rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/nodes.py
+-rw-rw-rw-   0        0        0    25542 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/parser.py
+-rw-rw-rw-   0        0        0     6746 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/reader.py
+-rw-rw-rw-   0        0        0    17711 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/representer.py
+-rw-rw-rw-   0        0        0     9122 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/resolver.py
+-rw-rw-rw-   0        0        0    52446 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/scanner.py
+-rw-rw-rw-   0        0        0     4171 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/serializer.py
+-rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/tokens.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.703771 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/
+-rw-rw-rw-   0        0        0     1101 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/LICENSE
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:48.867191 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/
+-rw-rw-rw-   0        0        0     9607 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/__init__.py
+-rw-rw-rw-   0        0        0     4881 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/composer.py
+-rw-rw-rw-   0        0        0    25554 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/constructor.py
+-rw-rw-rw-   0        0        0     3294 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/cyaml.py
+-rw-rw-rw-   0        0        0     2723 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/dumper.py
+-rw-rw-rw-   0        0        0    42954 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/emitter.py
+-rw-rw-rw-   0        0        0     2533 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/error.py
+-rw-rw-rw-   0        0        0     2445 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/events.py
+-rw-rw-rw-   0        0        0     1138 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/loader.py
+-rw-rw-rw-   0        0        0     1440 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/nodes.py
+-rw-rw-rw-   0        0        0    25495 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/parser.py
+-rw-rw-rw-   0        0        0     6854 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/reader.py
+-rw-rw-rw-   0        0        0    14097 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/representer.py
+-rw-rw-rw-   0        0        0     8970 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/resolver.py
+-rw-rw-rw-   0        0        0    51695 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/scanner.py
+-rw-rw-rw-   0        0        0     4165 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/serializer.py
+-rw-rw-rw-   0        0        0     2573 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/tokens.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:49.043415 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/
+-rw-rw-rw-   0        0        0     1002 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/LICENSE
+-rw-rw-rw-   0        0        0    31605 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/crc32.c
+-rw-rw-rw-   0        0        0   591749 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/crc32.h
+-rw-rw-rw-   0        0        0    16682 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zconf.h
+-rw-rw-rw-   0        0        0    96778 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zlib.h
+-rw-rw-rw-   0        0        0     7247 2023-12-06 01:19:25.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zutil.h
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:49.061341 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/
+-rw-rw-rw-   0        0        0     1530 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/LICENSE.txt
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:50.120453 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/
+-rw-rw-rw-   0        0        0    18198 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/bitstream.h
+-rw-rw-rw-   0        0        0    10157 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/compiler.h
+-rw-rw-rw-   0        0        0     4455 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/cpu.h
+-rw-rw-rw-   0        0        0     3763 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/debug.h
+-rw-rw-rw-   0        0        0    13662 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/entropy_common.c
+-rw-rw-rw-   0        0        0     3009 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/error_private.c
+-rw-rw-rw-   0        0        0     2441 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/error_private.h
+-rw-rw-rw-   0        0        0    34422 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/fse.h
+-rw-rw-rw-   0        0        0    14748 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/fse_decompress.c
+-rw-rw-rw-   0        0        0    20216 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/huf.h
+-rw-rw-rw-   0        0        0    13930 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/mem.h
+-rw-rw-rw-   0        0        0    26976 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/xxhash.c
+-rw-rw-rw-   0        0        0    11706 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/xxhash.h
+-rw-rw-rw-   0        0        0     2728 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_common.c
+-rw-rw-rw-   0        0        0     2497 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_deps.h
+-rw-rw-rw-   0        0        0     3828 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_errors.h
+-rw-rw-rw-   0        0        0    15880 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_internal.h
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:50.858562 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/
+-rw-rw-rw-   0        0        0    54982 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/huf_decompress.c
+-rw-rw-rw-   0        0        0     9164 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.c
+-rw-rw-rw-   0        0        0     1321 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.h
+-rw-rw-rw-   0        0        0    80283 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress.c
+-rw-rw-rw-   0        0        0    66784 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.c
+-rw-rw-rw-   0        0        0     2253 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.h
+-rw-rw-rw-   0        0        0     7906 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_internal.h
+-rw-rw-rw-   0        0        0   138334 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/zstd.h
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:54.513237 nuitka_winsvc-2.3/nuitka/build/static_src/
+-rw-rw-rw-   0        0        0    83930 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledAsyncgenType.c
+-rw-rw-rw-   0        0        0     9151 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCellType.c
+-rw-rw-rw-   0        0        0    59032 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCodeHelpers.c
+-rw-rw-rw-   0        0        0    72338 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCoroutineType.c
+-rw-rw-rw-   0        0        0    41388 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledFrameType.c
+-rw-rw-rw-   0        0        0   111154 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledFunctionType.c
+-rw-rw-rw-   0        0        0    67867 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledGeneratorType.c
+-rw-rw-rw-   0        0        0    56209 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledGeneratorTypeUncompiledIntegration.c
+-rw-rw-rw-   0        0        0    22410 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/CompiledMethodType.c
+-rw-rw-rw-   0        0        0    20752 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersAllocator.c
+-rw-rw-rw-   0        0        0    37589 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersAttributes.c
+-rw-rw-rw-   0        0        0    23729 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBuiltin.c
+-rw-rw-rw-   0        0        0   114017 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBuiltinTypeMethods.c
+-rw-rw-rw-   0        0        0     3066 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBytes.c
+-rw-rw-rw-   0        0        0    13482 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersCalling.c
+-rw-rw-rw-   0        0        0   483053 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersCallingGenerated.c
+-rw-rw-rw-   0        0        0     2065 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersChecksumTools.c
+-rw-rw-rw-   0        0        0     3051 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersClasses.c
+-rw-rw-rw-   0        0        0   321850 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonEq.c
+-rw-rw-rw-   0        0        0     4820 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonEqUtils.c
+-rw-rw-rw-   0        0        0   316970 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonGe.c
+-rw-rw-rw-   0        0        0   316372 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonGt.c
+-rw-rw-rw-   0        0        0   320184 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonLe.c
+-rw-rw-rw-   0        0        0   319586 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonLt.c
+-rw-rw-rw-   0        0        0   318598 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonNe.c
+-rw-rw-rw-   0        0        0     3864 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersConsole.c
+-rw-rw-rw-   0        0        0    36914 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersConstantsBlob.c
+-rw-rw-rw-   0        0        0    20361 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDeepcopy.c
+-rw-rw-rw-   0        0        0    40067 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDictionaries.c
+-rw-rw-rw-   0        0        0    28000 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDictionariesGenerated.c
+-rw-rw-rw-   0        0        0     2066 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDumpBacktraces.c
+-rw-rw-rw-   0        0        0     2194 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersEnvironmentVariables.c
+-rw-rw-rw-   0        0        0     2979 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersEnvironmentVariablesSystem.c
+-rw-rw-rw-   0        0        0    10646 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersExceptions.c
+-rw-rw-rw-   0        0        0     8349 2024-04-22 02:58:07.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFiles.c
+-rw-rw-rw-   0        0        0    30086 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFilesystemPaths.c
+-rw-rw-rw-   0        0        0     2719 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFloats.c
+-rw-rw-rw-   0        0        0     1803 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersHeapStorage.c
+-rw-rw-rw-   0        0        0    16088 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersImport.c
+-rw-rw-rw-   0        0        0    16843 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersImportHard.c
+-rw-rw-rw-   0        0        0     1821 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersJitSources.c
+-rw-rw-rw-   0        0        0    21580 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersLists.c
+-rw-rw-rw-   0        0        0    14316 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersListsGenerated.c
+-rw-rw-rw-   0        0        0     1669 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersMappings.c
+-rw-rw-rw-   0        0        0     4168 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersMatching.c
+-rw-rw-rw-   0        0        0   183706 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryAdd.c
+-rw-rw-rw-   0        0        0    19943 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryAddUtils.c
+-rw-rw-rw-   0        0        0    78269 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitand.c
+-rw-rw-rw-   0        0        0    78108 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitor.c
+-rw-rw-rw-   0        0        0    78269 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitxor.c
+-rw-rw-rw-   0        0        0    68434 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryDivmod.c
+-rw-rw-rw-   0        0        0     1265 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryDivmodUtils.c
+-rw-rw-rw-   0        0        0    69695 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryFloordiv.c
+-rw-rw-rw-   0        0        0     6300 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryInplaceAdd.c
+-rw-rw-rw-   0        0        0    84224 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryLshift.c
+-rw-rw-rw-   0        0        0    13868 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMatmult.c
+-rw-rw-rw-   0        0        0   184677 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMod.c
+-rw-rw-rw-   0        0        0   189035 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMult.c
+-rw-rw-rw-   0        0        0     3593 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMultUtils.c
+-rw-rw-rw-   0        0        0    67400 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryOlddiv.c
+-rw-rw-rw-   0        0        0    79727 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryPow.c
+-rw-rw-rw-   0        0        0     1052 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryPowUtils.c
+-rw-rw-rw-   0        0        0    78124 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryRshift.c
+-rw-rw-rw-   0        0        0    71067 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinarySub.c
+-rw-rw-rw-   0        0        0    68952 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryTruediv.c
+-rw-rw-rw-   0        0        0   152156 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceAdd.c
+-rw-rw-rw-   0        0        0     4242 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceAddUtils.c
+-rw-rw-rw-   0        0        0    53478 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitand.c
+-rw-rw-rw-   0        0        0    53376 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitor.c
+-rw-rw-rw-   0        0        0    53478 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitxor.c
+-rw-rw-rw-   0        0        0    77371 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceFloordiv.c
+-rw-rw-rw-   0        0        0    48019 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceLshift.c
+-rw-rw-rw-   0        0        0    17861 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMatmult.c
+-rw-rw-rw-   0        0        0   137015 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMod.c
+-rw-rw-rw-   0        0        0   142537 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMult.c
+-rw-rw-rw-   0        0        0    75001 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceOlddiv.c
+-rw-rw-rw-   0        0        0    83514 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplacePow.c
+-rw-rw-rw-   0        0        0    45503 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceRshift.c
+-rw-rw-rw-   0        0        0    83527 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceSub.c
+-rw-rw-rw-   0        0        0    77202 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceTruediv.c
+-rw-rw-rw-   0        0        0     3294 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersProfiling.c
+-rw-rw-rw-   0        0        0     3840 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersPythonPgo.c
+-rw-rw-rw-   0        0        0    18571 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersRaising.c
+-rw-rw-rw-   0        0        0     4049 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSafeStrings.c
+-rw-rw-rw-   0        0        0     3759 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSequences.c
+-rw-rw-rw-   0        0        0     2233 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSlices.c
+-rw-rw-rw-   0        0        0    32301 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersStrings.c
+-rw-rw-rw-   0        0        0     4481 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersTuples.c
+-rw-rw-rw-   0        0        0     6786 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/build/static_src/HelpersTypes.c
+-rw-rw-rw-   0        0        0    14331 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/InspectPatcher.c
+-rw-rw-rw-   0        0        0    56113 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/MainProgram.c
+-rw-rw-rw-   0        0        0    65104 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoader.c
+-rw-rw-rw-   0        0        0     4827 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderImportlibMetadataDistribution.c
+-rw-rw-rw-   0        0        0     6651 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReader.c
+-rw-rw-rw-   0        0        0    21913 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReaderFiles.c
+-rw-rw-rw-   0        0        0    37344 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/build/static_src/OnefileBootstrap.c
+-rw-rw-rw-   0        0        0     8050 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/build/static_src/OnefileSplashScreen.cpp
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:54.573070 nuitka_winsvc-2.3/nuitka/code_generation/
+-rw-rw-rw-   0        0        0     6491 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/AsyncgenCodes.py
+-rw-rw-rw-   0        0        0    10821 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/AttributeCodes.py
+-rw-rw-rw-   0        0        0    21926 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/BinaryOperationHelperDefinitions.py
+-rw-rw-rw-   0        0        0     2371 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/BranchCodes.py
+-rw-rw-rw-   0        0        0    17006 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/BuiltinCodes.py
+-rw-rw-rw-   0        0        0    36111 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/CallCodes.py
+-rw-rw-rw-   0        0        0     4958 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/ClassCodes.py
+-rw-rw-rw-   0        0        0    53600 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/CodeGeneration.py
+-rw-rw-rw-   0        0        0     2408 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/CodeHelperSelection.py
+-rw-rw-rw-   0        0        0    14320 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/CodeHelpers.py
+-rw-rw-rw-   0        0        0     5147 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/CodeObjectCodes.py
+-rw-rw-rw-   0        0        0    17957 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/ComparisonCodes.py
+-rw-rw-rw-   0        0        0     4479 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/ComparisonHelperDefinitions.py
+-rw-rw-rw-   0        0        0     7368 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/ConditionalCodes.py
+-rw-rw-rw-   0        0        0     6913 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/ConstantCodes.py
+-rw-rw-rw-   0        0        0    34299 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/Contexts.py
+-rw-rw-rw-   0        0        0     8589 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/CoroutineCodes.py
+-rw-rw-rw-   0        0        0     1607 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/CtypesCodes.py
+-rw-rw-rw-   0        0        0    28942 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/DictCodes.py
+-rw-rw-rw-   0        0        0     2159 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/Emission.py
+-rw-rw-rw-   0        0        0     9289 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/ErrorCodes.py
+-rw-rw-rw-   0        0        0    12983 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/EvalCodes.py
+-rw-rw-rw-   0        0        0     9243 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/ExceptionCodes.py
+-rw-rw-rw-   0        0        0     7384 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/ExpressionCTypeSelectionHelpers.py
+-rw-rw-rw-   0        0        0     2126 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/ExpressionCodes.py
+-rw-rw-rw-   0        0        0    17852 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/FrameCodes.py
+-rw-rw-rw-   0        0        0    28336 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/FunctionCodes.py
+-rw-rw-rw-   0        0        0     7836 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/GeneratorCodes.py
+-rw-rw-rw-   0        0        0     6478 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/GlobalConstants.py
+-rw-rw-rw-   0        0        0     6997 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/GlobalsLocalsCodes.py
+-rw-rw-rw-   0        0        0     1870 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/IdCodes.py
+-rw-rw-rw-   0        0        0    14727 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/ImportCodes.py
+-rw-rw-rw-   0        0        0     1429 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/Indentation.py
+-rw-rw-rw-   0        0        0     1574 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/IndexCodes.py
+-rw-rw-rw-   0        0        0     1066 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/InjectCCodes.py
+-rw-rw-rw-   0        0        0     3567 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/IntegerCodes.py
+-rw-rw-rw-   0        0        0    12211 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/IteratorCodes.py
+-rw-rw-rw-   0        0        0     1620 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/JitCodes.py
+-rw-rw-rw-   0        0        0     2055 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/LabelCodes.py
+-rw-rw-rw-   0        0        0     2645 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/LineNumberCodes.py
+-rw-rw-rw-   0        0        0    15865 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/ListCodes.py
+-rw-rw-rw-   0        0        0     6658 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/LoaderCodes.py
+-rw-rw-rw-   0        0        0    10022 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/LocalsDictCodes.py
+-rw-rw-rw-   0        0        0     3174 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/LoopCodes.py
+-rw-rw-rw-   0        0        0     1637 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/MatchCodes.py
+-rw-rw-rw-   0        0        0     7232 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/ModuleCodes.py
+-rw-rw-rw-   0        0        0     8224 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/Namify.py
+-rw-rw-rw-   0        0        0     1860 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/NetworkxCodes.py
+-rw-rw-rw-   0        0        0    12733 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/OperationCodes.py
+-rw-rw-rw-   0        0        0    30688 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/PackageResourceCodes.py
+-rw-rw-rw-   0        0        0     3054 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/PrintCodes.py
+-rw-rw-rw-   0        0        0     5670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/PythonAPICodes.py
+-rw-rw-rw-   0        0        0    13251 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/RaisingCodes.py
+-rw-rw-rw-   0        0        0     3476 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/Reports.py
+-rw-rw-rw-   0        0        0     5267 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/ReturnCodes.py
+-rw-rw-rw-   0        0        0     6591 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/SetCodes.py
+-rw-rw-rw-   0        0        0    14029 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/SliceCodes.py
+-rw-rw-rw-   0        0        0    10087 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/StringCodes.py
+-rw-rw-rw-   0        0        0     8018 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/SubscriptCodes.py
+-rw-rw-rw-   0        0        0     1939 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/TensorflowCodes.py
+-rw-rw-rw-   0        0        0    11208 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/TryCodes.py
+-rw-rw-rw-   0        0        0     3848 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/TupleCodes.py
+-rw-rw-rw-   0        0        0     2362 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/TypeAliasCodes.py
+-rw-rw-rw-   0        0        0    14811 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/VariableCodes.py
+-rw-rw-rw-   0        0        0     9155 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/VariableDeclarations.py
+-rw-rw-rw-   0        0        0     8129 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/YieldCodes.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:54.580103 nuitka_winsvc-2.3/nuitka/code_generation/c_types/
+-rw-rw-rw-   0        0        0     6102 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeBases.py
+-rw-rw-rw-   0        0        0     3432 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeBooleans.py
+-rw-rw-rw-   0        0        0     1837 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeCFloats.py
+-rw-rw-rw-   0        0        0     1410 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeCLongs.py
+-rw-rw-rw-   0        0        0     3642 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeModuleDictVariables.py
+-rw-rw-rw-   0        0        0     5161 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaBooleans.py
+-rw-rw-rw-   0        0        0     5243 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaInts.py
+-rw-rw-rw-   0        0        0     3988 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaVoids.py
+-rw-rw-rw-   0        0        0    19750 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypePyObjectPointers.py
+-rw-rw-rw-   0        0        0     2886 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeVoids.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/c_types/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:54.587112 nuitka_winsvc-2.3/nuitka/code_generation/templates/
+-rw-rw-rw-   0        0        0     2948 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesAsyncgens.py
+-rw-rw-rw-   0        0        0     9541 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesConstants.py
+-rw-rw-rw-   0        0        0     3040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesCoroutines.py
+-rw-rw-rw-   0        0        0     2439 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesExceptions.py
+-rw-rw-rw-   0        0        0     6483 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesFrames.py
+-rw-rw-rw-   0        0        0     3460 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesFunction.py
+-rw-rw-rw-   0        0        0     3390 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesGeneratorFunction.py
+-rw-rw-rw-   0        0        0     2408 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesIterators.py
+-rw-rw-rw-   0        0        0     4568 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesLoader.py
+-rw-rw-rw-   0        0        0    23519 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesModules.py
+-rw-rw-rw-   0        0        0     6840 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesVariables.py
+-rw-rw-rw-   0        0        0     2507 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/TemplateDebugWrapper.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.087460 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/
+-rw-rw-rw-   0        0        0    11318 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMethodPositional.c.j2
+-rw-rw-rw-   0        0        0     5837 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMixed.c.j2
+-rw-rw-rw-   0        0        0    24068 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositional.c.j2
+-rw-rw-rw-   0        0        0     5478 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositionalMethodDescr.c.j2
+-rw-rw-rw-   0        0        0     1786 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListHinted.c.j2
+-rw-rw-rw-   0        0        0     1723 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListSmall.c.j2
+-rw-rw-rw-   0        0        0     2706 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperBuiltinMethodOperation.c.j2
+-rw-rw-rw-   0        0        0    14958 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperDictionaryCopy.c.j2
+-rw-rw-rw-   0        0        0     1896 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperImportHard.c.j2
+-rw-rw-rw-   0        0        0     2618 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperLongTools.c.j2
+-rw-rw-rw-   0        0        0     1394 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperObjectTools.c.j2
+-rw-rw-rw-   0        0        0     7057 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationBinary.c.j2
+-rw-rw-rw-   0        0        0    12860 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparison.c.j2
+-rw-rw-rw-   0        0        0     4235 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonBytes.c.j2
+-rw-rw-rw-   0        0        0     1959 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonFloat.c.j2
+-rw-rw-rw-   0        0        0     1989 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonInt.c.j2
+-rw-rw-rw-   0        0        0     4140 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonList.c.j2
+-rw-rw-rw-   0        0        0     7278 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonLong.c.j2
+-rw-rw-rw-   0        0        0     4239 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonStr.c.j2
+-rw-rw-rw-   0        0        0     3769 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonTuple.c.j2
+-rw-rw-rw-   0        0        0     4534 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonUnicode.c.j2
+-rw-rw-rw-   0        0        0    11767 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationInplace.c.j2
+-rw-rw-rw-   0        0        0    19194 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsBinary.c.j2
+-rw-rw-rw-   0        0        0     2693 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsBytes.c.j2
+-rw-rw-rw-   0        0        0     3485 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsCommon.c.j2
+-rw-rw-rw-   0        0        0    11336 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsFloat.c.j2
+-rw-rw-rw-   0        0        0    15540 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsInt.c.j2
+-rw-rw-rw-   0        0        0     2934 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsList.c.j2
+-rw-rw-rw-   0        0        0    10395 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsLong.c.j2
+-rw-rw-rw-   0        0        0     2407 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsSet.c.j2
+-rw-rw-rw-   0        0        0     2870 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsStr.c.j2
+-rw-rw-rw-   0        0        0     2939 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsTuple.c.j2
+-rw-rw-rw-   0        0        0     3128 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsUnicode.c.j2
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.183586 nuitka_winsvc-2.3/nuitka/containers/
+-rw-rw-rw-   0        0        0     1467 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/containers/Namedtuples.py
+-rw-rw-rw-   0        0        0     6553 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/containers/OrderedDicts.py
+-rw-rw-rw-   0        0        0      554 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/nuitka/containers/OrderedSets.py
+-rw-rw-rw-   0        0        0     4430 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/containers/OrderedSetsFallback.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/containers/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.212708 nuitka_winsvc-2.3/nuitka/distutils/
+-rw-rw-rw-   0        0        0     2308 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/distutils/Build.py
+-rw-rw-rw-   0        0        0    15025 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/distutils/DistutilCommands.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/distutils/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.251063 nuitka_winsvc-2.3/nuitka/finalizations/
+-rw-rw-rw-   0        0        0     1258 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/finalizations/Finalization.py
+-rw-rw-rw-   0        0        0     5465 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/finalizations/FinalizeMarkups.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/finalizations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.457611 nuitka_winsvc-2.3/nuitka/freezer/
+-rw-rw-rw-   0        0        0     7953 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/DependsExe.py
+-rw-rw-rw-   0        0        0     2616 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesCommon.py
+-rw-rw-rw-   0        0        0    14423 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesMacOS.py
+-rw-rw-rw-   0        0        0     7468 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesPosix.py
+-rw-rw-rw-   0        0        0     6731 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesWin32.py
+-rw-rw-rw-   0        0        0    11999 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/ImportDetection.py
+-rw-rw-rw-   0        0        0    19404 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/IncludedDataFiles.py
+-rw-rw-rw-   0        0        0    11455 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/freezer/IncludedEntryPoints.py
+-rw-rw-rw-   0        0        0    10442 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/nuitka/freezer/Onefile.py
+-rw-rw-rw-   0        0        0    12274 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/freezer/Standalone.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/freezer/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.697413 nuitka_winsvc-2.3/nuitka/importing/
+-rw-rw-rw-   0        0        0    11040 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/importing/IgnoreListing.py
+-rw-rw-rw-   0        0        0     2989 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/importing/ImportCache.py
+-rw-rw-rw-   0        0        0     7784 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/importing/ImportResolving.py
+-rw-rw-rw-   0        0        0    33380 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/importing/Importing.py
+-rw-rw-rw-   0        0        0     4869 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/importing/PreloadedPackages.py
+-rw-rw-rw-   0        0        0    18804 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/importing/Recursion.py
+-rw-rw-rw-   0        0        0    12918 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/importing/StandardLibrary.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/importing/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.909460 nuitka_winsvc-2.3/nuitka/nodes/
+-rw-rw-rw-   0        0        0     3670 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/AsyncgenNodes.py
+-rw-rw-rw-   0        0        0     4115 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/AttributeLookupNodes.py
+-rw-rw-rw-   0        0        0    13255 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/AttributeNodes.py
+-rw-rw-rw-   0        0        0   379568 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/AttributeNodesGenerated.py
+-rw-rw-rw-   0        0        0     3856 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinAllNodes.py
+-rw-rw-rw-   0        0        0     4131 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinAnyNodes.py
+-rw-rw-rw-   0        0        0     2530 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinComplexNodes.py
+-rw-rw-rw-   0        0        0     1731 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinDecodingNodes.py
+-rw-rw-rw-   0        0        0     2760 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinDecoratorNodes.py
+-rw-rw-rw-   0        0        0     4727 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinDictNodes.py
+-rw-rw-rw-   0        0        0     4982 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinFormatNodes.py
+-rw-rw-rw-   0        0        0     2275 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinHashNodes.py
+-rw-rw-rw-   0        0        0     1457 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinInputNodes.py
+-rw-rw-rw-   0        0        0     5367 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinIntegerNodes.py
+-rw-rw-rw-   0        0        0    12812 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinIteratorNodes.py
+-rw-rw-rw-   0        0        0     2029 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinLenNodes.py
+-rw-rw-rw-   0        0        0     3639 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinNextNodes.py
+-rw-rw-rw-   0        0        0     3787 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinOpenNodes.py
+-rw-rw-rw-   0        0        0   246360 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinOperationNodeBasesGenerated.py
+-rw-rw-rw-   0        0        0    18648 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinRangeNodes.py
+-rw-rw-rw-   0        0        0     9468 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinRefNodes.py
+-rw-rw-rw-   0        0        0     3353 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinSumNodes.py
+-rw-rw-rw-   0        0        0    13576 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinTypeNodes.py
+-rw-rw-rw-   0        0        0     1605 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/BuiltinVarsNodes.py
+-rw-rw-rw-   0        0        0    26146 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/BytesNodes.py
+-rw-rw-rw-   0        0        0     6511 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/CallNodes.py
+-rw-rw-rw-   0        0        0     1583 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/Checkers.py
+-rw-rw-rw-   0        0        0   647842 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/ChildrenHavingMixins.py
+-rw-rw-rw-   0        0        0     8480 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ClassNodes.py
+-rw-rw-rw-   0        0        0     6622 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/CodeObjectSpecs.py
+-rw-rw-rw-   0        0        0    21716 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ComparisonNodes.py
+-rw-rw-rw-   0        0        0    30191 2024-05-15 06:21:28.000000 nuitka_winsvc-2.3/nuitka/nodes/ConditionalNodes.py
+-rw-rw-rw-   0        0        0    47737 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/ConstantRefNodes.py
+-rw-rw-rw-   0        0        0    12246 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ContainerMakingNodes.py
+-rw-rw-rw-   0        0        0     2867 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ContainerOperationNodes.py
+-rw-rw-rw-   0        0        0     4614 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/CoroutineNodes.py
+-rw-rw-rw-   0        0        0     1746 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/CtypesNodes.py
+-rw-rw-rw-   0        0        0    51053 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/DictionaryNodes.py
+-rw-rw-rw-   0        0        0     8151 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/ExceptionNodes.py
+-rw-rw-rw-   0        0        0     7408 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ExecEvalNodes.py
+-rw-rw-rw-   0        0        0    45046 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/ExpressionBases.py
+-rw-rw-rw-   0        0        0    56143 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/ExpressionBasesGenerated.py
+-rw-rw-rw-   0        0        0    21311 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/ExpressionShapeMixins.py
+-rw-rw-rw-   0        0        0    12024 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/FrameNodes.py
+-rw-rw-rw-   0        0        0     3577 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/FunctionAttributeNodes.py
+-rw-rw-rw-   0        0        0    41167 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/FunctionNodes.py
+-rw-rw-rw-   0        0        0     5409 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/FutureSpecs.py
+-rw-rw-rw-   0        0        0     6288 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/GeneratorNodes.py
+-rw-rw-rw-   0        0        0     6961 2024-04-07 02:15:13.000000 nuitka_winsvc-2.3/nuitka/nodes/GlobalsLocalsNodes.py
+-rw-rw-rw-   0        0        0   100500 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/HardImportNodesGenerated.py
+-rw-rw-rw-   0        0        0     5631 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/ImportHardNodes.py
+-rw-rw-rw-   0        0        0    48286 2024-05-15 06:21:28.000000 nuitka_winsvc-2.3/nuitka/nodes/ImportNodes.py
+-rw-rw-rw-   0        0        0     2766 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/IndicatorMixins.py
+-rw-rw-rw-   0        0        0     1533 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/InjectCNodes.py
+-rw-rw-rw-   0        0        0    11519 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/IterationHandles.py
+-rw-rw-rw-   0        0        0    11035 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/KeyValuePairNodes.py
+-rw-rw-rw-   0        0        0    16821 2024-03-14 05:29:37.000000 nuitka_winsvc-2.3/nuitka/nodes/ListOperationNodes.py
+-rw-rw-rw-   0        0        0    23177 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/LocalsDictNodes.py
+-rw-rw-rw-   0        0        0    15007 2024-03-06 05:39:35.000000 nuitka_winsvc-2.3/nuitka/nodes/LocalsScopes.py
+-rw-rw-rw-   0        0        0    15995 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/LoopNodes.py
+-rw-rw-rw-   0        0        0     1745 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/MatchNodes.py
+-rw-rw-rw-   0        0        0     6567 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/ModuleAttributeNodes.py
+-rw-rw-rw-   0        0        0    33158 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/ModuleNodes.py
+-rw-rw-rw-   0        0        0     1759 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/NetworkxNodes.py
+-rw-rw-rw-   0        0        0    24461 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/NodeBases.py
+-rw-rw-rw-   0        0        0    15147 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/NodeMakingHelpers.py
+-rw-rw-rw-   0        0        0     5580 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/NodeMetaClasses.py
+-rw-rw-rw-   0        0        0    31948 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/OperatorNodes.py
+-rw-rw-rw-   0        0        0     8976 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/OperatorNodesUnary.py
+-rw-rw-rw-   0        0        0     5718 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/OsSysNodes.py
+-rw-rw-rw-   0        0        0    12468 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/OutlineNodes.py
+-rw-rw-rw-   0        0        0    34735 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/PackageMetadataNodes.py
+-rw-rw-rw-   0        0        0    12289 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/PackageResourceNodes.py
+-rw-rw-rw-   0        0        0     3440 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/PrintNodes.py
+-rw-rw-rw-   0        0        0     6805 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/ReturnNodes.py
+-rw-rw-rw-   0        0        0     4748 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/SideEffectNodes.py
+-rw-rw-rw-   0        0        0    12547 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/SliceNodes.py
+-rw-rw-rw-   0        0        0    98808 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/StatementBasesGenerated.py
+-rw-rw-rw-   0        0        0     9336 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/StatementNodes.py
+-rw-rw-rw-   0        0        0    28691 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/StrNodes.py
+-rw-rw-rw-   0        0        0     3538 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/StringConcatenationNodes.py
+-rw-rw-rw-   0        0        0     8346 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/nodes/SubscriptNodes.py
+-rw-rw-rw-   0        0        0     1411 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/TensorflowNodes.py
+-rw-rw-rw-   0        0        0    17886 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/TryNodes.py
+-rw-rw-rw-   0        0        0     2438 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/TypeMatchNodes.py
+-rw-rw-rw-   0        0        0    11717 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/TypeNodes.py
+-rw-rw-rw-   0        0        0    42396 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/VariableAssignNodes.py
+-rw-rw-rw-   0        0        0    10779 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/VariableDelNodes.py
+-rw-rw-rw-   0        0        0     4607 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/VariableNameNodes.py
+-rw-rw-rw-   0        0        0    31274 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/VariableRefNodes.py
+-rw-rw-rw-   0        0        0     4781 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/VariableReleaseNodes.py
+-rw-rw-rw-   0        0        0     3937 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/YieldNodes.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.928455 nuitka_winsvc-2.3/nuitka/nodes/shapes/
+-rw-rw-rw-   0        0        0   157357 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/nodes/shapes/BuiltinTypeShapes.py
+-rw-rw-rw-   0        0        0     4420 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/shapes/ControlFlowDescriptions.py
+-rw-rw-rw-   0        0        0     5076 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/shapes/ShapeMixins.py
+-rw-rw-rw-   0        0        0    42509 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/shapes/StandardShapes.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/nodes/shapes/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.977794 nuitka_winsvc-2.3/nuitka/optimizations/
+-rw-rw-rw-   0        0        0     3358 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/optimizations/BytecodeDemotion.py
+-rw-rw-rw-   0        0        0     3953 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/optimizations/FunctionInlining.py
+-rw-rw-rw-   0        0        0     2177 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/optimizations/Graphs.py
+-rw-rw-rw-   0        0        0    10917 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/optimizations/Optimization.py
+-rw-rw-rw-   0        0        0    52575 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/optimizations/OptimizeBuiltinCalls.py
+-rw-rw-rw-   0        0        0     2287 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/optimizations/Tags.py
+-rw-rw-rw-   0        0        0    42800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/optimizations/TraceCollections.py
+-rw-rw-rw-   0        0        0    25799 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/optimizations/ValueTraces.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/optimizations/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.978849 nuitka_winsvc-2.3/nuitka/pgo/
+-rw-rw-rw-   0        0        0     4932 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/pgo/PGO.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/pgo/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:57.982031 nuitka_winsvc-2.3/nuitka/plugins/
+-rw-rw-rw-   0        0        0    57775 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/PluginBase.py
+-rw-rw-rw-   0        0        0    60905 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/Plugins.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.279238 nuitka_winsvc-2.3/nuitka/plugins/standard/
+-rw-rw-rw-   0        0        0    30813 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/AntiBloatPlugin.py
+-rw-rw-rw-   0        0        0     3509 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/ConsiderPyLintAnnotationsPlugin.py
+-rw-rw-rw-   0        0        0    11473 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DataFilesPlugin.py
+-rw-rw-rw-   0        0        0     5080 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DelvewheelPlugin.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.296128 nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin/
+-rw-rw-rw-   0        0        0     1688 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin/DillPlugin.c
+-rw-rw-rw-   0        0        0     9826 2024-03-25 02:50:30.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin/dill-postLoad.py
+-rw-rw-rw-   0        0        0     2679 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin.py
+-rw-rw-rw-   0        0        0    16496 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/DllFilesPlugin.py
+-rw-rw-rw-   0        0        0     2095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/EnumPlugin.py
+-rw-rw-rw-   0        0        0     1938 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/EventletPlugin.py
+-rw-rw-rw-   0        0        0     1913 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/GeventPlugin.py
+-rw-rw-rw-   0        0        0     4018 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/GiPlugin.py
+-rw-rw-rw-   0        0        0     4854 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/GlfwPlugin.py
+-rw-rw-rw-   0        0        0    32325 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/ImplicitImports.py
+-rw-rw-rw-   0        0        0     5024 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/KivyPlugin.py
+-rw-rw-rw-   0        0        0     8824 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/MatplotlibPlugin.py
+-rw-rw-rw-   0        0        0     7080 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/MultiprocessingPlugin.py
+-rw-rw-rw-   0        0        0     1220 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/NumpyPlugin.py
+-rw-rw-rw-   0        0        0     6045 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/OptionsNannyPlugin.py
+-rw-rw-rw-   0        0        0     1940 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/PbrPlugin.py
+-rw-rw-rw-   0        0        0     5144 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/PkgResourcesPlugin.py
+-rw-rw-rw-   0        0        0     7216 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/PmwPlugin.py
+-rw-rw-rw-   0        0        0    52013 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/PySidePyQtPlugin.py
+-rw-rw-rw-   0        0        0     3020 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/PywebViewPlugin.py
+-rw-rw-rw-   0        0        0     1194 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/TensorflowPlugin.py
+-rw-rw-rw-   0        0        0    13878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/TkinterPlugin.py
+-rw-rw-rw-   0        0        0     1174 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/TorchPlugin.py
+-rw-rw-rw-   0        0        0    12838 2024-04-07 02:15:13.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/TransformersPlugin.py
+-rw-rw-rw-   0        0        0     1107 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/TrioPlugin.py
+-rw-rw-rw-   0        0        0     5668 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/UpxPlugin.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/__init__.py
+-rw-rw-rw-   0        0        0   236832 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/standard.nuitka-package.config.yml
+-rw-rw-rw-   0        0        0     2357 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/stdlib2.nuitka-package.config.yml
+-rw-rw-rw-   0        0        0    12397 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/plugins/standard/stdlib3.nuitka-package.config.yml
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.310302 nuitka_winsvc-2.3/nuitka/reports/
+-rw-rw-rw-   0        0        0     2286 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/reports/CompilationReportReader.py
+-rw-rw-rw-   0        0        0     2089 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/reports/LicenseReport.rst.j2
+-rw-rw-rw-   0        0        0    28897 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/reports/Reports.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/reports/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.477295 nuitka_winsvc-2.3/nuitka/specs/
+-rw-rw-rw-   0        0        0     5943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinBytesOperationSpecs.py
+-rw-rw-rw-   0        0        0     2818 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinDictOperationSpecs.py
+-rw-rw-rw-   0        0        0     2573 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinListOperationSpecs.py
+-rw-rw-rw-   0        0        0    27022 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinParameterSpecs.py
+-rw-rw-rw-   0        0        0     6098 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinStrOperationSpecs.py
+-rw-rw-rw-   0        0        0     1190 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinTypeOperationSpecs.py
+-rw-rw-rw-   0        0        0     4834 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/specs/BuiltinUnicodeOperationSpecs.py
+-rw-rw-rw-   0        0        0     7211 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/specs/HardImportSpecs.py
+-rw-rw-rw-   0        0        0    19395 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/specs/ParameterSpecs.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/specs/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.478289 nuitka_winsvc-2.3/nuitka/tools/
+-rw-rw-rw-   0        0        0     1631 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/Basics.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.491292 nuitka_winsvc-2.3/nuitka/tools/commercial/
+-rw-rw-rw-   0        0        0      847 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/commercial/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.493288 nuitka_winsvc-2.3/nuitka/tools/data_composer/
+-rw-rw-rw-   0        0        0    15004 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/data_composer/DataComposer.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/data_composer/__init__.py
+-rw-rw-rw-   0        0        0     1338 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/data_composer/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.497289 nuitka_winsvc-2.3/nuitka/tools/environments/
+-rw-rw-rw-   0        0        0     2481 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/environments/CreateEnvironment.py
+-rw-rw-rw-   0        0        0     4198 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/environments/Virtualenv.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/environments/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.497289 nuitka_winsvc-2.3/nuitka/tools/general/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/general/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.500491 nuitka_winsvc-2.3/nuitka/tools/general/dll_report/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/general/dll_report/__init__.py
+-rw-rw-rw-   0        0        0     2352 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/general/dll_report/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.501488 nuitka_winsvc-2.3/nuitka/tools/general/find_module/
+-rw-rw-rw-   0        0        0     3998 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tools/general/find_module/FindModuleCode.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/general/find_module/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.502488 nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/
+-rw-rw-rw-   0        0        0    12545 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/OnefileCompressor.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/__init__.py
+-rw-rw-rw-   0        0        0     1343 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.504489 nuitka_winsvc-2.3/nuitka/tools/podman/
+-rw-rw-rw-   0        0        0     1905 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/podman/Podman.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/podman/__init__.py
+-rw-rw-rw-   0        0        0    11623 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/podman/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.505488 nuitka_winsvc-2.3/nuitka/tools/profiler/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/profiler/__init__.py
+-rw-rw-rw-   0        0        0     2561 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/profiler/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.506488 nuitka_winsvc-2.3/nuitka/tools/scanning/
+-rw-rw-rw-   0        0        0     3590 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/scanning/DisplayPackageDLLs.py
+-rw-rw-rw-   0        0        0     2314 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/scanning/DisplayPackageData.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/scanning/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.599500 nuitka_winsvc-2.3/nuitka/tools/specialize/
+-rw-rw-rw-   0        0        0    51832 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tools/specialize/CTypeDescriptions.py
+-rw-rw-rw-   0        0        0     7717 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/specialize/Common.py
+-rw-rw-rw-   0        0        0    39747 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/specialize/SpecializeC.py
+-rw-rw-rw-   0        0        0    36683 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/specialize/SpecializePython.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/specialize/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.625371 nuitka_winsvc-2.3/nuitka/tools/testing/
+-rw-rw-rw-   0        0        0    56502 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tools/testing/Common.py
+-rw-rw-rw-   0        0        0     1516 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/Constructs.py
+-rw-rw-rw-   0        0        0    10129 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/testing/OutputComparison.py
+-rw-rw-rw-   0        0        0     1310 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/testing/Pythons.py
+-rw-rw-rw-   0        0        0     8061 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/RuntimeTracing.py
+-rw-rw-rw-   0        0        0     5500 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tools/testing/SearchModes.py
+-rw-rw-rw-   0        0        0     3408 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/Valgrind.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.650203 nuitka_winsvc-2.3/nuitka/tools/testing/check_reference_counts/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/check_reference_counts/__init__.py
+-rw-rw-rw-   0        0        0     3095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/check_reference_counts/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.651204 nuitka_winsvc-2.3/nuitka/tools/testing/compare_with_cpython/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/compare_with_cpython/__init__.py
+-rw-rw-rw-   0        0        0    29697 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/testing/compare_with_cpython/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.655203 nuitka_winsvc-2.3/nuitka/tools/testing/find_sxs_modules/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/find_sxs_modules/__init__.py
+-rw-rw-rw-   0        0        0     1980 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/find_sxs_modules/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.656203 nuitka_winsvc-2.3/nuitka/tools/testing/measure_construct_performance/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/measure_construct_performance/__init__.py
+-rw-rw-rw-   0        0        0     8758 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/measure_construct_performance/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.658203 nuitka_winsvc-2.3/nuitka/tools/testing/run_nuitka_tests/
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/run_nuitka_tests/__init__.py
+-rw-rw-rw-   0        0        0    35342 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/testing/run_nuitka_tests/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.663608 nuitka_winsvc-2.3/nuitka/tools/watch/
+-rw-rw-rw-   0        0        0     3417 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tools/watch/GitHub.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tools/watch/__init__.py
+-rw-rw-rw-   0        0        0    21532 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tools/watch/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:58.723049 nuitka_winsvc-2.3/nuitka/tree/
+-rw-rw-rw-   0        0        0    50596 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tree/Building.py
+-rw-rw-rw-   0        0        0    75150 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ComplexCallHelperFunctions.py
+-rw-rw-rw-   0        0        0     1733 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/Extractions.py
+-rw-rw-rw-   0        0        0     2603 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/InternalModule.py
+-rw-rw-rw-   0        0        0     1544 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/Operations.py
+-rw-rw-rw-   0        0        0     2841 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationAssertStatements.py
+-rw-rw-rw-   0        0        0    43887 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationAssignmentStatements.py
+-rw-rw-rw-   0        0        0     2981 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationBooleanExpressions.py
+-rw-rw-rw-   0        0        0    11746 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationCallExpressions.py
+-rw-rw-rw-   0        0        0    15446 2024-03-20 02:57:24.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationClasses.py
+-rw-rw-rw-   0        0        0    38202 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationClasses3.py
+-rw-rw-rw-   0        0        0     6523 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationComparisonExpressions.py
+-rw-rw-rw-   0        0        0    22207 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationContractionExpressions.py
+-rw-rw-rw-   0        0        0    11266 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationDictionaryCreation.py
+-rw-rw-rw-   0        0        0    14805 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationExecStatements.py
+-rw-rw-rw-   0        0        0     7858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationForLoopStatements.py
+-rw-rw-rw-   0        0        0    30885 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationFunctionStatements.py
+-rw-rw-rw-   0        0        0    14095 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationImportStatements.py
+-rw-rw-rw-   0        0        0     6630 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationLambdaExpressions.py
+-rw-rw-rw-   0        0        0    22491 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationMatchStatements.py
+-rw-rw-rw-   0        0        0     2442 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationMultidist.py
+-rw-rw-rw-   0        0        0     7608 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationNamespacePackages.py
+-rw-rw-rw-   0        0        0     4711 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationPrintStatements.py
+-rw-rw-rw-   0        0        0    15606 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationSequenceCreation.py
+-rw-rw-rw-   0        0        0     4857 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationSubscriptExpressions.py
+-rw-rw-rw-   0        0        0    14948 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationTryExceptStatements.py
+-rw-rw-rw-   0        0        0     7014 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationTryFinallyStatements.py
+-rw-rw-rw-   0        0        0     5707 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationWhileLoopStatements.py
+-rw-rw-rw-   0        0        0    14439 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationWithStatements.py
+-rw-rw-rw-   0        0        0     3852 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/ReformulationYieldExpressions.py
+-rw-rw-rw-   0        0        0    13488 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/tree/SourceHandling.py
+-rw-rw-rw-   0        0        0     3790 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/SyntaxErrors.py
+-rw-rw-rw-   0        0        0    23423 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/tree/TreeHelpers.py
+-rw-rw-rw-   0        0        0    20465 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/VariableClosure.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/tree/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:59.208488 nuitka_winsvc-2.3/nuitka/utils/
+-rw-rw-rw-   0        0        0     3140 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/AppDirs.py
+-rw-rw-rw-   0        0        0     4314 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/CStrings.py
+-rw-rw-rw-   0        0        0     6394 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/CommandLineOptions.py
+-rw-rw-rw-   0        0        0    14983 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/Distributions.py
+-rw-rw-rw-   0        0        0     6477 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/Download.py
+-rw-rw-rw-   0        0        0    13519 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/Execution.py
+-rw-rw-rw-   0        0        0    42550 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/FileOperations.py
+-rw-rw-rw-   0        0        0     3753 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Hashing.py
+-rw-rw-rw-   0        0        0     2391 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/Images.py
+-rw-rw-rw-   0        0        0    10843 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/Importing.py
+-rw-rw-rw-   0        0        0     7884 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/InstalledPythons.py
+-rw-rw-rw-   0        0        0     2258 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/InstanceCounters.py
+-rw-rw-rw-   0        0        0     4586 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Jinja2.py
+-rw-rw-rw-   0        0        0     1271 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Json.py
+-rw-rw-rw-   0        0        0     4478 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/MacOSApp.py
+-rw-rw-rw-   0        0        0     5092 2024-03-25 02:50:30.000000 nuitka_winsvc-2.3/nuitka/utils/MemoryUsage.py
+-rw-rw-rw-   0        0        0     9951 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/ModuleNames.py
+-rw-rw-rw-   0        0        0     4715 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/ReExecute.py
+-rw-rw-rw-   0        0        0     1889 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Rest.py
+-rw-rw-rw-   0        0        0    24403 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/SharedLibraries.py
+-rw-rw-rw-   0        0        0     3698 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/Shebang.py
+-rw-rw-rw-   0        0        0     3687 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Signing.py
+-rw-rw-rw-   0        0        0     2084 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/SlotMetaClasses.py
+-rw-rw-rw-   0        0        0     6603 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/StaticLibraries.py
+-rw-rw-rw-   0        0        0     2634 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/ThreadedExecutor.py
+-rw-rw-rw-   0        0        0     2798 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/Timing.py
+-rw-rw-rw-   0        0        0    12705 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/Utils.py
+-rw-rw-rw-   0        0        0    10642 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/nuitka/utils/WindowsFileUsage.py
+-rw-rw-rw-   0        0        0    19837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/WindowsResources.py
+-rw-rw-rw-   0        0        0     7206 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/nuitka/utils/Yaml.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/nuitka/utils/__init__.py
+-rw-rw-rw-   0        0        0      865 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/pyproject.toml
+-rw-rw-rw-   0        0        0       42 2024-06-03 02:07:02.972622 nuitka_winsvc-2.3/setup.cfg
+-rw-rw-rw-   0        0        0    16351 2024-06-03 02:02:56.000000 nuitka_winsvc-2.3/setup.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:59.208488 nuitka_winsvc-2.3/tests/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.127111 nuitka_winsvc-2.3/tests/basics/
+-rw-rw-rw-   0        0        0     1798 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/AssertsTest.py
+-rw-rw-rw-   0        0        0     5966 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/AssignmentsTest.py
+-rw-rw-rw-   0        0        0     5910 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/AssignmentsTest32.py
+-rw-rw-rw-   0        0        0     4086 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/BranchingTest.py
+-rw-rw-rw-   0        0        0     1136 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/BuiltinOverload.py
+-rw-rw-rw-   0        0        0     3781 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/BuiltinSuperTest.py
+-rw-rw-rw-   0        0        0    17112 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/BuiltinsTest.py
+-rw-rw-rw-   0        0        0      898 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ClassMinimalTest.py
+-rw-rw-rw-   0        0        0     4796 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ClassesTest.py
+-rw-rw-rw-   0        0        0     3446 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ClassesTest32.py
+-rw-rw-rw-   0        0        0     1438 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ClassesTest34.py
+-rw-rw-rw-   0        0        0     4729 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ComparisonChainsTest.py
+-rw-rw-rw-   0        0        0     4672 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ConstantsTest.py
+-rw-rw-rw-   0        0        0     1027 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ConstantsTest27.py
+-rw-rw-rw-   0        0        0     1661 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/DecoratorsTest.py
+-rw-rw-rw-   0        0        0     2349 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/DefaultParametersTest.py
+-rw-rw-rw-   0        0        0     1159 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/DoubleDeletionsTest.py
+-rw-rw-rw-   0        0        0      838 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/EmptyModuleTest.py
+-rw-rw-rw-   0        0        0    14418 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest.py
+-rw-rw-rw-   0        0        0      993 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest32.py
+-rw-rw-rw-   0        0        0     1490 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest33.py
+-rw-rw-rw-   0        0        0     6779 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ExecEvalTest.py
+-rw-rw-rw-   0        0        0     1450 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/ExtremeClosureTest.py
+-rw-rw-rw-   0        0        0     1689 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/FunctionObjectsTest.py
+-rw-rw-rw-   0        0        0    12367 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/FunctionsTest.py
+-rw-rw-rw-   0        0        0     3635 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/FunctionsTest32.py
+-rw-rw-rw-   0        0        0     2658 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/FunctionsTest_2.py
+-rw-rw-rw-   0        0        0      922 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/FutureTest32.py
+-rw-rw-rw-   0        0        0     5841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/GeneratorExpressionsTest.py
+-rw-rw-rw-   0        0        0     1073 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/GeneratorExpressionsTest_37.py
+-rw-rw-rw-   0        0        0     3856 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/GlobalStatementTest.py
+-rw-rw-rw-   0        0        0     1318 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/HelloWorldTest_2.py
+-rw-rw-rw-   0        0        0     2501 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ImportingTest.py
+-rw-rw-rw-   0        0        0     1328 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/InplaceOperationsTest.py
+-rw-rw-rw-   0        0        0     4259 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/InspectionTest.py
+-rw-rw-rw-   0        0        0     1536 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/InspectionTest_35.py
+-rw-rw-rw-   0        0        0     1650 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/InspectionTest_36.py
+-rw-rw-rw-   0        0        0     1703 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/LambdasTest.py
+-rw-rw-rw-   0        0        0     2763 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/LateClosureAssignmentTest.py
+-rw-rw-rw-   0        0        0     2955 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ListContractionsTest.py
+-rw-rw-rw-   0        0        0     3361 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/LoopingTest.py
+-rw-rw-rw-   0        0        0     1568 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/MainProgramsTest.py
+-rw-rw-rw-   0        0        0     1957 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ModuleAttributesTest.py
+-rw-rw-rw-   0        0        0     2008 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/OperatorsTest.py
+-rw-rw-rw-   0        0        0    14935 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/OrderChecksTest.py
+-rw-rw-rw-   0        0        0     1859 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/OrderChecksTest27.py
+-rw-rw-rw-   0        0        0     1484 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/OverflowFunctionsTest_2.py
+-rw-rw-rw-   0        0        0     5885 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ParameterErrorsTest.py
+-rw-rw-rw-   0        0        0     1931 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ParameterErrorsTest32.py
+-rw-rw-rw-   0        0        0      895 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/PrintFutureTest.py
+-rw-rw-rw-   0        0        0     1444 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/PrintingTest_2.py
+-rw-rw-rw-   0        0        0      910 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/RecursionTest.py
+-rw-rw-rw-   0        0        0    24798 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest.py
+-rw-rw-rw-   0        0        0     2109 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest27.py
+-rw-rw-rw-   0        0        0     7869 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest33.py
+-rw-rw-rw-   0        0        0     5060 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest35.py
+-rw-rw-rw-   0        0        0     5497 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest36.py
+-rw-rw-rw-   0        0        0     2932 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ReferencingTest_2.py
+-rw-rw-rw-   0        0        0     1662 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/SlotsTest.py
+-rw-rw-rw-   0        0        0     1191 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/ThreadedGeneratorsTest.py
+-rw-rw-rw-   0        0        0    22998 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest32.py
+-rw-rw-rw-   0        0        0     1573 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest35.py
+-rw-rw-rw-   0        0        0     1820 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest_2.py
+-rw-rw-rw-   0        0        0     2118 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryContinueFinallyTest.py
+-rw-rw-rw-   0        0        0     2244 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryExceptContinueTest.py
+-rw-rw-rw-   0        0        0     2307 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryExceptFinallyTest.py
+-rw-rw-rw-   0        0        0     2336 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryExceptFramesTest.py
+-rw-rw-rw-   0        0        0     2874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryReturnFinallyTest.py
+-rw-rw-rw-   0        0        0     2360 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/TryYieldFinallyTest.py
+-rw-rw-rw-   0        0        0     1125 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/UnicodeTest.py
+-rw-rw-rw-   0        0        0     1909 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/UnpackingTest35.py
+-rw-rw-rw-   0        0        0     2143 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/VarargsTest.py
+-rw-rw-rw-   0        0        0     4913 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/WithStatementsTest.py
+-rw-rw-rw-   0        0        0     3103 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/YieldFromTest33.py
+-rw-rw-rw-   0        0        0     3851 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/run_all.py
+-rw-rw-rw-   0        0        0     2302 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/basics/run_xml.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.143511 nuitka_winsvc-2.3/tests/onefile/
+-rw-rw-rw-   0        0        0     1341 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/onefile/HelloWorldTest.py
+-rw-rw-rw-   0        0        0     1339 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/onefile/KeyboardInterruptTest.py
+-rw-rw-rw-   0        0        0     5846 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/onefile/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.284036 nuitka_winsvc-2.3/tests/optimizations/
+-rw-rw-rw-   0        0        0      991 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/optimizations/ArgumentTypes.py
+-rw-rw-rw-   0        0        0     1087 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/AttributesTest.py
+-rw-rw-rw-   0        0        0     1053 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/CallsTest.py
+-rw-rw-rw-   0        0        0      953 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/ConditionsTest.py
+-rw-rw-rw-   0        0        0      941 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/DecodingOperationsTest.py
+-rw-rw-rw-   0        0        0     1246 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/FormatStringsTest36.py
+-rw-rw-rw-   0        0        0     1183 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/HardImportsTest.py
+-rw-rw-rw-   0        0        0     1007 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/HardImportsTest_2.py
+-rw-rw-rw-   0        0        0      950 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/optimizations/Iterations.py
+-rw-rw-rw-   0        0        0     1292 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/LenTest.py
+-rw-rw-rw-   0        0        0     1133 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/MatchingTest310.py
+-rw-rw-rw-   0        0        0     2295 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/OperationsTest.py
+-rw-rw-rw-   0        0        0     1365 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/optimizations/SubscriptsTest.py
+-rw-rw-rw-   0        0        0     8827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/optimizations/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.293678 nuitka_winsvc-2.3/tests/packages/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.307691 nuitka_winsvc-2.3/tests/packages/package_data_files_embedding/
+-rw-rw-rw-   0        0        0     1576 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/package_data_files_embedding/PackageDataFilesEmbedding.py
+-rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/package_data_files_embedding/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.307691 nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/
+-rw-rw-rw-   0        0        0     2414 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/PackageImportSuccessAfterFailure.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.310261 nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/variable_package/
+-rw-rw-rw-   0        0        0      975 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/variable_package/SomeModule.py
+-rw-rw-rw-   0        0        0     1201 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/variable_package/__init__.py
+-rw-rw-rw-   0        0        0     4138 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.636143 nuitka_winsvc-2.3/tests/packages/sub_package/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.312881 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/
+-rw-rw-rw-   0        0        0     1262 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/__init__.py
+-rw-rw-rw-   0        0        0      940 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/bigkitty.py
+-rw-rw-rw-   0        0        0      942 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/smallkitty.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.315883 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/
+-rw-rw-rw-   0        0        0      961 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/__init__.py
+-rw-rw-rw-   0        0        0     1085 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/hello.py
+-rw-rw-rw-   0        0        0      999 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/miau.py
+-rw-rw-rw-   0        0        0     1001 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/purr.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.636143 nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.318882 nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/some_package/
+-rw-rw-rw-   0        0        0     2368 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/some_package/__init__.py
+-rw-rw-rw-   0        0        0      939 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/some_package/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.319980 nuitka_winsvc-2.3/tests/plugins/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.330940 nuitka_winsvc-2.3/tests/plugins/code_signing/
+-rw-rw-rw-   0        0        0     1202 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/plugins/code_signing/CodeSigningMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.346807 nuitka_winsvc-2.3/tests/plugins/data_files/
+-rw-rw-rw-   0        0        0     1474 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/plugins/data_files/DataFilesMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.356163 nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/
+-rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/__init__.py
+-rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/lala.txt
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.357154 nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/sub_dir/
+-rw-rw-rw-   0        0        0        0 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/sub_dir/lulu.txt
+-rw-rw-rw-   0        0        0      309 2024-01-29 03:39:42.000000 nuitka_winsvc-2.3/tests/plugins/data_files/test_case.nuitka-package.config.yml
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.363165 nuitka_winsvc-2.3/tests/plugins/parameters/
+-rw-rw-rw-   0        0        0     1198 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/tests/plugins/parameters/ParametersMain.py
+-rw-rw-rw-   0        0        0     2218 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/plugins/parameters/parameter-using-plugin.py
+-rw-rw-rw-   0        0        0     3513 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/tests/plugins/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.388186 nuitka_winsvc-2.3/tests/programs/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.397725 nuitka_winsvc-2.3/tests/programs/absolute_import/
+-rw-rw-rw-   0        0        0      899 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/absolute_import/AbsoluteImportMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.806132 nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/
+-rw-rw-rw-   0        0        0      828 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/__init__.py
+-rw-rw-rw-   0        0        0     1076 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/foobar.py
+-rw-rw-rw-   0        0        0      911 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/local.py
+-rw-rw-rw-   0        0        0      893 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/util.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.810640 nuitka_winsvc-2.3/tests/programs/case_imports1/
+-rw-rw-rw-   0        0        0      840 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports1/CasedImportingMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.833514 nuitka_winsvc-2.3/tests/programs/case_imports1/path1/
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports1/path1/Some_Module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.840371 nuitka_winsvc-2.3/tests/programs/case_imports1/path1/Some_Package/
+-rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports1/path1/Some_Package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.858328 nuitka_winsvc-2.3/tests/programs/case_imports1/path2/
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports1/path2/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.906187 nuitka_winsvc-2.3/tests/programs/case_imports1/path2/some_package/
+-rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports1/path2/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.911200 nuitka_winsvc-2.3/tests/programs/case_imports2/
+-rw-rw-rw-   0        0        0      840 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports2/CasedImportingMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.919389 nuitka_winsvc-2.3/tests/programs/case_imports2/path1/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports2/path1/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.924291 nuitka_winsvc-2.3/tests/programs/case_imports2/path1/some_package/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports2/path1/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.928291 nuitka_winsvc-2.3/tests/programs/case_imports2/path2/
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports2/path2/Some_Module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.938381 nuitka_winsvc-2.3/tests/programs/case_imports2/path2/Some_Package/
+-rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports2/path2/Some_Package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.947376 nuitka_winsvc-2.3/tests/programs/case_imports3/
+-rw-rw-rw-   0        0        0     1107 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports3/CasedImportingMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.951388 nuitka_winsvc-2.3/tests/programs/case_imports3/path1/
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports3/path1/Some_Module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.984266 nuitka_winsvc-2.3/tests/programs/case_imports3/path1/Some_Package/
+-rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports3/path1/Some_Package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:00.990319 nuitka_winsvc-2.3/tests/programs/case_imports3/path2/
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports3/path2/Some_Module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.011385 nuitka_winsvc-2.3/tests/programs/case_imports3/path2/Some_Package/
+-rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/case_imports3/path2/Some_Package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.017379 nuitka_winsvc-2.3/tests/programs/cyclic_imports/
+-rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/cyclic_imports/CyclicImportsMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.032337 nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/
+-rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child1.py
+-rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child2.py
+-rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.071449 nuitka_winsvc-2.3/tests/programs/dash_import/
+-rw-rw-rw-   0        0        0      920 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dash_import/DashImportMain.py
+-rw-rw-rw-   0        0        0      849 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dash_import/dash-module.py
+-rw-rw-rw-   0        0        0      849 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dash_import/plus+module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.111145 nuitka_winsvc-2.3/tests/programs/dash_main/
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dash_main/Dash-Main.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.126154 nuitka_winsvc-2.3/tests/programs/deep/
+-rw-rw-rw-   0        0        0      930 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/DeepProgramMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.163133 nuitka_winsvc-2.3/tests/programs/deep/some_package/
+-rw-rw-rw-   0        0        0     1012 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/some_package/DeepBrother.py
+-rw-rw-rw-   0        0        0      941 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/some_package/DeepChild.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.183340 nuitka_winsvc-2.3/tests/programs/deep/some_package/deep_package/
+-rw-rw-rw-   0        0        0      908 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/some_package/deep_package/DeepDeepChild.py
+-rw-rw-rw-   0        0        0      984 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/deep/some_package/deep_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.186339 nuitka_winsvc-2.3/tests/programs/dunderinit_imports/
+-rw-rw-rw-   0        0        0      826 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dunderinit_imports/DunderInitImportsMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.199971 nuitka_winsvc-2.3/tests/programs/dunderinit_imports/package/
+-rw-rw-rw-   0        0        0      829 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dunderinit_imports/package/SubModule.py
+-rw-rw-rw-   0        0        0      889 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/dunderinit_imports/package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.208020 nuitka_winsvc-2.3/tests/programs/import_variants/
+-rw-rw-rw-   0        0        0     1037 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/import_variants/ImportVariationsMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.234495 nuitka_winsvc-2.3/tests/programs/import_variants/some_package/
+-rw-rw-rw-   0        0        0      978 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child1.py
+-rw-rw-rw-   0        0        0     1130 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child2.py
+-rw-rw-rw-   0        0        0      854 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child3.py
+-rw-rw-rw-   0        0        0     1026 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/import_variants/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.258726 nuitka_winsvc-2.3/tests/programs/main_raises/
+-rw-rw-rw-   0        0        0      943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/main_raises/ErrorMain.py
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/main_raises/ErrorRaising.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.273450 nuitka_winsvc-2.3/tests/programs/main_raises2/
+-rw-rw-rw-   0        0        0     1112 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/main_raises2/ErrorInFunctionMain.py
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/main_raises2/ErrorRaising.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.286464 nuitka_winsvc-2.3/tests/programs/module_attributes/
+-rw-rw-rw-   0        0        0     1561 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/ModuleAttributesMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.314375 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/
+-rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/Nearby1.py
+-rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.336968 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/
+-rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/Nearby2.py
+-rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.522528 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/
+-rw-rw-rw-   0        0        0     1800 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/Nearby3.py
+-rw-rw-rw-   0        0        0     1643 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.629438 nuitka_winsvc-2.3/tests/programs/module_exits/
+-rw-rw-rw-   0        0        0      901 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_exits/ErrorExitingModule.py
+-rw-rw-rw-   0        0        0      899 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_exits/Main.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.664615 nuitka_winsvc-2.3/tests/programs/module_object_replacing/
+-rw-rw-rw-   0        0        0     1110 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_object_replacing/ModuleObjectReplacingMain.py
+-rw-rw-rw-   0        0        0     1391 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/module_object_replacing/SelfReplacingModule.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.692229 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/
+-rw-rw-rw-   0        0        0     1022 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/MultiprocessingUsingMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.747820 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/__init__.py
+-rw-rw-rw-   0        0        0      868 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/__main__.py
+-rw-rw-rw-   0        0        0     1791 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/entry.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.769425 nuitka_winsvc-2.3/tests/programs/named_imports/
+-rw-rw-rw-   0        0        0      878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/named_imports/NamedImportsMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.788127 nuitka_winsvc-2.3/tests/programs/named_imports/some_package/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/named_imports/some_package/SomeModule.py
+-rw-rw-rw-   0        0        0      856 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/named_imports/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.792447 nuitka_winsvc-2.3/tests/programs/named_imports/some_package/sub_package/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/named_imports/some_package/sub_package/SomeModule.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.801305 nuitka_winsvc-2.3/tests/programs/package_code/
+-rw-rw-rw-   0        0        0      832 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_code/PackageInitCodeMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.821700 nuitka_winsvc-2.3/tests/programs/package_code/some_package/
+-rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_code/some_package/SomeModule.py
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_code/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.841243 nuitka_winsvc-2.3/tests/programs/package_contains_main/
+-rw-rw-rw-   0        0        0      821 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_contains_main/PackageContainsMain.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_contains_main/__init__.py
+-rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_contains_main/local.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.855567 nuitka_winsvc-2.3/tests/programs/package_init_import/
+-rw-rw-rw-   0        0        0      855 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_init_import/PackageInitImportMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.878426 nuitka_winsvc-2.3/tests/programs/package_init_import/some_package/
+-rw-rw-rw-   0        0        0     1064 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/package_init_import/some_package/PackageLocal.py
+-rw-rw-rw-   0        0        0     1225 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/package_init_import/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.903902 nuitka_winsvc-2.3/tests/programs/package_init_issue/
+-rw-rw-rw-   0        0        0      821 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_init_issue/PackageInitIssueMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.912477 nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.925377 nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/child_package/
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/child_package/SomeModule.py
+-rw-rw-rw-   0        0        0      827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/child_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.931867 nuitka_winsvc-2.3/tests/programs/package_missing_init/
+-rw-rw-rw-   0        0        0      958 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_missing_init/PackageMissingInitMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.940960 nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/
+-rw-rw-rw-   0        0        0      997 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:01.955141 nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/sub_package/
+-rw-rw-rw-   0        0        0     1009 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/sub_package/some_sub_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.001283 nuitka_winsvc-2.3/tests/programs/package_module_collision/
+-rw-rw-rw-   0        0        0      933 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_module_collision/PackageAndModuleNamedSameMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.013283 nuitka_winsvc-2.3/tests/programs/package_module_collision/Something/
+-rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_module_collision/Something/__init__.py
+-rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_module_collision/something.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.032763 nuitka_winsvc-2.3/tests/programs/package_overload/
+-rw-rw-rw-   0        0        0      884 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_overload/Main.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.081720 nuitka_winsvc-2.3/tests/programs/package_overload/foo/
+-rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_overload/foo/__init__.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_overload/foo/bar.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_overload/foo/bar2.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.097720 nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/
+-rw-rw-rw-   0        0        0     3079 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/PackagePreventsSubmoduleMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.126213 nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/some_package/
+-rw-rw-rw-   0        0        0     1111 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/some_package/__init__.py
+-rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/some_package/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:06:43.676893 nuitka_winsvc-2.3/tests/programs/package_program/
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.135120 nuitka_winsvc-2.3/tests/programs/package_program/PackageAsMain/
+-rw-rw-rw-   0        0        0      920 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/package_program/PackageAsMain/__init__.py
+-rw-rw-rw-   0        0        0     1661 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/package_program/PackageAsMain/__main__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.154524 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/
+-rw-rw-rw-   0        0        0     1760 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/PkgUtilIterModulesMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.162450 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.195277 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleC.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleD.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.235736 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleA.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleB.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.238464 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/
+-rw-rw-rw-   0        0        0     1328 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/PkgUtilUsageMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.251657 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/
+-rw-rw-rw-   0        0        0       13 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/DATA_FILE.txt
+-rw-rw-rw-   0        0        0       14 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/DATA_FILE2.txt
+-rw-rw-rw-   0        0        0       14 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/DATA_FILE3.txt
+-rw-rw-rw-   0        0        0     1585 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/__init__.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.271728 nuitka_winsvc-2.3/tests/programs/plugin_import/
+-rw-rw-rw-   0        0        0      891 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/plugin_import/PluginImportMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.283412 nuitka_winsvc-2.3/tests/programs/plugin_import/some_package/
+-rw-rw-rw-   0        0        0      803 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/plugin_import/some_package/__init__.py
+-rw-rw-rw-   0        0        0      813 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/plugin_import/some_package/some_module.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.290280 nuitka_winsvc-2.3/tests/programs/reimport_main_dynamic/
+-rw-rw-rw-   0        0        0      943 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/reimport_main_dynamic/ImportItselfDynamicMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.302252 nuitka_winsvc-2.3/tests/programs/reimport_main_static/
+-rw-rw-rw-   0        0        0      930 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/reimport_main_static/ImportItselfStaticMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.326306 nuitka_winsvc-2.3/tests/programs/relative_import/
+-rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/relative_import/RelativeImportMain.py
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/relative_import/dircache.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.338250 nuitka_winsvc-2.3/tests/programs/resource_reader37/
+-rw-rw-rw-   0        0        0     1202 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/resource_reader37/ResourceReaderMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.353420 nuitka_winsvc-2.3/tests/programs/resource_reader37/some_package/
+-rw-rw-rw-   0        0        0       13 2023-09-05 03:06:57.000000 nuitka_winsvc-2.3/tests/programs/resource_reader37/some_package/DATA_FILE.txt
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/resource_reader37/some_package/__init__.py
+-rw-rw-rw-   0        0        0     6614 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/programs/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.398423 nuitka_winsvc-2.3/tests/programs/stdlib_overload/
+-rw-rw-rw-   0        0        0     1203 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/StdlibOverloadMain.py
+-rw-rw-rw-   0        0        0      831 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/pyexpat.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.432251 nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/
+-rw-rw-rw-   0        0        0      767 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/__init__.py
+-rw-rw-rw-   0        0        0      941 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/normal_importing.py
+-rw-rw-rw-   0        0        0      842 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/pyexpat.py
+-rw-rw-rw-   0        0        0     1268 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/star_importing.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.462701 nuitka_winsvc-2.3/tests/programs/syntax_errors/
+-rw-rw-rw-   0        0        0      822 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/syntax_errors/IndentationErroring.py
+-rw-rw-rw-   0        0        0      833 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/syntax_errors/SyntaxErroring.py
+-rw-rw-rw-   0        0        0     1111 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/syntax_errors/SyntaxErrorsMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.478668 nuitka_winsvc-2.3/tests/programs/unicode_bom/
+-rw-rw-rw-   0        0        0      995 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/unicode_bom/UnicodeBomMain.py
+-rw-rw-rw-   0        0        0      878 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/unicode_bom/unicode_bom.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.495509 nuitka_winsvc-2.3/tests/programs/with space/
+-rw-rw-rw-   0        0        0      858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/programs/with space/Space Main.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.502403 nuitka_winsvc-2.3/tests/reflected/
+-rw-rw-rw-   0        0        0    14254 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/reflected/compile_itself.py
+-rw-rw-rw-   0        0        0     1274 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/run-tests
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.798174 nuitka_winsvc-2.3/tests/standalone/
+-rw-rw-rw-   0        0        0     1090 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/BrotliUsing.py
+-rw-rw-rw-   0        0        0     2586 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/CtypesUsing.py
+-rw-rw-rw-   0        0        0     1950 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/DateutilsUsing.py
+-rw-rw-rw-   0        0        0     1168 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/FlaskUsing.py
+-rw-rw-rw-   0        0        0     1307 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/standalone/GiUsing.py
+-rw-rw-rw-   0        0        0     1022 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/GlfwUsing.py
+-rw-rw-rw-   0        0        0     1216 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/GtkUsing.py
+-rw-rw-rw-   0        0        0     1057 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/HexEncodingTest_2.py
+-rw-rw-rw-   0        0        0     1118 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/IdnaUsing.py
+-rw-rw-rw-   0        0        0     1215 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/LxmlUsing.py
+-rw-rw-rw-   0        0        0     1598 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/MatplotlibUsing.py
+-rw-rw-rw-   0        0        0     2570 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/MetadataPackagesUsing.py
+-rw-rw-rw-   0        0        0     1759 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/NumpyUsing.py
+-rw-rw-rw-   0        0        0      979 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/OpenGLUsing.py
+-rw-rw-rw-   0        0        0     1526 2024-06-03 02:02:10.000000 nuitka_winsvc-2.3/tests/standalone/PandasUsing.py
+-rw-rw-rw-   0        0        0     1098 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PasslibUsing.py
+-rw-rw-rw-   0        0        0     1248 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PendulumUsing.py
+-rw-rw-rw-   0        0        0     2106 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PkgResourcesRequiresUsing.py
+-rw-rw-rw-   0        0        0     1099 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PmwUsing.py
+-rw-rw-rw-   0        0        0     1369 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PyQt5Plugins.py
+-rw-rw-rw-   0        0        0     1253 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PyQt5SSLSupport.py
+-rw-rw-rw-   0        0        0     2198 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PyQt5Using.py
+-rw-rw-rw-   0        0        0     1203 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PyQt6Plugins.py
+-rw-rw-rw-   0        0        0     2168 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PyQt6Using.py
+-rw-rw-rw-   0        0        0     1789 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PySide2Using.py
+-rw-rw-rw-   0        0        0     1123 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PySide6Plugins.py
+-rw-rw-rw-   0        0        0     1789 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/PySide6Using.py
+-rw-rw-rw-   0        0        0     1371 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/RsaUsing.py
+-rw-rw-rw-   0        0        0     1227 2024-05-06 03:08:54.000000 nuitka_winsvc-2.3/tests/standalone/SetuptoolsUsing_311.py
+-rw-rw-rw-   0        0        0     1005 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/ShlibUsing.py
+-rw-rw-rw-   0        0        0     1569 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/SocketUsing.py
+-rw-rw-rw-   0        0        0     1973 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/TkInterUsing.py
+-rw-rw-rw-   0        0        0     3260 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/Urllib3Using.py
+-rw-rw-rw-   0        0        0     1232 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/Win32ComUsing.py
+-rw-rw-rw-   0        0        0     9912 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/run_all.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.812148 nuitka_winsvc-2.3/tests/standalone/zip_importer/
+-rw-rw-rw-   0        0        0     1296 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/standalone/zip_importer/ZipImporterMain.py
+drwxrwxrwx   0        0        0        0 2024-06-03 02:07:02.962570 nuitka_winsvc-2.3/tests/syntax/
+-rw-rw-rw-   0        0        0      844 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/AsyncgenReturn36.py
+-rw-rw-rw-   0        0        0      818 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/AwaitInModule36.py
+-rw-rw-rw-   0        0        0      901 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/BreakWithoutLoop.py
+-rw-rw-rw-   0        0        0      824 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/ClassReturn.py
+-rw-rw-rw-   0        0        0     1002 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/ClosureDel_2.py
+-rw-rw-rw-   0        0        0      882 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/ContinueWithoutLoop.py
+-rw-rw-rw-   0        0        0      824 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/DuplicateArgument.py
+-rw-rw-rw-   0        0        0     1142 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/ExecWithNesting_2.py
+-rw-rw-rw-   0        0        0      858 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/FutureBraces.py
+-rw-rw-rw-   0        0        0      837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/FutureUnknown.py
+-rw-rw-rw-   0        0        0     1073 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/GeneratorExpressions38.py
+-rw-rw-rw-   0        0        0      911 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/GeneratorReturn_2.py
+-rw-rw-rw-   0        0        0      825 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/GlobalForParameter.py
+-rw-rw-rw-   0        0        0     1027 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/Importing32.py
+-rw-rw-rw-   0        0        0      830 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/IndentationError.py
+-rw-rw-rw-   0        0        0      947 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/LateFutureImport.py
+-rw-rw-rw-   0        0        0      874 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/MisplacedFutureImport.py
+-rw-rw-rw-   0        0        0      832 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/ModuleReturn.py
+-rw-rw-rw-   0        0        0      915 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/NonAsciiWithoutEncoding_2.py
+-rw-rw-rw-   0        0        0      827 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/NonlocalForParameter32.py
+-rw-rw-rw-   0        0        0      900 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/NonlocalNotFound32.py
+-rw-rw-rw-   0        0        0      939 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/StarImportExtra.py
+-rw-rw-rw-   0        0        0      900 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/SyntaxError.py
+-rw-rw-rw-   0        0        0      907 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/TryExceptAllNotLast.py
+-rw-rw-rw-   0        0        0      908 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/TryFinallyContinue_37.py
+-rw-rw-rw-   0        0        0      808 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/UnpackNoTuple.py
+-rw-rw-rw-   0        0        0      841 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/UnpackTwoStars32.py
+-rw-rw-rw-   0        0        0      825 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/YieldFromInModule.py
+-rw-rw-rw-   0        0        0      837 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/YieldInAsync35.py
+-rw-rw-rw-   0        0        0      956 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/YieldInGenexp38.py
+-rw-rw-rw-   0        0        0      813 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/YieldInModule.py
+-rw-rw-rw-   0        0        0     2234 2024-03-06 05:39:36.000000 nuitka_winsvc-2.3/tests/syntax/run_all.py
```

### Comparing `nuitka_winsvc-2.2.3/Developer_Manual.rst` & `nuitka_winsvc-2.3/Developer_Manual.rst`

 * *Files 0% similar despite different names*

```diff
@@ -325,15 +325,15 @@
 
    A().x == 1  # True
    B().x == 1  # True (!)
 
 This pretty much is what makes properties bad. One would hope ``B().x``
 to be ``2``, but instead it's not changed. Because of the way properties
 take the functions and not members, and because they then are not part
-of the class, they cannot be overloaded without re-declaring them.
+of the class, they cannot be overloaded without redeclaring them.
 
 Overloading is then not at all obvious anymore. Now imagine having a
 setter and only overloading the getter. How to update the property
 easily?
 
 So, that's not likable about them. And then we are also for clarity in
 these internal APIs too. Properties try and hide the fact that code
```

### Comparing `nuitka_winsvc-2.2.3/LICENSE.txt` & `nuitka_winsvc-2.3/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/MANIFEST.in` & `nuitka_winsvc-2.3/MANIFEST.in`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/PKG-INFO` & `nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: Nuitka-winsvc
-Version: 2.2.3
+Version: 2.3
 Summary: Nuitka but support compile as Windows service
 Home-page: https://github.com/tabris17/Nuitka-winsvc
 Author: tabris17
 Author-email: tabris17.cn@gmail.com
 License: Apache License, Version 2.0
 Project-URL: Source, https://github.com/tabris17/Nuitka-winsvc
 Keywords: windows service,compiler,python,nuitka
```

### Comparing `nuitka_winsvc-2.2.3/Nuitka_winsvc.egg-info/SOURCES.txt` & `nuitka_winsvc-2.3/Nuitka_winsvc.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -793,14 +793,15 @@
 nuitka/build/static_src/HelpersComparisonEq.c
 nuitka/build/static_src/HelpersComparisonEqUtils.c
 nuitka/build/static_src/HelpersComparisonGe.c
 nuitka/build/static_src/HelpersComparisonGt.c
 nuitka/build/static_src/HelpersComparisonLe.c
 nuitka/build/static_src/HelpersComparisonLt.c
 nuitka/build/static_src/HelpersComparisonNe.c
+nuitka/build/static_src/HelpersConsole.c
 nuitka/build/static_src/HelpersConstantsBlob.c
 nuitka/build/static_src/HelpersDeepcopy.c
 nuitka/build/static_src/HelpersDictionaries.c
 nuitka/build/static_src/HelpersDictionariesGenerated.c
 nuitka/build/static_src/HelpersDumpBacktraces.c
 nuitka/build/static_src/HelpersEnvironmentVariables.c
 nuitka/build/static_src/HelpersEnvironmentVariablesSystem.c
```

### Comparing `nuitka_winsvc-2.2.3/PKG-INFO` & `nuitka_winsvc-2.3/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: Nuitka-winsvc
-Version: 2.2.3
+Version: 2.3
 Summary: Nuitka but support compile as Windows service
 Home-page: https://github.com/tabris17/Nuitka-winsvc
 Author: tabris17
 Author-email: tabris17.cn@gmail.com
 License: Apache License, Version 2.0
 Project-URL: Source, https://github.com/tabris17/Nuitka-winsvc
 Keywords: windows service,compiler,python,nuitka
```

### Comparing `nuitka_winsvc-2.2.3/README.md` & `nuitka_winsvc-2.3/README.md`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/README.rst` & `nuitka_winsvc-2.3/README.rst`

 * *Files 1% similar despite different names*

```diff
@@ -842,18 +842,18 @@
          matrix:
          os: [macos-latest, ubuntu-latest, windows-latest]
 
       runs-on: ${{ matrix.os }}
 
       steps:
          - name: Check-out repository
-         uses: actions/checkout@v3
+         uses: actions/checkout@v4
 
          - name: Setup Python
-         uses: actions/setup-python@v4
+         uses: actions/setup-python@v5
          with:
             python-version: '3.10'
             cache: 'pip'
             cache-dependency-path: |
                **/requirements*.txt
 
          - name: Install your Dependencies
@@ -888,19 +888,14 @@
    # Compilation mode, standalone everywhere, except on macOS there app bundle
    # nuitka-project-if: {OS} in ("Windows", "Linux", "FreeBSD"):
    #    nuitka-project: --onefile
    # nuitka-project-if: {OS} == "Darwin":
    #    nuitka-project: --standalone
    #    nuitka-project: --macos-create-app-bundle
    #
-   # Debugging options, controlled via environment variable at compile time.
-   # nuitka-project-if: os.getenv("DEBUG_COMPILATION", "no") == "yes"
-   #     nuitka-project: --enable-console
-   # nuitka-project-else:
-   #     nuitka-project: --disable-console
 
 ********
  Tweaks
 ********
 
 Icons
 =====
@@ -944,29 +939,18 @@
    Beware that in the likely case of using spaces in the description
    part, you need to quote it for your shell to get through to Nuitka
    and not be interpreted as Nuitka arguments.
 
 Console Window
 ==============
 
-On Windows, the console is opened by programs unless you say so. Nuitka
-defaults to this, effectively being only good for terminal programs, or
-programs where the output is requested to be seen. There is a difference
-in ``pythonw.exe`` and ``python.exe`` along those lines. This is
-replicated in Nuitka with the option ``--disable-console``. Nuitka
-recommends you to consider this in case you are using ``PySide6`` e.g.
-and other GUI packages, e.g. ``wx``, but it leaves the decision up to
-you. In case, you know your program is console application, just using
-``--enable-console`` which will get rid of these kinds of outputs from
-Nuitka.
-
-.. note::
-
-   The ``pythonw.exe`` is never good to be used with Nuitka, as you
-   cannot see its output.
+On Windows, the console is not opened by programs unless you say so.
+Nuitka defaults to not show it, you can force it by using
+``--console=force`` though, then the program will open a new terminal
+Window when its executed.
 
 Splash screen
 =============
 
 Splash screens are useful when program startup is slow. Onefile startup
 itself is not slow, but your program may be, and you cannot really know
 how fast the computer used will be, so it might be a good idea to have
@@ -1410,18 +1394,19 @@
       open(os.path.join(__compiled__.containing_dir, "user-provided-file.txt"))
    except NameError:
       open(os.path.join(os.path.dirname(sys.argv[0]), "user-provided-file.txt"))
 
 Windows Programs without console give no errors
 ===============================================
 
-For debugging purposes, remove ``--disable-console`` or use the options
-``--force-stdout-spec`` and ``--force-stderr-spec`` with paths as
-documented for ``--onefile-tempdir-spec`` above. These can be relative
-to the program or absolute, so you can see the outputs given.
+For debugging purposes, use the options ``--force-stdout-spec`` and
+``--force-stderr-spec`` with paths as documented for
+``--onefile-tempdir-spec`` above. These can be relative to the program
+or absolute, so you can see the outputs given. Also you can run the
+program on a terminal prompt like ``CMD.exe`` to see its outputs.
 
 Deep copying uncompiled functions
 =================================
 
 Sometimes people use this kind of code, which for packages on PyPI, we
 deal with by doing source code patches on the fly. If this is in your
 own code, here is what you can do:
```

### Comparing `nuitka_winsvc-2.2.3/bin/autoformat-nuitka-source` & `nuitka_winsvc-2.3/bin/autoformat-nuitka-source`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/check-nuitka-with-pylint` & `nuitka_winsvc-2.3/bin/check-nuitka-with-pylint`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/compare_with_cpython` & `nuitka_winsvc-2.3/bin/compare_with_cpython`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/compare_with_xml` & `nuitka_winsvc-2.3/bin/compare_with_xml`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/measure-construct-performance` & `nuitka_winsvc-2.3/bin/measure-construct-performance`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/nuitka` & `nuitka_winsvc-2.3/bin/nuitka`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/bin/nuitka-run` & `nuitka_winsvc-2.3/bin/nuitka-run`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Horizontal.svg` & `nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Horizontal.svg`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Symbol.svg` & `nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Symbol.svg`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/Logo/Nuitka-Logo-Vertical.svg` & `nuitka_winsvc-2.3/doc/Logo/Nuitka-Logo-Vertical.svg`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Horizontal.png` & `nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Horizontal.png`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Symbol.png` & `nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Symbol.png`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/images/Nuitka-Logo-Vertical.png` & `nuitka_winsvc-2.3/doc/images/Nuitka-Logo-Vertical.png`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/doc/nuitka-run.1` & `nuitka_winsvc-2.3/doc/nuitka-run.1`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH NUITKA-RUN "1" "2024" "nuitka-run 2.2" "User Commands"
+.TH NUITKA-RUN "1" "2024" "nuitka-run 2.3" "User Commands"
 .SH NAME
 nuitka-run \- the Python compiler
 .SH SYNOPSIS
 .B nuitka-run
 [\fI\,options\/\fR] \fI\,main_module.py\/\fR
 .SH OPTIONS
 .TP
@@ -115,16 +115,17 @@
 Follow to that module if used, or if a package, to the
 whole package. Can be given multiple times. Default
 empty.
 .TP
 \fB\-\-nofollow\-import\-to\fR=\fI\,MODULE\/\fR/PACKAGE
 Do not follow to that module name even if used, or if
 a package name, to the whole package in any case,
-overrides all other options. Can be given multiple
-times. Default empty.
+overrides all other options. This can also contain
+patterns, e.g. "*.tests". Can be given multiple times.
+Default empty.
 .TP
 \fB\-\-nofollow\-imports\fR
 Do not descend into any imported modules at all,
 overrides all other inclusion options and not usable
 for standalone mode. Defaults to off.
 .TP
 \fB\-\-follow\-stdlib\fR
@@ -208,14 +209,18 @@
 only sense in case of '\-\-onefile' compilation. First
 files have to be specified as included somehow, then
 this refers to target paths. Default empty.
 .TP
 \fB\-\-list\-package\-data\fR=\fI\,LIST_PACKAGE_DATA\/\fR
 Output the data files found for a given package name.
 Default not done.
+.TP
+\fB\-\-include\-raw\-dir\fR=\fI\,DIRECTORY\/\fR
+Include raw directories completely in the
+distribution. This is recursive. Check '\-\-includedata\-dir' to use the sane option. Default empty.
 .IP
 Metadata support:
 .TP
 \fB\-\-include\-distribution\-metadata\fR=\fI\,DISTRIBUTION\/\fR
 Include metadata information for the given
 distribution name. Some packages check metadata for
 presence, version, entry points, etc. and without this
@@ -568,24 +573,21 @@
 .TP
 \fB\-\-verbose\-output\fR=\fI\,PATH\/\fR
 Where to output from '\-\-verbose', should be a
 filename. Default is standard output.
 .IP
 General OS controls:
 .TP
-\fB\-\-disable\-console\fR
-When compiling for Windows or macOS, disable the
-console window and create a GUI application. Defaults
-to off.
-.TP
-\fB\-\-enable\-console\fR
-When compiling for Windows or macOS, enable the
-console window and create a console application. This
-disables hints from certain modules, e.g. "PySide"
-that suggest to disable it. Defaults to true.
+\fB\-\-windows\-console\-mode\fR=\fI\,CONSOLE_MODE\/\fR
+Select console mode to use. Default mode is 'force'
+and creates a console window if not available, i.e.
+the program was started from one. With 'disable' it
+doesn't create or use a console. With 'attach' an
+existing console will be used for outputs. Default is
+\&'force'.
 .TP
 \fB\-\-force\-stdout\-spec\fR=\fI\,FORCE_STDOUT_SPEC\/\fR
 Force standard output of the program to go to this
 location. Useful for programs with disabled console
 and programs using the Windows Services Plugin of
 Nuitka commercial. Defaults to not active, use e.g.
 \&'{PROGRAM_BASE}.out.txt', i.e. file near your program,
```

### Comparing `nuitka_winsvc-2.2.3/doc/nuitka.1` & `nuitka_winsvc-2.3/doc/nuitka.1`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.49.1.
-.TH NUITKA "1" "2024" "nuitka 2.2" "User Commands"
+.TH NUITKA "1" "2024" "nuitka 2.3" "User Commands"
 .SH NAME
 nuitka \- the Python compiler
 .SH SYNOPSIS
 .B nuitka
 [\fI\,--module\/\fR] [\fI\,--run\/\fR] [\fI\,options\/\fR] \fI\,main_module.py\/\fR
 .SH OPTIONS
 .TP
@@ -115,16 +115,17 @@
 Follow to that module if used, or if a package, to the
 whole package. Can be given multiple times. Default
 empty.
 .TP
 \fB\-\-nofollow\-import\-to\fR=\fI\,MODULE\/\fR/PACKAGE
 Do not follow to that module name even if used, or if
 a package name, to the whole package in any case,
-overrides all other options. Can be given multiple
-times. Default empty.
+overrides all other options. This can also contain
+patterns, e.g. "*.tests". Can be given multiple times.
+Default empty.
 .TP
 \fB\-\-nofollow\-imports\fR
 Do not descend into any imported modules at all,
 overrides all other inclusion options and not usable
 for standalone mode. Defaults to off.
 .TP
 \fB\-\-follow\-stdlib\fR
@@ -208,14 +209,18 @@
 only sense in case of '\-\-onefile' compilation. First
 files have to be specified as included somehow, then
 this refers to target paths. Default empty.
 .TP
 \fB\-\-list\-package\-data\fR=\fI\,LIST_PACKAGE_DATA\/\fR
 Output the data files found for a given package name.
 Default not done.
+.TP
+\fB\-\-include\-raw\-dir\fR=\fI\,DIRECTORY\/\fR
+Include raw directories completely in the
+distribution. This is recursive. Check '\-\-includedata\-dir' to use the sane option. Default empty.
 .IP
 Metadata support:
 .TP
 \fB\-\-include\-distribution\-metadata\fR=\fI\,DISTRIBUTION\/\fR
 Include metadata information for the given
 distribution name. Some packages check metadata for
 presence, version, entry points, etc. and without this
@@ -568,24 +573,21 @@
 .TP
 \fB\-\-verbose\-output\fR=\fI\,PATH\/\fR
 Where to output from '\-\-verbose', should be a
 filename. Default is standard output.
 .IP
 General OS controls:
 .TP
-\fB\-\-disable\-console\fR
-When compiling for Windows or macOS, disable the
-console window and create a GUI application. Defaults
-to off.
-.TP
-\fB\-\-enable\-console\fR
-When compiling for Windows or macOS, enable the
-console window and create a console application. This
-disables hints from certain modules, e.g. "PySide"
-that suggest to disable it. Defaults to true.
+\fB\-\-windows\-console\-mode\fR=\fI\,CONSOLE_MODE\/\fR
+Select console mode to use. Default mode is 'force'
+and creates a console window if not available, i.e.
+the program was started from one. With 'disable' it
+doesn't create or use a console. With 'attach' an
+existing console will be used for outputs. Default is
+\&'force'.
 .TP
 \fB\-\-force\-stdout\-spec\fR=\fI\,FORCE_STDOUT_SPEC\/\fR
 Force standard output of the program to go to this
 location. Useful for programs with disabled console
 and programs using the Windows Services Plugin of
 Nuitka commercial. Defaults to not active, use e.g.
 \&'{PROGRAM_BASE}.out.txt', i.e. file near your program,
```

### Comparing `nuitka_winsvc-2.2.3/lib/hints.py` & `nuitka_winsvc-2.3/lib/hints.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/misc/nuitka-run.bat` & `nuitka_winsvc-2.3/misc/nuitka-run.bat`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/misc/nuitka.bat` & `nuitka_winsvc-2.3/misc/nuitka.bat`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Builtins.py` & `nuitka_winsvc-2.3/nuitka/Builtins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/BytecodeCaching.py` & `nuitka_winsvc-2.3/nuitka/BytecodeCaching.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Bytecodes.py` & `nuitka_winsvc-2.3/nuitka/Bytecodes.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 
 """ Handle bytecode and compile source code to bytecode. """
 
 import ast
 
 from nuitka.Options import hasPythonFlagNoAsserts, hasPythonFlagNoDocStrings
 from nuitka.tree.TreeHelpers import getKind
+from nuitka.utils.Utils import withNoSyntaxWarning
 
 doc_having = tuple(
     getattr(ast, candidate)
     for candidate in ("FunctionDef", "ClassDef", "AsyncFunctionDef")
     if hasattr(ast, candidate)
 )
 
@@ -22,16 +23,17 @@
         elif getKind(node.body[0].value) == "Constant":  # python3.8
             node.body[0].value.value = ""
 
 
 def compileSourceToBytecode(source_code, filename):
     """Compile given source code into bytecode."""
 
-    # Prepare compile call with AST tree.
-    tree = ast.parse(source_code, filename)
+    with withNoSyntaxWarning():
+        # Prepare compile call with AST tree.
+        tree = ast.parse(source_code, filename)
 
     # Do we need to remove doc strings.
     remove_doc_strings_from_tree = hasPythonFlagNoDocStrings()
 
     # For Python2, we need to do this manually.
     remove_asserts_from_tree = hasPythonFlagNoAsserts() and str is bytes
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/CacheCleanup.py` & `nuitka_winsvc-2.3/nuitka/CacheCleanup.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Constants.py` & `nuitka_winsvc-2.3/nuitka/Constants.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Errors.py` & `nuitka_winsvc-2.3/nuitka/Errors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/HardImportRegistry.py` & `nuitka_winsvc-2.3/nuitka/HardImportRegistry.py`

 * *Files 0% similar despite different names*

```diff
@@ -207,14 +207,15 @@
 module_os_path_trust = {
     "exists": trust_node,
     "isfile": trust_node,
     "isdir": trust_node,
     "basename": trust_node,
     "dirname": trust_node,
     "abspath": trust_node,
+    "normpath": trust_node,
 }
 
 
 module_ctypes_trust = {
     "CDLL": trust_node,
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/MainControl.py` & `nuitka_winsvc-2.3/nuitka/MainControl.py`

 * *Files 2% similar despite different names*

```diff
@@ -83,15 +83,18 @@
     changeFilenameExtension,
     deleteFile,
     getExternalUsePath,
     openTextFile,
     removeDirectory,
     resetDirectory,
 )
-from nuitka.utils.Importing import getSharedLibrarySuffix
+from nuitka.utils.Importing import (
+    getPackageDirFilename,
+    getSharedLibrarySuffix,
+)
 from nuitka.utils.MemoryUsage import reportMemoryUsage, showMemoryTrace
 from nuitka.utils.ModuleNames import ModuleName
 from nuitka.utils.ReExecute import callExecProcess, reExecuteNuitka
 from nuitka.utils.StaticLibraries import getSystemStaticLibPythonPath
 from nuitka.utils.Utils import getArchitecture, isMacOS, isWin32Windows
 from nuitka.Version import getCommercialVersion, getNuitkaVersion
 
@@ -565,15 +568,14 @@
 
 def runSconsBackend():
     # Scons gets transported many details, that we express as variables, and
     # have checks for them, leading to many branches and statements,
     # pylint: disable=too-many-branches,too-many-statements
 
     options = {
-        "result_name": OutputDirectories.getResultBasePath(onefile=False),
         "source_dir": OutputDirectories.getSourceDirectoryPath(),
         "nuitka_python": asBoolStr(isNuitkaPython()),
         "debug_mode": asBoolStr(Options.is_debug),
         "debugger_mode": asBoolStr(Options.shallRunInDebugger()),
         "python_debug": asBoolStr(Options.shallUsePythonDebug()),
         "module_mode": asBoolStr(Options.shallMakeModule()),
         "full_compat": asBoolStr(Options.is_full_compat),
@@ -688,15 +690,17 @@
         options["python_sysflag_isolated"] = asBoolStr(True)
 
     abiflags = getPythonABI()
     if abiflags:
         options["abiflags"] = abiflags
 
     if Options.shallMakeModule():
-        options["module_suffix"] = getSharedLibrarySuffix(preferred=True)
+        options["result_exe"] = OutputDirectories.getResultBasePath(
+            onefile=False
+        ) + getSharedLibrarySuffix(preferred=True)
 
     link_module_libs = getModuleLinkerLibs()
     if link_module_libs:
         options["link_module_libs"] = ",".join(link_module_libs)
 
     env_values = setCommonSconsOptions(options)
 
@@ -755,35 +759,39 @@
     # Delete PGO files if asked to do that.
     if options.get("pgo_mode") == "use" and _wasMsvcMode():
         _deleteMsvcPGOFiles(pgo_mode="use")
 
     return result
 
 
-def callExecPython(args, add_path):
+def callExecPython(args, add_path, uac):
     if add_path:
         if "PYTHONPATH" in os.environ:
             os.environ["PYTHONPATH"] += ":" + Options.getOutputDir()
         else:
             os.environ["PYTHONPATH"] = Options.getOutputDir()
 
     # Add the main arguments, previous separated.
     args += Options.getPositionalArgs()[1:] + Options.getMainArgs()
 
-    callExecProcess(args)
+    callExecProcess(args, uac=uac)
 
 
 def _executeMain(binary_filename):
     # Wrap in debugger, unless the CMD file contains that call already.
     if Options.shallRunInDebugger() and not Options.shallCreateCmdFileForExecution():
         args = wrapCommandForDebuggerForExec(binary_filename)
     else:
         args = (binary_filename, binary_filename)
 
-    callExecPython(add_path=False, args=args)
+    callExecPython(
+        args=args,
+        add_path=False,
+        uac=isWin32Windows() and Options.shallAskForWindowsAdminRights(),
+    )
 
 
 def _executeModule(tree):
     """Execute the extension module just created."""
 
     if python_version < 0x340:
         python_command_template = """\
@@ -820,15 +828,15 @@
     }
 
     if Options.shallRunInDebugger():
         args = wrapCommandForDebuggerForExec(sys.executable, "-c", python_command)
     else:
         args = (sys.executable, "python", "-c", python_command)
 
-    callExecPython(add_path=True, args=args)
+    callExecPython(args=args, add_path=True, uac=False)
 
 
 def compileTree():
     source_dir = OutputDirectories.getSourceDirectoryPath()
 
     general.info("Completed Python level compilation and optimization.")
 
@@ -1081,17 +1089,15 @@
             )
 
     Plugins.onFinalResult(final_filename)
 
     if Options.shallMakeModule():
         base_path = OutputDirectories.getResultBasePath(onefile=False)
 
-        if os.path.isdir(base_path) and os.path.isfile(
-            os.path.join(base_path, "__init__.py")
-        ):
+        if os.path.isdir(base_path) and getPackageDirFilename(base_path):
             general.warning(
                 """\
 The compilation result is hidden by package directory '%s'. Importing will \
 not use compiled code while it exists."""
                 % base_path
             )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/ModuleRegistry.py` & `nuitka_winsvc-2.3/nuitka/ModuleRegistry.py`

 * *Files 2% similar despite different names*

```diff
@@ -291,14 +291,29 @@
     module_timing_infos[module_name] = tuple(module_timing_info)
 
 
 def getModuleOptimizationTimingInfos(module_name):
     return module_timing_infos.get(module_name, ())
 
 
+def getImportedModuleNames():
+    result = OrderedSet()
+
+    for module in getDoneModules():
+        for used_module in module.getUsedModules():
+            module_name = used_module.module_name
+
+            if hasDoneModule(module_name):
+                continue
+
+            result.add(module_name)
+
+    return result
+
+
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
 #     integrates with CPython, but also works on its own.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
 #
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/OptionParsing.py` & `nuitka_winsvc-2.3/nuitka/OptionParsing.py`

 * *Files 1% similar despite different names*

```diff
@@ -283,16 +283,16 @@
     "--nofollow-import-to",
     action="append",
     dest="follow_not_modules",
     metavar="MODULE/PACKAGE",
     default=[],
     help="""\
 Do not follow to that module name even if used, or if a package name, to the
-whole package in any case, overrides all other options. Can be given multiple
-times. Default empty.""",
+whole package in any case, overrides all other options. This can also contain
+patterns, e.g. "*.tests". Can be given multiple times. Default empty.""",
 )
 
 follow_group.add_option(
     "--nofollow-imports",
     action="store_false",
     dest="follow_all",
     default=None,
@@ -450,14 +450,26 @@
     dest="list_package_data",
     default="",
     require_compiling=False,
     help="""\
 Output the data files found for a given package name. Default not done.""",
 )
 
+data_group.add_option(
+    "--include-raw-dir",
+    action="append",
+    dest="raw_dirs",
+    metavar="DIRECTORY",
+    default=[],
+    help="""\
+Include raw directories completely in the distribution. This is
+recursive. Check '--include-data-dir' to use the sane option.
+Default empty.""",
+)
+
 
 del data_group
 
 metadata_group = parser.add_option_group("Metadata support")
 
 metadata_group.add_option(
     "--include-distribution-metadata",
@@ -1284,28 +1296,38 @@
 os_group.add_option(
     "--disable-console",
     "--macos-disable-console",
     "--windows-disable-console",
     action="store_true",
     dest="disable_console",
     default=None,
-    help="""\
-When compiling for Windows or macOS, disable the console window and create a GUI
-application. Defaults to off.""",
+    help=SUPPRESS_HELP,
 )
 
 os_group.add_option(
     "--enable-console",
     action="store_false",
     dest="disable_console",
     default=None,
+    help=SUPPRESS_HELP,
+)
+
+os_group.add_option(
+    "--windows-console-mode",
+    action="store",
+    dest="console_mode",
+    choices=("force", "disable", "attach"),
+    metavar="CONSOLE_MODE",
+    default=None,
     help="""\
-When compiling for Windows or macOS, enable the console window and create a console
-application. This disables hints from certain modules, e.g. "PySide" that suggest
-to disable it. Defaults to true.""",
+Select console mode to use. Default mode is 'force' and creates a
+console window if not available, i.e. the program was started from one. With
+'disable' it doesn't create or use a console. With 'attach' an existing console
+will be used for outputs. Default is 'force'.
+""",
 )
 
 os_group.add_option(
     "--force-stdout-spec",
     "--windows-force-stdout-spec",
     action="store",
     dest="force_stdout_spec",
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/Options.py` & `nuitka_winsvc-2.3/nuitka/Options.py`

 * *Files 0% similar despite different names*

```diff
@@ -321,14 +321,36 @@
             """\
 Using onefile specific option '%s' has no effect \
 when '--onefile' is not specified."""
             % option_name
         )
 
 
+def _checkDataDirOptionValue(data_dir, option_name):
+    if "=" not in data_dir:
+        Tracing.options_logger.sysexit(
+            "Error, malformed '%s' value '%s' description, must specify a relative target path with '=' separating it."
+            % (option_name, data_dir)
+        )
+
+    src, dst = data_dir.split("=", 1)
+
+    if os.path.isabs(dst):
+        Tracing.options_logger.sysexit(
+            "Error, malformed '%s' value, must specify relative target path for data dir, not '%s' as in '%s'."
+            % (option_name, dst, data_dir)
+        )
+
+    if not os.path.isdir(src):
+        Tracing.options_logger.sysexit(
+            "Error, malformed '%s' value, must specify existing source data directory, not '%s' as in '%s'."
+            % (option_name, dst, data_dir)
+        )
+
+
 def parseArgs():
     """Parse the command line arguments
 
     :meta private:
     """
     # singleton with many cases checking the options right away.
     # pylint: disable=global-statement,too-many-branches,too-many-locals,too-many-statements
@@ -624,19 +646,14 @@
 
     icon_exe_path = getWindowsIconExecutablePath()
     if icon_exe_path is not None and not os.path.exists(icon_exe_path):
         Tracing.options_logger.sysexit(
             "Error, icon path executable '%s' does not exist." % icon_exe_path
         )
 
-    if isMacOS() and not shallCreateAppBundle() and shallDisableConsoleWindow():
-        Tracing.options_logger.sysexit(
-            "Error, cannot disable console unless also using '--macos-create-app-bundle'."
-        )
-
     try:
         file_version = getFileVersionTuple()
     # Catch all the things, don't want any interface, pylint: disable=broad-except
     except Exception:
         Tracing.options_logger.sysexit(
             "Error, file version must be a tuple of up to 4 integer values."
         )
@@ -747,32 +764,18 @@
         if os.path.isabs(dst):
             Tracing.options_logger.sysexit(
                 "Error, must specify relative target path for data file, not absolute path '%s'."
                 % data_file_desc
             )
 
     for data_dir in options.data_dirs:
-        if "=" not in data_dir:
-            Tracing.options_logger.sysexit(
-                "Error, malformed data dir description, must specify relative target path with '=' separating it."
-            )
-
-        src, dst = data_dir.split("=", 1)
-
-        if os.path.isabs(dst):
-            Tracing.options_logger.sysexit(
-                "Error, must specify relative target path for data dir, not '%s' as in '%s'."
-                % (dst, data_dir)
-            )
+        _checkDataDirOptionValue(data_dir=data_dir, option_name="--include-data-dir")
 
-        if not os.path.isdir(src):
-            Tracing.options_logger.sysexit(
-                "Error, must specify existing source data directory, not '%s' as in '%s'."
-                % (dst, data_dir)
-            )
+    for data_dir in options.raw_dirs:
+        _checkDataDirOptionValue(data_dir=data_dir, option_name="--include-raw-dir")
 
     for pattern in getShallFollowExtraFilePatterns():
         if os.path.isdir(pattern):
             Tracing.options_logger.sysexit(
                 "Error, pattern '%s' given to '--include-plugin-files' cannot be a directory name."
                 % pattern
             )
@@ -816,19 +819,22 @@
             )
 
         if str is bytes:
             Tracing.options_logger.sysexit(
                 "Error, Apple Python 2.7 from macOS is not usable as per Apple decision, use e.g. CPython 2.7 instead."
             )
 
-    if isStandaloneMode() and isLinux() and getExecutablePath("patchelf") is None:
-        Tracing.options_logger.sysexit(
-            "Error, standalone mode on Linux requires 'patchelf' to be installed. Use 'apt/dnf/yum install patchelf' first."
+    if isStandaloneMode() and isLinux():
+        # Cyclic dependency
+        from nuitka.utils.SharedLibraries import (
+            checkPatchElfPresenceAndUsability,
         )
 
+        checkPatchElfPresenceAndUsability(Tracing.options_logger)
+
     pgo_executable = getPgoExecutable()
     if pgo_executable and not isPathExecutable(pgo_executable):
         Tracing.options_logger.sysexit(
             "Error, path '%s' to binary to use for PGO is not executable."
             % pgo_executable
         )
 
@@ -891,16 +897,35 @@
                 % (
                     python_version_str,
                     getNuitkaVersion(),
                     getSupportedPythonVersions()[-1],
                 )
             )
 
+    if sys.version_info.releaselevel != "final":
+        if python_version_str not in getNotYetSupportedPythonVersions():
+            Tracing.general.sysexit(
+                """\
+Non-final versions '%s' '%s' are not supported by Nuitka, use the \
+final version instead."""
+                % (python_version_str, sys.version_info.releaselevel)
+            )
+
     if python_version_str in getNotYetSupportedPythonVersions():
-        if not isExperimental("python" + python_version_str):
+        if sys.version_info.releaselevel != "final" and not isExperimental(
+            "python" + python_version_str
+        ):
+            Tracing.general.warning(
+                """\
+The Python version '%s' '%s' is only experimentally supported by \
+and recommended only for use in Nuitka development and testing."""
+                % (python_version_str, sys.version_info.releaselevel)
+            )
+
+        elif not isExperimental("python" + python_version_str):
             Tracing.general.sysexit(
                 """\
 The Python version '%s' is not supported by Nuitka '%s', but an upcoming \
 release will add it. In the mean time use '%s' instead."""
                 % (
                     python_version_str,
                     getNuitkaVersion(),
@@ -1108,23 +1133,18 @@
         Tracing.general.sysexit(
             """\
 Error, for using the debug Python version, you need to run it will that version
 and not with the non-debug version.
 """
         )
 
-    if (
-        isMacOS()
-        and shallCreateAppBundle()
-        and shallDisableConsoleWindow()
-        and not getMacOSIconPaths()
-    ):
+    if isMacOS() and shallCreateAppBundle() and not getMacOSIconPaths():
         Tracing.general.warning(
             """\
-For GUI applications, you ought to specify an icon with '--macos-app-icon'.", \
+For application bundles, you ought to specify an icon with '--macos-app-icon'.", \
 otherwise a dock icon may not be present."""
         )
 
     if (
         isMacOS()
         and shallUseSigningForNotarization()
         and getMacOSSigningIdentity() == "-"
@@ -1135,27 +1155,70 @@
 notarization capable signature, the default identify 'ad-hoc' is not going \
 to work."""
         )
 
     if (
         isWin32Windows()
         and 0x340 <= python_version < 0x380
-        and not shallDisableConsoleWindow()
+        and getWindowsConsoleMode() != "disable"
     ):
         Tracing.general.warning(
             """\
 On Windows, support for input/output on the console Windows, does \
 not work on non-UTF8 systems, unless Python 3.8 or higher is used \
 but this is %s, so please consider upgrading, or disabling the \
 console window for deployment.
 """
             % python_version_str,
             mnemonic="old-python-windows-console",
         )
 
+    if shallMakeModule() and (getForcedStderrPath() or getForcedStdoutPath()):
+        Tracing.general.warning(
+            """\
+Extension modules do not control process outputs, therefore the \
+options '--force-stdout-spec' and '--force-stderr-spec' have no \
+impact and should not be specified."""
+        )
+
+    if shallMakeModule() and options.console_mode is not None:
+        Tracing.general.warning(
+            """\
+Extension modules are not binaries, and therefore the option \
+'--windows-console-mode' does not have an impact and should \
+not be specified."""
+        )
+
+    if options.disable_console in (True, False):
+        if isWin32Windows():
+            Tracing.general.warning(
+                """\
+The old console option '%s' should not be given anymore, use '%s' \
+instead. It also has the extra mode 'attach' to consider."""
+                % (
+                    (
+                        "--disable-console"
+                        if options.disable_console
+                        else "--enable-console"
+                    ),
+                    "--windows-console-module=%s"
+                    % ("force" if options.disable_console else "disable"),
+                )
+            )
+        else:
+            Tracing.general.warning(
+                """The old console option '%s' should not be given anymore, and doesn't
+have any effect anymore on non-Windows."""
+                % (
+                    "--disable-console"
+                    if options.disable_console
+                    else "--enable-console"
+                )
+            )
+
 
 def isVerbose():
     """:returns: bool derived from ``--verbose``"""
     return options is not None and options.verbose
 
 
 def shallTraceExecution():
@@ -1654,24 +1717,21 @@
 
 
 def shallDisableCompressionCacheUsage():
     """:returns: bool derived from ``--disable-cache=compression``"""
     return shallDisableCacheUsage("compression")
 
 
-def shallDisableConsoleWindow():
-    """:returns: None (not given), False, or True derived from ``--disable-console or ``--enable-console``"""
-    return options.disable_console
-
-
-def mayDisableConsoleWindow():
-    """:returns: bool derived from platform support of disabling the console,"""
-
-    # TODO: What about MSYS2?
-    return isWin32Windows() or isMacOS()
+def getWindowsConsoleMode():
+    """:returns: str from ``--windows-console-mode``"""
+    if options.disable_console is True:
+        return "disable"
+    if options.disable_console is False:
+        return "force"
+    return options.console_mode or "force"
 
 
 def _isFullCompat():
     """:returns: bool derived from ``--full-compat``
 
     Notes:
         Code should should use "Options.is_full_compat" instead, this
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/OutputDirectories.py` & `nuitka_winsvc-2.3/nuitka/OutputDirectories.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/PostProcessing.py` & `nuitka_winsvc-2.3/nuitka/PostProcessing.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,28 +7,29 @@
 
 import ctypes
 import os
 import sys
 
 from nuitka import Options, OutputDirectories
 from nuitka.build.DataComposerInterface import getConstantBlobFilename
-from nuitka.finalizations.FinalizeMarkups import getImportedNames
+from nuitka.ModuleRegistry import getImportedModuleNames
 from nuitka.PythonVersions import (
     getPythonABI,
     getTargetPythonDLLPath,
     python_version,
     python_version_str,
 )
 from nuitka.Tracing import postprocessing_logger
 from nuitka.utils.Execution import wrapCommandForDebuggerForExec
 from nuitka.utils.FileOperations import (
     getExternalUsePath,
     getFileContents,
     getFileSize,
     hasFilenameExtension,
+    isFilesystemEncodable,
     makePath,
     putTextFileContents,
     removeFileExecutablePermission,
 )
 from nuitka.utils.Images import convertImageToIconFormat
 from nuitka.utils.MacOSApp import createPlistInfoFile
 from nuitka.utils.SharedLibraries import (
@@ -281,19 +282,14 @@
     These are in part required steps, not usable after failure.
     """
 
     # Lots of cases to deal with, pylint: disable=too-many-branches
 
     result_filename = OutputDirectories.getResultFullpath(onefile=False)
 
-    if not os.path.exists(result_filename):
-        postprocessing_logger.sysexit(
-            "Error, scons failed to create the expected file %r. " % result_filename
-        )
-
     if isWin32Windows():
         if not Options.shallMakeModule():
             if python_version < 0x300:
                 # Copy the Windows manifest from the CPython binary to the created
                 # executable, so it finds "MSCRT.DLL". This is needed for Python2
                 # only, for Python3 newer MSVC doesn't hide the C runtime.
                 manifest = getWindowsExecutableManifest(sys.executable)
@@ -383,15 +379,19 @@
                 (" ".join(wrapCommandForDebuggerForExec()) + " ")
                 if Options.shallRunInDebugger()
                 else ""
             ),
             "dll_directory": dll_directory,
             "python_home": sys.prefix,
             "python_path": ";".join(sys.path),
-            "exe_filename": os.path.basename(result_filename),
+            "exe_filename": os.path.basename(
+                result_filename
+                if isFilesystemEncodable(result_filename)
+                else getExternalUsePath(result_filename)
+            ),
         }
 
         putTextFileContents(cmd_filename, cmd_contents)
 
     # Create a ".pyi" file for created modules
     if Options.shallMakeModule() and Options.shallCreatePyiFile():
         pyi_filename = OutputDirectories.getResultBasePath() + ".pyi"
@@ -416,15 +416,16 @@
 # This is not Python source even if it looks so. Make it clear for
 # now. This was decided by PEP 484 designers.
 __name__ = ...
 
 """
             % {
                 "imports": "\n".join(
-                    "import %s" % module_name for module_name in getImportedNames()
+                    "import %s" % module_name
+                    for module_name in getImportedModuleNames()
                 )
             },
             encoding="utf-8",
         )
 
     if isWin32Windows() and getFileSize(result_filename) > 2**30 * 1.8:
         postprocessing_logger.warning(
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/Progress.py` & `nuitka_winsvc-2.3/nuitka/Progress.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/PythonFlavors.py` & `nuitka_winsvc-2.3/nuitka/PythonFlavors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/PythonOperators.py` & `nuitka_winsvc-2.3/nuitka/PythonOperators.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/PythonVersions.py` & `nuitka_winsvc-2.3/nuitka/PythonVersions.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,26 +27,27 @@
         "3.5",
         "3.6",
         "3.7",
         "3.8",
         "3.9",
         "3.10",
         "3.11",
+        "3.12",
     )
 
 
 def getNotYetSupportedPythonVersions():
     """Versions known to not work at all (yet)."""
     return ("3.13",)
 
 
 def getPartiallySupportedPythonVersions():
     """Partially supported Python versions for Nuitka."""
 
-    return ("3.12",)
+    return ()
 
 
 def getZstandardSupportingVersions():
     result = getSupportedPythonVersions() + getPartiallySupportedPythonVersions()
 
     # This will crash if we remove versions, but it is more likely to work
     # with newly supported versions, and to list the ones not supported by
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/Serialization.py` & `nuitka_winsvc-2.3/nuitka/Serialization.py`

 * *Files 10% similar despite different names*

```diff
@@ -159,85 +159,92 @@
         self.count = 0
         self.pickle = pickle.Unpickler(const_file)
 
     def readConstantValue(self):
         return self.pickle.load()
 
 
-class ConstantAccessor(object):
+class GlobalConstantAccessor(object):
+    __slots__ = ("constants", "constants_writer", "top_level_name")
+
     def __init__(self, data_filename, top_level_name):
         self.constants = OrderedSet()
 
         self.constants_writer = ConstantStreamWriter(data_filename)
         self.top_level_name = top_level_name
 
     def getConstantCode(self, constant):
-        # Use in user code, or for constants building code itself, many
-        # constant types get special code immediately.
-        # pylint: disable=too-many-branches,too-many-statements
+        # Use in user code, or for constants building code itself, many constant
+        # types get special code immediately, and it's return driven.
+        # pylint: disable=too-many-branches,too-many-return-statements
         if constant is None:
-            key = "Py_None"
+            return "Py_None"
         elif constant is True:
-            key = "Py_True"
+            return "Py_True"
         elif constant is False:
-            key = "Py_False"
+            return "Py_False"
         elif constant is Ellipsis:
-            key = "Py_Ellipsis"
+            return "Py_Ellipsis"
         elif constant is NotImplemented:
-            key = "Py_NotImplemented"
+            return "Py_NotImplemented"
         elif constant is sys.version_info:
-            key = "Py_SysVersionInfo"
+            return "Py_SysVersionInfo"
         elif type(constant) is type:
             # TODO: Maybe make this a mapping in nuitka.Builtins
 
             if constant is None:
-                key = "(PyObject *)Py_TYPE(Py_None)"
+                return "(PyObject *)Py_TYPE(Py_None)"
             elif constant is object:
-                key = "(PyObject *)&PyBaseObject_Type"
+                return "(PyObject *)&PyBaseObject_Type"
             elif constant is staticmethod:
-                key = "(PyObject *)&PyStaticMethod_Type"
+                return "(PyObject *)&PyStaticMethod_Type"
             elif constant is classmethod:
-                key = "(PyObject *)&PyClassMethod_Type"
+                return "(PyObject *)&PyClassMethod_Type"
             elif constant is bytearray:
-                key = "(PyObject *)&PyByteArray_Type"
+                return "(PyObject *)&PyByteArray_Type"
             elif constant is enumerate:
-                key = "(PyObject *)&PyEnum_Type"
+                return "(PyObject *)&PyEnum_Type"
             elif constant is frozenset:
-                key = "(PyObject *)&PyFrozenSet_Type"
+                return "(PyObject *)&PyFrozenSet_Type"
             elif python_version >= 0x270 and constant is memoryview:
-                key = "(PyObject *)&PyMemoryView_Type"
+                return "(PyObject *)&PyMemoryView_Type"
             elif python_version < 0x300 and constant is basestring:
-                key = "(PyObject *)&PyBaseString_Type"
+                return "(PyObject *)&PyBaseString_Type"
             elif python_version < 0x300 and constant is xrange:
-                key = "(PyObject *)&PyRange_Type"
+                return "(PyObject *)&PyRange_Type"
             elif constant in builtin_anon_values:
-                key = "(PyObject *)" + builtin_anon_codes[builtin_anon_values[constant]]
+                return (
+                    "(PyObject *)" + builtin_anon_codes[builtin_anon_values[constant]]
+                )
             elif constant in builtin_exception_values_list:
-                key = "(PyObject *)PyExc_%s" % constant.__name__
+                return "(PyObject *)PyExc_%s" % constant.__name__
             elif constant is ExceptionGroup:
-                key = "(PyObject *)_PyInterpreterState_GET()->exc_state.PyExc_ExceptionGroup"
+                return "(PyObject *)_PyInterpreterState_GET()->exc_state.PyExc_ExceptionGroup"
             elif constant is BaseExceptionGroup:
-                key = "(PyObject *)PyExc_BaseExceptionGroup"
+                return "(PyObject *)PyExc_BaseExceptionGroup"
             else:
                 type_name = constant.__name__
 
                 if constant is int and python_version >= 0x300:
                     type_name = "long"
                 elif constant is str:
                     type_name = "string" if python_version < 0x300 else "unicode"
 
-                key = "(PyObject *)&Py%s_Type" % type_name.capitalize()
+                return "(PyObject *)&Py%s_Type" % type_name.capitalize()
         else:
-            key = "const_" + namifyConstant(constant)
+            return self._getConstantCode(constant)
 
-            if key not in self.constants:
-                self.constants.add(key)
-                self.constants_writer.addConstantValue(constant)
+    def _getConstantCode(self, constant):
+        key = "const_" + namifyConstant(constant)
 
-            key = "%s[%d]" % (self.top_level_name, self.constants.index(key))
+        if key not in self.constants:
+            self.constants.add(key)
+            self.constants_writer.addConstantValue(constant)
+
+        key = "%s[%d]" % (self.top_level_name, self.constants.index(key))
 
         # TODO: Make it returning, more clear.
         return key
 
     def getBlobDataCode(self, data, name):
         key = "blob_" + namifyConstant(data)
 
@@ -252,14 +259,24 @@
     def getConstantsCount(self):
         # Make sure to add no more after asking this.
         self.constants_writer.close()
 
         return len(self.constants)
 
 
+class ConstantAccessor(GlobalConstantAccessor):
+    def _getConstantCode(self, constant):
+        constant_type = type(constant)
+
+        if constant_type is tuple and not constant:
+            return "const_tuple_empty"
+
+        return GlobalConstantAccessor._getConstantCode(self, constant)
+
+
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
 #     integrates with CPython, but also works on its own.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
 #
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/SourceCodeReferences.py` & `nuitka_winsvc-2.3/nuitka/SourceCodeReferences.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Tracing.py` & `nuitka_winsvc-2.3/nuitka/Tracing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/TreeXML.py` & `nuitka_winsvc-2.3/nuitka/TreeXML.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Variables.py` & `nuitka_winsvc-2.3/nuitka/Variables.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/Version.py` & `nuitka_winsvc-2.3/nuitka/Version.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 #     limitations under the License.
 #
 """ Nuitka version related stuff.
 
 """
 
 version_string = """\
-Nuitka V2.2.3
+Nuitka V2.3
 Copyright (C) 2024 Kay Hayen."""
 
 
 def getNuitkaVersion():
     """Return Nuitka version as a string.
 
     This should not be used for >= comparisons directly.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/__init__.py` & `nuitka_winsvc-2.3/nuitka/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/__main__.py` & `nuitka_winsvc-2.3/nuitka/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/__past__.py` & `nuitka_winsvc-2.3/nuitka/__past__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/Backend.scons` & `nuitka_winsvc-2.3/nuitka/build/Backend.scons`

 * *Files 3% similar despite different names*

```diff
@@ -35,15 +35,21 @@
 from nuitka.Tracing import (
     my_print,
     scons_details_logger,
     scons_logger,
     setQuiet,
 )
 from nuitka.utils.Execution import check_output
-from nuitka.utils.FileOperations import getExternalUsePath
+from nuitka.utils.FileOperations import (
+    changeFilenameExtension,
+    deleteFile,
+    getExternalUsePath,
+    getFilenameExtension,
+    isFilesystemEncodable,
+)
 from nuitka.utils.Json import loadJsonFromFilename
 from nuitka.utils.Utils import (
     isDebianBasedLinux,
     isFedoraBasedLinux,
     isMacOS,
     isNetBSD,
 )
@@ -100,26 +106,20 @@
 source_dir = getArgumentRequired("source_dir")
 
 # The directory containing Nuitka provided C files to be built and where it
 # should be used.
 nuitka_src = getArgumentRequired("nuitka_src")
 static_src = os.path.join(source_dir, "static")
 
-# The name of executable or extension module that we produce.
-result_base_path = getArgumentRequired("result_name")
-
-# The name of executable that we produce (in executable mode).
-result_exe = getArgumentDefaulted("result_exe", None)
+# The name of executable that we are supposed to produce.
+result_exe = getArgumentRequired("result_exe")
 
 # Name of the main program (in executable mode, typically __main__ but can be in a package too.)
 main_module_name = getArgumentDefaulted("main_module_name", "__main__")
 
-# The suffix for an extension module (in module mode).
-module_suffix = getArgumentDefaulted("module_suffix", None)
-
 # Full names shall be used, no remapping for cacheable filenames.
 full_names = getArgumentBool("full_names", False)
 
 # Module mode: Create a Python extension module, create an executable otherwise.
 module_mode = getArgumentBool("module_mode", False)
 
 # Debug mode: Less optimizations, debug information in the resulting binary.
@@ -163,16 +163,16 @@
 # LTO mode: Use link time optimizations of C compiler if available and known
 # good with the compiler in question.
 lto_mode = getArgumentDefaulted("lto_mode", "auto")
 
 # PGO mode: Use profile guided optimization of C compiler if available.
 pgo_mode = getArgumentDefaulted("pgo_mode", "no")
 
-# Windows subsystem mode: Disable console for windows builds.
-disable_console = getArgumentBool("disable_console", False)
+# Console mode specified
+console_mode = getArgumentDefaulted("console_mode", "attach")
 
 # Windows might be running a Python whose DLL we have to use.
 uninstalled_python = getArgumentBool("uninstalled_python", False)
 
 # Unstripped mode: Do not remove debug symbols.
 unstripped_mode = getArgumentBool("unstripped_mode", False)
 
@@ -350,15 +350,15 @@
 )
 
 env.the_compiler = env["CC"]
 env.the_cc_name = os.path.normcase(os.path.basename(env.the_compiler))
 env.standalone_mode = standalone_mode
 env.debug_mode = debug_mode
 env.unstripped_mode = unstripped_mode
-env.disable_console = disable_console
+env.console_mode = console_mode
 env.source_dir = source_dir
 env.nuitka_src = nuitka_src
 env.low_memory = low_memory
 env.macos_min_version = macos_min_version
 env.macos_target_arch = macos_target_arch
 
 # Requested or user provided, detect if it's clang even from environment
@@ -466,14 +466,16 @@
         if "allow-c-warnings" not in env.experimental_flags and not debugger_mode:
             env.Append(
                 CCFLAGS=[
                     "-Wall",
                     "-Werror",
                 ]
             )
+        else:
+            env.Append(CCFLAGS=["-Wno-unused-but-set-variable"])
 
         env.Append(
             CCFLAGS=[
                 # Unfortunately Py_INCREF(Py_False) triggers aliasing warnings,
                 # which are unfounded, so disable them.
                 "-Wno-error=strict-aliasing",
                 "-Wno-strict-aliasing",
@@ -500,14 +502,17 @@
             ]
         )
 
         # Disable warnings, that CPython headers already show.
         if python_version >= (3, 4):
             env.Append(CCFLAGS=["/wd4512", "/wd4510", "/wd4610"])
 
+        if python_version >= (3, 13):
+            env.Append(CCFLAGS=["/wd4324"])
+
         # We use null arrays in our structure Python declarations, which C11 does
         # not really allow, but should work.
         env.Append(CCFLAGS=["/wd4200"])
 
         # Do not show deprecation warnings, we will use methods for as long
         # as they work.
         env.Append(CCFLAGS=["/wd4996"])
@@ -633,14 +638,17 @@
             scons_logger.sysexit(
                 """\
 Error, no 'Python.h' %s headers can be found at '%s', dependency \
 not satisfied!"""
                 % ("debug" if python_debug else "development", candidates)
             )
 
+    if python_version >= (3, 13):
+        yield os.path.join(candidate, "internal", "mimalloc")
+
     if env.self_compiled_python_uninstalled:
         yield python_prefix_external
 
 
 env.Append(CPPPATH=list(_detectPythonHeaderPath()))
 
 # To support self-built Python on Windows, need to also add the "PC" directory,
@@ -904,32 +912,51 @@
     ]
 
     return result
 
 
 source_files = discoverSourceFiles()
 
+# Remove the target file to avoid cases where it falsely doesn't get rebuild
+# and then lingers from previous builds,
+deleteFile(result_exe, must_exist=False)
+
+# Workaround for MinGW64 not supporting unicode result paths for "-o" basename.
+if os.name == "nt" and not isFilesystemEncodable(result_exe):
+    result_exe = os.path.join(
+        os.path.dirname(result_exe),
+        "_nuitka_temp.pyd" if module_mode else "_nuitka_temp.exe",
+    )
+
+    deleteFile(result_exe, must_exist=False)
+
 if module_mode:
-    # For Python modules, the standard shared library extension is not what
-    # gets used. spell-checker: ignore SHLIBSUFFIX
+    # For Python modules, the standard shared library extension is not what gets
+    # used. spell-checker: ignore SHLIBSUFFIX
+    module_suffix = getFilenameExtension(result_exe)
+    result_base_path = changeFilenameExtension(result_exe, "")
+
+    extra_suffix = getFilenameExtension(result_base_path)
+    if extra_suffix != "":
+        module_suffix = extra_suffix + module_suffix
+        result_base_path = changeFilenameExtension(result_base_path, "")
+
+    assert getFilenameExtension(result_base_path) == "", result_base_path
+
     env["SHLIBSUFFIX"] = module_suffix
 
     target = env.SharedLibrary(
         result_base_path, source_files, no_import_lib=no_import_lib
     )
 else:
     target = env.Program(result_exe, source_files)
 
 # Use compiler/linker flags provided via environment variables
 importEnvironmentVariableSettings(env)
 
-# Remove the target file to avoid cases where it falsely doesn't get rebuild
-# and then lingers from previous builds,
-if os.path.exists(target[0].abspath):
-    os.unlink(target[0].abspath)
 
 if job_count:
     scons_details_logger.info("Told to run compilation on %d CPUs." % job_count)
 
 
 def createBuildDefinitionsFile():
     build_definitions = {}
@@ -1055,15 +1082,15 @@
 
 if env.msvc_mode and not disable_ccache:
     enableClcache(
         env=env,
         source_dir=source_dir,
     )
 
-writeSconsReport(env)
+writeSconsReport(env=env, target=target)
 
 setSconsProgressBarTotal(name=env.progressbar_name, total=len(source_files))
 
 scons_details_logger.info("Launching Scons target: %s" % target)
 env.Default(target)
 
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/CCompilerVersion.scons` & `nuitka_winsvc-2.3/nuitka/build/CCompilerVersion.scons`

 * *Files 4% similar despite different names*

```diff
@@ -83,16 +83,16 @@
 # Experimental indications. Do things that are not yet safe to do.
 experimental = getArgumentList("experimental", "")
 
 # LTO mode: Use link time optimizations of C compiler if available and known
 # good with the compiler in question.
 lto_mode = getArgumentDefaulted("lto_mode", "auto")
 
-# Windows subsystem mode: Disable console for windows builds.
-disable_console = getArgumentBool("disable_console", False)
+# Console mode specified
+console_mode = getArgumentDefaulted("console_mode", "attach")
 
 # Unstripped mode: Do not remove debug symbols.
 unstripped_mode = getArgumentBool("unstripped_mode", False)
 
 # Target arch, uses for compiler choice and quick linking of constants binary
 # data.
 target_arch = ARGUMENTS["target_arch"]
@@ -203,15 +203,15 @@
     assume_yes_for_downloads=assume_yes_for_downloads,
 )
 
 env.the_compiler = env["CC"] or env["CXX"]
 env.the_cc_name = os.path.normcase(os.path.basename(env.the_compiler))
 env.debug_mode = debug_mode
 env.unstripped_mode = unstripped_mode
-env.disable_console = disable_console
+env.console_mode = console_mode
 env.nuitka_src = nuitka_src
 env.low_memory = False
 env.macos_min_version = macos_min_version
 env.macos_target_arch = macos_target_arch
 
 # Requested or user provided, detect if it's clang even from environment
 if isClangName(env.the_cc_name):
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/DataComposerInterface.py` & `nuitka_winsvc-2.3/nuitka/build/DataComposerInterface.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/Onefile.scons` & `nuitka_winsvc-2.3/nuitka/build/Onefile.scons`

 * *Files 2% similar despite different names*

```diff
@@ -122,16 +122,16 @@
 # Tracing mode. Output program progress.
 trace_mode = getArgumentBool("trace_mode", False)
 
 # LTO mode: Use link time optimizations of C compiler if available and known
 # good with the compiler in question.
 lto_mode = getArgumentDefaulted("lto_mode", "auto")
 
-# Windows subsystem mode: Disable console for windows builds.
-disable_console = getArgumentBool("disable_console", False)
+# Console mode specified
+console_mode = getArgumentDefaulted("console_mode", "attach")
 
 # Unstripped mode: Do not remove debug symbols.
 unstripped_mode = getArgumentBool("unstripped_mode", False)
 
 # Target arch, uses for compiler choice and quick linking of constants binary
 # data.
 target_arch = ARGUMENTS["target_arch"]
@@ -261,15 +261,15 @@
 )
 
 env.the_compiler = env["CC"] or env["CXX"]
 env.the_cc_name = os.path.normcase(os.path.basename(env.the_compiler))
 env.standalone_mode = True  # We are only used in this case.
 env.debug_mode = debug_mode
 env.unstripped_mode = unstripped_mode
-env.disable_console = disable_console
+env.console_mode = console_mode
 env.source_dir = source_dir
 env.nuitka_src = nuitka_src
 env.low_memory = False  # Never a concern in this case.
 env.macos_min_version = macos_min_version
 env.macos_target_arch = macos_target_arch
 
 # Requested or user provided, detect if it's clang even from environment
@@ -533,15 +533,15 @@
 if env.gcc_mode:
     makeGccUseLinkerFile(
         source_files=source_files,
         module_mode=module_mode,
         env=env,
     )
 
-writeSconsReport(env)
+writeSconsReport(env=env, target=target)
 
 setSconsProgressBarTotal(name="Onefile", total=len(source_files))
 
 scons_details_logger.info("Launching Scons target: %s" % target)
 env.Default(target)
 
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsCaching.py` & `nuitka_winsvc-2.3/nuitka/build/SconsCaching.py`

 * *Files 1% similar despite different names*

```diff
@@ -139,16 +139,17 @@
 def enableCcache(
     env, source_dir, python_prefix, assume_yes_for_downloads, disable_ccache
 ):
     inject_ccache = not disable_ccache
 
     if inject_ccache:
         # The ccache needs absolute path, otherwise it will not work.
-        ccache_logfile = os.path.abspath(
-            os.path.join(source_dir, "ccache-%d.txt" % os.getpid())
+        ccache_logfile = getExternalUsePath(
+            os.path.abspath(os.path.join(source_dir, "ccache-%d.txt" % os.getpid())),
+            only_dirname=True,
         )
 
         setEnvironmentVariable(env, "CCACHE_LOGFILE", ccache_logfile)
         env["CCACHE_LOGFILE"] = ccache_logfile
 
         # Unless asked to do otherwise, store ccache files in our own directory.
         if "CCACHE_DIR" not in os.environ:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsCompilerSettings.py` & `nuitka_winsvc-2.3/nuitka/build/SconsCompilerSettings.py`

 * *Files 2% similar despite different names*

```diff
@@ -633,15 +633,15 @@
     if "clang" in env.the_cc_name:
         env.Append(CCFLAGS=["-w"])
         env.Append(CPPDEFINES=["_XOPEN_SOURCE"])
 
         # Don't export anything by default, this should create smaller executables.
         env.Append(CCFLAGS=["-fvisibility=hidden", "-fvisibility-inlines-hidden"])
 
-        if env.debug_mode:
+        if env.debug_mode and "allow-c-warnings" not in env.experimental_flags:
             env.Append(CCFLAGS=["-Wunused-but-set-variable"])
 
     # Support for macOS standalone to run on older OS versions.
     if isMacOS():
         setEnvironmentVariable(env, "MACOSX_DEPLOYMENT_TARGET", env.macos_min_version)
 
         target_flag = "--target=%s-macos%s" % (
@@ -776,20 +776,26 @@
 
     # For MinGW64 we need to tell the subsystem to target as well as to
     # automatically import everything used.
     if env.mingw_mode:
         if not env.clang_mode:
             env.Append(LINKFLAGS=["-Wl,--enable-auto-import"])
 
-        if env.disable_console:
+    # Even if console is forced, for Win32 it means to specify Windows
+    # subsystem, we can still attach or create.
+    if env.console_mode != "force":
+        if env.mingw_mode:
             env.Append(LINKFLAGS=["-Wl,--subsystem,windows"])
-
-    if env.mingw_mode or env.msvc_mode:
-        if env.disable_console:
             env.Append(CPPDEFINES=["_NUITKA_WINMAIN_ENTRY_POINT"])
+        elif env.msvc_mode:
+            env.Append(LINKFLAGS=["/SUBSYSTEM:windows"])
+            env.Append(CPPDEFINES=["_NUITKA_WINMAIN_ENTRY_POINT"])
+
+    if env.console_mode == "attach" and os.name == "nt":
+        env.Append(CPPDEFINES=["_NUITKA_ATTACH_CONSOLE_WINDOW"])
 
     # Avoid dependency on MinGW libraries, spell-checker: ignore libgcc
     if env.mingw_mode and not env.clang_mode:
         env.Append(LINKFLAGS=["-static-libgcc"])
 
     # MinGW64 for 64 bits needs this due to CPython bugs.
     if env.mingw_mode and env.target_arch == "x86_64" and env.python_version < (3, 12):
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsHacks.py` & `nuitka_winsvc-2.3/nuitka/build/SconsHacks.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsInterface.py` & `nuitka_winsvc-2.3/nuitka/build/SconsInterface.py`

 * *Files 2% similar despite different names*

```diff
@@ -33,36 +33,38 @@
 from nuitka.utils.AppDirs import getCacheDirEnvironmentVariableName
 from nuitka.utils.Download import getDownloadCacheDir, getDownloadCacheName
 from nuitka.utils.Execution import (
     getExecutablePath,
     withEnvironmentVarsOverridden,
 )
 from nuitka.utils.FileOperations import (
+    areSamePaths,
     changeFilenameExtension,
     deleteFile,
     getDirectoryRealPath,
     getExternalUsePath,
     getWindowsShortPathName,
     hasFilenameExtension,
     listDir,
     makePath,
     putTextFileContents,
+    renameFile,
     withDirectoryChange,
 )
 from nuitka.utils.InstalledPythons import findInstalledPython
 from nuitka.utils.SharedLibraries import detectBinaryMinMacOS
 from nuitka.utils.Utils import (
     getArchitecture,
     isMacOS,
     isWin32OrPosixWindows,
     isWin32Windows,
 )
 
 from .SconsCaching import checkCachingSuccess
-from .SconsUtils import flushSconsReports
+from .SconsUtils import flushSconsReports, getSconsReportValue
 
 
 def getSconsDataPath():
     """Return path to where data for scons lives, e.g. static C source files."""
 
     return os.path.dirname(__file__)
 
@@ -332,18 +334,17 @@
             # Make sure we become non-local, by changing all paths to be
             # absolute, but ones that can be resolved by any program
             # externally, as the Python of Scons may not be good at unicode.
 
             options = copy.deepcopy(options)
             source_dir = options["source_dir"]
             options["source_dir"] = "."
-            options["result_name"] = getExternalUsePath(
-                options["result_name"], only_dirname=True
-            )
             options["nuitka_src"] = getExternalUsePath(options["nuitka_src"])
+
+            orig_result_exe = options.get("result_exe")
             if "result_exe" in options:
                 options["result_exe"] = getExternalUsePath(
                     options["result_exe"], only_dirname=True
                 )
 
         else:
             source_dir = None
@@ -366,24 +367,39 @@
         with withEnvironmentVarsOverridden(env_values):
             # Create debug script to quickly re-run this step only.
             if source_dir is not None:
                 _createSconsDebugScript(
                     source_dir=source_dir, scons_command=scons_command
                 )
 
+                source_dir = getExternalUsePath(source_dir)
             try:
                 result = subprocess.call(scons_command, shell=False, cwd=source_dir)
             except KeyboardInterrupt:
                 Tracing.scons_logger.sysexit("User interrupted scons build.")
 
         # TODO: Actually this should only flush one of these, namely the one for
         # current source_dir.
         flushSconsReports()
 
         if "source_dir" in options and result == 0:
+            if "result_exe" in options:
+                scons_created_exe = getSconsReportValue(
+                    source_dir or options["source_dir"], "TARGET"
+                )
+
+                if not os.path.exists(scons_created_exe):
+                    Tracing.scons_logger.sysexit(
+                        "Error, scons failed to create the expected file %r. "
+                        % scons_created_exe
+                    )
+
+                if not areSamePaths(options["result_exe"], scons_created_exe):
+                    renameFile(scons_created_exe, orig_result_exe)
+
             checkCachingSuccess(source_dir or options["source_dir"])
 
         return result == 0
 
 
 def asBoolStr(value):
     """Encode booleans for transfer via command line."""
@@ -471,16 +487,16 @@
 
     if Options.getMsvcVersion():
         options["msvc_version"] = Options.getMsvcVersion()
 
     if Options.shallDisableCCacheUsage():
         options["disable_ccache"] = asBoolStr(True)
 
-    if Options.shallDisableConsoleWindow() and Options.mayDisableConsoleWindow():
-        options["disable_console"] = asBoolStr(True)
+    if isWin32Windows() and Options.getWindowsConsoleMode() != "attach":
+        options["console_mode"] = Options.getWindowsConsoleMode()
 
     if Options.getLtoMode() != "auto":
         options["lto_mode"] = Options.getLtoMode()
 
     if isWin32OrPosixWindows() or isMacOS():
         options["noelf_mode"] = asBoolStr(True)
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsProgress.py` & `nuitka_winsvc-2.3/nuitka/build/SconsProgress.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsSpawn.py` & `nuitka_winsvc-2.3/nuitka/build/SconsSpawn.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/SconsUtils.py` & `nuitka_winsvc-2.3/nuitka/build/SconsUtils.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,17 @@
 import sys
 
 from nuitka.__past__ import basestring, unicode
 from nuitka.containers.OrderedDicts import OrderedDict
 from nuitka.Tracing import scons_details_logger, scons_logger
 from nuitka.utils.Execution import executeProcess
 from nuitka.utils.FileOperations import (
+    changeFilenameExtension,
     getFileContentByLine,
+    getFilenameExtension,
     getWindowsShortPathName,
     hasFilenameExtension,
     isFilesystemEncodable,
     openPickleFile,
     openTextFile,
     withFileLock,
 )
@@ -355,15 +357,15 @@
         path_value.insert(0, dirname)
     else:
         path_value.append(dirname)
 
     setEnvironmentVariable(env, "PATH", os.pathsep.join(path_value))
 
 
-def writeSconsReport(env):
+def writeSconsReport(env, target):
     with openTextFile(
         _getSconsReportFilename(env.source_dir), "w", encoding="utf8"
     ) as report_file:
         # We are friends to get at this debug info, pylint: disable=protected-access
         for key, value in sorted(env._dict.items()):
             if type(value) is list and all(isinstance(v, basestring) for v in value):
                 value = repr(value)
@@ -386,14 +388,15 @@
         print("gcc_mode=%s" % env.gcc_mode, file=report_file)
         print("clang_mode=%s" % env.clang_mode, file=report_file)
         print("msvc_mode=%s" % env.msvc_mode, file=report_file)
         print("mingw_mode=%s" % env.mingw_mode, file=report_file)
         print("clangcl_mode=%s" % env.clangcl_mode, file=report_file)
 
         print("PATH=%s" % os.environ["PATH"], file=report_file)
+        print("TARGET=%s" % target[0].abspath, file=report_file)
 
 
 def reportSconsUnexpectedOutput(env, cmdline, stdout, stderr):
     with withFileLock("writing scons error report"):
         file_handle, pickler = openPickleFile(
             _getSconsErrorReportFilename(env.source_dir), "ab", protocol=2
         )
@@ -620,14 +623,19 @@
         filename = os.path.join(dirname, filename_base)
 
         target_filename = filename
 
         if isWin32Windows() and not isFilesystemEncodable(filename_base):
             target_filename = getWindowsShortPathName(target_filename)
 
+            # Avoid ".C" suffixes, that MinGW64 wouldn't recognize.
+            target_filename = changeFilenameExtension(
+                target_filename, getFilenameExtension(target_filename).lower()
+            )
+
         # We pretend to use C++ if no C11 compiler is present.
         if env.c11_mode:
             yield target_filename
         else:
             if hasFilenameExtension(filename, ".c"):
                 target_filename += "pp"  # .cpp" suffix then
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/allocator.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/allocator.h`

 * *Files 14% similar despite different names*

```diff
@@ -9,14 +9,47 @@
 #endif
 
 // For Python2.6, these assertions cannot be done easily, just disable them with dummy code.
 #if PYTHON_VERSION < 0x270 && !defined(__NUITKA_NO_ASSERT__)
 #define _PyObject_GC_IS_TRACKED(obj) (1)
 #endif
 
+// The full API is available for Python 3.5 only
+#if PYTHON_VERSION >= 0x350 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_ALLOCATORS)
+extern void *(*python_obj_malloc)(void *ctx, size_t size);
+extern void *(*python_mem_malloc)(void *ctx, size_t size);
+extern void *(*python_mem_calloc)(void *ctx, size_t nelem, size_t elsize);
+
+#if defined(Py_DEBUG)
+extern void *python_obj_ctx;
+extern void *python_mem_ctx;
+#else
+#define python_obj_ctx (NULL)
+#define python_mem_ctx (NULL)
+#endif
+
+extern void initNuitkaAllocators(void);
+
+// Our version of "PyObject_Malloc".
+NUITKA_MAY_BE_UNUSED static void *NuitkaObject_Malloc(size_t size) { return python_obj_malloc(python_obj_ctx, size); }
+
+// Our version of "PyMem_Malloc".
+NUITKA_MAY_BE_UNUSED static void *NuitkaMem_Malloc(size_t size) { return python_mem_malloc(python_mem_ctx, size); }
+
+// Our version of "PyMem_Calloc".
+NUITKA_MAY_BE_UNUSED static void *NuitkaMem_Calloc(size_t nelem, size_t elsize) {
+    return python_mem_calloc(python_mem_ctx, nelem, elsize);
+}
+
+#else
+#define NuitkaObject_Malloc(size) PyObject_MALLOC(size)
+#define NuitkaMem_Malloc(size) PyMem_MALLOC(size)
+#define NuitkaMem_Calloc(elem, elsize) PyMem_CALLOC(elem, elsize)
+#endif
+
 #if PYTHON_VERSION >= 0x380 && PYTHON_VERSION < 0x3c0
 // Need to make Py_DECREF a macro again that doesn't call an API
 static inline void _Nuitka_Py_DECREF(PyObject *ob) {
     assert(ob != NULL && ob->ob_refcnt >= 0);
 
     // Non-limited C API and limited C API for Python 3.9 and older access
     // directly PyObject.ob_refcnt.
@@ -67,14 +100,26 @@
             (op) = NULL;                                                                                               \
             Py_DECREF(_py_tmp);                                                                                        \
         }                                                                                                              \
     } while (0)
 
 #endif
 
+// For Python3.12, avoid reference management if value is known to be immortal.
+#if PYTHON_VERSION < 0x3c0
+#define Py_INCREF_IMMORTAL(value) Py_INCREF(value)
+#define Py_DECREF_IMMORTAL(value) Py_DECREF(value)
+#elif defined(__NUITKA_NO_ASSERT__)
+#define Py_INCREF_IMMORTAL(value)
+#define Py_DECREF_IMMORTAL(value)
+#else
+#define Py_INCREF_IMMORTAL(value) assert(Py_REFCNT(value) == _Py_IMMORTAL_REFCNT)
+#define Py_DECREF_IMMORTAL(value) assert(Py_REFCNT(value) == _Py_IMMORTAL_REFCNT)
+#endif
+
 // Macro introduced with Python3.9 or higher, make it generally available.
 #ifndef Py_SET_TYPE
 static inline void _Py_SET_TYPE(PyObject *ob, PyTypeObject *type) { ob->ob_type = type; }
 #define Py_SET_TYPE(ob, type) _Py_SET_TYPE((PyObject *)(ob), type)
 #endif
 
 // After Python 3.9 this was moved into the DLL potentially, making
@@ -112,15 +157,15 @@
     // There is always a sentinel now, therefore add one
     const size_t size = _PyObject_VAR_SIZE(type, nitems + 1);
 
     // TODO: This ought to be static for all our types, so remove it as a call.
     const size_t pre_size = Nuitka_PyType_PreHeaderSize(type);
     assert(pre_size == sizeof(PyGC_Head));
 
-    char *alloc = (char *)PyObject_Malloc(size + pre_size);
+    char *alloc = (char *)NuitkaObject_Malloc(size + pre_size);
     assert(alloc);
     PyObject *obj = (PyObject *)(alloc + pre_size);
 
     assert(pre_size);
     if (pre_size) {
         ((PyObject **)alloc)[0] = NULL;
         ((PyObject **)alloc)[1] = NULL;
@@ -147,15 +192,15 @@
     return obj;
 }
 
 static PyObject *Nuitka_PyType_AllocNoTrack(PyTypeObject *type) {
     // TODO: This ought to be static for all our types, so remove it as a call.
     const size_t pre_size = Nuitka_PyType_PreHeaderSize(type);
 
-    char *alloc = (char *)PyObject_Malloc(_PyObject_SIZE(type) + pre_size);
+    char *alloc = (char *)NuitkaObject_Malloc(_PyObject_SIZE(type) + pre_size);
     assert(alloc);
     PyObject *obj = (PyObject *)(alloc + pre_size);
 
     assert(pre_size);
     ((PyObject **)alloc)[0] = NULL;
     ((PyObject **)alloc)[1] = NULL;
 
@@ -225,14 +270,25 @@
 #else
     // TODO: We ought to inline this probably too, no point as a separate function.
     PyObject *op = Nuitka_PyType_AllocNoTrack(type);
 #endif
     return op;
 }
 
+static bool inline Nuitka_GC_IS_TRACKED_X(PyObject *object) {
+    return object == NULL || _PyObject_GC_IS_TRACKED(object);
+}
+
+// To allow us marking some of our own values as immortal.
+#if PYTHON_VERSION >= 0x3c0
+static void inline Py_SET_REFCNT_IMMORTAL(PyObject *object) { object->ob_refcnt = _Py_IMMORTAL_REFCNT; }
+#else
+#define Py_SET_REFCNT_IMMORTAL(object)
+#endif
+
 #endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/builtins.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/builtins.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/calling.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/calling.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/checkers.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/checkers.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/checksum_tools.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/checksum_tools.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_asyncgen.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_asyncgen.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_cell.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_cell.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_coroutine.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_coroutine.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_frame.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_frame.h`

 * *Files 4% similar despite different names*

```diff
@@ -86,19 +86,35 @@
     _Py_CODEUNIT *code_unit = _PyCode_CODE(code);
     return code_unit->op.code == 0;
 #endif
 }
 
 extern PyTypeObject Nuitka_Frame_Type;
 
-static inline bool Nuitka_Frame_Check(PyObject *object) {
+static inline bool Nuitka_Frame_CheckExact(PyObject *object) {
     CHECK_OBJECT(object);
     return Py_TYPE(object) == &Nuitka_Frame_Type;
 }
 
+static inline bool Nuitka_Frame_Check(PyObject *object) {
+    assert(object);
+
+    if (!_PyObject_GC_IS_TRACKED(object)) {
+        return false;
+    }
+
+    CHECK_OBJECT(object);
+
+    if (Nuitka_Frame_CheckExact(object)) {
+        return true;
+    }
+
+    return strcmp(Py_TYPE(object)->tp_name, "compiled_frame") == 0;
+}
+
 struct Nuitka_FrameObject {
     PyFrameObject m_frame;
 
 #if PYTHON_VERSION >= 0x3b0
     PyObject *m_generator;
     PyFrameState m_frame_state;
     _PyInterpreterFrame m_interpreter_frame;
@@ -150,28 +166,39 @@
 extern int count_hit_frame_cache_instances;
 #endif
 
 #if _DEBUG_FRAME
 extern void dumpFrameStack(void);
 #endif
 
+#if PYTHON_VERSION >= 0x3b0
+inline static PyCodeObject *Nuitka_InterpreterFrame_GetCodeObject(_PyInterpreterFrame *frame) {
+#if PYTHON_VERSION < 0x3d0
+    return frame->f_code;
+#else
+    return (PyCodeObject *)frame->f_executable;
+#endif
+}
+#endif
+
 inline static PyCodeObject *Nuitka_Frame_GetCodeObject(PyFrameObject *frame) {
 #if PYTHON_VERSION >= 0x3b0
     assert(frame->f_frame);
-    return frame->f_frame->f_code;
+    return Nuitka_InterpreterFrame_GetCodeObject(frame->f_frame);
 #else
     return frame->f_code;
 #endif
 }
 
 inline static void assertPythonFrameObject(PyFrameObject *frame_object) {
 
     // TODO: Need to do this manually, as this is making frame caching code
     // vulnerable to mistakes, but so far the compiled frame type is private
     // assert(PyObject_IsInstance((PyObject *)frame_object, (PyObject *)&PyFrame_Type));
+    CHECK_OBJECT(frame_object);
 
     CHECK_CODE_OBJECT(Nuitka_Frame_GetCodeObject(frame_object));
 }
 
 inline static void assertFrameObject(struct Nuitka_FrameObject *frame_object) {
     CHECK_OBJECT(frame_object);
 
@@ -252,22 +279,31 @@
 #else
     return frame->m_frame.f_executing == 1;
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x3b0
+
+#if PYTHON_VERSION < 0x3d0
+#define CURRENT_TSTATE_INTERPRETER_FRAME(tstate) tstate->cframe->current_frame
+#else
+#define CURRENT_TSTATE_INTERPRETER_FRAME(tstate) tstate->current_frame
+#endif
+
 NUITKA_MAY_BE_UNUSED inline static void pushFrameStackInterpreterFrame(PyThreadState *tstate,
                                                                        _PyInterpreterFrame *interpreter_frame) {
-    _PyInterpreterFrame *old = tstate->cframe->current_frame;
+    _PyInterpreterFrame *old = CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
     interpreter_frame->previous = old;
-    tstate->cframe->current_frame = interpreter_frame;
+    CURRENT_TSTATE_INTERPRETER_FRAME(tstate) = interpreter_frame;
 
-    if (old != NULL && interpreter_frame->frame_obj) {
+    if (old != NULL && !_PyFrame_IsIncomplete(old) && interpreter_frame->frame_obj) {
         interpreter_frame->frame_obj->f_back = old->frame_obj;
+        CHECK_OBJECT_X(old->frame_obj);
+
         Py_XINCREF(old->frame_obj);
     }
 }
 #else
 // Put frame at the top of the frame stack and mark as executing.
 NUITKA_MAY_BE_UNUSED inline static void pushFrameStackPythonFrame(PyThreadState *tstate, PyFrameObject *frame_object) {
     PRINT_TOP_FRAME("Normal push entry top frame:");
@@ -277,26 +313,25 @@
     assertPythonFrameObject(frame_object);
 
     PyFrameObject *old = tstate->frame;
     CHECK_OBJECT_X(old);
 
     if (old) {
         assertPythonFrameObject(old);
-        CHECK_CODE_OBJECT(old->f_code);
+        CHECK_CODE_OBJECT(Nuitka_Frame_GetCodeObject(old));
     }
 
     // No recursion with identical frames allowed, assert against it.
     assert(old != frame_object);
 
     // Push the new frame as the currently active one.
     tstate->frame = frame_object;
 
     // Transfer ownership of old frame.
     if (old != NULL) {
-
         frame_object->f_back = old;
     }
 
     Nuitka_PythonFrame_MarkAsExecuting(frame_object);
     Py_INCREF(frame_object);
 
     PRINT_TOP_FRAME("Normal push exit top frame:");
@@ -332,21 +367,21 @@
     // Put previous frame on top.
     tstate->frame = frame_object->m_frame.f_back;
     frame_object->m_frame.f_back = NULL;
 
     Nuitka_Frame_MarkAsNotExecuting(frame_object);
     Py_DECREF(frame_object);
 #else
-    assert(tstate->cframe);
-    assert(tstate->cframe->current_frame);
+    assert(CURRENT_TSTATE_INTERPRETER_FRAME(tstate));
 
-    struct Nuitka_FrameObject *frame_object = (struct Nuitka_FrameObject *)tstate->cframe->current_frame->frame_obj;
+    struct Nuitka_FrameObject *frame_object =
+        (struct Nuitka_FrameObject *)CURRENT_TSTATE_INTERPRETER_FRAME(tstate)->frame_obj;
     CHECK_OBJECT(frame_object);
 
-    tstate->cframe->current_frame = tstate->cframe->current_frame->previous;
+    CURRENT_TSTATE_INTERPRETER_FRAME(tstate) = CURRENT_TSTATE_INTERPRETER_FRAME(tstate)->previous;
 
     Nuitka_Frame_MarkAsNotExecuting(frame_object);
 
     CHECK_OBJECT_X(frame_object->m_frame.f_back);
     Py_CLEAR(frame_object->m_frame.f_back);
 
     Py_DECREF(frame_object);
@@ -385,15 +420,15 @@
 }
 #endif
 
 NUITKA_MAY_BE_UNUSED static PyCodeObject *Nuitka_GetFrameCodeObject(struct Nuitka_FrameObject *nuitka_frame) {
 #if PYTHON_VERSION < 0x3b0
     return nuitka_frame->m_frame.f_code;
 #else
-    return nuitka_frame->m_interpreter_frame.f_code;
+    return Nuitka_InterpreterFrame_GetCodeObject(&nuitka_frame->m_interpreter_frame);
 #endif
 }
 
 NUITKA_MAY_BE_UNUSED static int Nuitka_GetFrameLineNumber(struct Nuitka_FrameObject *nuitka_frame) {
     return nuitka_frame->m_frame.f_lineno;
 }
 
@@ -411,15 +446,15 @@
 // Attach locals to a frame object. TODO: Upper case, this is for generated code only.
 extern void Nuitka_Frame_AttachLocals(struct Nuitka_FrameObject *frame, char const *type_description, ...);
 
 NUITKA_MAY_BE_UNUSED static Nuitka_ThreadStateFrameType *_Nuitka_GetThreadStateFrame(PyThreadState *tstate) {
 #if PYTHON_VERSION < 0x3b0
     return tstate->frame;
 #else
-    return tstate->cframe->current_frame;
+    return CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
 #endif
 }
 
 NUITKA_MAY_BE_UNUSED inline static void pushFrameStackGenerator(PyThreadState *tstate,
                                                                 Nuitka_ThreadStateFrameType *frame_object) {
 #if PYTHON_VERSION < 0x3b0
     Nuitka_ThreadStateFrameType *return_frame = _Nuitka_GetThreadStateFrame(tstate);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_function.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_function.h`

 * *Files 1% similar despite different names*

```diff
@@ -67,14 +67,18 @@
     PyObject *m_annotations;
 #endif
 
 #if PYTHON_VERSION >= 0x300
     PyObject *m_qualname;
 #endif
 
+#if PYTHON_VERSION >= 0x3c0
+    PyObject *m_type_params;
+#endif
+
     // Constant return value to use.
     PyObject *m_constant_return_value;
 
     // A kind of uuid for the function object, used in comparisons.
     long m_counter;
 
     // Closure taken objects, for use in __closure__ and for accessing it.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_generator.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_generator.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/compiled_method.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/compiled_method.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/constants.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/constants.h`

 * *Files 0% similar despite different names*

```diff
@@ -87,14 +87,16 @@
 #define const_str_plain_range global_constants[29]
 // 'rb'
 #define const_str_plain_rb global_constants[29]
 // 'open'
 #define const_str_plain_open global_constants[30]
 // 'keys'
 #define const_str_plain_keys global_constants[30]
+// 'get'
+#define const_str_plain_get global_constants[30]
 // 'as_file'
 #define const_str_plain_as_file global_constants[30]
 // 'register'
 #define const_str_plain_register global_constants[30]
 // 'close'
 #define const_str_plain_close global_constants[30]
 // 'throw'
@@ -111,14 +113,18 @@
 #define const_str_plain_bytearray global_constants[34]
 // 'staticmethod'
 #define const_str_plain_staticmethod global_constants[35]
 // 'classmethod'
 #define const_str_plain_classmethod global_constants[36]
 // 'name'
 #define const_str_plain_name global_constants[37]
+// 'ascii'
+#define const_str_plain_ascii global_constants[37]
+// 'punycode'
+#define const_str_plain_punycode global_constants[37]
 // 'globals'
 #define const_str_plain_globals global_constants[38]
 // 'locals'
 #define const_str_plain_locals global_constants[39]
 // 'fromlist'
 #define const_str_plain_fromlist global_constants[40]
 // 'level'
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/constants_blob.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/constants_blob.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/environment_variables.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/environment_variables.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/environment_variables_system.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/environment_variables_system.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/exception_groups.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/exception_groups.h`

 * *Files 7% similar despite different names*

```diff
@@ -78,17 +78,17 @@
 extern PyObject *const_str_plain_split;
 
 NUITKA_MAY_BE_UNUSED static int EXCEPTION_GROUP_MATCH(PyThreadState *tstate, PyObject *exc_value, PyObject *match_type,
                                                       PyObject **match, PyObject **rest) {
     // TODO: Avoid this from happening, we should not call it then.
     if (exc_value == Py_None) {
         *match = Py_None;
-        Py_INCREF(*match);
+        Py_INCREF_IMMORTAL(*match);
         *rest = Py_None;
-        Py_INCREF(*rest);
+        Py_INCREF_IMMORTAL(*rest);
 
         return 0;
     }
 
     // If not none, must be an instance at this point.
     assert(PyExceptionInstance_Check(exc_value));
 
@@ -96,27 +96,27 @@
         bool is_exception_group = _PyBaseExceptionGroup_Check(exc_value);
 
         if (is_exception_group) {
             *match = exc_value;
             Py_INCREF(*match);
         } else {
             // Old style plain exception, put it into an exception group.
-            PyObject *exception_tuple = MAKE_TUPLE1_0(exc_value);
+            PyObject *exception_tuple = MAKE_TUPLE1_0(tstate, exc_value);
             PyObject *wrapped = _PyExc_CreateExceptionGroup("", exception_tuple);
             Py_DECREF(exception_tuple);
 
             if (unlikely(wrapped == NULL)) {
                 return -1;
             }
 
             *match = wrapped;
         }
 
         *rest = Py_None;
-        Py_INCREF(*rest);
+        Py_INCREF_IMMORTAL(*rest);
 
         return 0;
     }
 
     // exc_value does not match match_type completely, need to check for partial
     // match if it's an exception group.
     if (_PyBaseExceptionGroup_Check(exc_value)) {
@@ -138,18 +138,18 @@
         Py_INCREF(*rest);
 
         Py_DECREF(pair);
         return 0;
     }
 
     *match = Py_None;
-    Py_INCREF(*match);
+    Py_INCREF_IMMORTAL(*match);
 
     *rest = Py_None;
-    Py_INCREF(*rest);
+    Py_INCREF_IMMORTAL(*rest);
 
     return 0;
 }
 
 #endif
 
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/exceptions.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/exceptions.h`

 * *Files 0% similar despite different names*

```diff
@@ -531,15 +531,15 @@
             frame->f_exc_traceback = tstate->exc_traceback;
             Py_XINCREF(frame->f_exc_traceback);
         } else {
 #if _DEBUG_EXCEPTIONS
             PRINT_STRING("PRESERVE_FRAME_EXCEPTION: no exception to preserve\n");
 #endif
             frame->f_exc_type = Py_None;
-            Py_INCREF(frame->f_exc_type);
+            Py_INCREF_IMMORTAL(frame->f_exc_type);
             frame->f_exc_value = NULL;
             frame->f_exc_traceback = NULL;
         }
     }
 #if _DEBUG_EXCEPTIONS
     else {
         PRINT_STRING("PRESERVE_FRAME_EXCEPTION: already preserving\n");
@@ -747,15 +747,15 @@
 // Format a UnboundLocalError exception for a variable name.
 extern void FORMAT_UNBOUND_LOCAL_ERROR(PyObject **exception_type, PyObject **exception_value, PyObject *variable_name);
 
 extern void FORMAT_UNBOUND_CLOSURE_ERROR(PyObject **exception_type, PyObject **exception_value,
                                          PyObject *variable_name);
 
 #if PYTHON_VERSION >= 0x3c0
-NUITKA_MAY_BE_UNUSED static PyObject *MAKE_TUPLE1(PyObject *element1);
+NUITKA_MAY_BE_UNUSED static PyObject *MAKE_TUPLE1(PyThreadState *tstate, PyObject *element1);
 
 NUITKA_MAY_BE_UNUSED static PyObject *MAKE_EXCEPTION_FROM_TYPE_ARG0(PyThreadState *tstate, PyObject *type,
                                                                     PyObject *arg) {
     PyBaseExceptionObject *self;
 
     PyTypeObject *type_object = (PyTypeObject *)type;
 
@@ -765,15 +765,15 @@
     self->notes = NULL;
     self->traceback = self->cause = self->context = NULL;
     self->suppress_context = 0;
 
     assert(arg != NULL);
 
     if (!PyTuple_Check(arg)) {
-        self->args = MAKE_TUPLE1(arg);
+        self->args = MAKE_TUPLE1(tstate, arg);
     } else {
         self->args = Py_NewRef(arg);
     }
 
     return (PyObject *)self;
 }
 #else
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/filesystem_paths.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/filesystem_paths.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/freelists.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/freelists.h`

 * *Files 5% similar despite different names*

```diff
@@ -59,14 +59,25 @@
         *((void **)object) = NULL;                                                                                     \
                                                                                                                        \
         assert(free_list##_count == 0);                                                                                \
                                                                                                                        \
         free_list##_count += 1;                                                                                        \
     }
 
+#if PYTHON_VERSION >= 0x3d0
+NUITKA_MAY_BE_UNUSED static inline struct _Py_object_freelists *_Nuitka_object_freelists_GET(PyThreadState *tstate) {
+
+#ifdef Py_GIL_DISABLED
+    return &((_PyThreadStateImpl *)tstate)->freelists;
+#else
+    return &tstate->interp->object_state.freelists;
+#endif
+}
+#endif
+
 #endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/hedley.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/hedley.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/attributes.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/attributes.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/boolean.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/boolean.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/bytearrays.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/bytearrays.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/bytes.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/bytes.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/calling_generated.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/calling_generated.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_eq.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_eq.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_ge.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_ge.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_gt.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_gt.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_le.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_le.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_lt.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_lt.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/comparisons_ne.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/comparisons_ne.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/complex.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/complex.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/dictionaries.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/dictionaries.h`

 * *Files 1% similar despite different names*

```diff
@@ -384,30 +384,31 @@
 // Python dictionary values view
 extern PyObject *DICT_VIEWVALUES(PyObject *dict);
 
 // Python dictionary items view
 extern PyObject *DICT_VIEWITEMS(PyObject *dict);
 
 // Python dictionary copy, return a shallow copy of a dictionary.
-extern PyObject *DICT_COPY(PyObject *dict);
+extern PyObject *DICT_COPY(PyThreadState *tstate, PyObject *dict);
 
 // Python dictionary clear, empties the dictionary.
 extern void DICT_CLEAR(PyObject *dict);
 
 // Replacement for PyDict_Next that is faster (to call).
 extern bool Nuitka_DictNext(PyObject *dict, Py_ssize_t *pos, PyObject **key_ptr, PyObject **value_ptr);
 
-#if PYTHON_VERSION >= 0x3a0 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_FREELIST_ALL)
+#if PYTHON_VERSION >= 0x3a0 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_FREELIST_ALL) &&                                  \
+    !defined(_NUITKA_EXPERIMENTAL_DISABLE_FREELIST_DICT)
 #define NUITKA_DICT_HAS_FREELIST 1
 
 // Replacement for PyDict_New that is faster
-extern PyObject *MAKE_DICT_EMPTY(void);
+extern PyObject *MAKE_DICT_EMPTY(PyThreadState *tstate);
 #else
 #define NUITKA_DICT_HAS_FREELIST 0
-#define MAKE_DICT_EMPTY PyDict_New
+#define MAKE_DICT_EMPTY(tstate) PyDict_New()
 #endif
 
 // Create a dictionary from key/value pairs.
 extern PyObject *MAKE_DICT(PyObject **pairs, Py_ssize_t size);
 // Create a dictionary from key/value pairs (NULL value means skip)
 extern PyObject *MAKE_DICT_X(PyObject **pairs, Py_ssize_t size);
 // Create a dictionary from key/value pairs (NULL value means skip) where keys are C strings.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/floats.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/floats.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/import_hard.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/import_hard.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/indexes.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/indexes.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/ints.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/ints.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/iterators.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/iterators.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/lists.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/lists.h`

 * *Files 4% similar despite different names*

```diff
@@ -13,19 +13,19 @@
 
 #ifndef _PyList_ITEMS
 #define _PyList_ITEMS(op) (((PyListObject *)(op))->ob_item)
 #endif
 
 #if PYTHON_VERSION >= 0x3a0
 #define NUITKA_LIST_HAS_FREELIST 1
-extern PyObject *MAKE_LIST_EMPTY(Py_ssize_t size);
+extern PyObject *MAKE_LIST_EMPTY(PyThreadState *tstate, Py_ssize_t size);
 #else
 #define NUITKA_LIST_HAS_FREELIST 0
 
-#define MAKE_LIST_EMPTY(size) PyList_New(size)
+#define MAKE_LIST_EMPTY(tstate, size) PyList_New(size)
 #endif
 
 extern bool LIST_EXTEND_FROM_ITERABLE(PyThreadState *tstate, PyObject *list, PyObject *other);
 extern bool LIST_EXTEND_FOR_UNPACK(PyThreadState *tstate, PyObject *list, PyObject *other);
 
 // Like "PyList_Append", but we get to specify the transfer of refcount ownership.
 extern bool LIST_APPEND1(PyObject *target, PyObject *item);
@@ -37,15 +37,15 @@
 // Like list.clear
 extern void LIST_CLEAR(PyObject *target);
 
 // Like list.reverse
 extern void LIST_REVERSE(PyObject *list);
 
 // Like list.copy
-extern PyObject *LIST_COPY(PyObject *list);
+extern PyObject *LIST_COPY(PyThreadState *tstate, PyObject *list);
 
 // Like list.count
 extern PyObject *LIST_COUNT(PyObject *list, PyObject *item);
 
 // Like list.index
 extern PyObject *LIST_INDEX2(PyThreadState *tstate, PyObject *list, PyObject *item);
 extern PyObject *LIST_INDEX3(PyThreadState *tstate, PyObject *list, PyObject *item, PyObject *start);
@@ -56,16 +56,16 @@
 // Like PyList_Insert
 extern void LIST_INSERT_CONST(PyObject *list, Py_ssize_t index, PyObject *item);
 
 extern PyObject *MAKE_LIST(PyThreadState *tstate, PyObject *iterable);
 
 extern bool LIST_EXTEND_FROM_LIST(PyObject *list, PyObject *other);
 
-NUITKA_MAY_BE_UNUSED static PyObject *MAKE_LIST_REPEATED(Py_ssize_t size, PyObject *element) {
-    PyObject *result = MAKE_LIST_EMPTY(size);
+NUITKA_MAY_BE_UNUSED static PyObject *MAKE_LIST_REPEATED(PyThreadState *tstate, Py_ssize_t size, PyObject *element) {
+    PyObject *result = MAKE_LIST_EMPTY(tstate, size);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     for (Py_ssize_t i = 0; i < size; i++) {
         Py_INCREF(element);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/lists_generated.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/rangeobjects.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,28 +1,58 @@
 //     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
-/* WARNING, this code is GENERATED. Modify the template CodeTemplateMakeListSmall.c.j2 instead! */
+#ifndef __NUITKA_HELPER_RANGEOBJECTS_H__
+#define __NUITKA_HELPER_RANGEOBJECTS_H__
+
+/* For built-in built-in range() functionality. */
+
+extern PyObject *BUILTIN_RANGE3(PyThreadState *tstate, PyObject *low, PyObject *high, PyObject *step);
+extern PyObject *BUILTIN_RANGE2(PyThreadState *tstate, PyObject *low, PyObject *high);
+extern PyObject *BUILTIN_RANGE(PyThreadState *tstate, PyObject *boundary);
+
+/* For built-in built-in xrange() functionality. */
+extern PyObject *BUILTIN_XRANGE1(PyThreadState *tstate, PyObject *high);
+extern PyObject *BUILTIN_XRANGE2(PyThreadState *tstate, PyObject *low, PyObject *high);
+extern PyObject *BUILTIN_XRANGE3(PyThreadState *tstate, PyObject *low, PyObject *high, PyObject *step);
+
+#if PYTHON_VERSION >= 0x300
+
+/* Python3 range objects */
+struct _rangeobject3 {
+    /* Python object folklore: */
+    PyObject_HEAD
+
+        PyObject *start;
+    PyObject *stop;
+    PyObject *step;
+    PyObject *length;
+};
+
+NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Start(PyObject *range) { return ((struct _rangeobject3 *)range)->start; }
+
+NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Stop(PyObject *range) { return ((struct _rangeobject3 *)range)->stop; }
+
+NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Step(PyObject *range) { return ((struct _rangeobject3 *)range)->step; }
+
+#else
+
+struct _rangeobject2 {
+    /* Python object folklore: */
+    PyObject_HEAD
+
+        long start;
+    long step;
+    long len;
+};
+
+extern PyObject *MAKE_XRANGE(PyThreadState *tstate, long start, long stop, long step);
 
-/* This file is included from another C file, help IDEs to still parse it on its own. */
-#ifdef __IDE_ONLY__
-#include "nuitka/prelude.h"
 #endif
 
-extern PyObject *MAKE_LIST1(PyObject *arg0);
-extern PyObject *MAKE_LIST2(PyObject *arg0, PyObject *arg1);
-extern PyObject *MAKE_LIST3(PyObject *arg0, PyObject *arg1, PyObject *arg2);
-extern PyObject *MAKE_LIST4(PyObject *list);
-extern PyObject *MAKE_LIST5(PyObject *list);
-extern PyObject *MAKE_LIST6(PyObject *list);
-extern PyObject *MAKE_LIST7(PyObject *list);
-extern PyObject *MAKE_LIST8(PyObject *list);
-extern PyObject *MAKE_LIST9(PyObject *list);
-extern PyObject *MAKE_LIST10(PyObject *list);
-extern PyObject *MAKE_LIST11(PyObject *list);
-extern PyObject *MAKE_LIST12(PyObject *list);
+#endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/mappings.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/mappings.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_add.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_add.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitand.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitand.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitor.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitor.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_bitxor.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_bitxor.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_divmod.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_divmod.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_floordiv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_floordiv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_lshift.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_lshift.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_matmult.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_matmult.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_mod.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_mod.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_mult.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_mult.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_olddiv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_olddiv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_pow.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_pow.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_rshift.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_rshift.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_sub.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_sub.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_binary_truediv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_binary_truediv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_builtin_types.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_builtin_types.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_add.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_add.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitand.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitand.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitor.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitor.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitxor.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_bitxor.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_floordiv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_floordiv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_lshift.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_lshift.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_matmult.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_matmult.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_mod.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_mod.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_mult.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_mult.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_olddiv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_olddiv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_pow.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_pow.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_rshift.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_rshift.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_sub.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_sub.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/operations_inplace_truediv.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/operations_inplace_truediv.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/raising.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/raising.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/rangeobjects.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/strings.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,59 +1,23 @@
 //     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
-#ifndef __NUITKA_HELPER_RANGEOBJECTS_H__
-#define __NUITKA_HELPER_RANGEOBJECTS_H__
+#ifndef __NUITKA_STRINGS_H__
+#define __NUITKA_STRINGS_H__
 
-/* For built-in built-in range() functionality. */
-
-extern PyObject *BUILTIN_RANGE3(PyThreadState *tstate, PyObject *low, PyObject *high, PyObject *step);
-extern PyObject *BUILTIN_RANGE2(PyThreadState *tstate, PyObject *low, PyObject *high);
-extern PyObject *BUILTIN_RANGE(PyThreadState *tstate, PyObject *boundary);
-
-/* For built-in built-in xrange() functionality. */
-extern PyObject *BUILTIN_XRANGE1(PyThreadState *tstate, PyObject *high);
-extern PyObject *BUILTIN_XRANGE2(PyThreadState *tstate, PyObject *low, PyObject *high);
-extern PyObject *BUILTIN_XRANGE3(PyThreadState *tstate, PyObject *low, PyObject *high, PyObject *step);
-
-#if PYTHON_VERSION >= 0x300
-
-/* Python3 range objects */
-struct _rangeobject3 {
-    /* Python object folklore: */
-    PyObject_HEAD
-
-        PyObject *start;
-    PyObject *stop;
-    PyObject *step;
-    PyObject *length;
-};
-
-NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Start(PyObject *range) { return ((struct _rangeobject3 *)range)->start; }
-
-NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Stop(PyObject *range) { return ((struct _rangeobject3 *)range)->stop; }
-
-NUITKA_MAY_BE_UNUSED static PyObject *PyRange_Step(PyObject *range) { return ((struct _rangeobject3 *)range)->step; }
-
-#else
-
-struct _rangeobject2 {
-    /* Python object folklore: */
-    PyObject_HEAD
-
-        long start;
-    long step;
-    long len;
-};
+#if PYTHON_VERSION < 0x300
+extern PyObject *STR_JOIN(PyThreadState *tstate, PyObject *str, PyObject *iterable);
+#endif
 
-extern PyObject *MAKE_XRANGE(PyThreadState *tstate, long start, long stop, long step);
+extern PyObject *UNICODE_JOIN(PyThreadState *tstate, PyObject *str, PyObject *iterable);
+extern PyObject *UNICODE_PARTITION(PyThreadState *tstate, PyObject *str, PyObject *sep);
+extern PyObject *UNICODE_RPARTITION(PyThreadState *tstate, PyObject *str, PyObject *sep);
 
-#endif
+extern PyObject *NuitkaUnicode_FromWideChar(wchar_t const *str, Py_ssize_t size);
 
 #endif
-
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
 //
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/richcomparisons.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/richcomparisons.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/sequences.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/sequences.h`

 * *Files 10% similar despite different names*

```diff
@@ -5,14 +5,20 @@
 
 // TODO: Provide enhanced form of PySequence_Contains with less overhead as well.
 
 extern bool SEQUENCE_SET_ITEM(PyObject *sequence, Py_ssize_t index, PyObject *value);
 
 extern Py_ssize_t Nuitka_PyObject_Size(PyObject *sequence);
 
+// Our version of "_PyObject_HasLen", a former API function.
+NUITKA_MAY_BE_UNUSED static int Nuitka_PyObject_HasLen(PyObject *o) {
+    return (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_length) ||
+           (Py_TYPE(o)->tp_as_mapping && Py_TYPE(o)->tp_as_mapping->mp_length);
+}
+
 #endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/sets.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/sets.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/slices.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/slices.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,36 +1,42 @@
 //     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 #ifndef __NUITKA_HELPER_SLICES_H__
 #define __NUITKA_HELPER_SLICES_H__
 
+/* This file is included from another C file, help IDEs to still parse it on its own. */
+#ifdef __IDE_ONLY__
+#include "nuitka/prelude.h"
+#endif
+
 #if PYTHON_VERSION >= 0x3a0
-extern PyObject *Nuitka_Slice_New(PyObject *start, PyObject *stop, PyObject *step);
+extern PyObject *Nuitka_Slice_New(PyThreadState *tstate, PyObject *start, PyObject *stop, PyObject *step);
 #else
-#define Nuitka_Slice_New PySlice_New
+#define Nuitka_Slice_New(tstate, start, stop, step) PySlice_New(start, stop, step)
 #endif
 
 // Note: Cannot these cannot fail, PySlice_New does not return errors.
-NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT3(PyObject *start, PyObject *stop, PyObject *step) {
+NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT3(PyThreadState *tstate, PyObject *start, PyObject *stop,
+                                                         PyObject *step) {
     CHECK_OBJECT(start);
     CHECK_OBJECT(stop);
     CHECK_OBJECT(step);
 
-    return Nuitka_Slice_New(start, stop, step);
+    return Nuitka_Slice_New(tstate, start, stop, step);
 }
-NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT2(PyObject *start, PyObject *stop) {
+NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT2(PyThreadState *tstate, PyObject *start, PyObject *stop) {
     CHECK_OBJECT(start);
     CHECK_OBJECT(stop);
 
-    return Nuitka_Slice_New(start, stop, Py_None);
+    return Nuitka_Slice_New(tstate, start, stop, Py_None);
 }
-NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT1(PyObject *stop) {
+NUITKA_MAY_BE_UNUSED static PyObject *MAKE_SLICE_OBJECT1(PyThreadState *tstate, PyObject *stop) {
     CHECK_OBJECT(stop);
 
-    return Nuitka_Slice_New(Py_None, stop, Py_None);
+    return Nuitka_Slice_New(tstate, Py_None, stop, Py_None);
 }
 
 #if PYTHON_VERSION < 0x300
 // Note: It appears that Python3 has no index slicing operations anymore, but
 // uses slice objects all the time. That's fine and make sure we adhere to it by
 // guarding the presence of the helpers.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/strings.h` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersJitSources.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,21 +1,37 @@
 //     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
-#ifndef __NUITKA_STRINGS_H__
-#define __NUITKA_STRINGS_H__
-
-#if PYTHON_VERSION < 0x300
-extern PyObject *STR_JOIN(PyThreadState *tstate, PyObject *str, PyObject *iterable);
+// This file is included from another C file, help IDEs to still parse it on
+// its own.
+#ifdef __IDE_ONLY__
+#include "nuitka/prelude.h"
 #endif
 
-extern PyObject *UNICODE_JOIN(PyThreadState *tstate, PyObject *str, PyObject *iterable);
-extern PyObject *UNICODE_PARTITION(PyThreadState *tstate, PyObject *str, PyObject *sep);
-extern PyObject *UNICODE_RPARTITION(PyThreadState *tstate, PyObject *str, PyObject *sep);
+#ifdef _NUITKA_STANDALONE
+
+static char const *uncompiled_sources_dict_attribute_name = "_uncompiled_function_sources_dict";
+
+void SET_UNCOMPILED_FUNCTION_SOURCE_DICT(PyObject *name, PyObject *source) {
+    PyObject *uncompiled_function_sources_dict =
+        PyObject_GetAttrString((PyObject *)builtin_module, uncompiled_sources_dict_attribute_name);
+
+    if (uncompiled_function_sources_dict == NULL) {
+        PyThreadState *tstate = PyThreadState_GET();
+
+        DROP_ERROR_OCCURRED(tstate);
+
+        uncompiled_function_sources_dict = MAKE_DICT_EMPTY(tstate);
+
+        PyObject_SetAttrString((PyObject *)builtin_module, uncompiled_sources_dict_attribute_name,
+                               uncompiled_function_sources_dict);
+    }
 
-extern PyObject *NuitkaUnicode_FromWideChar(wchar_t const *str, Py_ssize_t size);
+    bool res = DICT_SET_ITEM(uncompiled_function_sources_dict, name, source);
+    assert(res == false);
+}
 
 #endif
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helper/subscripts.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helper/subscripts.h`

 * *Files 16% similar despite different names*

```diff
@@ -234,198 +234,15 @@
 #endif
 
     formatNotSubscriptableError(source);
     return NULL;
 #endif
 }
 
-NUITKA_MAY_BE_UNUSED static bool HAS_SUBSCRIPT_CONST(PyThreadState *tstate, PyObject *source, PyObject *const_subscript,
-                                                     Py_ssize_t int_subscript) {
-    CHECK_OBJECT(source);
-    CHECK_OBJECT(const_subscript);
-
-#if _NUITKA_EXPERIMENTAL_DISABLE_SUBSCRIPT_OPT
-    PyObject *item = PyObject_GetItem(source, const_subscript);
-
-    if (item) {
-        Py_DECREF(item);
-        return true;
-    } else {
-        return false;
-    }
-#else
-    PyTypeObject *type = Py_TYPE(source);
-    PyMappingMethods *tp_as_mapping = type->tp_as_mapping;
-
-    if (tp_as_mapping && tp_as_mapping->mp_subscript) {
-        if (PyList_CheckExact(source)) {
-            Py_ssize_t list_size = PyList_GET_SIZE(source);
-
-            if (int_subscript < 0) {
-                if (-int_subscript > list_size) {
-                    return false;
-                }
-
-                int_subscript += list_size;
-            } else {
-                if (int_subscript >= list_size) {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-#if PYTHON_VERSION < 0x300
-        else if (PyString_CheckExact(source)) {
-            Py_ssize_t string_size = PyString_GET_SIZE(source);
-
-            if (int_subscript < 0) {
-                if (-int_subscript > string_size) {
-                    return false;
-                }
-
-                int_subscript += string_size;
-            } else {
-                if (int_subscript >= string_size) {
-                    return false;
-                }
-            }
-
-            return true;
-        }
-#else
-        else if (PyUnicode_CheckExact(source)) {
-            if (int_subscript < 0) {
-                int_subscript += PyUnicode_GET_LENGTH(source);
-            }
-
-            PyObject *result = type->tp_as_sequence->sq_item(source, int_subscript);
-
-            bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-            Py_XDECREF(result);
-            return bool_result;
-        }
-#endif
-        else {
-            PyObject *result = tp_as_mapping->mp_subscript(source, const_subscript);
-
-            bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-            Py_XDECREF(result);
-
-            return bool_result;
-        }
-    } else if (type->tp_as_sequence) {
-        PyObject *result = SEQUENCE_GET_ITEM_CONST(source, int_subscript);
-
-        bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-        Py_XDECREF(result);
-        return bool_result;
-    } else {
-#if PYTHON_VERSION >= 0x370
-        if (PyType_Check(source)) {
-#if PYTHON_VERSION >= 0x390
-            if (source == (PyObject *)&PyType_Type) {
-                return true;
-            }
-#endif
-
-            PyObject *meth = LOOKUP_ATTRIBUTE(tstate, source, const_str_plain___class_getitem__);
-
-            if (meth) {
-                PyObject *subscript = PyLong_FromSsize_t(int_subscript);
-                PyObject *result = CALL_FUNCTION_WITH_SINGLE_ARG(tstate, meth, subscript);
-                Py_DECREF(meth);
-                Py_DECREF(subscript);
-
-                bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-                Py_XDECREF(result);
-                return bool_result;
-            }
-        }
-#endif
-
-        return false;
-    }
-
-    return false;
-
-#endif
-}
-
-NUITKA_MAY_BE_UNUSED static bool HAS_SUBSCRIPT(PyThreadState *tstate, PyObject *source, PyObject *subscript) {
-    CHECK_OBJECT(source);
-    CHECK_OBJECT(subscript);
-
-#if _NUITKA_EXPERIMENTAL_DISABLE_SUBSCRIPT_OPT
-    PyObject *item = PyObject_GetItem(source, subscript);
-
-    if (item) {
-        Py_DECREF(item);
-        return true;
-    } else {
-        return false;
-    }
-#else
-    PyTypeObject *type = Py_TYPE(source);
-    PyMappingMethods *tp_as_mapping = type->tp_as_mapping;
-
-    if (tp_as_mapping != NULL && tp_as_mapping->mp_subscript != NULL) {
-        PyObject *result = tp_as_mapping->mp_subscript(source, subscript);
-        bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-        Py_XDECREF(result);
-        return bool_result;
-    } else if (type->tp_as_sequence != NULL) {
-        if (Nuitka_Index_Check(subscript)) {
-            Py_ssize_t index = PyNumber_AsSsize_t(subscript, NULL);
-
-            if (index == -1 && HAS_ERROR_OCCURRED(tstate)) {
-                return false;
-            }
-
-            PyObject *result = SEQUENCE_GET_ITEM_CONST(source, index);
-            bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-            Py_XDECREF(result);
-            return bool_result;
-        } else if (type->tp_as_sequence->sq_item) {
-            return false;
-#if PYTHON_VERSION < 0x370
-        } else {
-            return false;
-#endif
-        }
-    }
-
-#if PYTHON_VERSION >= 0x370
-    if (PyType_Check(source)) {
-#if PYTHON_VERSION >= 0x390
-        if (source == (PyObject *)&PyType_Type) {
-            return true;
-        }
-#endif
-        PyObject *meth = LOOKUP_ATTRIBUTE(tstate, source, const_str_plain___class_getitem__);
-
-        if (meth) {
-            PyObject *result = CALL_FUNCTION_WITH_SINGLE_ARG(tstate, meth, subscript);
-            bool bool_result = !DROP_ERROR_OCCURRED(tstate);
-
-            Py_XDECREF(result);
-            return bool_result;
-        }
-    }
-#endif
-
-    return false;
-#endif
-}
+int MATCH_MAPPING_KEY(PyThreadState *tstate, PyObject *map, PyObject *key);
 
 NUITKA_MAY_BE_UNUSED static bool SET_SUBSCRIPT_CONST(PyThreadState *tstate, PyObject *target, PyObject *subscript,
                                                      Py_ssize_t int_subscript, PyObject *value) {
     CHECK_OBJECT(value);
     CHECK_OBJECT(target);
     CHECK_OBJECT(subscript);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/helpers.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/helpers.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/importing.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/importing.h`

 * *Files 2% similar despite different names*

```diff
@@ -51,14 +51,19 @@
 #elif PYTHON_VERSION < 0x3c0
     return _PyInterpreterState_GET()->modules;
 #else
     return _PyInterpreterState_GET()->imports.modules;
 #endif
 }
 
+// Check if a module is in "sys.modules"
+NUITKA_MAY_BE_UNUSED static bool Nuitka_HasModule(PyThreadState *tstate, PyObject *module_name) {
+    return DICT_HAS_ITEM(tstate, Nuitka_GetSysModules(), module_name) == 1;
+}
+
 // Replacement for "PyImport_GetModule" working across all versions and less checks.
 NUITKA_MAY_BE_UNUSED static PyObject *Nuitka_GetModule(PyThreadState *tstate, PyObject *module_name) {
     return DICT_GET_ITEM1(tstate, Nuitka_GetSysModules(), module_name);
 }
 
 // Replacement for PyImport_GetModule working across all versions and less checks.
 NUITKA_MAY_BE_UNUSED static PyObject *Nuitka_GetModuleString(PyThreadState *tstate, char const *module_name) {
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/incbin.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/incbin.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/jit_sources.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/jit_sources.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/prelude.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/prelude.h`

 * *Files 3% similar despite different names*

```diff
@@ -144,15 +144,19 @@
 #include <internal/pycore_dict.h>
 #include <internal/pycore_frame.h>
 #include <internal/pycore_gc.h>
 #endif
 
 // Uncompiled generator integration requires these.
 #if PYTHON_VERSION >= 0x3b0
+#if PYTHON_VERSION >= 0x3d0
+#include <opcode_ids.h>
+#else
 #include <internal/pycore_opcode.h>
+#endif
 // Clashes with our helper names.
 #undef CALL_FUNCTION
 #endif
 
 #if PYTHON_VERSION >= 0x3c0
 #include <cpython/code.h>
 #endif
@@ -166,14 +170,21 @@
 #if PYTHON_VERSION >= 0x380
 #undef _PyObject_LookupSpecial
 #include <internal/pycore_object.h>
 #else
 #include <objimpl.h>
 #endif
 
+#if PYTHON_VERSION >= 0x3d0
+#include <internal/pycore_freelist.h>
+#include <internal/pycore_intrinsics.h>
+#include <internal/pycore_modsupport.h>
+#include <internal/pycore_setobject.h>
+#endif
+
 #undef Py_BUILD_CORE
 
 #endif
 
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
@@ -268,16 +279,23 @@
 #define Nuitka_String_AsString _PyUnicode_AsString
 
 /* Note: This is from unicodeobject.c */
 #define _PyUnicode_UTF8(op) (((PyCompactUnicodeObject *)(op))->utf8)
 #define PyUnicode_UTF8(op)                                                                                             \
     (assert(PyUnicode_IS_READY(op)),                                                                                   \
      PyUnicode_IS_COMPACT_ASCII(op) ? ((char *)((PyASCIIObject *)(op) + 1)) : _PyUnicode_UTF8(op))
+#ifdef __NUITKA_NO_ASSERT__
 #define Nuitka_String_AsString_Unchecked PyUnicode_UTF8
-
+#else
+NUITKA_MAY_BE_UNUSED static char const *Nuitka_String_AsString_Unchecked(PyObject *object) {
+    char const *result = PyUnicode_UTF8(object);
+    assert(result != NULL);
+    return result;
+}
+#endif
 #define Nuitka_String_Check PyUnicode_Check
 #define Nuitka_String_CheckExact PyUnicode_CheckExact
 #define Nuitka_StringOrUnicode_CheckExact PyUnicode_CheckExact
 #define Nuitka_StringObject PyUnicodeObject
 #define Nuitka_String_FromString PyUnicode_FromString
 #define Nuitka_String_FromStringAndSize PyUnicode_FromStringAndSize
 #define Nuitka_String_FromFormat PyUnicode_FromFormat
@@ -408,14 +426,29 @@
 #define Py_SET_SIZE(op, size) ((PyVarObject *)(op))->ob_size = size
 #endif
 
 #ifndef PyFloat_SET_DOUBLE
 #define PyFloat_SET_DOUBLE(op, value) ((PyFloatObject *)(op))->ob_fval = value
 #endif
 
+#ifndef Py_NewRef
+static inline PyObject *_Py_NewRef(PyObject *obj) {
+    Py_INCREF(obj);
+    return obj;
+}
+
+static inline PyObject *_Py_XNewRef(PyObject *obj) {
+    Py_XINCREF(obj);
+    return obj;
+}
+
+#define Py_NewRef(obj) _Py_NewRef((PyObject *)(obj))
+#define Py_XNewRef(obj) _Py_XNewRef((PyObject *)(obj))
+#endif
+
 // For older Python, we don't have a feature "CLASS" anymore, that's implied now.
 #if PYTHON_VERSION < 0x300
 #define NuitkaType_HasFeatureClass(descr) (PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS))
 #else
 #define NuitkaType_HasFeatureClass(descr) (1)
 #endif
 
@@ -448,15 +481,15 @@
 #include "nuitka/compiled_frame.h"
 
 #include "nuitka/compiled_cell.h"
 
 #include "nuitka/compiled_function.h"
 
 /* Sentinel PyObject to be used for all our call iterator endings. */
-extern PyObject *_sentinel_value;
+extern PyObject *Nuitka_sentinel_value;
 
 /* Value to use for __compiled__ value of all modules. */
 extern PyObject *Nuitka_dunder_compiled_value;
 
 #include "nuitka/compiled_generator.h"
 
 #include "nuitka/compiled_method.h"
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/printing.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/printing.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/python_pgo.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/python_pgo.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/safe_string_ops.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/safe_string_ops.h`

 * *Files 4% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 
 /* Safe to use function to append a string, will abort program for overflow. */
 extern void appendCharSafe(char *target, char c, size_t buffer_size);
 extern void appendStringSafe(char *target, char const *source, size_t buffer_size);
 
 /* Safe to use functions to append a wide char string, will abort program for overflow. */
 extern void appendCharSafeW(wchar_t *target, char c, size_t buffer_size);
+extern void appendWCharSafeW(wchar_t *target, wchar_t c, size_t buffer_size);
 extern void appendStringSafeW(wchar_t *target, char const *source, size_t buffer_size);
 extern void appendWStringSafeW(wchar_t *target, wchar_t const *source, size_t buffer_size);
 
 /* Get OS error code and print it to stderr. */
 #ifdef _WIN32
 typedef DWORD error_code_t;
 #define ERROR_CODE_FORMAT_STR "%ld"
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/threading.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/threading.h`

 * *Files 6% similar despite different names*

```diff
@@ -10,50 +10,52 @@
 extern volatile int _Py_Ticker;
 #define _Py_CheckInterval 20
 #endif
 
 #ifdef NUITKA_USE_PYCORE_THREAD_STATE
 
 #if PYTHON_VERSION < 0x380
+
 // Signals pending got their own indicator only in 3.8, covered by calls to do before.
 #define HAS_WORK_TO_DO(ceval, ceval2) (ceval2->pending.calls_to_do._value)
-#else
+#elif PYTHON_VERSION < 0x3d0
 #define HAS_WORK_TO_DO(ceval, ceval2) (ceval->signals_pending._value || ceval2->pending.calls_to_do._value)
+#else
+#define HAS_WORK_TO_DO(ceval, ceval2) _Py_eval_breaker_bit_is_set(tstate, _PY_SIGNALS_PENDING_BIT | _PY_CALLS_TO_DO_BIT)
 #endif
 
+#ifndef Py_GIL_DISABLED
 NUITKA_MAY_BE_UNUSED static inline bool CONSIDER_THREADING(PyThreadState *tstate) {
-#if PYTHON_VERSION >= 0x390
-    _PyRuntimeState *const runtime = tstate->interp->runtime;
-#else
+#if PYTHON_VERSION < 0x390
     _PyRuntimeState *const runtime = &_PyRuntime;
+#else
+    _PyRuntimeState *const runtime = tstate->interp->runtime;
 #endif
 
+#if PYTHON_VERSION < 0x3d0
     // This was split in 2 parts in 3.9 or higher.
     struct _ceval_runtime_state *ceval = &runtime->ceval;
 #if PYTHON_VERSION >= 0x390
     struct _ceval_state *ceval2 = &tstate->interp->ceval;
 #else
     struct _ceval_runtime_state *ceval2 = ceval;
 #endif
-
+#endif
     // Pending signals or calls to do
     if (HAS_WORK_TO_DO(ceval, ceval2)) {
         int res = Py_MakePendingCalls();
 
         if (unlikely(res < 0 && HAS_ERROR_OCCURRED(tstate))) {
             return false;
         }
     }
 
-#ifdef PY_NOGIL
-    /* load eval breaker */
-    uintptr_t b = _Py_atomic_load_uintptr(&tstate->eval_breaker);
-
+#if PYTHON_VERSION >= 0x3d0
     /* GIL drop request */
-    if ((b & EVAL_PENDING_SIGNALS) != 0) {
+    if (_Py_eval_breaker_bit_is_set(tstate, _PY_GIL_DROP_REQUEST_BIT)) {
 #else
     /* GIL drop request */
     if (ceval2->gil_drop_request._value) {
 #endif
         /* Give another thread a chance */
         PyEval_SaveThread();
         PyEval_AcquireThread(tstate);
@@ -66,14 +68,15 @@
         SET_CURRENT_EXCEPTION_TYPE0(tstate, async_exc);
 
         return false;
     }
 
     return true;
 }
+#endif
 
 #else
 
 NUITKA_MAY_BE_UNUSED static inline bool CONSIDER_THREADING(PyThreadState *tstate) {
     // Decrease ticker
     if (--_Py_Ticker < 0) {
         _Py_Ticker = _Py_CheckInterval;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/tracing.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/tracing.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/type_aliases.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/type_aliases.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/include/nuitka/unfreezing.h` & `nuitka_winsvc-2.3/nuitka/build/include/nuitka/unfreezing.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/appdirs/LICENSE.txt` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/appdirs/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/appdirs/appdirs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/appdirs/appdirs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/atomicwrites/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/atomicwrites/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/atomicwrites/atomicwrites.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/atomicwrites/atomicwrites.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/bin/scons.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/bin/scons.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/clcache/clcache/caching.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/clcache/clcache/caching.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/LICENSE.txt` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/ansi.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/ansi.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/ansitowin32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/ansitowin32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/initialise.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/initialise.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/win32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/win32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/colorama/colorama/winterm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/colorama/colorama/winterm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/compat.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/compat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/fnmatch.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/fnmatch.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/glob2/glob2/impl.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/glob2/glob2/impl.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/LICENSE.rst` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/LICENSE.rst`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/_compat.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/_compat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/_identifier.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/_identifier.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/bccache.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/bccache.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/compiler.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/compiler.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/constants.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/constants.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/debug.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/debug.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/defaults.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/defaults.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/environment.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/environment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/exceptions.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/exceptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/ext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/ext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/filters.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/filters.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/idtracking.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/idtracking.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/lexer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/lexer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/loaders.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/loaders.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/meta.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/meta.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/nativetypes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/nativetypes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/nodes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/nodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/optimizer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/optimizer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/parser.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/parser.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/runtime.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/runtime.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/sandbox.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/sandbox.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/tests.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/tests.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/utils.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/utils.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2/jinja2/visitor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2/jinja2/visitor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/LICENSE.rst` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/LICENSE.rst`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_compat.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_compat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_identifier.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/_identifier.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/bccache.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/bccache.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/compiler.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/compiler.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/constants.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/constants.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/debug.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/debug.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/defaults.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/defaults.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/environment.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/environment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/exceptions.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/exceptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/ext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/ext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/filters.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/filters.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/idtracking.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/idtracking.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/lexer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/lexer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/loaders.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/loaders.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/meta.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/meta.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nativetypes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nativetypes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nodes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/nodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/optimizer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/optimizer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/parser.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/parser.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/runtime.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/runtime.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/sandbox.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/sandbox.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/tests.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/tests.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/utils.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/utils.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/jinja2_35/jinja2/visitor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/jinja2_35/jinja2/visitor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Action.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Action.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Builder.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Builder.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/CacheDir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/CacheDir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Conftest.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Conftest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Debug.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Debug.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Defaults.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Defaults.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Environment.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Environment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Errors.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Errors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Executor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Executor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Job.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Job.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Memoize.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Memoize.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Alias.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Alias.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/FS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/FS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Python.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/Python.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Node/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/BoolOption.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/BoolOption.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/EnumOption.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/EnumOption.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/ListOption.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/ListOption.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PackageOption.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PackageOption.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PathOption.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/PathOption.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Options/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/PathList.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/PathList.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/aix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/aix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/cygwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/cygwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/darwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/darwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/hpux.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/hpux.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/irix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/irix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/os2.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/os2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/posix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/posix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/sunos.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/sunos.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/win32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Platform/win32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConf.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConf.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConsign.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/SConsign.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/C.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/C.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Dir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Dir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Prog.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/Prog.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/RC.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/RC.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Scanner/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Interactive.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Interactive.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Main.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConsOptions.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConsOptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConscript.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/SConscript.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Script/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Sig.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Sig.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Subst.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Subst.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Taskmaster.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Taskmaster.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/386asm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/386asm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/BitKeeper.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/BitKeeper.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/CVS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/CVS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/GettextCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/GettextCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/arch.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/arch.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/common.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/common.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/netframework.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/netframework.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/sdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/sdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/MSCommon/vs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Perforce.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Perforce.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/PharLapCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/PharLapCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/RCS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/RCS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/SCCS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/SCCS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Subversion.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/Subversion.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixf77.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixf77.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/aixlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/applelink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/applelink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/as.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/as.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/bcc32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/bcc32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/c++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/c++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cyglink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/cyglink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/default.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/default.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/docbook/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/filesystem.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/filesystem.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g77.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/g77.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gas.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gas.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gdc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gdc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gettext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gettext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gfortran.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gfortran.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gnulink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/gnulink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hpcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hplink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/hplink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icl.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/icl.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/ilink32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/install.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/install.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/intelc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/intelc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/lex.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/lex.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/link.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/link.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/linkloc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/linkloc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/m4.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/m4.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/masm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/masm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mingw.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mingw.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgfmt.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgfmt.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msginit.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msginit.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgmerge.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msgmerge.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mslink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mssdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mssdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/msvs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwld.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/mwld.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/nasm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/nasm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rmic.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rmic.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rpcgen.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/rpcgen.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgiar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgiar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgic++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgic++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgicc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgicc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sgilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/suncc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/suncc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/sunlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/textfile.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/textfile.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tlib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/tlib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/wix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/wix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/xgettext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/xgettext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/zip.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Tool/zip.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Util.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Util.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/BoolVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/BoolVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/EnumVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/EnumVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/ListVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/ListVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PackageVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PackageVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PathVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/PathVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Variables/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Warnings.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/Warnings.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_builtins.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_builtins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_collections.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_collections.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_dbm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_dbm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_hashlib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_hashlib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_io.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_io.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_sets.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_sets.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_subprocess.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/compat/_scons_subprocess.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/cpp.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/cpp.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/dblite.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/dblite.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/exitfuncs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-2.3.2/SCons/exitfuncs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Action.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Action.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Builder.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Builder.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/CacheDir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/CacheDir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Conftest.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Conftest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Debug.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Debug.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Defaults.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Defaults.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Environment.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Environment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Errors.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Errors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Executor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Executor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Job.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Job.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Memoize.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Memoize.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Alias.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Alias.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/FS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/FS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Python.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/Python.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Node/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/PathList.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/PathList.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/aix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/aix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/cygwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/cygwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/darwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/darwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/hpux.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/hpux.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/irix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/irix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/mingw.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/mingw.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/os2.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/os2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/posix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/posix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/sunos.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/sunos.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/virtualenv.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/virtualenv.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/win32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Platform/win32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConf.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConf.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConsign.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/SConsign.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/C.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/C.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Dir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Dir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Prog.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/Prog.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/RC.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/RC.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Scanner/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Interactive.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Interactive.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Main.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConsOptions.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConsOptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConscript.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/SConscript.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Script/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Subst.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Subst.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Taskmaster.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Taskmaster.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/386asm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/386asm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/GettextCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/GettextCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/arch.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/arch.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/common.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/common.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/netframework.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/netframework.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/sdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/sdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/MSCommon/vs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/PharLapCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/PharLapCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixcxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/aixlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/applelink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/applelink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/as.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/as.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/bcc32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/bcc32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/c++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/c++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clang.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clang.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/clangxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cyglink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/cyglink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/default.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/default.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/docbook/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/filesystem.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/filesystem.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/g++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/g++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gas.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gas.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gettext_tool.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gettext_tool.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gnulink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gnulink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/gxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hpcxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hplink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/hplink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icl.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/icl.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/ilink32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/install.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/install.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/intelc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/intelc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/link.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/link.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/linkloc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/linkloc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/m4.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/m4.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/masm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/masm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mingw.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mingw.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgfmt.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgfmt.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msginit.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msginit.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgmerge.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msgmerge.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mslink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mssdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mssdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/msvs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwld.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/mwld.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/nasm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/nasm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rmic.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rmic.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rpcgen.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/rpcgen.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgiar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgiar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgic++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgic++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgicxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sgilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/suncxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/sunlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/textfile.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/textfile.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tlib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/tlib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/wix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/wix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/xgettext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/xgettext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/zip.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Tool/zip.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Util.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Util.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/BoolVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/BoolVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/EnumVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/EnumVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/ListVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/ListVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PackageVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PackageVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PathVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/PathVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Variables/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Warnings.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/Warnings.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/_scons_dbm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/compat/_scons_dbm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/cpp.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/cpp.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/dblite.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/dblite.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/exitfuncs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-3.1.2/SCons/exitfuncs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Action.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Action.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Builder.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Builder.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/CacheDir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/CacheDir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Conftest.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Conftest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Debug.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Debug.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Defaults.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Defaults.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Environment.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Environment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/EnvironmentValues.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/EnvironmentValues.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Errors.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Errors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Executor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Executor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Job.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Job.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Memoize.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Memoize.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Alias.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Alias.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/FS.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/FS.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Python.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/Python.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Node/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/PathList.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/PathList.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/aix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/aix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/cygwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/cygwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/darwin.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/darwin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/hpux.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/hpux.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/irix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/irix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/mingw.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/mingw.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/os2.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/os2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/posix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/posix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/sunos.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/sunos.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/virtualenv.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/virtualenv.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/win32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Platform/win32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConf.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConf.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConsign.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/SConsign.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/C.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/C.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Dir.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Dir.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Prog.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/Prog.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/RC.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/RC.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Scanner/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Interactive.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Interactive.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Main.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConsOptions.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConsOptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConscript.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/SConscript.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Script/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Subst.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Subst.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Taskmaster.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Taskmaster.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/386asm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/386asm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/GettextCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/GettextCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/arch.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/arch.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/common.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/common.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/netframework.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/netframework.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/sdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/sdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/MSCommon/vs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/PharLapCommon.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/PharLapCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixcxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/aixlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/applelink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/applelink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/as.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/as.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/asm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/asm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/bcc32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/bcc32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/c++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/c++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clang.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clang.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/clangxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cyglink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/cyglink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/default.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/default.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/filesystem.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/filesystem.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/g++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/g++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gas.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gas.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gettext_tool.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gettext_tool.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gnulink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gnulink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/gxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hpcxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hplink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/hplink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icl.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/icl.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/ilink32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/install.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/install.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/intelc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/intelc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/link.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/link.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/LoadableModule.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/LoadableModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/SharedLibrary.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/SharedLibrary.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkCommon/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkloc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/linkloc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/m4.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/m4.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/masm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/masm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mingw.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mingw.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgfmt.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgfmt.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msginit.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msginit.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgmerge.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msgmerge.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mslink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mssdk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mssdk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/msvs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwcc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwcc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwld.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/mwld.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/nasm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/nasm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rmic.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rmic.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rpcgen.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/rpcgen.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgiar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgiar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgic++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgic++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgicxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgilink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sgilink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunc++.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunc++.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncc.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncc.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncxx.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/suncxx.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunlink.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/sunlink.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tar.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/textfile.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/textfile.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tlib.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/tlib.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/wix.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/wix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/xgettext.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/xgettext.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/zip.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Tool/zip.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Util.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Util.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/ConfigureCache.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/ConfigureCache.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/sconsign.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Utilities/sconsign.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/BoolVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/BoolVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/EnumVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/EnumVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/ListVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/ListVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PackageVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PackageVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PathVariable.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/PathVariable.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Variables/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Warnings.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/Warnings.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/_scons_dbm.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/_scons_dbm.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/win32.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/compat/win32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/cpp.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/cpp.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/dblite.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/dblite.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/exitfuncs.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/lib/scons-4.3.0/SCons/exitfuncs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/LICENSE.rst` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/LICENSE.rst`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_compat.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_compat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_constants.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_constants.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_native.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/markupsafe/markupsafe/_native.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/py31compat.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/pkg_resources/pkg_resources/py31compat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_monitor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_monitor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_pandas.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_tqdm_pandas.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/_utils.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/_utils.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/auto.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/auto.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/autonotebook.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/autonotebook.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/dask.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/dask.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/notebook.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/notebook.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/std.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/std.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/tk.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/tk.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/tqdm/tqdm/utils.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/tqdm/tqdm/utils.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/composer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/composer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/constructor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/constructor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/cyaml.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/cyaml.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/dumper.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/dumper.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/emitter.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/emitter.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/error.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/error.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/events.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/events.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/loader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/loader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/nodes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/nodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/parser.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/parser.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/reader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/reader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/representer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/representer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/resolver.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/resolver.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/scanner.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/scanner.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/serializer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/serializer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml/yaml/tokens.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml/yaml/tokens.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/composer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/composer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/constructor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/constructor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/cyaml.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/cyaml.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/dumper.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/dumper.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/emitter.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/emitter.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/error.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/error.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/events.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/events.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/loader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/loader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/nodes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/nodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/parser.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/parser.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/reader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/reader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/representer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/representer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/resolver.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/resolver.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/scanner.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/scanner.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/serializer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/serializer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_27/yaml/tokens.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_27/yaml/tokens.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/__init__.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/composer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/composer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/constructor.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/constructor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/cyaml.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/cyaml.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/dumper.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/dumper.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/emitter.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/emitter.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/error.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/error.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/events.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/events.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/loader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/loader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/nodes.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/nodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/parser.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/parser.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/reader.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/reader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/representer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/representer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/resolver.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/resolver.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/scanner.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/scanner.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/serializer.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/serializer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/yaml_35/yaml/tokens.py` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/yaml_35/yaml/tokens.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/LICENSE` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/LICENSE`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/crc32.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/crc32.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/crc32.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/crc32.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zconf.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zconf.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zlib.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zlib.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zlib/zutil.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zlib/zutil.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/LICENSE.txt` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/bitstream.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/bitstream.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/compiler.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/compiler.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/cpu.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/cpu.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/debug.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/debug.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/entropy_common.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/entropy_common.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/error_private.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/error_private.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/error_private.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/error_private.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/fse.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/fse.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/fse_decompress.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/fse_decompress.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/huf.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/huf.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/mem.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/mem.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/xxhash.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/xxhash.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/xxhash.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/xxhash.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_common.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_common.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_deps.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_deps.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_errors.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_errors.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/common/zstd_internal.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/common/zstd_internal.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/huf_decompress.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/huf_decompress.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_ddict.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.c` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_block.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_internal.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/decompress/zstd_decompress_internal.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/inline_copy/zstd/zstd.h` & `nuitka_winsvc-2.3/nuitka/build/inline_copy/zstd/zstd.h`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledAsyncgenType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledAsyncgenType.c`

 * *Files 1% similar despite different names*

```diff
@@ -120,15 +120,15 @@
 static PyObject *Nuitka_Asyncgen_get_ag_await(struct Nuitka_AsyncgenObject *asyncgen) {
     CHECK_OBJECT(asyncgen);
 
     if (asyncgen->m_yield_from) {
         Py_INCREF(asyncgen->m_yield_from);
         return asyncgen->m_yield_from;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 static PyObject *Nuitka_Asyncgen_get_code(struct Nuitka_AsyncgenObject *asyncgen) {
     CHECK_OBJECT(asyncgen);
     CHECK_OBJECT(asyncgen->m_code_object);
@@ -150,15 +150,15 @@
     CHECK_OBJECT(asyncgen);
     CHECK_OBJECT_X(asyncgen->m_frame);
 
     if (asyncgen->m_frame) {
         Py_INCREF(asyncgen->m_frame);
         return (PyObject *)asyncgen->m_frame;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 static int Nuitka_Asyncgen_set_frame(struct Nuitka_AsyncgenObject *asyncgen, PyObject *value) {
     CHECK_OBJECT(asyncgen);
     CHECK_OBJECT_X(value);
@@ -1348,15 +1348,21 @@
 struct _PyAsyncGenWrappedValue {
     /* Python object folklore: */
     PyObject_HEAD
 
         PyObject *agw_val;
 };
 
+#if PYTHON_VERSION < 0x3d0
 #define _PyAsyncGenWrappedValue_CheckExact(o) (Py_TYPE(o) == &_PyAsyncGenWrappedValue_Type)
+#else
+static PyTypeObject *Nuitka_PyAsyncGenWrappedValue_Type = NULL;
+
+#define _PyAsyncGenWrappedValue_CheckExact(o) (Py_TYPE(o) == Nuitka_PyAsyncGenWrappedValue_Type)
+#endif
 
 static PyObject *_Nuitka_Asyncgen_unwrap_value(PyThreadState *tstate, struct Nuitka_AsyncgenObject *asyncgen,
                                                PyObject *result) {
     CHECK_OBJECT(asyncgen);
     CHECK_OBJECT_X(result);
 
     if (result == NULL) {
@@ -1374,27 +1380,25 @@
         asyncgen->m_running_async = false;
 #endif
         return NULL;
     }
 
     if (_PyAsyncGenWrappedValue_CheckExact(result)) {
         /* async yield */
-        // TODO: Unify with coroutines and generators, who do things manually with a shared
-        // helper, "Nuitka_SetStopIterationValue" should be usable instead.
-        _PyGen_SetStopIterationValue(((struct _PyAsyncGenWrappedValue *)result)->agw_val);
+        Nuitka_SetStopIterationValue(tstate, ((struct _PyAsyncGenWrappedValue *)result)->agw_val);
 
         Py_DECREF(result);
 
 #if PYTHON_VERSION >= 0x380
         asyncgen->m_running_async = false;
 #endif
         return NULL;
     } else if (Nuitka_AsyncgenWrappedValue_CheckExact(result)) {
         /* async yield */
-        _PyGen_SetStopIterationValue(((struct Nuitka_AsyncgenWrappedValueObject *)result)->m_value);
+        Nuitka_SetStopIterationValue(tstate, ((struct Nuitka_AsyncgenWrappedValueObject *)result)->m_value);
 
         Py_DECREF(result);
 
 #if PYTHON_VERSION >= 0x380
         asyncgen->m_running_async = false;
 #endif
         return NULL;
@@ -1638,15 +1642,15 @@
 #endif
     return result;
 }
 
 static PyObject *Nuitka_AsyncgenAsend_close(struct Nuitka_AsyncgenAsendObject *asyncgen_asend, PyObject *args) {
     asyncgen_asend->m_state = AWAITABLE_STATE_CLOSED;
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
     return Py_None;
 }
 
 static PyObject *Nuitka_AsyncgenAsend_tp_repr(struct Nuitka_AsyncgenAsendObject *asyncgen_asend) {
     return PyUnicode_FromFormat("<compiled_async_generator_asend of %s at %p>",
                                 Nuitka_String_AsString(asyncgen_asend->m_gen->m_qualname), asyncgen_asend);
 }
@@ -2045,15 +2049,15 @@
 static PyObject *Nuitka_AsyncgenAthrow_tp_iternext(struct Nuitka_AsyncgenAthrowObject *asyncgen_athrow) {
     return Nuitka_AsyncgenAthrow_send(asyncgen_athrow, Py_None);
 }
 
 static PyObject *Nuitka_AsyncgenAthrow_close(struct Nuitka_AsyncgenAthrowObject *asyncgen_athrow) {
     asyncgen_athrow->m_state = AWAITABLE_STATE_CLOSED;
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
     return Py_None;
 }
 
 static PyMethodDef Nuitka_AsyncgenAthrow_methods[] = {
     {"send", (PyCFunction)Nuitka_AsyncgenAthrow_send, METH_O, NULL},
     {"throw", (PyCFunction)Nuitka_AsyncgenAthrow_throw, METH_VARARGS, NULL},
     {"close", (PyCFunction)Nuitka_AsyncgenAthrow_close, METH_NOARGS, NULL},
@@ -2176,14 +2180,21 @@
     assert(Nuitka_Asyncgen_Type.tp_weaklist != PyAsyncGen_Type.tp_weaklist);
     assert(Nuitka_Asyncgen_Type.tp_del != PyAsyncGen_Type.tp_del || PyAsyncGen_Type.tp_del == NULL);
     assert(Nuitka_Asyncgen_Type.tp_finalize != PyAsyncGen_Type.tp_finalize || PyAsyncGen_Type.tp_finalize == NULL);
 
     Nuitka_PyType_Ready(&Nuitka_AsyncgenAsend_Type, NULL, true, false, true, true, false);
     Nuitka_PyType_Ready(&Nuitka_AsyncgenAthrow_Type, NULL, true, false, true, true, false);
     Nuitka_PyType_Ready(&Nuitka_AsyncgenValueWrapper_Type, NULL, false, false, false, false, false);
+
+#if PYTHON_VERSION >= 0x3d0
+    PyThreadState *tstate = PyThreadState_GET();
+    PyObject *asyncgen_wrapper_object = _PyIntrinsics_UnaryFunctions[INTRINSIC_ASYNC_GEN_WRAP].func(tstate, Py_None);
+    Nuitka_PyAsyncGenWrappedValue_Type = Py_TYPE(asyncgen_wrapper_object);
+    Py_DECREF(asyncgen_wrapper_object);
+#endif
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCellType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCellType.c`

 * *Files 0% similar despite different names*

```diff
@@ -120,15 +120,15 @@
         result = BOOL_FROM(res > 0);
         break;
     default:
         PyErr_BadArgument();
         return NULL;
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 
 static PyObject *Nuitka_Cell_tp_repr(struct Nuitka_CellObject *cell) {
     if (cell->ob_ref == NULL) {
         return Nuitka_String_FromFormat("<compiled_cell at %p: empty>", cell);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCodeHelpers.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCodeHelpers.c`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
     _initUnicodeBuiltinMethods();
     NUITKA_PRINT_TRACE("main(): Calling _initDictBuiltinMethods().");
     _initDictBuiltinMethods();
     NUITKA_PRINT_TRACE("main(): Calling _initListBuiltinMethods().");
     _initListBuiltinMethods();
 }
 
-#if PYTHON_VERSION >= 0x3b0
+#if PYTHON_VERSION >= 0x350
 #include "HelpersAllocator.c"
 #endif
 
 #include "HelpersBuiltin.c"
 #include "HelpersBytes.c"
 #include "HelpersClasses.c"
 #include "HelpersDictionaries.c"
@@ -77,30 +77,30 @@
 
     if (step > 0) {
         size = ESTIMATE_RANGE(low, high, step);
     } else {
         size = ESTIMATE_RANGE(high, low, -step);
     }
 
-    PyObject *result = MAKE_LIST_EMPTY(size);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, size);
 
     long current = low;
 
     for (int i = 0; i < size; i++) {
         PyList_SET_ITEM(result, i, PyInt_FromLong(current));
         current += step;
     }
 
     return result;
 }
 
 static PyObject *_BUILTIN_RANGE_INT2(long low, long high) { return _BUILTIN_RANGE_INT3(low, high, 1); }
 
 static PyObject *_BUILTIN_RANGE_INT(long boundary) {
-    PyObject *result = MAKE_LIST_EMPTY(boundary > 0 ? boundary : 0);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, boundary > 0 ? boundary : 0);
 
     for (int i = 0; i < boundary; i++) {
         PyList_SET_ITEM(result, i, PyInt_FromLong(i));
     }
 
     return result;
 }
@@ -187,15 +187,15 @@
 
     if (unlikely(end == -1 && DROP_ERROR_OCCURRED(tstate))) {
         fallback = true;
     }
 
     if (fallback) {
         // Transfers references to tuple.
-        PyObject *pos_args = MAKE_TUPLE2_0(low_temp, high_temp);
+        PyObject *pos_args = MAKE_TUPLE2_0(tstate, low_temp, high_temp);
         NUITKA_ASSIGN_BUILTIN(range);
 
         PyObject *result = CALL_FUNCTION_WITH_POSARGS2(tstate, NUITKA_ACCESS_BUILTIN(range), pos_args);
 
         Py_DECREF(pos_args);
 
         return result;
@@ -246,15 +246,15 @@
     long step_long = PyInt_AsLong(step_temp);
 
     if (unlikely(step_long == -1 && DROP_ERROR_OCCURRED(tstate))) {
         fallback = true;
     }
 
     if (fallback) {
-        PyObject *pos_args = MAKE_TUPLE3_0(low_temp, high_temp, step_temp);
+        PyObject *pos_args = MAKE_TUPLE3_0(tstate, low_temp, high_temp, step_temp);
 
         NUITKA_ASSIGN_BUILTIN(range);
 
         PyObject *result = CALL_FUNCTION_WITH_POSARGS3(tstate, NUITKA_ACCESS_BUILTIN(range), pos_args);
 
         Py_DECREF(pos_args);
 
@@ -581,26 +581,26 @@
         if (unlikely(cmp < 0)) {
             Py_DECREF(it);
             return NULL;
         }
 
         if (cmp == 0) {
             Py_DECREF(it);
-            Py_INCREF(Py_False);
+            Py_INCREF_IMMORTAL(Py_False);
             return Py_False;
         }
     }
 
     Py_DECREF(it);
 
     if (unlikely(!CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED(tstate))) {
         return NULL;
     }
 
-    Py_INCREF(Py_True);
+    Py_INCREF_IMMORTAL(Py_True);
     return Py_True;
 }
 
 PyObject *BUILTIN_LEN(PyThreadState *tstate, PyObject *value) {
     CHECK_OBJECT(value);
 
     Py_ssize_t res = Nuitka_PyObject_Size(value);
@@ -631,25 +631,25 @@
         Py_DECREF(item);
         if (unlikely(cmp < 0)) {
             Py_DECREF(it);
             return NULL;
         }
         if (cmp > 0) {
             Py_DECREF(it);
-            Py_INCREF(Py_True);
+            Py_INCREF_IMMORTAL(Py_True);
             return Py_True;
         }
     }
 
     Py_DECREF(it);
     if (unlikely(!CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED(tstate))) {
         return NULL;
     }
 
-    Py_INCREF(Py_False);
+    Py_INCREF_IMMORTAL(Py_False);
     return Py_False;
 }
 
 PyObject *BUILTIN_ABS(PyObject *o) {
     CHECK_OBJECT(o);
 
     PyNumberMethods *m = o->ob_type->tp_as_number;
@@ -804,24 +804,24 @@
     NUITKA_ASSIGN_BUILTIN(print);
 
     struct Nuitka_ExceptionPreservationItem saved_exception_state;
 
     FETCH_ERROR_OCCURRED_STATE_UNTRACED(tstate, &saved_exception_state);
 
     // TODO: Have a helper that creates a dictionary for PyObject **
-    PyObject *print_kw = MAKE_DICT_EMPTY();
+    PyObject *print_kw = MAKE_DICT_EMPTY(tstate);
     DICT_SET_ITEM(print_kw, const_str_plain_end, const_str_empty);
 
     if (file == NULL) {
         DICT_SET_ITEM(print_kw, const_str_plain_file, GET_STDOUT());
     } else {
         DICT_SET_ITEM(print_kw, const_str_plain_file, file);
     }
 
-    PyObject *print_args = MAKE_TUPLE1(object);
+    PyObject *print_args = MAKE_TUPLE1(tstate, object);
 
     PyObject *result = CALL_FUNCTION(tstate, NUITKA_ACCESS_BUILTIN(print), print_args, print_kw);
 
     Py_DECREF(print_args);
     Py_DECREF(print_kw);
 
     Py_XDECREF(result);
@@ -963,15 +963,15 @@
 
     while (traceback != NULL) {
         printf(" line %d (frame object chain):\n", traceback->tb_lineno);
 
         PyFrameObject *frame = traceback->tb_frame;
 
         while (frame != NULL) {
-            printf("  Frame at %s\n", PyString_AsString(PyObject_Str((PyObject *)frame->f_code)));
+            printf("  Frame at %s\n", PyString_AsString(PyObject_Str((PyObject *)Nuitka_Frame_GetCodeObject(frame))));
 
             frame = frame->f_back;
         }
 
         assert(traceback->tb_next != traceback);
         traceback = traceback->tb_next;
     }
@@ -1156,15 +1156,15 @@
             Py_INCREF(klass->cl_dict);
             return klass->cl_dict;
         } else if (strcmp(sattr_name, "__bases__") == 0) {
             Py_INCREF(klass->cl_bases);
             return klass->cl_bases;
         } else if (strcmp(sattr_name, "__name__") == 0) {
             if (klass->cl_name == NULL) {
-                Py_INCREF(Py_None);
+                Py_INCREF_IMMORTAL(Py_None);
                 return Py_None;
             } else {
                 Py_INCREF(klass->cl_name);
                 return klass->cl_name;
             }
         }
     }
@@ -1378,15 +1378,15 @@
 
                 continue;
             }
         }
 #endif
 
         if (item == Py_False) {
-            Py_DECREF(item);
+            Py_DECREF_IMMORTAL(item);
             continue;
         }
 
         if (item == Py_True) {
             long b = 1;
             long x = int_result + b;
 
@@ -1455,15 +1455,15 @@
 
 PyObject *BUILTIN_SUM2(PyThreadState *tstate, PyObject *sequence, PyObject *start) {
     NUITKA_ASSIGN_BUILTIN(sum);
 
     CHECK_OBJECT(sequence);
     CHECK_OBJECT(start);
 
-    PyObject *pos_args = MAKE_TUPLE2(sequence, start);
+    PyObject *pos_args = MAKE_TUPLE2(tstate, sequence, start);
 
     PyObject *result = CALL_FUNCTION_WITH_POSARGS2(tstate, NUITKA_ACCESS_BUILTIN(sum), pos_args);
 
     Py_DECREF(pos_args);
 
     return result;
 }
@@ -1998,15 +1998,17 @@
 volatile int _Py_Ticker = _Py_CheckInterval;
 #endif
 
 #if PYTHON_VERSION >= 0x270
 iternextfunc default_iternext;
 
 void _initSlotIterNext(void) {
-    PyObject *pos_args = MAKE_TUPLE1((PyObject *)&PyBaseObject_Type);
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *pos_args = MAKE_TUPLE1(tstate, (PyObject *)&PyBaseObject_Type);
 
     // Note: Not using MAKE_DICT_EMPTY on purpose, this is called early on.
     PyObject *kw_args = PyDict_New();
     PyDict_SetItem(kw_args, const_str_plain___iter__, Py_True);
 
     PyObject *c =
         PyObject_CallFunctionObjArgs((PyObject *)&PyType_Type, const_str_plain___iter__, pos_args, kw_args, NULL);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledCoroutineType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledCoroutineType.c`

 * *Files 1% similar despite different names*

```diff
@@ -120,15 +120,15 @@
     CHECK_OBJECT(coroutine);
     CHECK_OBJECT_X(coroutine->m_yield_from);
 
     if (coroutine->m_yield_from) {
         Py_INCREF(coroutine->m_yield_from);
         return coroutine->m_yield_from;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 static PyObject *Nuitka_Coroutine_get_code(struct Nuitka_CoroutineObject *coroutine) {
     CHECK_OBJECT(coroutine);
     CHECK_OBJECT(coroutine->m_code_object);
@@ -150,15 +150,15 @@
     CHECK_OBJECT(coroutine);
     CHECK_OBJECT_X(coroutine->m_frame);
 
     if (coroutine->m_frame) {
         Py_INCREF(coroutine->m_frame);
         return (PyObject *)coroutine->m_frame;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 static int Nuitka_Coroutine_set_frame(struct Nuitka_CoroutineObject *coroutine, PyObject *value) {
     CHECK_OBJECT(coroutine);
     CHECK_OBJECT_X(value);
@@ -218,15 +218,15 @@
         }
     } else if (PyGen_CheckExact(yield_from) || PyCoro_CheckExact(yield_from)) {
         retval = Nuitka_PyGen_Send(tstate, (PyGenObject *)yield_from, Py_None);
     } else if (send_value == Py_None && Nuitka_CoroutineWrapper_Check(yield_from)) {
         struct Nuitka_CoroutineObject *yieldfrom_coroutine =
             ((struct Nuitka_CoroutineWrapperObject *)yield_from)->m_coroutine;
 
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
 
         struct Nuitka_ExceptionPreservationItem no_exception_state;
         INIT_ERROR_OCCURRED_STATE(&no_exception_state);
 
         retval = _Nuitka_Coroutine_send(tstate, yieldfrom_coroutine, Py_None, mode ? false : true, &no_exception_state);
     } else if (send_value == Py_None && Py_TYPE(yield_from)->tp_iternext != NULL) {
         retval = Py_TYPE(yield_from)->tp_iternext(yield_from);
@@ -241,15 +241,15 @@
     }
 
     // Check the sub-generator result
     if (retval == NULL) {
         PyObject *error = GET_ERROR_OCCURRED(tstate);
 
         if (error == NULL) {
-            Py_INCREF(Py_None);
+            Py_INCREF_IMMORTAL(Py_None);
             *returned_value = Py_None;
         } else if (likely(EXCEPTION_MATCH_BOOL_SINGLE(tstate, error, PyExc_StopIteration))) {
             // The sub-generator has given an exception. In case of
             // StopIteration, we need to check the value, as it is going to be
             // the expression value of this "yield from", and we are done. All
             // other errors, we need to raise.
             *returned_value = ERROR_GET_STOP_ITERATION_VALUE(tstate);
@@ -589,17 +589,15 @@
                                         struct Nuitka_ExceptionPreservationItem *exception_state) {
 
     PyObject *result;
     PySendResult res = _Nuitka_Coroutine_sendR(tstate, coroutine, value, closing, exception_state, &result);
 
     switch (res) {
     case PYGEN_RETURN:
-        if (result == NULL) {
-            SET_CURRENT_EXCEPTION_TYPE0(tstate, PyExc_StopIteration);
-        } else {
+        if (result != NULL) {
             if (result != Py_None) {
                 Nuitka_SetStopIterationValue(tstate, result);
             }
 
             Py_DECREF(result);
         }
 
@@ -666,15 +664,15 @@
     PyThreadState *tstate = PyThreadState_GET();
 
     bool r = _Nuitka_Coroutine_close(tstate, coroutine);
 
     if (unlikely(r == false)) {
         return NULL;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 #if PYTHON_VERSION >= 0x360
 static bool Nuitka_AsyncgenAsend_Check(PyObject *object);
 struct Nuitka_AsyncgenAsendObject;
@@ -1349,64 +1347,67 @@
 
 // Not exported by the core library.
 static int Nuitka_PyInterpreterFrame_GetLine(_PyInterpreterFrame *frame) {
     // TODO: For Nuitka frames there is a better way actually, since
     // we have the line number stored.
 
     int addr = _PyInterpreterFrame_LASTI(frame) * sizeof(_Py_CODEUNIT);
+#if PYTHON_VERSION < 0x3d0
     return PyCode_Addr2Line(frame->f_code, addr);
+#else
+    return PyCode_Addr2Line((PyCodeObject *)frame->f_executable, addr);
+#endif
 }
 
-static PyObject *computeCoroutineOrigin(int origin_depth) {
-    PyThreadState *tstate = _PyThreadState_GET();
-    _PyInterpreterFrame *current_frame = tstate->cframe->current_frame;
+static PyObject *computeCoroutineOrigin(PyThreadState *tstate, int origin_depth) {
+    _PyInterpreterFrame *current_frame = CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
 
     // Create result tuple with correct size.
     int frame_count = 0;
     _PyInterpreterFrame *frame = current_frame;
     while (frame != NULL && frame_count < origin_depth) {
         frame = frame->previous;
         frame_count += 1;
     }
-    PyObject *cr_origin = MAKE_TUPLE_EMPTY_VAR(frame_count);
+    PyObject *cr_origin = MAKE_TUPLE_EMPTY_VAR(tstate, frame_count);
 
     frame = current_frame;
     for (int i = 0; i < frame_count; i++) {
-        PyCodeObject *code = frame->f_code;
+        PyCodeObject *code = Nuitka_InterpreterFrame_GetCodeObject(frame);
 
         int line = Nuitka_PyInterpreterFrame_GetLine(frame);
 
         PyObject *frame_info = Py_BuildValue("OiO", code->co_filename, line, code->co_name);
         assert(frame_info);
 
         PyTuple_SET_ITEM(cr_origin, i, frame_info);
         frame = frame->previous;
     }
 
     return cr_origin;
 }
 
 #elif PYTHON_VERSION >= 0x370
-static PyObject *computeCoroutineOrigin(int origin_depth) {
+static PyObject *computeCoroutineOrigin(PyThreadState *tstate, int origin_depth) {
     PyFrameObject *frame = PyEval_GetFrame();
 
     int frame_count = 0;
 
     while (frame != NULL && frame_count < origin_depth) {
         frame = frame->f_back;
         frame_count += 1;
     }
 
-    PyObject *cr_origin = MAKE_TUPLE_EMPTY(frame_count);
+    PyObject *cr_origin = MAKE_TUPLE_EMPTY(tstate, frame_count);
 
     frame = PyEval_GetFrame();
 
     for (int i = 0; i < frame_count; i++) {
-        PyObject *frame_info =
-            Py_BuildValue("OiO", frame->f_code->co_filename, PyFrame_GetLineNumber(frame), frame->f_code->co_name);
+        PyObject *frame_info = Py_BuildValue("OiO", Nuitka_Frame_GetCodeObject(frame)->co_filename,
+                                             PyFrame_GetLineNumber(frame), frame->f_code->co_name);
 
         assert(frame_info);
 
         PyTuple_SET_ITEM(cr_origin, i, frame_info);
 
         frame = frame->f_back;
     }
@@ -1474,15 +1475,15 @@
 
 #if PYTHON_VERSION >= 0x370
     int origin_depth = tstate->coroutine_origin_tracking_depth;
 
     if (origin_depth == 0) {
         result->m_origin = NULL;
     } else {
-        result->m_origin = computeCoroutineOrigin(origin_depth);
+        result->m_origin = computeCoroutineOrigin(tstate, origin_depth);
     }
 #endif
 
 #if PYTHON_VERSION >= 0x370
     result->m_exc_state = Nuitka_ExceptionStackItem_Empty;
 #endif
 
@@ -1492,17 +1493,20 @@
     Nuitka_GC_Track(result);
     return (PyObject *)result;
 }
 
 static inline PyCodeObject *_Nuitka_PyGen_GetCode(PyGenObject *gen) {
 #if PYTHON_VERSION < 0x3c0
     return (PyCodeObject *)gen->gi_code;
-#else
+#elif PYTHON_VERSION < 0x3d0
     _PyInterpreterFrame *frame = (_PyInterpreterFrame *)(gen->gi_iframe);
     return frame->f_code;
+#else
+    _PyInterpreterFrame *frame = (_PyInterpreterFrame *)(gen->gi_iframe);
+    return (PyCodeObject *)frame->f_executable;
 #endif
 }
 
 static int gen_is_coroutine(PyObject *object) {
     if (PyGen_CheckExact(object)) {
         PyCodeObject *code = _Nuitka_PyGen_GetCode((PyGenObject *)object);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledFrameType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledFrameType.c`

 * *Files 2% similar despite different names*

```diff
@@ -33,30 +33,30 @@
 #else
 #define Nuitka_Frame_memberlist 0
 #endif
 
 #if PYTHON_VERSION < 0x300
 
 static PyObject *Nuitka_Frame_get_exc_traceback(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result = frame->m_frame.f_exc_traceback;
 
     if (result == NULL) {
         result = Py_None;
     }
 
     Py_INCREF(result);
     return result;
 }
 
 static int Nuitka_Frame_set_exc_traceback(struct Nuitka_FrameObject *frame, PyObject *traceback) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     Py_XDECREF(frame->m_frame.f_exc_traceback);
 
     if (traceback == Py_None) {
         traceback = NULL;
@@ -65,15 +65,15 @@
     frame->m_frame.f_exc_traceback = traceback;
     Py_XINCREF(traceback);
 
     return 0;
 }
 
 static PyObject *Nuitka_Frame_get_exc_type(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result;
 
     if (frame->m_frame.f_exc_type != NULL) {
         result = frame->m_frame.f_exc_type;
@@ -82,15 +82,15 @@
     }
 
     Py_INCREF(result);
     return result;
 }
 
 static int Nuitka_Frame_set_exc_type(struct Nuitka_FrameObject *frame, PyObject *exception_type) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *old = frame->m_frame.f_exc_type;
 
     if (exception_type == Py_None) {
         exception_type = NULL;
@@ -101,15 +101,15 @@
 
     Py_XDECREF(old);
 
     return 0;
 }
 
 static PyObject *Nuitka_Frame_get_exc_value(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result;
 
     if (frame->m_frame.f_exc_value != NULL) {
         result = frame->m_frame.f_exc_value;
@@ -118,15 +118,15 @@
     }
 
     Py_INCREF(result);
     return result;
 }
 
 static int Nuitka_Frame_set_exc_value(struct Nuitka_FrameObject *frame, PyObject *exception_value) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *old = frame->m_frame.f_exc_value;
 
     if (exception_value == Py_None) {
         exception_value = NULL;
@@ -136,44 +136,46 @@
     Py_XINCREF(exception_value);
     Py_XDECREF(old);
 
     return 0;
 }
 
 static PyObject *Nuitka_Frame_get_restricted(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
-    Py_INCREF(Py_False);
+    Py_INCREF_IMMORTAL(Py_False);
     return Py_False;
 }
 
 #endif
 
 static PyObject *Nuitka_Frame_getlocals(struct Nuitka_FrameObject *nuitka_frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)nuitka_frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)nuitka_frame));
     CHECK_OBJECT((PyObject *)nuitka_frame);
     assert(_PyObject_GC_IS_TRACKED(nuitka_frame));
 
+    NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+
     if (nuitka_frame->m_type_description == NULL) {
 #if PYTHON_VERSION < 0x3b0
         PyFrameObject *locals_owner = &nuitka_frame->m_frame;
 #else
         _PyInterpreterFrame *locals_owner = &nuitka_frame->m_interpreter_frame;
 #endif
 
         if (locals_owner->f_locals == NULL) {
-            locals_owner->f_locals = MAKE_DICT_EMPTY();
+            locals_owner->f_locals = MAKE_DICT_EMPTY(tstate);
         }
 
         Py_INCREF(locals_owner->f_locals);
         return locals_owner->f_locals;
     } else {
-        PyObject *result = MAKE_DICT_EMPTY();
+        PyObject *result = MAKE_DICT_EMPTY(tstate);
         PyObject **var_names = Nuitka_GetCodeVarNames(Nuitka_GetFrameCodeObject(nuitka_frame));
 
         char const *w = nuitka_frame->m_type_description;
         char const *t = nuitka_frame->m_locals_storage;
 
         while (*w != 0) {
             switch (*w) {
@@ -232,89 +234,89 @@
         }
 
         return result;
     }
 }
 
 static PyObject *Nuitka_Frame_getlineno(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     return PyInt_FromLong(frame->m_frame.f_lineno);
 }
 
 static PyObject *Nuitka_Frame_gettrace(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result = frame->m_frame.f_trace;
     Py_INCREF(result);
     return result;
 }
 
 static int Nuitka_Frame_settrace(struct Nuitka_FrameObject *frame, PyObject *v, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyThreadState *tstate = PyThreadState_GET();
 
     SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, "f_trace is not writable in Nuitka");
     return -1;
 }
 
 #if PYTHON_VERSION >= 0x370
 static PyObject *Nuitka_Frame_gettracelines(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result = Py_False;
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static int Nuitka_Frame_settracelines(struct Nuitka_FrameObject *frame, PyObject *v, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyThreadState *tstate = PyThreadState_GET();
 
     SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, "f_trace_lines is not writable in Nuitka");
     return -1;
 }
 
 static PyObject *Nuitka_Frame_gettraceopcodes(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyObject *result = Py_False;
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static int Nuitka_Frame_settraceopcodes(struct Nuitka_FrameObject *frame, PyObject *v, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyThreadState *tstate = PyThreadState_GET();
 
     SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, "f_trace_opcodes is not writable in Nuitka");
     return -1;
 }
 #endif
 
 #if PYTHON_VERSION >= 0x3b0
 static PyObject *Nuitka_Frame_getback(struct Nuitka_FrameObject *frame, void *closure) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     return (PyObject *)PyFrame_GetBack(&frame->m_frame);
 }
 #endif
 
@@ -335,15 +337,15 @@
 #if PYTHON_VERSION >= 0x3b0
     {(char *)"f_trace_lines", (getter)Nuitka_Frame_getback, NULL, NULL},
 #endif
     {NULL}};
 
 // tp_repr slot, decide how a function shall be output
 static PyObject *Nuitka_Frame_tp_repr(struct Nuitka_FrameObject *nuitka_frame) {
-    assert(Nuitka_Frame_Check((PyObject *)nuitka_frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)nuitka_frame));
     CHECK_OBJECT((PyObject *)nuitka_frame);
     assert(_PyObject_GC_IS_TRACKED(nuitka_frame));
 
 #if PYTHON_VERSION >= 0x370
     PyCodeObject *code_object = Nuitka_GetFrameCodeObject(nuitka_frame);
     return Nuitka_String_FromFormat("<compiled_frame at %p, file %R, line %d, code %S>", nuitka_frame,
                                     code_object->co_filename, Nuitka_GetFrameLineNumber(nuitka_frame),
@@ -429,14 +431,15 @@
     PyFrameObject *frame = &nuitka_frame->m_frame;
 #if PYTHON_VERSION < 0x3b0
     PyFrameObject *locals_owner = frame;
 #else
     _PyInterpreterFrame *locals_owner = &nuitka_frame->m_interpreter_frame;
 #endif
 
+    assert(Nuitka_GC_IS_TRACKED_X((PyObject *)frame->f_back));
     Py_XDECREF(frame->f_back);
     Py_DECREF(locals_owner->f_builtins);
     Py_DECREF(locals_owner->f_globals);
     Py_XDECREF(locals_owner->f_locals);
 
 #if PYTHON_VERSION < 0x370
     Py_XDECREF(frame->f_exc_type);
@@ -467,15 +470,15 @@
     RESTORE_ERROR_OCCURRED_STATE(tstate, &saved_exception_state2);
 
     ASSERT_SAME_EXCEPTION_STATE(&saved_exception_state1, &saved_exception_state2);
 #endif
 }
 
 static int Nuitka_Frame_tp_traverse(struct Nuitka_FrameObject *frame, visitproc visit, void *arg) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     Py_VISIT(frame->m_frame.f_back);
 
 #if PYTHON_VERSION < 0x3b0
     PyFrameObject *locals_owner = &frame->m_frame;
@@ -537,15 +540,15 @@
 
     return 0;
 }
 
 #if PYTHON_VERSION >= 0x340
 
 static PyObject *Nuitka_Frame_clear(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     PyThreadState *tstate = PyThreadState_GET();
 
     if (Nuitka_Frame_IsExecuting(frame)) {
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, "cannot clear an executing frame");
@@ -619,27 +622,27 @@
 
     Py_RETURN_NONE;
 }
 
 #endif
 
 static inline Py_ssize_t Nuitka_Frame_GetSize(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
 #if PYTHON_VERSION < 0x3b0
     return Py_SIZE(frame);
 #else
     return frame->m_ob_size;
 #endif
 }
 
 static PyObject *Nuitka_Frame_sizeof(struct Nuitka_FrameObject *frame) {
-    assert(Nuitka_Frame_Check((PyObject *)frame));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame));
     CHECK_OBJECT((PyObject *)frame);
     assert(_PyObject_GC_IS_TRACKED(frame));
 
     return PyInt_FromSsize_t(sizeof(struct Nuitka_FrameObject) + Py_SIZE(frame));
 }
 
 static PyMethodDef Nuitka_Frame_methods[] = {
@@ -747,15 +750,20 @@
     // Globals and locals are stored differently before Python 3.11
 #if PYTHON_VERSION < 0x3b0
     PyFrameObject *locals_owner = frame;
 #else
     _PyInterpreterFrame *locals_owner = &result->m_interpreter_frame;
 #endif
 
+#if PYTHON_VERSION < 0x3d0
     locals_owner->f_code = code;
+#else
+    // TODO: Why is our code object not just immortal.
+    locals_owner->f_executable = (PyObject *)code;
+#endif
 
     frame->f_trace = Py_None;
 
 #if PYTHON_VERSION < 0x370
     frame->f_exc_type = NULL;
     frame->f_exc_value = NULL;
     frame->f_exc_traceback = NULL;
@@ -794,17 +802,24 @@
     Nuitka_SetFrameGenerator(result, NULL);
 
     Nuitka_Frame_MarkAsNotExecuting(result);
 #endif
 
 #if PYTHON_VERSION >= 0x3b0
     result->m_interpreter_frame.frame_obj = &result->m_frame;
-    result->m_interpreter_frame.owner = 0;
+    result->m_interpreter_frame.owner = FRAME_OWNED_BY_GENERATOR;
+#if PYTHON_VERSION >= 0x3c0
+    result->m_interpreter_frame.f_funcobj = NULL;
+#else
+    result->m_interpreter_frame.f_func = NULL;
     result->m_interpreter_frame.prev_instr = _PyCode_CODE(code);
+#endif
     result->m_frame.f_frame = &result->m_interpreter_frame;
+
+    assert(!_PyFrame_IsIncomplete(&result->m_interpreter_frame));
 #endif
 
     Nuitka_GC_Track(result);
     return result;
 }
 
 struct Nuitka_FrameObject *MAKE_MODULE_FRAME(PyCodeObject *code, PyObject *module) {
@@ -976,15 +991,15 @@
     }
 
     CHECK_OBJECT(result);
     return result;
 }
 
 void Nuitka_Frame_AttachLocals(struct Nuitka_FrameObject *frame_object, char const *type_description, ...) {
-    assert(Nuitka_Frame_Check((PyObject *)frame_object));
+    assert(Nuitka_Frame_CheckExact((PyObject *)frame_object));
     CHECK_OBJECT((PyObject *)frame_object);
     assert(_PyObject_GC_IS_TRACKED(frame_object));
     assertFrameObject(frame_object);
 
 #if _DEBUG_FRAME
     PRINT_FORMAT("Attaching to frame 0x%lx %s\n", frame_object,
                  Nuitka_String_AsString(PyObject_Repr((PyObject *)Nuitka_Frame_GetCodeObject(&frame_object->m_frame))));
@@ -1074,17 +1089,14 @@
 }
 
 // Make a dump of the active frame stack. For debugging purposes only.
 #if _DEBUG_FRAME
 void dumpFrameStack(void) {
     PyThreadState *tstate = PyThreadState_GET();
 
-    PyObject *saved_exception_type, *saved_exception_value;
-    PyTracebackObject *saved_exception_tb;
-
     struct Nuitka_ExceptionPreservationItem saved_exception_state;
     FETCH_ERROR_OCCURRED_STATE(tstate, &saved_exception_state);
 
     int total = 0;
 
 #if PYTHON_VERSION < 0x3b0
     PyFrameObject *current = PyThreadState_GET()->frame;
@@ -1114,15 +1126,15 @@
         PyObject *current_repr = NULL;
         if (current->current_frame->frame_obj != NULL) {
             current_repr = PyObject_Str((PyObject *)current->current_frame->frame_obj);
         } else {
             current_repr = const_str_empty;
             Py_INCREF(const_str_empty);
         }
-        PyObject *code_repr = PyObject_Str((PyObject *)current->current_frame->f_code);
+        PyObject *code_repr = PyObject_Str((PyObject *)Nuitka_InterpreterFrame_GetCodeObject(current->current_frame));
 #endif
 
         PRINT_FORMAT("Frame stack %d: %s %d %s\n", total--, Nuitka_String_AsString(current_repr), Py_REFCNT(current),
                      Nuitka_String_AsString(code_repr));
 
         Py_DECREF(current_repr);
         Py_DECREF(code_repr);
@@ -1170,15 +1182,15 @@
 #else
     PRINT_STRING(prefix);
     PRINT_STRING(" ");
 
     if (frame) {
         PRINT_FORMAT("0x%lx ", frame);
 
-        PyObject *code_object_str = PyObject_Repr((PyObject *)frame->f_code);
+        PyObject *code_object_str = PyObject_Repr((PyObject *)Nuitka_InterpreterFrame_GetCodeObject(frame));
         PRINT_ITEM(code_object_str);
         Py_DECREF(code_object_str);
     } else {
         PRINT_STRING("<NULL> no frame");
     }
 
     PRINT_NEW_LINE();
@@ -1187,15 +1199,15 @@
 
 void PRINT_TOP_FRAME(char const *prefix) {
     PyThreadState *tstate = PyThreadState_GET();
 
 #if PYTHON_VERSION < 0x3b0
     PRINT_UNCOMPILED_FRAME(prefix, tstate->frame);
 #else
-    PRINT_INTERPRETER_FRAME(prefix, tstate->cframe->current_frame);
+    PRINT_INTERPRETER_FRAME(prefix, CURRENT_TSTATE_INTERPRETER_FRAME(tstate));
 #endif
 }
 
 #endif
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledFunctionType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledFunctionType.c`

 * *Files 1% similar despite different names*

```diff
@@ -41,21 +41,19 @@
 
 // tp_repr slot, decide how compiled function shall be output to "repr" built-in
 static PyObject *Nuitka_Function_tp_repr(struct Nuitka_FunctionObject *function) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
-    return Nuitka_String_FromFormat("<compiled_function %s at %p>",
 #if PYTHON_VERSION < 0x300
-                                    Nuitka_String_AsString(function->m_name),
+    return Nuitka_String_FromFormat("<compiled_function %s at %p>", Nuitka_String_AsString(function->m_name), function);
 #else
-                                    Nuitka_String_AsString(function->m_qualname),
+    return Nuitka_String_FromFormat("<compiled_function %U at %p>", function->m_qualname, function);
 #endif
-                                    function);
 }
 
 static long Nuitka_Function_tp_traverse(struct Nuitka_FunctionObject *function, visitproc visit, void *arg) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
@@ -188,15 +186,17 @@
 
 static PyObject *Nuitka_Function_get_dict(struct Nuitka_FunctionObject *function) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
     if (function->m_dict == NULL) {
-        function->m_dict = MAKE_DICT_EMPTY();
+        NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+
+        function->m_dict = MAKE_DICT_EMPTY(tstate);
     }
 
     CHECK_OBJECT(function->m_dict);
 
     Py_INCREF(function->m_dict);
     return function->m_dict;
 }
@@ -305,17 +305,18 @@
 
 static PyObject *Nuitka_Function_get_closure(struct Nuitka_FunctionObject *function) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
     if (function->m_closure_given > 0) {
-        return MAKE_TUPLE((PyObject *const *)function->m_closure, function->m_closure_given);
+        NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+        return MAKE_TUPLE(tstate, (PyObject *const *)function->m_closure, function->m_closure_given);
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 static int Nuitka_Function_set_closure(struct Nuitka_FunctionObject *function, PyObject *value) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
@@ -436,15 +437,17 @@
 
 static PyObject *Nuitka_Function_get_annotations(struct Nuitka_FunctionObject *function) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
     if (function->m_annotations == NULL) {
-        function->m_annotations = MAKE_DICT_EMPTY();
+        PyThreadState *tstate = PyThreadState_GET();
+
+        function->m_annotations = MAKE_DICT_EMPTY(tstate);
     }
     CHECK_OBJECT(function->m_annotations);
 
     Py_INCREF(function->m_annotations);
     return function->m_annotations;
 }
 
@@ -516,21 +519,27 @@
     return LOOKUP_SUBSCRIPT(tstate, PyModule_GetDict(function->m_module), const_str_plain___builtins__);
 }
 #endif
 
 #if PYTHON_VERSION >= 0x3c0
 static int Nuitka_Function_set_type_params(struct Nuitka_FunctionObject *function, PyObject *value) {
     CHECK_OBJECT((PyObject *)function);
+    CHECK_OBJECT_X(value);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
-    PyThreadState *tstate = PyThreadState_GET();
+    if (unlikely(value == NULL || !PyTuple_Check(value))) {
+        PyThreadState *tstate = PyThreadState_GET();
 
-    SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "readonly attribute");
-    return -1;
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "__type_params__ must be set to a tuple");
+        return -1;
+    }
+
+    Py_SETREF(function->m_type_params, Py_NewRef(value));
+    return 0;
 }
 
 static PyObject *Nuitka_Function_get_type_params(struct Nuitka_FunctionObject *function) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
 
@@ -543,15 +552,17 @@
 static int Nuitka_Function_set_module(struct Nuitka_FunctionObject *function, PyObject *value) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
     assert(_PyObject_GC_IS_TRACKED(function));
     CHECK_OBJECT_X(value);
 
     if (function->m_dict == NULL) {
-        function->m_dict = MAKE_DICT_EMPTY();
+        NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+
+        function->m_dict = MAKE_DICT_EMPTY(tstate);
     }
 
     if (value == NULL) {
         value = Py_None;
     }
 
     return DICT_SET_ITEM(function->m_dict, const_str_plain___module__, value) ? 0 : -1;
@@ -659,27 +670,29 @@
 #if PYTHON_VERSION >= 0x300
 #if 0
     PRINT_STRING("Nuitka_Function_clone:");
     PRINT_ITEM((PyObject *)function);
     PRINT_NEW_LINE();
 #endif
 
+    PyThreadState *tstate = PyThreadState_GET();
+
     PyObject *annotations = function->m_annotations;
     if (annotations != NULL) {
         if (DICT_SIZE(annotations) != 0) {
-            annotations = DICT_COPY(annotations);
+            annotations = DICT_COPY(tstate, annotations);
         } else {
             annotations = NULL;
         }
     }
 
     PyObject *kwdefaults = function->m_kwdefaults;
     if (kwdefaults != NULL) {
         if (DICT_SIZE(kwdefaults) != 0) {
-            kwdefaults = DICT_COPY(kwdefaults);
+            kwdefaults = DICT_COPY(tstate, kwdefaults);
         } else {
             kwdefaults = NULL;
         }
     }
 #endif
 
     struct Nuitka_FunctionObject *result =
@@ -725,14 +738,18 @@
     }
 
     Py_DECREF(function->m_name);
 #if PYTHON_VERSION >= 0x300
     Py_DECREF(function->m_qualname);
 #endif
 
+#if PYTHON_VERSION >= 0x3c0
+    Py_DECREF(function->m_type_params);
+#endif
+
     // These may actually resurrect the object, not?
     Py_XDECREF(function->m_dict);
     Py_DECREF(function->m_defaults);
 
     Py_XDECREF(function->m_doc);
 
 #if PYTHON_VERSION >= 0x300
@@ -1000,15 +1017,15 @@
 
     for (Py_ssize_t i = 0; i < arg_count; i++) {
         Py_DECREF(python_pars[i]);
     }
 
     PyObject *result = Py_True;
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static PyObject *_Nuitka_FunctionEmptyCodeFalseImpl(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
                                                     PyObject **python_pars) {
     CHECK_OBJECT((PyObject *)function);
     assert(Nuitka_Function_Check((PyObject *)function));
@@ -1017,16 +1034,15 @@
     Py_ssize_t arg_count = function->m_args_overall_count;
 
     for (Py_ssize_t i = 0; i < arg_count; i++) {
         Py_DECREF(python_pars[i]);
     }
 
     PyObject *result = Py_False;
-
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static PyObject *_Nuitka_FunctionEmptyCodeGenericImpl(PyThreadState *tstate,
                                                       struct Nuitka_FunctionObject const *function,
                                                       PyObject **python_pars) {
     CHECK_OBJECT((PyObject *)function);
@@ -1244,15 +1260,15 @@
     CHECK_OBJECT(qualname);
 
     Py_INCREF(qualname);
     result->m_qualname = qualname;
 #endif
 
     if (defaults == NULL) {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         defaults = Py_None;
     }
     CHECK_OBJECT(defaults);
     assert(defaults == Py_None || (PyTuple_Check(defaults) && PyTuple_GET_SIZE(defaults) > 0));
     result->m_defaults = defaults;
 
     _onUpdatedCompiledFunctionDefaultsValue(result);
@@ -1314,14 +1330,19 @@
     static long Nuitka_Function_counter = 0;
     result->m_counter = Nuitka_Function_counter++;
 
 #if PYTHON_VERSION >= 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_VECTORCALL_SLOT)
     result->m_vectorcall = (vectorcallfunc)Nuitka_Function_tp_vectorcall;
 #endif
 
+#if PYTHON_VERSION >= 0x3c0
+    result->m_type_params = const_tuple_empty;
+    assert(_Py_IsImmortal(result->m_type_params));
+#endif
+
     Nuitka_GC_Track(result);
 
     assert(Py_REFCNT(result) == 1);
 
     return result;
 }
 
@@ -1881,25 +1902,25 @@
 
         kw_found += 1;
     }
 
     return kw_found;
 }
 
-static PyObject *COPY_DICT_KW(PyObject *dict_value);
+static PyObject *COPY_DICT_KW(PyThreadState *tstate, PyObject *dict_value);
 
 static bool MAKE_STAR_DICT_DICTIONARY_COPY(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
                                            PyObject **python_pars, PyObject *kw) {
     Py_ssize_t star_dict_index = function->m_args_star_dict_index;
     assert(star_dict_index != -1);
 
     if (kw == NULL || ((PyDictObject *)kw)->ma_used == 0) {
-        python_pars[star_dict_index] = MAKE_DICT_EMPTY();
+        python_pars[star_dict_index] = MAKE_DICT_EMPTY(tstate);
     } else {
-        python_pars[star_dict_index] = COPY_DICT_KW(kw);
+        python_pars[star_dict_index] = COPY_DICT_KW(tstate, kw);
 
         if (unlikely(python_pars[star_dict_index] == NULL)) {
             formatErrorKeywordsMustBeString(tstate, function);
             return false;
         }
     }
 
@@ -2022,38 +2043,38 @@
 #endif
         }
     }
 
     return kw_found;
 }
 
-static void makeStarListTupleCopy(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
-                                  PyObject *const *args, Py_ssize_t args_size) {
+static void makeStarListTupleCopy(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
+                                  PyObject **python_pars, PyObject *const *args, Py_ssize_t args_size) {
     assert(function->m_args_star_list_index != -1);
     Py_ssize_t list_star_index = function->m_args_star_list_index;
 
     // Copy left-over argument values to the star list parameter given.
     if (args_size > function->m_args_positional_count) {
         python_pars[list_star_index] =
-            MAKE_TUPLE(&args[function->m_args_positional_count], args_size - function->m_args_positional_count);
+            MAKE_TUPLE(tstate, &args[function->m_args_positional_count], args_size - function->m_args_positional_count);
     } else {
         python_pars[list_star_index] = const_tuple_empty;
         Py_INCREF(const_tuple_empty);
     }
 }
 
-static void makeStarListTupleCopyMethod(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
-                                        PyObject *const *args, Py_ssize_t args_size) {
+static void makeStarListTupleCopyMethod(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
+                                        PyObject **python_pars, PyObject *const *args, Py_ssize_t args_size) {
     assert(function->m_args_star_list_index != -1);
     Py_ssize_t list_star_index = function->m_args_star_list_index;
 
     // Copy left-over argument values to the star list parameter given.
     if (args_size + 1 > function->m_args_positional_count) {
-        python_pars[list_star_index] =
-            MAKE_TUPLE(&args[function->m_args_positional_count - 1], args_size + 1 - function->m_args_positional_count);
+        python_pars[list_star_index] = MAKE_TUPLE(tstate, &args[function->m_args_positional_count - 1],
+                                                  args_size + 1 - function->m_args_positional_count);
     } else {
         python_pars[list_star_index] = const_tuple_empty;
         Py_INCREF(const_tuple_empty);
     }
 }
 
 static bool _handleArgumentsPlainOnly(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
@@ -2133,15 +2154,15 @@
             formatErrorTooManyArguments(function, args_size, 0);
             return false;
         }
     }
 #endif
 
     if (function->m_args_star_list_index != -1) {
-        makeStarListTupleCopy(function, python_pars, args, args_size);
+        makeStarListTupleCopy(tstate, function, python_pars, args, args_size);
     }
 
     return true;
 }
 
 static bool handleMethodArgumentsPlainOnly(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
                                            PyObject **python_pars, PyObject *object, PyObject *const *args,
@@ -2152,15 +2173,15 @@
     if (arg_count >= 1) {
         python_pars[0] = object;
         Py_INCREF(object);
     } else {
         // Without self, there can only be star list to get the object as its
         // first element. Or we complain about illegal arguments.
         if (function->m_args_star_list_index == 0) {
-            python_pars[0] = MAKE_TUPLE_EMPTY(args_size + 1);
+            python_pars[0] = MAKE_TUPLE_EMPTY(tstate, args_size + 1);
             PyTuple_SET_ITEM0(python_pars[0], 0, object);
 
             for (Py_ssize_t i = 0; i < args_size; i++) {
                 PyTuple_SET_ITEM0(python_pars[0], i + 1, args[i]);
             }
 
             return true;
@@ -2237,15 +2258,15 @@
             formatErrorTooManyArguments(function, args_size + 1, 0);
             return false;
         }
     }
 #endif
 
     if (function->m_args_star_list_index != -1) {
-        makeStarListTupleCopyMethod(function, python_pars, args, args_size);
+        makeStarListTupleCopyMethod(tstate, function, python_pars, args, args_size);
     }
 
     return true;
 }
 
 #if PYTHON_VERSION < 0x270
 static bool _handleArgumentsPlain(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
@@ -2367,15 +2388,15 @@
             formatErrorTooManyArguments(function, args_size, kw_only_found);
             return false;
         }
     }
 #endif
 
     if (function->m_args_star_list_index != -1) {
-        makeStarListTupleCopy(function, python_pars, args, args_size);
+        makeStarListTupleCopy(tstate, function, python_pars, args, args_size);
     }
 
     return true;
 }
 
 // Release them all in case of an error.
 static void releaseParameters(struct Nuitka_FunctionObject const *function, PyObject *const *python_pars) {
@@ -2434,15 +2455,15 @@
         releaseParameters(function, python_pars);
         return false;
     }
 
 #endif
 
     if (function->m_args_star_dict_index != -1) {
-        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY();
+        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY(tstate);
     }
 
     return true;
 }
 
 // We leave it to partial inlining to specialize this.
 static bool parseArgumentsEmpty(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
@@ -2486,15 +2507,15 @@
         releaseParameters(function, python_pars);
         return false;
     }
 
 #endif
 
     if (function->m_args_star_dict_index != -1) {
-        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY();
+        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY(tstate);
     }
 
     return true;
 }
 
 static bool parseArgumentsFullKwSplit(PyThreadState *tstate, struct Nuitka_FunctionObject const *function,
                                       PyObject **python_pars, PyObject *const *args, Py_ssize_t args_size,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledGeneratorType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledGeneratorType.c`

 * *Files 1% similar despite different names*

```diff
@@ -106,21 +106,23 @@
 
     if (generator->m_frame) {
         Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);
     }
 }
 
 static PyObject *Nuitka_Generator_tp_repr(struct Nuitka_GeneratorObject *generator) {
-    return Nuitka_String_FromFormat("<compiled_generator object %s at %p>",
-#if PYTHON_VERSION < 0x350
-                                    Nuitka_String_AsString(generator->m_name),
+#if PYTHON_VERSION < 0x300
+    return Nuitka_String_FromFormat("<compiled_generator object %s at %p>", Nuitka_String_AsString(generator->m_name),
+                                    generator);
+#elif PYTHON_VERSION < 0x350
+    return Nuitka_String_FromFormat("<compiled_generator object %U at %p>", generator->m_name, generator);
+
 #else
-                                    Nuitka_String_AsString(generator->m_qualname),
+    return Nuitka_String_FromFormat("<compiled_generator object %U at %p>", generator->m_qualname, generator);
 #endif
-                                    generator);
 }
 
 static long Nuitka_Generator_tp_traverse(struct Nuitka_GeneratorObject *generator, visitproc visit, void *arg) {
     CHECK_OBJECT(generator);
 
     // TODO: Identify the impact of not visiting owned objects like module.
 #if PYTHON_VERSION >= 0x300
@@ -171,15 +173,15 @@
             Py_DECREF(exception_value);
         } else {
             value = exception_value;
         }
     }
 
     if (value == NULL) {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         value = Py_None;
     }
 
     return value;
 }
 
 static PyObject *Nuitka_CallGeneratorThrowMethod(PyObject *throw_method,
@@ -361,15 +363,15 @@
     }
 
     // Check the sub-generator result
     if (retval == NULL) {
         PyObject *error = GET_ERROR_OCCURRED(tstate);
 
         if (error == NULL) {
-            Py_INCREF(Py_None);
+            Py_INCREF_IMMORTAL(Py_None);
             generator->m_returned = Py_None;
         } else if (likely(EXCEPTION_MATCH_BOOL_SINGLE(tstate, error, PyExc_StopIteration))) {
             // The sub-generator has given an exception. In case of
             // StopIteration, we need to check the value, as it is going to be
             // the expression value of this "yield from", and we are done. All
             // other errors, we need to raise.
             generator->m_returned = ERROR_GET_STOP_ITERATION_VALUE(tstate);
@@ -452,15 +454,15 @@
 
 #endif
 
 static void _Nuitka_GeneratorPopFrame(PyThreadState *tstate, Nuitka_ThreadStateFrameType *return_frame) {
 #if PYTHON_VERSION < 0x3b0
     tstate->frame = return_frame;
 #else
-    tstate->cframe->current_frame = return_frame;
+    CURRENT_TSTATE_INTERPRETER_FRAME(tstate) = return_frame;
 #endif
 
     PRINT_TOP_FRAME("Generator pop exit gives top frame:");
 }
 
 #if PYTHON_VERSION >= 0x350
 static void RAISE_RUNTIME_ERROR_RAISED_STOP_ITERATION(PyThreadState *tstate, char const *message) {
@@ -477,21 +479,19 @@
     SET_EXCEPTION_PRESERVATION_STATE_FROM_TYPE0_STR(tstate, &new_exception_state, PyExc_RuntimeError, message);
 
 #if PYTHON_VERSION < 0x3c0
     NORMALIZE_EXCEPTION(tstate, &new_exception_state.exception_type, &new_exception_state.exception_value,
                         &new_exception_state.exception_tb);
 #endif
 
-#if PYTHON_VERSION < 0x3c0
     Py_INCREF(saved_exception_state.exception_value);
     RAISE_EXCEPTION_WITH_CAUSE_STATE(tstate, &new_exception_state, saved_exception_state.exception_value);
 
     Py_INCREF(saved_exception_state.exception_value);
     PyException_SetContext(new_exception_state.exception_value, saved_exception_state.exception_value);
-#endif
 
     RELEASE_ERROR_OCCURRED_STATE_X(&saved_exception_state);
     RESTORE_ERROR_OCCURRED_STATE(tstate, &new_exception_state);
 }
 #endif
 
 static PyObject *_Nuitka_Generator_send(PyThreadState *tstate, struct Nuitka_GeneratorObject *generator,
@@ -595,15 +595,17 @@
         Nuitka_MarkGeneratorAsNotRunning(generator);
 
         // Remove the generator from the frame stack.
         if (generator->m_frame) {
             // assert(tstate->frame == &generator->m_frame->m_frame);
             assertFrameObject(generator->m_frame);
 
-            Py_CLEAR(generator->m_frame->m_frame.f_back);
+            if (generator->m_frame->m_frame.f_back) {
+                Py_CLEAR(generator->m_frame->m_frame.f_back);
+            }
         }
 
         // Return back to the frame that called us.
         _Nuitka_GeneratorPopFrame(tstate, return_frame);
 
 #if _DEBUG_GENERATOR
         PRINT_GENERATOR_STATUS("Returned from generator", generator);
@@ -702,17 +704,17 @@
                                   saved_exception_traceback ? (PyObject *)saved_exception_traceback : Py_None);
                 }
             } else {
                 tstate->exc_type = Py_None;
                 tstate->exc_value = Py_None;
                 tstate->exc_traceback = (PyObject *)Py_None;
 
-                Py_INCREF(Py_None);
-                Py_INCREF(Py_None);
-                Py_INCREF(Py_None);
+                Py_INCREF_IMMORTAL(Py_None);
+                Py_INCREF_IMMORTAL(Py_None);
+                Py_INCREF_IMMORTAL(Py_None);
 
                 Py_XDECREF(old_type);
                 Py_XDECREF(old_value);
                 Py_XDECREF(old_tb);
 
                 if (old_type != Py_None) {
                     DICT_SET_ITEM(sys_dict, const_str_plain_exc_type, Py_None);
@@ -763,26 +765,26 @@
 
     return result;
 }
 
 static PyObject *Nuitka_Generator_tp_iternext(struct Nuitka_GeneratorObject *generator) {
     PyThreadState *tstate = PyThreadState_GET();
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
 
     struct Nuitka_ExceptionPreservationItem exception_state;
     INIT_ERROR_OCCURRED_STATE(&exception_state);
 
     return _Nuitka_Generator_send(tstate, generator, Py_None, &exception_state);
 }
 
 /* Our own qiter interface, which is for quicker simple loop style iteration,
    that does not send anything in. */
 PyObject *Nuitka_Generator_qiter(PyThreadState *tstate, struct Nuitka_GeneratorObject *generator, bool *finished) {
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
 
     struct Nuitka_ExceptionPreservationItem exception_state;
     INIT_ERROR_OCCURRED_STATE(&exception_state);
 
     PyObject *result = _Nuitka_Generator_send(tstate, generator, Py_None, &exception_state);
 
     if (result == NULL) {
@@ -849,15 +851,15 @@
     PyThreadState *tstate = PyThreadState_GET();
 
     bool r = _Nuitka_Generator_close(tstate, generator);
 
     if (unlikely(r == false)) {
         return NULL;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 #if PYTHON_VERSION >= 0x3c0
 static bool _Nuitka_Generator_check_throw_args(PyThreadState *tstate, PyObject **exception_type,
                                                PyObject **exception_value, PyTracebackObject **exception_tb) {
@@ -1485,15 +1487,15 @@
 }
 
 static PyObject *Nuitka_Generator_get_yieldfrom(struct Nuitka_GeneratorObject *generator) {
     if (generator->m_yield_from) {
         Py_INCREF(generator->m_yield_from);
         return generator->m_yield_from;
     } else {
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 }
 
 #endif
 
 static PyObject *Nuitka_Generator_get_code(struct Nuitka_GeneratorObject *generator) {
@@ -1533,15 +1535,15 @@
     PyObject *result;
 
 /* The type of "gi_running" changed in Python3. */
 #if PYTHON_VERSION < 0x300
     result = PyInt_FromLong(generator->m_running);
 #else
     result = BOOL_FROM(generator->m_running != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
 #endif
     return result;
 }
 
 static int Nuitka_Generator_set_running(struct Nuitka_GeneratorObject *generator, PyObject *value) {
 #if PYTHON_VERSION < 0x300
     PyObject *exception_type = PyExc_TypeError;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledGeneratorTypeUncompiledIntegration.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledGeneratorTypeUncompiledIntegration.c`

 * *Files 12% similar despite different names*

```diff
@@ -20,43 +20,68 @@
 #endif
 
 #if PYTHON_VERSION >= 0x300
 static PyObject *Nuitka_CallGeneratorThrowMethod(PyObject *throw_method,
                                                  struct Nuitka_ExceptionPreservationItem *exception_state);
 #endif
 
+#if PYTHON_VERSION >= 0x300
+static PyBaseExceptionObject *Nuitka_BaseExceptionSingleArg_new(PyThreadState *tstate, PyTypeObject *type,
+                                                                PyObject *arg) {
+    PyBaseExceptionObject *result = (PyBaseExceptionObject *)type->tp_alloc(type, 0);
+
+    result->dict = NULL;
+    result->traceback = NULL;
+    result->cause = NULL;
+    result->context = NULL;
+    result->suppress_context = 0;
+
+    result->args = MAKE_TUPLE1(tstate, arg);
+
+    return result;
+}
+
+static PyObject *Nuitka_CreateStopIteration(PyThreadState *tstate, PyObject *value) {
+    PyStopIterationObject *result =
+        (PyStopIterationObject *)Nuitka_BaseExceptionSingleArg_new(tstate, (PyTypeObject *)PyExc_StopIteration, value);
+
+    result->value = value;
+    Py_INCREF(value);
+
+    return (PyObject *)result;
+}
+
 // This function takes no reference to value, and publishes a StopIteration
 // exception with it.
-#if PYTHON_VERSION >= 0x300
 static void Nuitka_SetStopIterationValue(PyThreadState *tstate, PyObject *value) {
     CHECK_OBJECT(value);
 
 #if PYTHON_VERSION <= 0x352
     PyObject *stop_value = CALL_FUNCTION_WITH_SINGLE_ARG(tstate, PyExc_StopIteration, value);
 
     if (unlikely(stop_value == NULL)) {
         return;
     }
 
     SET_CURRENT_EXCEPTION_TYPE0_VALUE1(tstate, PyExc_StopIteration, stop_value);
+#elif PYTHON_VERSION >= 0x3c0
+    struct Nuitka_ExceptionPreservationItem exception_state = {Nuitka_CreateStopIteration(tstate, value)};
+
+    RESTORE_ERROR_OCCURRED_STATE(tstate, &exception_state);
 #else
     if (likely(!PyTuple_Check(value) && !PyExceptionInstance_Check(value))) {
         Py_INCREF(PyExc_StopIteration);
         Py_INCREF(value);
 
         RESTORE_ERROR_OCCURRED(tstate, PyExc_StopIteration, value, NULL);
     } else {
-        PyObject *stop_value = CALL_FUNCTION_WITH_SINGLE_ARG(tstate, (PyObject *)PyExc_StopIteration, value);
+        struct Nuitka_ExceptionPreservationItem exception_state = {Py_NewRef(PyExc_StopIteration),
+                                                                   Nuitka_CreateStopIteration(tstate, value)};
 
-        if (unlikely(stop_value == NULL)) {
-            return;
-        }
-
-        Py_INCREF(PyExc_StopIteration);
-        RESTORE_ERROR_OCCURRED(tstate, PyExc_StopIteration, stop_value, NULL);
+        RESTORE_ERROR_OCCURRED_STATE(tstate, &exception_state);
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x370
 static inline void Nuitka_PyGen_exc_state_clear(_PyErr_StackItem *exc_state) {
@@ -99,53 +124,18 @@
 #endif
 
 // This is for CPython iterator objects, the respective code is not exported as
 // API, so we need to redo it. This is an re-implementation that closely follows
 // what it does. It's unrelated to compiled generators, and used from coroutines
 // and asyncgen to interact with them.
 static PyObject *Nuitka_PyGen_Send(PyThreadState *tstate, PyGenObject *gen, PyObject *arg) {
-#if defined(PY_NOGIL)
-    PyObject *res;
-
-    if (gen->status == GEN_CREATED) {
-        if (unlikely(arg != Py_None)) {
-            char const *msg = "generator raised StopIteration";
-            if (PyCoro_CheckExact(gen)) {
-                msg = "coroutine raised StopIteration";
-            } else if (PyAsyncGen_CheckExact(gen)) {
-                msg = "async generator raised StopIteration";
-            }
-
-            _PyErr_FormatFromCause(PyExc_RuntimeError, "%s", msg);
-            return NULL;
-        }
-        arg = NULL;
-    }
-
-    res = PyEval2_EvalGen(gen, arg);
-
-    if (likely(res != NULL)) {
-        assert(gen->status == GEN_SUSPENDED);
-        return res;
-    }
-
-    if (likely(gen->return_value == Py_None)) {
-        gen->return_value = NULL;
-        SET_CURRENT_EXCEPTION_TYPE0(tstate,
-                                    PyAsyncGen_CheckExact(gen) ? PyExc_StopAsyncIteration : PyExc_StopIteration);
-        return NULL;
-    } else if (gen->return_value != NULL) {
-        Nuitka_SetStopIterationValue(tstate, gen->return_value);
-        return NULL;
-    } else {
-        return gen_wrap_exception(gen);
-    }
-#elif PYTHON_VERSION >= 0x3a0
+#if PYTHON_VERSION >= 0x3a0
     PyObject *result;
 
+    // TODO: Avoid API call for performance.
     PySendResult res = PyIter_Send((PyObject *)gen, arg, &result);
 
     switch (res) {
     case PYGEN_RETURN:
         if (result == NULL) {
             SET_CURRENT_EXCEPTION_TYPE0(tstate, PyExc_StopIteration);
         } else {
@@ -298,15 +288,15 @@
     if (result) {
         if (!_PyFrameHasCompleted(f)) {
             return result;
         }
         assert(result == Py_None || !PyAsyncGen_CheckExact(gen));
 
         if (result == Py_None && !PyAsyncGen_CheckExact(gen)) {
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
             result = NULL;
         }
     } else {
         if (PyErr_ExceptionMatches(PyExc_StopIteration)) {
             const char *msg = "generator raised StopIteration";
             if (PyCoro_CheckExact(gen)) {
                 msg = "coroutine raised StopIteration";
@@ -333,28 +323,22 @@
 
     return result;
 #endif
 }
 
 #endif
 
-// TODO: Disabled for NOGIL until it becomes more ready.
+// TODO: Disabled for Python 3.13 until it becomes more ready.
 // Not done for earlier versions yet, indicate usability for compiled
 // generators, but it seems that mostly coroutines need it anyway, so the
 // benefit would be only for performance and not by a lot.
-#if PYTHON_VERSION >= 0x340 && !defined(PY_NOGIL)
+#if PYTHON_VERSION >= 0x340 && PYTHON_VERSION < 0x3d0
 #define NUITKA_UNCOMPILED_THROW_INTEGRATION 1
 #endif
 
-// TODO: Disabled for Python3.12 until release of it
-#if PYTHON_VERSION >= 0x3c0
-#undef NUITKA_UNCOMPILED_THROW_INTEGRATION
-#define NUITKA_UNCOMPILED_THROW_INTEGRATION 0
-#endif
-
 #if NUITKA_UNCOMPILED_THROW_INTEGRATION
 
 static bool _Nuitka_Generator_check_throw(PyThreadState *tstate,
                                           struct Nuitka_ExceptionPreservationItem *exception_state);
 
 #if PYTHON_VERSION < 0x3b0
 #include <opcode.h>
@@ -371,48 +355,46 @@
 #if PYTHON_VERSION >= 0x3b0
 
 // Private opcode mapping, that we need too
 // spell-checker: ignore deopt,subscr,isinstance,getitem,noargs,aiter,anext
 // spell-checker: ignore classderef,getattribute,precall
 const uint8_t Nuitka_PyOpcode_Deopt[256] = {
 #if PYTHON_VERSION >= 0x3c0
-    [ASYNC_GEN_WRAP] = ASYNC_GEN_WRAP,
     [BEFORE_ASYNC_WITH] = BEFORE_ASYNC_WITH,
     [BEFORE_WITH] = BEFORE_WITH,
     [BINARY_OP] = BINARY_OP,
-    [BINARY_OP_ADAPTIVE] = BINARY_OP,
     [BINARY_OP_ADD_FLOAT] = BINARY_OP,
     [BINARY_OP_ADD_INT] = BINARY_OP,
     [BINARY_OP_ADD_UNICODE] = BINARY_OP,
     [BINARY_OP_INPLACE_ADD_UNICODE] = BINARY_OP,
     [BINARY_OP_MULTIPLY_FLOAT] = BINARY_OP,
     [BINARY_OP_MULTIPLY_INT] = BINARY_OP,
     [BINARY_OP_SUBTRACT_FLOAT] = BINARY_OP,
     [BINARY_OP_SUBTRACT_INT] = BINARY_OP,
     [BINARY_SLICE] = BINARY_SLICE,
     [BINARY_SUBSCR] = BINARY_SUBSCR,
-    [BINARY_SUBSCR_ADAPTIVE] = BINARY_SUBSCR,
     [BINARY_SUBSCR_DICT] = BINARY_SUBSCR,
     [BINARY_SUBSCR_GETITEM] = BINARY_SUBSCR,
     [BINARY_SUBSCR_LIST_INT] = BINARY_SUBSCR,
     [BINARY_SUBSCR_TUPLE_INT] = BINARY_SUBSCR,
     [BUILD_CONST_KEY_MAP] = BUILD_CONST_KEY_MAP,
     [BUILD_LIST] = BUILD_LIST,
     [BUILD_MAP] = BUILD_MAP,
     [BUILD_SET] = BUILD_SET,
     [BUILD_SLICE] = BUILD_SLICE,
     [BUILD_STRING] = BUILD_STRING,
     [BUILD_TUPLE] = BUILD_TUPLE,
     [CACHE] = CACHE,
     [CALL] = CALL,
-    [CALL_ADAPTIVE] = CALL,
     [CALL_BOUND_METHOD_EXACT_ARGS] = CALL,
     [CALL_BUILTIN_CLASS] = CALL,
     [CALL_BUILTIN_FAST_WITH_KEYWORDS] = CALL,
     [CALL_FUNCTION_EX] = CALL_FUNCTION_EX,
+    [CALL_INTRINSIC_1] = CALL_INTRINSIC_1,
+    [CALL_INTRINSIC_2] = CALL_INTRINSIC_2,
     [CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS] = CALL,
     [CALL_NO_KW_BUILTIN_FAST] = CALL,
     [CALL_NO_KW_BUILTIN_O] = CALL,
     [CALL_NO_KW_ISINSTANCE] = CALL,
     [CALL_NO_KW_LEN] = CALL,
     [CALL_NO_KW_LIST_APPEND] = CALL,
     [CALL_NO_KW_METHOD_DESCRIPTOR_FAST] = CALL,
@@ -423,138 +405,152 @@
     [CALL_NO_KW_TYPE_1] = CALL,
     [CALL_PY_EXACT_ARGS] = CALL,
     [CALL_PY_WITH_DEFAULTS] = CALL,
     [CHECK_EG_MATCH] = CHECK_EG_MATCH,
     [CHECK_EXC_MATCH] = CHECK_EXC_MATCH,
     [CLEANUP_THROW] = CLEANUP_THROW,
     [COMPARE_OP] = COMPARE_OP,
-    [COMPARE_OP_ADAPTIVE] = COMPARE_OP,
-    [COMPARE_OP_FLOAT_JUMP] = COMPARE_OP,
-    [COMPARE_OP_INT_JUMP] = COMPARE_OP,
-    [COMPARE_OP_STR_JUMP] = COMPARE_OP,
+    [COMPARE_OP_FLOAT] = COMPARE_OP,
+    [COMPARE_OP_INT] = COMPARE_OP,
+    [COMPARE_OP_STR] = COMPARE_OP,
     [CONTAINS_OP] = CONTAINS_OP,
     [COPY] = COPY,
     [COPY_FREE_VARS] = COPY_FREE_VARS,
     [DELETE_ATTR] = DELETE_ATTR,
     [DELETE_DEREF] = DELETE_DEREF,
     [DELETE_FAST] = DELETE_FAST,
     [DELETE_GLOBAL] = DELETE_GLOBAL,
     [DELETE_NAME] = DELETE_NAME,
     [DELETE_SUBSCR] = DELETE_SUBSCR,
     [DICT_MERGE] = DICT_MERGE,
     [DICT_UPDATE] = DICT_UPDATE,
     [END_ASYNC_FOR] = END_ASYNC_FOR,
+    [END_FOR] = END_FOR,
+    [END_SEND] = END_SEND,
     [EXTENDED_ARG] = EXTENDED_ARG,
-    [EXTENDED_ARG_QUICK] = EXTENDED_ARG,
     [FORMAT_VALUE] = FORMAT_VALUE,
     [FOR_ITER] = FOR_ITER,
-    [FOR_ITER_ADAPTIVE] = FOR_ITER,
+    [FOR_ITER_GEN] = FOR_ITER,
     [FOR_ITER_LIST] = FOR_ITER,
     [FOR_ITER_RANGE] = FOR_ITER,
+    [FOR_ITER_TUPLE] = FOR_ITER,
     [GET_AITER] = GET_AITER,
     [GET_ANEXT] = GET_ANEXT,
     [GET_AWAITABLE] = GET_AWAITABLE,
     [GET_ITER] = GET_ITER,
     [GET_LEN] = GET_LEN,
     [GET_YIELD_FROM_ITER] = GET_YIELD_FROM_ITER,
     [IMPORT_FROM] = IMPORT_FROM,
     [IMPORT_NAME] = IMPORT_NAME,
-    [IMPORT_STAR] = IMPORT_STAR,
+    [INSTRUMENTED_CALL] = INSTRUMENTED_CALL,
+    [INSTRUMENTED_CALL_FUNCTION_EX] = INSTRUMENTED_CALL_FUNCTION_EX,
+    [INSTRUMENTED_END_FOR] = INSTRUMENTED_END_FOR,
+    [INSTRUMENTED_END_SEND] = INSTRUMENTED_END_SEND,
+    [INSTRUMENTED_FOR_ITER] = INSTRUMENTED_FOR_ITER,
+    [INSTRUMENTED_INSTRUCTION] = INSTRUMENTED_INSTRUCTION,
+    [INSTRUMENTED_JUMP_BACKWARD] = INSTRUMENTED_JUMP_BACKWARD,
+    [INSTRUMENTED_JUMP_FORWARD] = INSTRUMENTED_JUMP_FORWARD,
+    [INSTRUMENTED_LINE] = INSTRUMENTED_LINE,
+    [INSTRUMENTED_LOAD_SUPER_ATTR] = INSTRUMENTED_LOAD_SUPER_ATTR,
+    [INSTRUMENTED_POP_JUMP_IF_FALSE] = INSTRUMENTED_POP_JUMP_IF_FALSE,
+    [INSTRUMENTED_POP_JUMP_IF_NONE] = INSTRUMENTED_POP_JUMP_IF_NONE,
+    [INSTRUMENTED_POP_JUMP_IF_NOT_NONE] = INSTRUMENTED_POP_JUMP_IF_NOT_NONE,
+    [INSTRUMENTED_POP_JUMP_IF_TRUE] = INSTRUMENTED_POP_JUMP_IF_TRUE,
+    [INSTRUMENTED_RESUME] = INSTRUMENTED_RESUME,
+    [INSTRUMENTED_RETURN_CONST] = INSTRUMENTED_RETURN_CONST,
+    [INSTRUMENTED_RETURN_VALUE] = INSTRUMENTED_RETURN_VALUE,
+    [INSTRUMENTED_YIELD_VALUE] = INSTRUMENTED_YIELD_VALUE,
+    [INTERPRETER_EXIT] = INTERPRETER_EXIT,
     [IS_OP] = IS_OP,
     [JUMP_BACKWARD] = JUMP_BACKWARD,
     [JUMP_BACKWARD_NO_INTERRUPT] = JUMP_BACKWARD_NO_INTERRUPT,
-    [JUMP_BACKWARD_QUICK] = JUMP_BACKWARD,
     [JUMP_FORWARD] = JUMP_FORWARD,
-    [JUMP_IF_FALSE_OR_POP] = JUMP_IF_FALSE_OR_POP,
-    [JUMP_IF_TRUE_OR_POP] = JUMP_IF_TRUE_OR_POP,
     [KW_NAMES] = KW_NAMES,
     [LIST_APPEND] = LIST_APPEND,
     [LIST_EXTEND] = LIST_EXTEND,
-    [LIST_TO_TUPLE] = LIST_TO_TUPLE,
     [LOAD_ASSERTION_ERROR] = LOAD_ASSERTION_ERROR,
     [LOAD_ATTR] = LOAD_ATTR,
-    [LOAD_ATTR_ADAPTIVE] = LOAD_ATTR,
     [LOAD_ATTR_CLASS] = LOAD_ATTR,
     [LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN] = LOAD_ATTR,
     [LOAD_ATTR_INSTANCE_VALUE] = LOAD_ATTR,
     [LOAD_ATTR_METHOD_LAZY_DICT] = LOAD_ATTR,
     [LOAD_ATTR_METHOD_NO_DICT] = LOAD_ATTR,
-    [LOAD_ATTR_METHOD_WITH_DICT] = LOAD_ATTR,
     [LOAD_ATTR_METHOD_WITH_VALUES] = LOAD_ATTR,
     [LOAD_ATTR_MODULE] = LOAD_ATTR,
     [LOAD_ATTR_PROPERTY] = LOAD_ATTR,
     [LOAD_ATTR_SLOT] = LOAD_ATTR,
     [LOAD_ATTR_WITH_HINT] = LOAD_ATTR,
     [LOAD_BUILD_CLASS] = LOAD_BUILD_CLASS,
-    [LOAD_CLASSDEREF] = LOAD_CLASSDEREF,
     [LOAD_CLOSURE] = LOAD_CLOSURE,
     [LOAD_CONST] = LOAD_CONST,
     [LOAD_CONST__LOAD_FAST] = LOAD_CONST,
     [LOAD_DEREF] = LOAD_DEREF,
     [LOAD_FAST] = LOAD_FAST,
+    [LOAD_FAST_AND_CLEAR] = LOAD_FAST_AND_CLEAR,
     [LOAD_FAST_CHECK] = LOAD_FAST_CHECK,
     [LOAD_FAST__LOAD_CONST] = LOAD_FAST,
     [LOAD_FAST__LOAD_FAST] = LOAD_FAST,
+    [LOAD_FROM_DICT_OR_DEREF] = LOAD_FROM_DICT_OR_DEREF,
+    [LOAD_FROM_DICT_OR_GLOBALS] = LOAD_FROM_DICT_OR_GLOBALS,
     [LOAD_GLOBAL] = LOAD_GLOBAL,
-    [LOAD_GLOBAL_ADAPTIVE] = LOAD_GLOBAL,
     [LOAD_GLOBAL_BUILTIN] = LOAD_GLOBAL,
     [LOAD_GLOBAL_MODULE] = LOAD_GLOBAL,
+    [LOAD_LOCALS] = LOAD_LOCALS,
     [LOAD_NAME] = LOAD_NAME,
+    [LOAD_SUPER_ATTR] = LOAD_SUPER_ATTR,
+    [LOAD_SUPER_ATTR_ATTR] = LOAD_SUPER_ATTR,
+    [LOAD_SUPER_ATTR_METHOD] = LOAD_SUPER_ATTR,
     [MAKE_CELL] = MAKE_CELL,
     [MAKE_FUNCTION] = MAKE_FUNCTION,
     [MAP_ADD] = MAP_ADD,
     [MATCH_CLASS] = MATCH_CLASS,
     [MATCH_KEYS] = MATCH_KEYS,
     [MATCH_MAPPING] = MATCH_MAPPING,
     [MATCH_SEQUENCE] = MATCH_SEQUENCE,
     [NOP] = NOP,
     [POP_EXCEPT] = POP_EXCEPT,
     [POP_JUMP_IF_FALSE] = POP_JUMP_IF_FALSE,
     [POP_JUMP_IF_NONE] = POP_JUMP_IF_NONE,
     [POP_JUMP_IF_NOT_NONE] = POP_JUMP_IF_NOT_NONE,
     [POP_JUMP_IF_TRUE] = POP_JUMP_IF_TRUE,
     [POP_TOP] = POP_TOP,
-    [PREP_RERAISE_STAR] = PREP_RERAISE_STAR,
-    [PRINT_EXPR] = PRINT_EXPR,
     [PUSH_EXC_INFO] = PUSH_EXC_INFO,
     [PUSH_NULL] = PUSH_NULL,
     [RAISE_VARARGS] = RAISE_VARARGS,
     [RERAISE] = RERAISE,
+    [RESERVED] = RESERVED,
     [RESUME] = RESUME,
-    [RESUME_QUICK] = RESUME,
+    [RETURN_CONST] = RETURN_CONST,
     [RETURN_GENERATOR] = RETURN_GENERATOR,
     [RETURN_VALUE] = RETURN_VALUE,
     [SEND] = SEND,
+    [SEND_GEN] = SEND,
     [SETUP_ANNOTATIONS] = SETUP_ANNOTATIONS,
     [SET_ADD] = SET_ADD,
     [SET_UPDATE] = SET_UPDATE,
     [STORE_ATTR] = STORE_ATTR,
-    [STORE_ATTR_ADAPTIVE] = STORE_ATTR,
     [STORE_ATTR_INSTANCE_VALUE] = STORE_ATTR,
     [STORE_ATTR_SLOT] = STORE_ATTR,
     [STORE_ATTR_WITH_HINT] = STORE_ATTR,
     [STORE_DEREF] = STORE_DEREF,
     [STORE_FAST] = STORE_FAST,
     [STORE_FAST__LOAD_FAST] = STORE_FAST,
     [STORE_FAST__STORE_FAST] = STORE_FAST,
     [STORE_GLOBAL] = STORE_GLOBAL,
     [STORE_NAME] = STORE_NAME,
     [STORE_SLICE] = STORE_SLICE,
     [STORE_SUBSCR] = STORE_SUBSCR,
-    [STORE_SUBSCR_ADAPTIVE] = STORE_SUBSCR,
     [STORE_SUBSCR_DICT] = STORE_SUBSCR,
     [STORE_SUBSCR_LIST_INT] = STORE_SUBSCR,
     [SWAP] = SWAP,
     [UNARY_INVERT] = UNARY_INVERT,
     [UNARY_NEGATIVE] = UNARY_NEGATIVE,
     [UNARY_NOT] = UNARY_NOT,
-    [UNARY_POSITIVE] = UNARY_POSITIVE,
     [UNPACK_EX] = UNPACK_EX,
     [UNPACK_SEQUENCE] = UNPACK_SEQUENCE,
-    [UNPACK_SEQUENCE_ADAPTIVE] = UNPACK_SEQUENCE,
     [UNPACK_SEQUENCE_LIST] = UNPACK_SEQUENCE,
     [UNPACK_SEQUENCE_TUPLE] = UNPACK_SEQUENCE,
     [UNPACK_SEQUENCE_TWO_TUPLE] = UNPACK_SEQUENCE,
     [WITH_EXCEPT_START] = WITH_EXCEPT_START,
     [YIELD_VALUE] = YIELD_VALUE,
 #else
     [ASYNC_GEN_WRAP] = ASYNC_GEN_WRAP,
@@ -761,14 +757,15 @@
 
         Py_INCREF(yf);
     }
 
     return yf;
 }
 
+#if PYTHON_VERSION < 0x3c0
 // Because it is not exported, we need to duplicate this.
 static PyFrameObject *_Nuitka_PyFrame_New_NoTrack(PyCodeObject *code) {
     int slots = code->co_nlocalsplus + code->co_stacksize;
 
     PyFrameObject *f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type, slots);
 
     if (f == NULL) {
@@ -829,15 +826,14 @@
         return res;
     }
 
     return _Nuitka_PyFrame_MakeAndSetFrameObject(tstate, frame);
 }
 
 // Also not exported, taking over a frame object.
-
 static void _Nuitka_take_ownership(PyThreadState *tstate, PyFrameObject *f, _PyInterpreterFrame *frame) {
     assert(frame->owner != FRAME_OWNED_BY_FRAME_OBJECT);
     assert(frame->owner != FRAME_CLEARED);
 
     Py_ssize_t size = ((char *)&frame->localsplus[frame->stacktop]) - (char *)frame;
     memcpy((_PyInterpreterFrame *)f->_f_frame_data, frame, size);
 
@@ -898,17 +894,25 @@
     Py_XDECREF(frame->frame_obj);
     Py_XDECREF(frame->f_locals);
 #if PYTHON_VERSION < 0x3c0
     Py_DECREF(frame->f_func);
 #else
     Py_DECREF(frame->f_funcobj);
 #endif
-    Py_DECREF(frame->f_code);
+
+#if PYTHON_VERSION < 0x3d0
+    Py_XDECREF(frame->f_code);
+#else
+    Py_XDECREF(frame->f_executable);
+#endif
 }
+#endif
 
+// Needs to be similar to "gen_send_ex2" implementation in CPython. This is the low
+// end of an uncompiled generator receiving a value.
 static PySendResult Nuitka_PyGen_gen_send_ex2(PyThreadState *tstate, PyGenObject *gen, PyObject *arg,
                                               PyObject **presult, int exc, int closing) {
     _PyInterpreterFrame *frame = (_PyInterpreterFrame *)gen->gi_iframe;
     PyObject *result;
 
     *presult = NULL;
 
@@ -938,78 +942,99 @@
     }
 
     if (gen->gi_frame_state >= FRAME_COMPLETED) {
         if (PyCoro_CheckExact(gen) && !closing) {
             SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, "cannot reuse already awaited coroutine");
         } else if (arg && !exc) {
             *presult = Py_None;
-            Py_INCREF(*presult);
+            Py_INCREF_IMMORTAL(*presult);
             return PYGEN_RETURN;
         }
         return PYGEN_ERROR;
     }
 
     assert(gen->gi_frame_state < FRAME_EXECUTING);
 
     // Put arg on the frame's stack
     result = arg ? arg : Py_None;
     Py_INCREF(result);
     _PyFrame_StackPush(frame, result);
 
-    frame->previous = tstate->cframe->current_frame;
+#if PYTHON_VERSION < 0x3c0
+    frame->previous = CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
+#endif
+
+    _PyErr_StackItem *prev_exc_info = tstate->exc_info;
+    gen->gi_exc_state.previous_item = prev_exc_info;
 
-    gen->gi_exc_state.previous_item = tstate->exc_info;
     tstate->exc_info = &gen->gi_exc_state;
 
     if (exc) {
         assert(_PyErr_Occurred(tstate));
         _PyErr_ChainStackItem(NULL);
     }
 
     gen->gi_frame_state = FRAME_EXECUTING;
     result = _PyEval_EvalFrame(tstate, frame, exc);
+#if PYTHON_VERSION < 0x3c0
     if (gen->gi_frame_state == FRAME_EXECUTING) {
         gen->gi_frame_state = FRAME_COMPLETED;
     }
     tstate->exc_info = gen->gi_exc_state.previous_item;
     gen->gi_exc_state.previous_item = NULL;
 
-    assert(tstate->cframe->current_frame == frame->previous);
+    assert(CURRENT_TSTATE_INTERPRETER_FRAME(tstate) == frame->previous);
     frame->previous = NULL;
-
+#else
+    assert(tstate->exc_info == prev_exc_info);
+    assert(gen->gi_exc_state.previous_item == NULL);
+    assert(gen->gi_frame_state != FRAME_EXECUTING);
+    assert(frame->previous == NULL);
+#endif
     if (result != NULL) {
         if (gen->gi_frame_state == FRAME_SUSPENDED) {
             *presult = result;
             return PYGEN_NEXT;
         }
 
         assert(result == Py_None || !PyAsyncGen_CheckExact(gen));
 
         if (result == Py_None && !PyAsyncGen_CheckExact(gen) && !arg) {
+            // TODO: Have Py_CLEAR_IMMORTAL maybe
+
             Py_CLEAR(result);
         }
     } else {
+#if PYTHON_VERSION < 0x3c0
         if (PyErr_ExceptionMatches(PyExc_StopIteration)) {
             const char *msg = "generator raised StopIteration";
             if (PyCoro_CheckExact(gen)) {
                 msg = "coroutine raised StopIteration";
             } else if (PyAsyncGen_CheckExact(gen)) {
                 msg = "async generator raised StopIteration";
             }
             _PyErr_FormatFromCause(PyExc_RuntimeError, "%s", msg);
         } else if (PyAsyncGen_CheckExact(gen) && PyErr_ExceptionMatches(PyExc_StopAsyncIteration)) {
             const char *msg = "async generator raised StopAsyncIteration";
             _PyErr_FormatFromCause(PyExc_RuntimeError, "%s", msg);
         }
+#else
+        assert(!PyErr_ExceptionMatches(PyExc_StopIteration));
+        assert(!PyAsyncGen_CheckExact(gen) || !PyErr_ExceptionMatches(PyExc_StopAsyncIteration));
+
+#endif
     }
 
     _PyErr_ClearExcState(&gen->gi_exc_state);
 
     gen->gi_frame_state = FRAME_CLEARED;
+
+#if PYTHON_VERSION < 0x3c0
     _Nuitka_PyFrame_Clear(tstate, frame);
+#endif
 
     *presult = result;
     return result ? PYGEN_RETURN : PYGEN_ERROR;
 }
 
 static PyObject *Nuitka_PyGen_gen_send_ex(PyThreadState *tstate, PyGenObject *gen, PyObject *arg, int exc,
                                           int closing) {
@@ -1018,15 +1043,15 @@
     if (Nuitka_PyGen_gen_send_ex2(tstate, gen, arg, &result, exc, closing) == PYGEN_RETURN) {
         if (PyAsyncGen_CheckExact(gen)) {
             assert(result == Py_None);
             SET_CURRENT_EXCEPTION_TYPE0(tstate, PyExc_StopAsyncIteration);
         } else if (result == Py_None) {
             SET_CURRENT_EXCEPTION_TYPE0(tstate, PyExc_StopIteration);
         } else {
-            _PyGen_SetStopIterationValue(result);
+            Nuitka_SetStopIterationValue(tstate, result);
         }
 
         Py_DECREF(result);
         return NULL;
     }
 
     return result;
@@ -1048,16 +1073,15 @@
 #endif
 
     PyObject *yf = Nuitka_PyGen_yf(gen);
 
     if (yf != NULL) {
         _PyInterpreterFrame *frame = (_PyInterpreterFrame *)gen->gi_iframe;
 
-        if (close_on_genexit &&
-            EXCEPTION_MATCH_BOOL_SINGLE(tstate, exception_state->exception_type, PyExc_GeneratorExit)) {
+        if (close_on_genexit && EXCEPTION_STATE_MATCH_BOOL_SINGLE(tstate, exception_state, PyExc_GeneratorExit)) {
             PyFrameState state = (PyFrameState)gen->gi_frame_state;
             gen->gi_frame_state = FRAME_EXECUTING;
 
             int err = Nuitka_PyGen_gen_close_iter(tstate, yf);
 
             gen->gi_frame_state = state;
 
@@ -1074,24 +1098,24 @@
             // Handing exception ownership to this code.
             goto throw_here;
         }
 
         PyObject *ret;
 
         if (PyGen_CheckExact(yf) || PyCoro_CheckExact(yf)) {
-            _PyInterpreterFrame *prev = tstate->cframe->current_frame;
+            _PyInterpreterFrame *prev = CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
             frame->previous = prev;
-            tstate->cframe->current_frame = frame;
+            CURRENT_TSTATE_INTERPRETER_FRAME(tstate) = frame;
             PyFrameState state = (PyFrameState)gen->gi_frame_state;
             gen->gi_frame_state = FRAME_EXECUTING;
 
             // Handing exception ownership to "Nuitka_UncompiledGenerator_throw".
             ret = Nuitka_UncompiledGenerator_throw(tstate, (PyGenObject *)yf, close_on_genexit, exception_state);
             gen->gi_frame_state = state;
-            tstate->cframe->current_frame = prev;
+            CURRENT_TSTATE_INTERPRETER_FRAME(tstate) = prev;
             frame->previous = NULL;
         } else {
 #if 0
             // TODO: Add slow mode traces.
             PRINT_ITEM(yf);
             PRINT_NEW_LINE();
 #endif
@@ -1121,72 +1145,43 @@
             RELEASE_ERROR_OCCURRED_STATE(exception_state);
 
             Py_DECREF(meth);
         }
         Py_DECREF(yf);
 
         if (ret == NULL) {
+#if PYTHON_VERSION < 0x3c0
             PyObject *val;
             assert(gen->gi_frame_state < FRAME_CLEARED);
             ret = _PyFrame_StackPop((_PyInterpreterFrame *)gen->gi_iframe);
             assert(ret == yf);
             Py_DECREF(ret);
             assert(_PyInterpreterFrame_LASTI(frame) >= 0);
             assert(_Py_OPCODE(frame->prev_instr[-1]) == SEND);
             int jump = _Py_OPARG(frame->prev_instr[-1]);
             frame->prev_instr += jump - 1;
             if (_PyGen_FetchStopIterationValue(&val) == 0) {
                 ret = Nuitka_PyGen_gen_send_ex(tstate, gen, val, 0, 0);
                 Py_DECREF(val);
-            } else {
+            } else
+#endif
+            {
                 ret = Nuitka_PyGen_gen_send_ex(tstate, gen, Py_None, 1, 0);
             }
         }
 
         return ret;
     }
 
 throw_here:
-    if (exception_state->exception_tb == (PyTracebackObject *)Py_None) {
-        exception_state->exception_tb = NULL;
-        Py_DECREF(exception_state->exception_tb);
-    } else if (exception_state->exception_tb != NULL && !PyTraceBack_Check(exception_state->exception_tb)) {
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "throw() third argument must be a traceback object");
-        goto failed_throw;
-    }
-
     tstate = _PyThreadState_GET();
 
-    if (PyExceptionClass_Check(exception_state->exception_type)) {
-        Nuitka_Err_NormalizeException(tstate, &exception_state->exception_type, &exception_state->exception_value,
-                                      &exception_state->exception_tb);
-    } else if (PyExceptionInstance_Check(exception_state->exception_type)) {
-        if (exception_state->exception_value && exception_state->exception_value != Py_None) {
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError,
-                                            "instance exception may not have a separate value");
-            goto failed_throw;
-        } else {
-            // Normalize manually here via APIs
-            Py_XDECREF(exception_state->exception_value);
-            exception_state->exception_value = exception_state->exception_type;
-            exception_state->exception_type = PyExceptionInstance_Class(exception_state->exception_type);
-            Py_INCREF(exception_state->exception_type);
-
-            if (exception_state->exception_tb == NULL) {
-                // Can remain NULL if no traceback is available.
-                exception_state->exception_tb = GET_EXCEPTION_TRACEBACK(exception_state->exception_value);
-                Py_XINCREF(exception_state->exception_tb);
-            }
-        }
-    } else {
-        // Raisable
-        SET_CURRENT_EXCEPTION_TYPE_COMPLAINT(
-            "exceptions must be classes or instances deriving from BaseException, not %s",
-            exception_state->exception_type);
-        goto failed_throw;
+    if (unlikely(_Nuitka_Generator_check_throw(tstate, exception_state) == false)) {
+        // Exception was released by _Nuitka_Generator_check_throw already.
+        return NULL;
     }
 
     RESTORE_ERROR_OCCURRED_STATE(tstate, exception_state);
 
     return Nuitka_PyGen_gen_send_ex(tstate, gen, Py_None, 1, 1);
 
 failed_throw:
@@ -1356,14 +1351,15 @@
             {
                 SET_CURRENT_EXCEPTION_TYPE0(tstate, PyExc_StopIteration);
             }
         } else {
             Nuitka_SetStopIterationValue(tstate, result);
         }
 
+        // TODO: Add Py_CLEAR_IMMORTAL maybe
         Py_CLEAR(result);
     }
 #if PYTHON_VERSION >= 0x350
     else if (result == NULL && PyErr_ExceptionMatches(PyExc_StopIteration)) {
 #if PYTHON_VERSION < 0x370
         const int check_stop_iter_error_flags = CO_FUTURE_GENERATOR_STOP | CO_COROUTINE |
 #if PYTHON_VERSION >= 0x360
@@ -1423,14 +1419,15 @@
 #else
     if (result) {
         if (!_PyFrameHasCompleted(f)) {
             return result;
         }
         assert(result == Py_None || !PyAsyncGen_CheckExact(gen));
         if (result == Py_None && !PyAsyncGen_CheckExact(gen) && !arg) {
+            // TODO: Add Py_CLEAR_IMMORTAL maybe
             Py_CLEAR(result);
         }
     } else {
         if (PyErr_ExceptionMatches(PyExc_StopIteration)) {
             const char *msg = "generator raised StopIteration";
             if (PyCoro_CheckExact(gen)) {
                 msg = "coroutine raised StopIteration";
@@ -1705,15 +1702,15 @@
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_RuntimeError, msg);
         return NULL;
     }
 
     if (PyErr_ExceptionMatches(PyExc_StopIteration) || PyErr_ExceptionMatches(PyExc_GeneratorExit)) {
         CLEAR_ERROR_OCCURRED(tstate);
 
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
     return NULL;
 }
 
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/CompiledMethodType.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/CompiledMethodType.c`

 * *Files 2% similar despite different names*

```diff
@@ -40,29 +40,27 @@
     {(char *)"im_self", T_OBJECT, OFF(m_object), READONLY | RESTRICTED,
      (char *)"the instance to which a method is bound; None for unbound method"},
     {(char *)"__self__", T_OBJECT, OFF(m_object), READONLY | RESTRICTED,
      (char *)"the instance to which a method is bound; None for unbound method"},
     {NULL}};
 
 static PyObject *Nuitka_Method_reduce(struct Nuitka_MethodObject *method) {
-#if PYTHON_VERSION < 0x300
     PyThreadState *tstate = PyThreadState_GET();
 
+#if PYTHON_VERSION < 0x300
     // spell-checker: ignore instancemethod
     SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "can't pickle instancemethod objects");
     return NULL;
 #elif PYTHON_VERSION < 0x340
-    PyThreadState *tstate = PyThreadState_GET();
-
     SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "can't pickle method objects");
     return NULL;
 #else
-    PyObject *result = MAKE_TUPLE_EMPTY(2);
+    PyObject *result = MAKE_TUPLE_EMPTY(tstate, 2);
     PyTuple_SET_ITEM0(result, 0, LOOKUP_BUILTIN(const_str_plain_getattr));
-    PyObject *arg_tuple = MAKE_TUPLE2(method->m_object, method->m_function->m_name);
+    PyObject *arg_tuple = MAKE_TUPLE2(tstate, method->m_object, method->m_function->m_name);
     PyTuple_SET_ITEM(result, 1, arg_tuple);
 
     CHECK_OBJECT_DEEP(result);
 
     return result;
 #endif
 }
@@ -87,21 +85,21 @@
 
     PyObject *newobj_func = LOOKUP_ATTRIBUTE(tstate, copy_reg, const_str_plain___newobj__);
     Py_DECREF(copy_reg);
     if (unlikely(newobj_func == NULL)) {
         return NULL;
     }
 
-    PyObject *result = MAKE_TUPLE_EMPTY(5);
+    PyObject *result = MAKE_TUPLE_EMPTY(tstate, 5);
     PyTuple_SET_ITEM(result, 0, newobj_func);
-    PyObject *type_tuple = MAKE_TUPLE1((PyObject *)&Nuitka_Method_Type);
+    PyObject *type_tuple = MAKE_TUPLE1(tstate, (PyObject *)&Nuitka_Method_Type);
     PyTuple_SET_ITEM(result, 1, type_tuple);
-    PyTuple_SET_ITEM0(result, 2, Py_None);
-    PyTuple_SET_ITEM0(result, 3, Py_None);
-    PyTuple_SET_ITEM0(result, 4, Py_None);
+    PyTuple_SET_ITEM_IMMORTAL(result, 2, Py_None);
+    PyTuple_SET_ITEM_IMMORTAL(result, 3, Py_None);
+    PyTuple_SET_ITEM_IMMORTAL(result, 4, Py_None);
 
     CHECK_OBJECT_DEEP(result);
 
     return result;
 #else
     return Nuitka_Method_reduce(method);
 #endif
@@ -319,21 +317,21 @@
         else if (!PyUnicode_Check(object_repr)) {
             Py_DECREF(object_repr);
             return NULL;
         }
 #endif
 
 #if PYTHON_VERSION < 0x350
-        PyObject *result = Nuitka_String_FromFormat(
-            "<bound compiled_method %s.%s of %s>", GET_CLASS_NAME(method->m_class),
-            Nuitka_String_AsString(method->m_function->m_name), Nuitka_String_AsString_Unchecked(object_repr));
+        PyObject *result =
+            Nuitka_String_FromFormat("<bound compiled_method %s.%s of %s>", GET_CLASS_NAME(method->m_class),
+                                     Nuitka_String_AsString_Unchecked(method->m_function->m_name),
+                                     Nuitka_String_AsString_Unchecked(object_repr));
 #else
-        PyObject *result = PyUnicode_FromFormat("<bound compiled_method %s of %s>",
-                                                Nuitka_String_AsString(method->m_function->m_qualname),
-                                                Nuitka_String_AsString_Unchecked(object_repr));
+        PyObject *result =
+            PyUnicode_FromFormat("<bound compiled_method %U of %U>", method->m_function->m_qualname, object_repr);
 #endif
 
         Py_DECREF(object_repr);
 
         return result;
     }
 }
@@ -395,15 +393,15 @@
 
     if (op == Py_EQ) {
         result = BOOL_FROM(b_res);
     } else {
         result = BOOL_FROM(!b_res);
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static long Nuitka_Method_tp_hash(struct Nuitka_MethodObject *method) {
     // Just give the hash of the method function, that ought to be good enough.
     return method->m_function->m_counter;
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersAllocator.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersAllocator.c`

 * *Files 6% similar despite different names*

```diff
@@ -4,16 +4,52 @@
 
 // This file is included from another C file, help IDEs to still parse it on
 // its own.
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
+void *(*python_obj_malloc)(void *ctx, size_t size) = NULL;
+void *(*python_mem_malloc)(void *ctx, size_t size) = NULL;
+void *(*python_mem_calloc)(void *ctx, size_t nelem, size_t elsize) = NULL;
+
+#if defined(Py_DEBUG)
+void *python_obj_ctx = NULL;
+void *python_mem_ctx = NULL;
+#endif
+
+void initNuitkaAllocators(void) {
+    // PyMem_SetupDebugHooks();
+
+    PyMemAllocatorEx allocators;
+
+    PyMem_GetAllocator(PYMEM_DOMAIN_OBJ, &allocators);
+
+#if defined(Py_DEBUG)
+    python_obj_ctx = allocators.ctx;
+#endif
+
+    python_obj_malloc = allocators.malloc;
+
+    PyMem_GetAllocator(PYMEM_DOMAIN_MEM, &allocators);
+
+#if defined(Py_DEBUG)
+    python_mem_ctx = allocators.ctx;
+#endif
+
+    python_mem_malloc = allocators.malloc;
+    python_mem_calloc = allocators.calloc;
+}
+
+#if PYTHON_VERSION >= 0x3b0
+
 typedef struct _gc_runtime_state GCState;
 
+#if PYTHON_VERSION < 0x3d0
+
 #define AS_GC(o) ((PyGC_Head *)(((char *)(o)) - sizeof(PyGC_Head)))
 #define FROM_GC(g) ((PyObject *)(((char *)(g)) + sizeof(PyGC_Head)))
 
 static inline bool Nuitka_gc_is_collecting(PyGC_Head *g) { return (g->_gc_prev & _PyGC_PREV_MASK_COLLECTING) != 0; }
 
 static inline void Nuitka_gc_clear_collecting(PyGC_Head *g) { g->_gc_prev &= ~_PyGC_PREV_MASK_COLLECTING; }
 
@@ -592,16 +628,27 @@
             break;
         }
     }
 
     return n;
 }
 
+#else
+
+static void Nuitka_Py_ScheduleGC(PyThreadState *tstate) {
+    if (!_Py_eval_breaker_bit_is_set(tstate, _PY_GC_SCHEDULED_BIT)) {
+        _Py_set_eval_breaker_bit(tstate, _PY_GC_SCHEDULED_BIT);
+    }
+}
+
+#endif
+
 // This is called during object creation and might trigger garbage collection
 void Nuitka_PyObject_GC_Link(PyObject *op) {
+#if PYTHON_VERSION < 0x3d0
     PyGC_Head *g = AS_GC(op);
 
     PyThreadState *tstate = _PyThreadState_GET();
     GCState *gcstate = &tstate->interp->gc;
 
     g->_gc_next = 0;
     g->_gc_prev = 0;
@@ -610,16 +657,40 @@
     if (gcstate->generations[0].count > gcstate->generations[0].threshold && gcstate->enabled &&
         gcstate->generations[0].threshold && !gcstate->collecting && !HAS_ERROR_OCCURRED(tstate)) {
 
         gcstate->collecting = 1;
         Nuitka_gc_collect_generations(tstate);
         gcstate->collecting = 0;
     }
+#else
+    PyGC_Head *gc = _Py_AS_GC(op);
+
+    // gc must be correctly aligned
+    _PyObject_ASSERT(op, ((uintptr_t)gc & (sizeof(uintptr_t) - 1)) == 0);
+
+    // TODO: Have this passed.
+
+    PyThreadState *tstate = _PyThreadState_GET();
+    GCState *gcstate = &tstate->interp->gc;
+
+    gc->_gc_next = 0;
+    gc->_gc_prev = 0;
+
+    gcstate->young.count++;
+    gcstate->heap_size++;
+
+    if (gcstate->young.count > gcstate->young.threshold && gcstate->enabled && gcstate->young.threshold &&
+        !_Py_atomic_load_int_relaxed(&gcstate->collecting) && !_PyErr_Occurred(tstate)) {
+        Nuitka_Py_ScheduleGC(tstate);
+    }
+#endif
 }
 
+#endif
+
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
 //
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersAttributes.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersAttributes.c`

 * *Files 0% similar despite different names*

```diff
@@ -971,15 +971,15 @@
             return res >= 0;
         } else
 #endif
         {
             dict = *dict_pointer;
 
             if (dict == NULL) {
-                dict = MAKE_DICT_EMPTY();
+                dict = MAKE_DICT_EMPTY(tstate);
                 *dict_pointer = dict;
             }
         }
     }
 
     if (dict != NULL) {
         CHECK_OBJECT(dict);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBuiltin.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBuiltin.c`

 * *Files 1% similar despite different names*

```diff
@@ -34,25 +34,25 @@
     PyObject *kw_dict = NULL;
 
     while (i < max_args) {
         if (args[i] != NULL) {
             CHECK_OBJECT(args[i]);
 
             if (kw_dict == NULL) {
-                kw_dict = MAKE_DICT_EMPTY();
+                kw_dict = MAKE_DICT_EMPTY(tstate);
             }
 
             NUITKA_MAY_BE_UNUSED int res = PyDict_SetItemString(kw_dict, arg_names[i], args[i]);
             assert(res == 0);
         }
 
         i++;
     }
 
-    PyObject *args_tuple = MAKE_TUPLE(args, usable_args);
+    PyObject *args_tuple = MAKE_TUPLE(tstate, args, usable_args);
 
     PyObject *result = CALL_FUNCTION(tstate, callable, args_tuple, kw_dict);
     Py_XDECREF(kw_dict);
     Py_DECREF(args_tuple);
 
     return result;
 }
@@ -74,15 +74,15 @@
     // May be a source, but also could already be a compiled object, in which
     // case this should just return it.
     if (PyCode_Check(source_code)) {
         Py_INCREF(source_code);
         return source_code;
     }
 
-    PyObject *pos_args = MAKE_TUPLE3(source_code, file_name, mode);
+    PyObject *pos_args = MAKE_TUPLE3(tstate, source_code, file_name, mode);
 
     PyObject *kw_values[] = {
         flags,
         dont_inherit,
 #if PYTHON_VERSION >= 0x300
         optimize,
 #endif
@@ -589,15 +589,15 @@
     CHECK_OBJECT(result);
 
     Py_INCREF(result);
     return result;
 }
 
 PyObject *BUILTIN_TYPE3(PyThreadState *tstate, PyObject *module_name, PyObject *name, PyObject *bases, PyObject *dict) {
-    PyObject *pos_args = MAKE_TUPLE3(name, bases, dict);
+    PyObject *pos_args = MAKE_TUPLE3(tstate, name, bases, dict);
 
     PyObject *result = PyType_Type.tp_new(&PyType_Type, pos_args, NULL);
 
     if (unlikely(result == NULL)) {
         Py_DECREF(pos_args);
         return NULL;
     }
@@ -669,15 +669,15 @@
 /** The "callable" built-in.
  *
  **/
 
 PyObject *BUILTIN_CALLABLE(PyObject *value) {
     int res = PyCallable_Check(value);
     PyObject *result = BOOL_FROM(res != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 /* The "getattr" built-in with default value.
  *
  * We might want to split it off for a variant without default value.
  *
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBuiltinTypeMethods.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBuiltinTypeMethods.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersBytes.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersBytes.c`

 * *Files 1% similar despite different names*

```diff
@@ -61,18 +61,18 @@
 #else
         Py_INCREF(BYTES_EMPTY);
         return (PyObject *)BYTES_EMPTY;
 
 #endif
     }
 
-    op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + size);
+    op = (PyBytesObject *)NuitkaObject_Malloc(PyBytesObject_SIZE + size);
 
-    Py_SET_SIZE(op, size);
     Py_SET_TYPE(op, &PyBytes_Type);
+    Py_SET_SIZE(op, size);
 
     Nuitka_Py_NewReference((PyObject *)op);
 
     op->ob_shash = -1;
     memcpy(op->ob_sval, data, size);
     op->ob_sval[size] = '\0';
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersCalling.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersCalling.c`

 * *Files 1% similar despite different names*

```diff
@@ -76,14 +76,15 @@
         kwdefs,
 #endif
         PyFunction_GET_CLOSURE(func));
 
     return result;
 }
 
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
 static PyObject *callPythonFunctionNoArgs(PyObject *func) {
     PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
     PyObject *globals = PyFunction_GET_GLOBALS(func);
     PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
 
 #if PYTHON_VERSION >= 0x300
     PyObject *kwdefs = PyFunction_GET_KW_DEFAULTS(func);
@@ -141,14 +142,16 @@
 #endif
         PyFunction_GET_CLOSURE(func));
 
     return result;
 }
 #endif
 
+#endif
+
 PyObject *CALL_METHOD_WITH_POSARGS(PyThreadState *tstate, PyObject *source, PyObject *attr_name,
                                    PyObject *positional_args) {
     CHECK_OBJECT(source);
     CHECK_OBJECT(attr_name);
     CHECK_OBJECT(positional_args);
 
 #if PYTHON_VERSION < 0x300
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersCallingGenerated.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersCallingGenerated.c`

 * *Files 1% similar despite different names*

```diff
@@ -159,15 +159,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunctionNoArgs(called);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, NULL, 0, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -508,52 +508,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 1);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 1);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 1, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 1);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 1);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 1);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 1);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 1, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -586,15 +586,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 1);
+                pos_args = MAKE_TUPLE(tstate, args, 1);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -659,15 +659,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 1);
+                            pos_args = MAKE_TUPLE(tstate, args, 1);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -758,15 +758,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 1);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -949,15 +949,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 1);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 1, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -1294,52 +1294,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 2);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 2);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 2, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 2);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 2);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 2);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 2);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 2, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -1366,15 +1366,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 2);
+                pos_args = MAKE_TUPLE(tstate, args, 2);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -1438,15 +1438,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 2);
+                            pos_args = MAKE_TUPLE(tstate, args, 2);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -1537,15 +1537,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 2);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -1716,15 +1716,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 2);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 2, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -2054,52 +2054,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 3);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 3);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 3, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 3);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 3);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 3);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 3);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 3, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -2126,15 +2126,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 3);
+                pos_args = MAKE_TUPLE(tstate, args, 3);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -2198,15 +2198,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 3);
+                            pos_args = MAKE_TUPLE(tstate, args, 3);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -2297,15 +2297,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 3);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -2476,15 +2476,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 3);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 3, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -2814,52 +2814,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 4);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 4);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 4, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 4);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 4);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 4);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 4);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 4, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -2886,15 +2886,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 4);
+                pos_args = MAKE_TUPLE(tstate, args, 4);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -2958,15 +2958,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 4);
+                            pos_args = MAKE_TUPLE(tstate, args, 4);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -3057,15 +3057,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 4);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -3236,15 +3236,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 4);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 4, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -3574,52 +3574,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 5);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 5);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 5, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 5);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 5);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 5);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 5);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 5, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -3646,15 +3646,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 5);
+                pos_args = MAKE_TUPLE(tstate, args, 5);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -3718,15 +3718,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 5);
+                            pos_args = MAKE_TUPLE(tstate, args, 5);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -3817,15 +3817,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 5);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -3996,15 +3996,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 5);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 5, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -4334,52 +4334,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 6);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 6);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 6, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 6);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 6);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 6);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 6);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 6, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -4406,15 +4406,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 6);
+                pos_args = MAKE_TUPLE(tstate, args, 6);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -4478,15 +4478,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 6);
+                            pos_args = MAKE_TUPLE(tstate, args, 6);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -4577,15 +4577,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 6);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -4756,15 +4756,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 6);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 6, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -5094,52 +5094,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 7);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 7);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 7, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 7);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 7);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 7);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 7);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 7, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -5166,15 +5166,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 7);
+                pos_args = MAKE_TUPLE(tstate, args, 7);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -5238,15 +5238,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 7);
+                            pos_args = MAKE_TUPLE(tstate, args, 7);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -5337,15 +5337,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 7);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -5516,15 +5516,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 7);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 7, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -5854,52 +5854,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 8);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 8);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 8, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 8);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 8);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 8);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 8);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 8, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -5926,15 +5926,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 8);
+                pos_args = MAKE_TUPLE(tstate, args, 8);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -5998,15 +5998,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 8);
+                            pos_args = MAKE_TUPLE(tstate, args, 8);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -6097,15 +6097,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 8);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -6276,15 +6276,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 8);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 8, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -6614,52 +6614,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 9);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 9);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 9, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 9);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 9);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 9);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 9);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 9, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -6686,15 +6686,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 9);
+                pos_args = MAKE_TUPLE(tstate, args, 9);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -6758,15 +6758,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 9);
+                            pos_args = MAKE_TUPLE(tstate, args, 9);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -6857,15 +6857,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 9);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -7036,15 +7036,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 9);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 9, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -7374,52 +7374,52 @@
 #endif
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-            PyObject *pos_args = MAKE_TUPLE(args, 10);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
             }
 
             Py_DECREF(pos_args);
 #else
             if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-                PyObject *pos_args = MAKE_TUPLE(args, 10);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
                 Py_DECREF(pos_args);
             } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, 10, NULL);
 #else
-                PyObject *pos_args = MAKE_TUPLE(args, 10);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, 10);
                 Py_DECREF(pos_args);
 #endif
             } else {
-                PyObject *pos_args = MAKE_TUPLE(args, 10);
+                PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
                 result = (*method)(self, pos_args);
                 Py_DECREF(pos_args);
             }
 #endif
 
 #ifdef _NUITKA_FULL_COMPAT
             Py_LeaveRecursiveCall();
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 10);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 10, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -7446,15 +7446,15 @@
                     formatCannotInstantiateAbstractClass(tstate, called_type);
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
-                pos_args = MAKE_TUPLE(args, 10);
+                pos_args = MAKE_TUPLE(tstate, args, 10);
                 obj = called_type->tp_new(called_type, pos_args, NULL);
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
                     Py_DECREF(pos_args);
                     return obj;
@@ -7518,15 +7518,15 @@
                             Py_DECREF(obj);
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, 10);
+                            pos_args = MAKE_TUPLE(tstate, args, 10);
                         }
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
                             Py_XDECREF(pos_args);
                             return NULL;
                         }
@@ -7617,15 +7617,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 10);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     CHECK_OBJECT_X(result);
 
@@ -7796,15 +7796,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
         PyObject *result = callPythonFunction(called, args, 10);
 #else
         PyObject *result = _PyFunction_Vectorcall(called, args, 10, NULL);
 #endif
         CHECK_OBJECT_X(result);
@@ -8137,15 +8137,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 1);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[1 + i];
@@ -8225,15 +8225,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 1);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -8396,15 +8396,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 2);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[2 + i];
@@ -8484,15 +8484,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 2);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -8655,15 +8655,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 3);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[3 + i];
@@ -8743,15 +8743,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 3);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -8914,15 +8914,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 4);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[4 + i];
@@ -9002,15 +9002,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 4);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -9173,15 +9173,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 5);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[5 + i];
@@ -9261,15 +9261,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 5);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 5);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -9432,15 +9432,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 6);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[6 + i];
@@ -9520,15 +9520,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 6);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 6);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -9691,15 +9691,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 7);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[7 + i];
@@ -9779,15 +9779,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 7);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 7);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -9950,15 +9950,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 8);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[8 + i];
@@ -10038,15 +10038,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 8);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 8);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -10209,15 +10209,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 9);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[9 + i];
@@ -10297,15 +10297,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 9);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 9);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -10468,15 +10468,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 10);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = args[10 + i];
@@ -10556,15 +10556,15 @@
         return NULL;
     }
 
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
-    PyObject *pos_args = MAKE_TUPLE(args, 10);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 10);
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
 
         PyObject *value = kw_values[i];
@@ -10714,38 +10714,38 @@
     } else if (flags & METH_VARARGS) {
         PyCFunction method = method_def->ml_meth;
         PyObject *self = args[0];
 
         PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-        PyObject *pos_args = MAKE_TUPLE(args + 1, 0);
+        PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 0);
 
         if (flags & METH_KEYWORDS) {
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
         } else {
             result = (*method)(self, pos_args);
         }
 
         Py_DECREF(pos_args);
 #else
         if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 0);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 0);
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             Py_DECREF(pos_args);
         } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
             result = (*(_PyCFunctionFast)method)(self, (PyObject **)args + 1, 0, NULL);
 #else
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 0);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 0);
             result = (*(_PyCFunctionFast)method)(self, &pos_args, 1);
             Py_DECREF(pos_args);
 #endif
         } else {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 0);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 0);
             result = (*method)(self, pos_args);
             Py_DECREF(pos_args);
         }
 #endif
 #ifndef __NUITKA_NO_ASSERT__
         return Nuitka_CheckFunctionResult(tstate, called, result);
 #else
@@ -10756,15 +10756,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 1);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 1);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     return result;
 #endif
@@ -10816,38 +10816,38 @@
     } else if (flags & METH_VARARGS) {
         PyCFunction method = method_def->ml_meth;
         PyObject *self = args[0];
 
         PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-        PyObject *pos_args = MAKE_TUPLE(args + 1, 1);
+        PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 1);
 
         if (flags & METH_KEYWORDS) {
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
         } else {
             result = (*method)(self, pos_args);
         }
 
         Py_DECREF(pos_args);
 #else
         if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 1);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 1);
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             Py_DECREF(pos_args);
         } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
             result = (*(_PyCFunctionFast)method)(self, (PyObject **)args + 1, 1, NULL);
 #else
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 1);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 1);
             result = (*(_PyCFunctionFast)method)(self, &pos_args, 2);
             Py_DECREF(pos_args);
 #endif
         } else {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 1);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 1);
             result = (*method)(self, pos_args);
             Py_DECREF(pos_args);
         }
 #endif
 #ifndef __NUITKA_NO_ASSERT__
         return Nuitka_CheckFunctionResult(tstate, called, result);
 #else
@@ -10858,15 +10858,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 2);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 2);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     return result;
 #endif
@@ -10911,38 +10911,38 @@
     } else if (flags & METH_VARARGS) {
         PyCFunction method = method_def->ml_meth;
         PyObject *self = args[0];
 
         PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-        PyObject *pos_args = MAKE_TUPLE(args + 1, 2);
+        PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 2);
 
         if (flags & METH_KEYWORDS) {
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
         } else {
             result = (*method)(self, pos_args);
         }
 
         Py_DECREF(pos_args);
 #else
         if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 2);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 2);
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             Py_DECREF(pos_args);
         } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
             result = (*(_PyCFunctionFast)method)(self, (PyObject **)args + 1, 2, NULL);
 #else
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 2);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 2);
             result = (*(_PyCFunctionFast)method)(self, &pos_args, 3);
             Py_DECREF(pos_args);
 #endif
         } else {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 2);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 2);
             result = (*method)(self, pos_args);
             Py_DECREF(pos_args);
         }
 #endif
 #ifndef __NUITKA_NO_ASSERT__
         return Nuitka_CheckFunctionResult(tstate, called, result);
 #else
@@ -10953,15 +10953,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 3);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 3);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     return result;
 #endif
@@ -11006,38 +11006,38 @@
     } else if (flags & METH_VARARGS) {
         PyCFunction method = method_def->ml_meth;
         PyObject *self = args[0];
 
         PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-        PyObject *pos_args = MAKE_TUPLE(args + 1, 3);
+        PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 3);
 
         if (flags & METH_KEYWORDS) {
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
         } else {
             result = (*method)(self, pos_args);
         }
 
         Py_DECREF(pos_args);
 #else
         if (flags == (METH_VARARGS | METH_KEYWORDS)) {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 3);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 3);
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             Py_DECREF(pos_args);
         } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
             result = (*(_PyCFunctionFast)method)(self, (PyObject **)args + 1, 3, NULL);
 #else
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 3);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 3);
             result = (*(_PyCFunctionFast)method)(self, &pos_args, 4);
             Py_DECREF(pos_args);
 #endif
         } else {
-            PyObject *pos_args = MAKE_TUPLE(args + 1, 3);
+            PyObject *pos_args = MAKE_TUPLE(tstate, args + 1, 3);
             result = (*method)(self, pos_args);
             Py_DECREF(pos_args);
         }
 #endif
 #ifndef __NUITKA_NO_ASSERT__
         return Nuitka_CheckFunctionResult(tstate, called, result);
 #else
@@ -11048,15 +11048,15 @@
 #if 0
     PRINT_NEW_LINE();
     PRINT_STRING("FALLBACK");
     PRINT_ITEM(called);
     PRINT_NEW_LINE();
 #endif
 
-    PyObject *pos_args = MAKE_TUPLE(args, 4);
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, 4);
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 
     return result;
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersChecksumTools.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersChecksumTools.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersClasses.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersClasses.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonEq.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonLe.c`

 * *Files 3% similar despite different names*

```diff
@@ -3,67 +3,66 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationComparison.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-#include "HelpersComparisonEqUtils.c"
-/* C helpers for type specialized "==" (EQ) comparisons */
+/* C helpers for type specialized "<=" (LE) comparisons */
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_EQ_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_EQ_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 #endif
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
         bool r = true;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
@@ -79,23 +78,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -103,15 +102,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -128,62 +127,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -240,15 +239,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -263,103 +262,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
         bool r = true;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
@@ -383,15 +382,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -399,15 +398,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -415,15 +414,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -452,15 +451,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -468,21 +467,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -490,20 +489,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -511,15 +510,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -576,15 +575,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -611,15 +610,15 @@
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -627,22 +626,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -650,22 +649,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -673,100 +672,99 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_EQ_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    if (len_a != len_b) {
-        bool r = false;
-
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
-    } else {
-        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = true;
+    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
+    int c;
 
-            // Convert to target type.
-            PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
-            return result;
-        } else {
-            bool r = false;
+    if (min_len > 0) {
+        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
 
-            // Convert to target type.
-            PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
-            return result;
+        if (c == 0) {
+            c = memcmp(a->ob_sval, b->ob_sval, min_len);
         }
+    } else {
+        c = 0;
     }
+
+    if (c == 0) {
+        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
+    }
+
+    c = c <= 0;
+
+    // Convert to target type.
+    PyObject *result = BOOL_FROM(c != 0);
+    Py_INCREF_IMMORTAL(result);
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -780,23 +778,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -804,15 +802,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -829,62 +827,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -941,15 +939,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -964,103 +962,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -1074,23 +1072,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1098,15 +1096,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1123,62 +1121,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1235,15 +1233,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1258,107 +1256,107 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
+    return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_EQ_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
@@ -1372,52 +1370,51 @@
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    if (len_a != len_b) {
-        bool r = false;
+    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
+    int c;
 
-        // Convert to target type.
-        bool result = r;
+    if (min_len > 0) {
+        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
 
-        return result;
+        if (c == 0) {
+            c = memcmp(a->ob_sval, b->ob_sval, min_len);
+        }
     } else {
-        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = true;
+        c = 0;
+    }
 
-            // Convert to target type.
-            bool result = r;
+    if (c == 0) {
+        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
+    }
 
-            return result;
-        } else {
-            bool r = false;
+    c = c <= 0;
 
-            // Convert to target type.
-            bool result = r;
+    // Convert to target type.
+    bool result = c != 0;
 
-            return result;
-        }
-    }
+    return result;
 }
 /* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
-bool RICH_COMPARE_EQ_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2);
+    return COMPARE_LE_CBOOL_STR_STR(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1431,15 +1428,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1447,15 +1444,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1463,15 +1460,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1500,15 +1497,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1516,21 +1513,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1538,20 +1535,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1559,15 +1556,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1624,15 +1621,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1659,15 +1656,15 @@
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1675,22 +1672,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1698,22 +1695,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1721,53 +1718,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1781,15 +1778,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1797,15 +1794,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1813,15 +1810,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1850,15 +1847,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1866,21 +1863,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1888,20 +1885,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1909,15 +1906,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1974,15 +1971,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2009,15 +2006,15 @@
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2025,22 +2022,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2048,22 +2045,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2071,131 +2068,76 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_EQ_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
-#if PYTHON_VERSION >= 0x300
-    bool r;
+    PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LE);
+    CHECK_OBJECT(r);
 
-    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
-    if (PyUnicode_GET_LENGTH(b) != len) {
-        r = false;
-    } else {
-        int kind1 = PyUnicode_KIND(a);
-#if PYTHON_VERSION < 0x3c0
-        if (unlikely(kind1 == 0)) {
-            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)a);
-            assert(res != -1);
-            kind1 = PyUnicode_KIND(a);
-            assert(kind1 != 0);
-        }
-#endif
-
-        int kind2 = PyUnicode_KIND(b);
-#if PYTHON_VERSION < 0x3c0
-        if (unlikely(kind2 == 0)) {
-            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)b);
-            assert(res != -1);
-            kind2 = PyUnicode_KIND(b);
-            assert(kind2 != 0);
-        }
-#endif
-
-        if (kind1 != kind2) {
-            r = false;
-        } else {
-            const void *data1 = PyUnicode_DATA(a);
-            const void *data2 = PyUnicode_DATA(b);
-
-            int cmp = memcmp(data1, data2, len * kind1);
-            r = (cmp == 0);
-        }
-    }
-
-    PyObject *result = BOOL_FROM(r == true);
-    Py_INCREF(result);
-    return result;
-#else
-    bool r;
-
-    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
-    if (PyUnicode_GET_LENGTH(b) != len) {
-        r = false;
-    } else {
-        const Py_UNICODE *data1 = a->str;
-        const Py_UNICODE *data2 = b->str;
-
-        int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
-        r = (cmp == 0);
-    }
-
-    PyObject *result = BOOL_FROM(r == true);
-    Py_INCREF(result);
-    return result;
-#endif
+    return r;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2209,23 +2151,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2233,15 +2175,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2258,62 +2200,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2370,15 +2312,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2393,103 +2335,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2503,23 +2445,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2527,15 +2469,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2552,62 +2494,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2664,15 +2606,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2687,106 +2629,106 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() <= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
  * Python3 'str'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
+    return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
 }
 
-static bool COMPARE_EQ_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
@@ -2797,86 +2739,35 @@
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
-#if PYTHON_VERSION >= 0x300
-    bool r;
-
-    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
-    if (PyUnicode_GET_LENGTH(b) != len) {
-        r = false;
-    } else {
-        int kind1 = PyUnicode_KIND(a);
-#if PYTHON_VERSION < 0x3c0
-        if (unlikely(kind1 == 0)) {
-            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)a);
-            assert(res != -1);
-            kind1 = PyUnicode_KIND(a);
-            assert(kind1 != 0);
-        }
-#endif
-
-        int kind2 = PyUnicode_KIND(b);
-#if PYTHON_VERSION < 0x3c0
-        if (unlikely(kind2 == 0)) {
-            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)b);
-            assert(res != -1);
-            kind2 = PyUnicode_KIND(b);
-            assert(kind2 != 0);
-        }
-#endif
-
-        if (kind1 != kind2) {
-            r = false;
-        } else {
-            const void *data1 = PyUnicode_DATA(a);
-            const void *data2 = PyUnicode_DATA(b);
-
-            int cmp = memcmp(data1, data2, len * kind1);
-            r = (cmp == 0);
-        }
-    }
-
-    bool result = r == true;
-
-    return result;
-#else
-    bool r;
-
-    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
-    if (PyUnicode_GET_LENGTH(b) != len) {
-        r = false;
-    } else {
-        const Py_UNICODE *data1 = a->str;
-        const Py_UNICODE *data2 = b->str;
-
-        int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
-        r = (cmp == 0);
-    }
+    PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LE);
+    CHECK_OBJECT(r);
 
-    bool result = r == true;
+    // Convert to target type if necessary
+    bool result = r == Py_True;
+    Py_DECREF_IMMORTAL(r);
 
     return result;
-#endif
 }
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
  * Python3 'str'. */
-bool RICH_COMPARE_EQ_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2);
+    return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -2890,15 +2781,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2906,15 +2797,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2922,15 +2813,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2959,15 +2850,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2975,21 +2866,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2997,20 +2888,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3018,15 +2909,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3083,15 +2974,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3118,15 +3009,15 @@
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3134,22 +3025,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3157,22 +3048,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3180,53 +3071,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -3240,15 +3131,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3256,15 +3147,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3272,15 +3163,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3309,15 +3200,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3325,21 +3216,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3347,20 +3238,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3368,15 +3259,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3433,15 +3324,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3468,15 +3359,15 @@
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3484,22 +3375,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3507,22 +3398,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3530,101 +3421,100 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() <= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION >= 0x300
-static PyObject *COMPARE_EQ_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    if (len_a != len_b) {
-        bool r = false;
-
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
-    } else {
-        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = true;
+    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
+    int c;
 
-            // Convert to target type.
-            PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
-            return result;
-        } else {
-            bool r = false;
+    if (min_len > 0) {
+        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
 
-            // Convert to target type.
-            PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
-            return result;
+        if (c == 0) {
+            c = memcmp(a->ob_sval, b->ob_sval, min_len);
         }
+    } else {
+        c = 0;
+    }
+
+    if (c == 0) {
+        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
+
+    c = c <= 0;
+
+    // Convert to target type.
+    PyObject *result = BOOL_FROM(c != 0);
+    Py_INCREF_IMMORTAL(result);
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3638,23 +3528,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3662,15 +3552,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3687,62 +3577,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3799,15 +3689,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3822,103 +3712,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3932,23 +3822,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3956,15 +3846,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3981,62 +3871,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4093,15 +3983,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4116,107 +4006,107 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
+    return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
-static bool COMPARE_EQ_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
@@ -4230,52 +4120,51 @@
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    if (len_a != len_b) {
-        bool r = false;
+    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
+    int c;
 
-        // Convert to target type.
-        bool result = r;
+    if (min_len > 0) {
+        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
 
-        return result;
+        if (c == 0) {
+            c = memcmp(a->ob_sval, b->ob_sval, min_len);
+        }
     } else {
-        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = true;
+        c = 0;
+    }
 
-            // Convert to target type.
-            bool result = r;
+    if (c == 0) {
+        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
+    }
 
-            return result;
-        } else {
-            bool r = false;
+    c = c <= 0;
 
-            // Convert to target type.
-            bool result = r;
+    // Convert to target type.
+    bool result = c != 0;
 
-            return result;
-        }
-    }
+    return result;
 }
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
-bool RICH_COMPARE_EQ_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2);
+    return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4289,15 +4178,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4305,15 +4194,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4321,15 +4210,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4358,15 +4247,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4374,21 +4263,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4396,20 +4285,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4417,15 +4306,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4482,15 +4371,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4517,15 +4406,15 @@
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4533,22 +4422,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4556,22 +4445,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4579,53 +4468,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4639,15 +4528,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4655,15 +4544,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4671,15 +4560,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4708,15 +4597,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4724,21 +4613,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4746,20 +4635,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4767,15 +4656,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4832,15 +4721,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4867,15 +4756,15 @@
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4883,22 +4772,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4906,22 +4795,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4929,53 +4818,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -4989,23 +4878,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5013,15 +4902,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5038,62 +4927,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5150,15 +5039,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5173,103 +5062,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -5283,23 +5172,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5307,15 +5196,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5332,62 +5221,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5444,15 +5333,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5467,119 +5356,119 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
+    return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-bool RICH_COMPARE_EQ_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2);
+    return COMPARE_LE_CBOOL_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5593,15 +5482,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5609,15 +5498,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5625,15 +5514,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5662,15 +5551,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5678,21 +5567,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5700,20 +5589,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5721,15 +5610,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5786,15 +5675,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5821,15 +5710,15 @@
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5837,22 +5726,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5860,22 +5749,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5883,53 +5772,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5943,15 +5832,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5959,15 +5848,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5975,15 +5864,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6012,15 +5901,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6028,21 +5917,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6050,20 +5939,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6071,15 +5960,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6136,15 +6025,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6171,15 +6060,15 @@
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6187,22 +6076,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6210,22 +6099,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6233,48 +6122,48 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_EQ_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
@@ -6282,38 +6171,42 @@
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
         r = true;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - Nuitka_LongGetSignedDigitSize(operand2_long_object) <
+            0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] <
+                    Nuitka_LongGetDigitPointer(operand2_long_object)[i];
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6327,23 +6220,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6351,15 +6244,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6376,62 +6269,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6488,15 +6381,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6511,103 +6404,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6621,23 +6514,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6645,15 +6538,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6670,62 +6563,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6782,15 +6675,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6805,105 +6698,105 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() <= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
+    return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
 }
 
-static bool COMPARE_EQ_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
@@ -6911,44 +6804,48 @@
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
         r = true;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - Nuitka_LongGetSignedDigitSize(operand2_long_object) <
+            0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] <
+                    Nuitka_LongGetDigitPointer(operand2_long_object)[i];
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-bool RICH_COMPARE_EQ_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2);
+    return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -6962,15 +6859,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6978,15 +6875,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6994,15 +6891,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7031,15 +6928,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7047,21 +6944,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7069,20 +6966,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7090,15 +6987,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7155,15 +7052,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7190,15 +7087,15 @@
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7206,22 +7103,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7229,22 +7126,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7252,53 +7149,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -7312,15 +7209,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7328,15 +7225,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7344,15 +7241,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7381,15 +7278,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7397,21 +7294,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7419,20 +7316,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7440,15 +7337,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7505,15 +7402,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7540,15 +7437,15 @@
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7556,22 +7453,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7579,22 +7476,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7602,69 +7499,69 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() <= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_EQ_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7678,23 +7575,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7702,15 +7599,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7727,62 +7624,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7839,15 +7736,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7862,101 +7759,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7970,23 +7867,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7994,15 +7891,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8019,62 +7916,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8131,15 +8028,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8154,129 +8051,129 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
+    return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
 }
 
-static bool COMPARE_EQ_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_LE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-bool RICH_COMPARE_EQ_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2);
+    return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8290,15 +8187,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8306,15 +8203,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8322,15 +8219,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8359,15 +8256,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8375,21 +8272,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8397,20 +8294,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8418,15 +8315,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8483,15 +8380,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8518,15 +8415,15 @@
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8534,22 +8431,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8557,22 +8454,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8580,51 +8477,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8638,15 +8535,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8654,15 +8551,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8670,15 +8567,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8707,15 +8604,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8723,21 +8620,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8745,20 +8642,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8766,15 +8663,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8831,15 +8728,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8866,15 +8763,15 @@
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8882,22 +8779,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8905,22 +8802,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8928,67 +8825,59 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_EQ_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
-    if (len_a != len_b) {
-        bool r = false;
-
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
-    }
-
+    bool found = false;
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < len_a && i < len_b; i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -8999,30 +8888,35 @@
         res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(aa, bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NULL;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
+            found = true;
             break;
         }
     }
 
-    bool r = res == NUITKA_BOOL_TRUE;
+    if (found == false) {
+        bool r = len_a <= len_b;
 
-    // Convert to target type.
-    PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
-    return result;
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
+    }
+
+    return RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -9036,23 +8930,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9060,15 +8954,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9085,62 +8979,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9197,15 +9091,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9220,101 +9114,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -9328,23 +9222,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9352,15 +9246,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9377,62 +9271,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9489,15 +9383,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9512,123 +9406,115 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_EQ_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_LE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
-    if (len_a != len_b) {
-        bool r = false;
-
-        // Convert to target type.
-        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
-
-        return result;
-    }
-
+    bool found = false;
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < len_a && i < len_b; i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -9639,30 +9525,35 @@
         res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(aa, bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NUITKA_BOOL_EXCEPTION;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
+            found = true;
             break;
         }
     }
 
-    bool r = res == NUITKA_BOOL_TRUE;
+    if (found == false) {
+        bool r = len_a <= len_b;
 
-    // Convert to target type.
-    nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        // Convert to target type.
+        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
-    return result;
+        return result;
+    }
+
+    return RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -9676,15 +9567,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9692,15 +9583,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9708,15 +9599,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9745,15 +9636,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9761,21 +9652,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9783,20 +9674,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9804,15 +9695,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9869,15 +9760,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9904,15 +9795,15 @@
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9920,22 +9811,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9943,22 +9834,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9966,51 +9857,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -10024,15 +9915,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10040,15 +9931,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10056,15 +9947,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10093,15 +9984,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10109,21 +10000,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10131,20 +10022,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10152,15 +10043,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10217,15 +10108,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10252,15 +10143,15 @@
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10268,22 +10159,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10291,22 +10182,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10314,70 +10205,62 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
 }
 
-static PyObject *COMPARE_EQ_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_LE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
-    if (Py_SIZE(a) != Py_SIZE(b)) {
-        bool r = false;
-
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
-    }
-
+    bool found = false;
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < Py_SIZE(a) && i < Py_SIZE(b); i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -10392,35 +10275,35 @@
         Py_DECREF(bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NULL;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
+            found = true;
             break;
         }
     }
 
-    bool r;
-    if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
-        r = Py_SIZE(a) == Py_SIZE(b);
-    } else {
-        r = res == NUITKA_BOOL_TRUE;
+    if (found == false) {
+        bool r = Py_SIZE(a) <= Py_SIZE(b);
+
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
     }
 
-    // Convert to target type.
-    PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
-    return result;
+    return RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10434,23 +10317,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10458,15 +10341,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10483,62 +10366,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10595,15 +10478,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10618,101 +10501,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10726,23 +10609,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10750,15 +10633,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10775,62 +10658,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10887,15 +10770,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10910,120 +10793,112 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
+    return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_EQ_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_LE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
-    if (Py_SIZE(a) != Py_SIZE(b)) {
-        bool r = false;
-
-        // Convert to target type.
-        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
-
-        return result;
-    }
-
+    bool found = false;
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < Py_SIZE(a) && i < Py_SIZE(b); i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -11038,35 +10913,35 @@
         Py_DECREF(bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NUITKA_BOOL_EXCEPTION;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
+            found = true;
             break;
         }
     }
 
-    bool r;
-    if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
-        r = Py_SIZE(a) == Py_SIZE(b);
-    } else {
-        r = res == NUITKA_BOOL_TRUE;
-    }
+    if (found == false) {
+        bool r = Py_SIZE(a) <= Py_SIZE(b);
 
-    // Convert to target type.
-    nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        // Convert to target type.
+        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
-    return result;
+        return result;
+    }
+
+    return RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -11080,15 +10955,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11096,15 +10971,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11112,15 +10987,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11149,15 +11024,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11165,21 +11040,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11187,20 +11062,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11208,15 +11083,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11273,15 +11148,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11308,15 +11183,15 @@
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11324,22 +11199,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11347,22 +11222,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11370,51 +11245,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -11428,15 +11303,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
+            PyObject *result = (*frich)(operand1, operand2, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11444,15 +11319,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11460,15 +11335,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_EQ) {
+            switch (Py_LE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11497,15 +11372,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11513,21 +11388,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11535,20 +11410,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_EQ);
+        PyObject *result = (*f)(operand2, operand1, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11556,15 +11431,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11621,15 +11496,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11656,15 +11531,15 @@
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11672,22 +11547,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_EQ);
+        PyObject *result = (*f)(operand1, operand2, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11695,22 +11570,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_EQ);
+            PyObject *result = (*f)(operand2, operand1, Py_GE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11718,54 +11593,54 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_EQ) {
+    switch (Py_LE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() == %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() <= %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_EQ_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_LE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
+    return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_EQ_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_LE_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11793,41 +11668,43 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - operand2_size < 0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < operand2_digits[i];
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_LE_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_EQ_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_LE_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11855,193 +11732,203 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - operand2_size < 0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < operand2_digits[i];
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-bool RICH_COMPARE_EQ_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_LE_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_EQ_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_LE_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_EQ_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_LE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-PyObject *RICH_COMPARE_EQ_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_EQ_OBJECT_INT_CLONG(operand1, operand2);
+    return COMPARE_LE_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_EQ_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_LE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-bool RICH_COMPARE_EQ_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_LE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_EQ_CBOOL_INT_CLONG(operand1, operand2);
+    return COMPARE_LE_CBOOL_INT_CLONG(operand1, operand2);
 }
 #endif
 
-static PyObject *COMPARE_EQ_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_LE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) -
+                (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1)) <
+            0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < (digit)Py_ABS(operand2);
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-PyObject *RICH_COMPARE_EQ_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_EQ_OBJECT_LONG_DIGIT(operand1, operand2);
+    return COMPARE_LE_OBJECT_LONG_DIGIT(operand1, operand2);
 }
 
-static bool COMPARE_EQ_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+static bool COMPARE_LE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = false;
+        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) -
+                (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1)) <
+            0;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
         r = true;
-
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = false;
+                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < (digit)Py_ABS(operand2);
+                if (Nuitka_LongIsNegative(operand1_long_object)) {
+                    r = !r;
+                }
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-bool RICH_COMPARE_EQ_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_LE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_EQ_CBOOL_LONG_DIGIT(operand1, operand2);
+    return COMPARE_LE_CBOOL_LONG_DIGIT(operand1, operand2);
 }
 
-static PyObject *COMPARE_EQ_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *COMPARE_LE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_EQ_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_LE_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
 
-static bool COMPARE_EQ_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static bool COMPARE_LE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a == b;
+    bool r = a <= b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-bool RICH_COMPARE_EQ_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+bool RICH_COMPARE_LE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_EQ_CBOOL_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_LE_CBOOL_FLOAT_CFLOAT(operand1, operand2);
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonEqUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonEqUtils.c`

 * *Files 10% similar despite different names*

```diff
@@ -21,16 +21,18 @@
 
 void _initSlotCompare(void) {
     // Create a class with "__cmp__" attribute, to get a hand at the default
     // implementation of tp_compare. It's not part of the API and with shared
     // libraries it's not accessible. The name does not matter, nor does the
     // actual value used for "__cmp__".
 
+    PyThreadState *tstate = PyThreadState_GET();
+
     // Use "int" as the base class.
-    PyObject *pos_args = MAKE_TUPLE1((PyObject *)&PyLong_Type);
+    PyObject *pos_args = MAKE_TUPLE1(tstate, (PyObject *)&PyLong_Type);
 
     // Use "__cmp__" with true value, won't matter.
     // Note: Not using MAKE_DICT_EMPTY on purpose, this is called early on.
     PyObject *kw_args = PyDict_New();
 #if PYTHON_VERSION < 0x0300
     PyDict_SetItem(kw_args, const_str_plain___cmp__, Py_True);
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonGe.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonGe.c`

 * *Files 6% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
     bool r = a >= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
 static bool COMPARE_GE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
@@ -54,15 +54,15 @@
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
         bool r = true;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
@@ -86,15 +86,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -127,15 +127,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -147,42 +147,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -262,15 +262,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
@@ -282,63 +282,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= %s()", type1->tp_name, type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and '%s'", type1->tp_name,
@@ -398,15 +398,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -467,15 +467,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -489,15 +489,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -510,15 +510,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -626,15 +626,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -649,15 +649,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -672,15 +672,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -721,15 +721,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -749,15 +749,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c >= 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
         return COMPARE_GE_OBJECT_STR_STR(operand1, operand2);
@@ -786,15 +786,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -827,15 +827,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -847,42 +847,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -962,15 +962,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
@@ -982,63 +982,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= str()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'str'", type1->tp_name);
@@ -1080,15 +1080,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1121,15 +1121,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -1141,42 +1141,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1256,15 +1256,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
@@ -1276,63 +1276,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'str' and '%s'", type2->tp_name);
@@ -1428,15 +1428,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1497,15 +1497,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -1519,15 +1519,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -1540,15 +1540,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1656,15 +1656,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -1679,15 +1679,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -1702,15 +1702,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -1778,15 +1778,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1847,15 +1847,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -1869,15 +1869,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -1890,15 +1890,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -2006,15 +2006,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -2029,15 +2029,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -2052,15 +2052,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -2100,15 +2100,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_GE);
     CHECK_OBJECT(r);
 
     return r;
@@ -2143,15 +2143,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2184,15 +2184,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2204,42 +2204,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2319,15 +2319,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
@@ -2339,63 +2339,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= str()", type1->tp_name);
@@ -2437,15 +2437,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2478,15 +2478,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2498,42 +2498,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2613,15 +2613,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
@@ -2633,63 +2633,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: unicode() >= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() >= %s()", type2->tp_name);
@@ -2721,15 +2721,15 @@
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_GE);
     CHECK_OBJECT(r);
 
     // Convert to target type if necessary
     bool result = r == Py_True;
-    Py_DECREF(r);
+    Py_DECREF_IMMORTAL(r);
 
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
 nuitka_bool RICH_COMPARE_GE_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
@@ -2767,15 +2767,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2836,15 +2836,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -2858,15 +2858,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -2879,15 +2879,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2995,15 +2995,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -3018,15 +3018,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -3041,15 +3041,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3117,15 +3117,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3186,15 +3186,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -3208,15 +3208,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -3229,15 +3229,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3345,15 +3345,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -3368,15 +3368,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -3391,15 +3391,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3441,15 +3441,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -3469,15 +3469,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c >= 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
         return COMPARE_GE_OBJECT_BYTES_BYTES(operand1, operand2);
@@ -3506,15 +3506,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3547,15 +3547,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3567,42 +3567,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3682,15 +3682,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
@@ -3702,63 +3702,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= bytes()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
@@ -3800,15 +3800,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3841,15 +3841,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3861,42 +3861,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -3976,15 +3976,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
@@ -3996,63 +3996,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: bytes() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
@@ -4148,15 +4148,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4217,15 +4217,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -4239,15 +4239,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -4260,15 +4260,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4376,15 +4376,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -4399,15 +4399,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -4422,15 +4422,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4498,15 +4498,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4567,15 +4567,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -4589,15 +4589,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -4610,15 +4610,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4726,15 +4726,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -4749,15 +4749,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -4772,15 +4772,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4840,15 +4840,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4881,15 +4881,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -4901,42 +4901,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5016,15 +5016,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
@@ -5036,63 +5036,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= int()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'int'", type1->tp_name);
@@ -5134,15 +5134,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5175,15 +5175,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -5195,42 +5195,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5310,15 +5310,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
@@ -5330,63 +5330,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'int' and '%s'", type2->tp_name);
@@ -5436,15 +5436,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5505,15 +5505,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -5527,15 +5527,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -5548,15 +5548,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5664,15 +5664,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -5687,15 +5687,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -5710,15 +5710,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -5786,15 +5786,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5855,15 +5855,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -5877,15 +5877,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -5898,15 +5898,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6014,15 +6014,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -6037,15 +6037,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -6060,15 +6060,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -6129,15 +6129,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
         return COMPARE_GE_OBJECT_LONG_LONG(operand1, operand2);
@@ -6166,15 +6166,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6207,15 +6207,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6227,42 +6227,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6342,15 +6342,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
@@ -6362,63 +6362,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= int()", type1->tp_name);
@@ -6460,15 +6460,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6501,15 +6501,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6521,42 +6521,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6636,15 +6636,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
@@ -6656,63 +6656,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: long() >= %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() >= %s()", type2->tp_name);
@@ -6801,15 +6801,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6870,15 +6870,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -6892,15 +6892,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -6913,15 +6913,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7029,15 +7029,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -7052,15 +7052,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -7075,15 +7075,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7151,15 +7151,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7220,15 +7220,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -7242,15 +7242,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -7263,15 +7263,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7379,15 +7379,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -7402,15 +7402,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -7425,15 +7425,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7472,15 +7472,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     bool r = a >= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
         return COMPARE_GE_OBJECT_FLOAT_FLOAT(operand1, operand2);
@@ -7509,15 +7509,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7550,15 +7550,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7570,42 +7570,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7685,15 +7685,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
@@ -7705,63 +7705,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= float()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'float'", type1->tp_name);
@@ -7801,15 +7801,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7842,15 +7842,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7862,42 +7862,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -7977,15 +7977,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
@@ -7997,63 +7997,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: float() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'float' and '%s'", type2->tp_name);
@@ -8117,15 +8117,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8186,15 +8186,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -8208,15 +8208,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -8229,15 +8229,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8345,15 +8345,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -8368,15 +8368,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -8391,15 +8391,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8465,15 +8465,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8534,15 +8534,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -8556,15 +8556,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -8577,15 +8577,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8693,15 +8693,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -8716,15 +8716,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -8739,15 +8739,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8812,15 +8812,15 @@
     }
 
     if (found == false) {
         bool r = len_a >= len_b;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_GE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
@@ -8852,15 +8852,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8893,15 +8893,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -8913,42 +8913,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9028,15 +9028,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
@@ -9048,63 +9048,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= tuple()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
@@ -9144,15 +9144,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9185,15 +9185,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -9205,42 +9205,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9320,15 +9320,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
@@ -9340,63 +9340,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: tuple() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
@@ -9497,15 +9497,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9566,15 +9566,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -9588,15 +9588,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -9609,15 +9609,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9725,15 +9725,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -9748,15 +9748,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -9771,15 +9771,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -9845,15 +9845,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9914,15 +9914,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -9936,15 +9936,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -9957,15 +9957,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10073,15 +10073,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -10096,15 +10096,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -10119,15 +10119,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -10199,15 +10199,15 @@
     }
 
     if (found == false) {
         bool r = Py_SIZE(a) >= Py_SIZE(b);
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_GE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
 PyObject *RICH_COMPARE_GE_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
@@ -10239,15 +10239,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10280,15 +10280,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10300,42 +10300,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10415,15 +10415,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
@@ -10435,63 +10435,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() >= list()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of '%s' and 'list'", type1->tp_name);
@@ -10531,15 +10531,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10572,15 +10572,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10592,42 +10592,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10707,15 +10707,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
@@ -10727,63 +10727,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: list() >= %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>=' not supported between instances of 'list' and '%s'", type2->tp_name);
@@ -10885,15 +10885,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10954,15 +10954,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -10976,15 +10976,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -10997,15 +10997,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11113,15 +11113,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -11136,15 +11136,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -11159,15 +11159,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11233,15 +11233,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11302,15 +11302,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
 
@@ -11324,15 +11324,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LE);
 
         if (result != Py_NotImplemented) {
@@ -11345,15 +11345,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11461,15 +11461,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GE);
@@ -11484,15 +11484,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LE);
@@ -11507,15 +11507,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11599,15 +11599,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
 PyObject *RICH_COMPARE_GE_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
     return COMPARE_GE_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
@@ -11685,15 +11685,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
     bool r = a >= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
 PyObject *RICH_COMPARE_GE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
     return COMPARE_GE_OBJECT_INT_CLONG(operand1, operand2);
 }
@@ -11747,15 +11747,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
 PyObject *RICH_COMPARE_GE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
     return COMPARE_GE_OBJECT_LONG_DIGIT(operand1, operand2);
@@ -11808,15 +11808,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
     bool r = a >= b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
 PyObject *RICH_COMPARE_GE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
     return COMPARE_GE_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonGt.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonGt.c`

 * *Files 4% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
     bool r = a > b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
 static bool COMPARE_GT_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
@@ -78,15 +78,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -119,15 +119,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -139,42 +139,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -254,15 +254,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
@@ -274,63 +274,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > %s()", type1->tp_name, type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and '%s'", type1->tp_name,
@@ -382,15 +382,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -451,15 +451,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -473,15 +473,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -494,15 +494,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -610,15 +610,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -633,15 +633,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -656,15 +656,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -705,15 +705,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -733,15 +733,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c > 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
         return COMPARE_GT_OBJECT_STR_STR(operand1, operand2);
@@ -770,15 +770,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -811,15 +811,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -831,42 +831,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -946,15 +946,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
@@ -966,63 +966,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > str()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'str'", type1->tp_name);
@@ -1064,15 +1064,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1105,15 +1105,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -1125,42 +1125,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1240,15 +1240,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
@@ -1260,63 +1260,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'str' and '%s'", type2->tp_name);
@@ -1412,15 +1412,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1481,15 +1481,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -1503,15 +1503,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -1524,15 +1524,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1640,15 +1640,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -1663,15 +1663,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -1686,15 +1686,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -1762,15 +1762,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1831,15 +1831,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -1853,15 +1853,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -1874,15 +1874,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1990,15 +1990,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -2013,15 +2013,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -2036,15 +2036,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -2084,15 +2084,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_GT);
     CHECK_OBJECT(r);
 
     return r;
@@ -2127,15 +2127,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2168,15 +2168,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2188,42 +2188,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2303,15 +2303,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
@@ -2323,63 +2323,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > str()", type1->tp_name);
@@ -2421,15 +2421,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2462,15 +2462,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2482,42 +2482,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2597,15 +2597,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
@@ -2617,63 +2617,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: unicode() > %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() > %s()", type2->tp_name);
@@ -2705,15 +2705,15 @@
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_GT);
     CHECK_OBJECT(r);
 
     // Convert to target type if necessary
     bool result = r == Py_True;
-    Py_DECREF(r);
+    Py_DECREF_IMMORTAL(r);
 
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
 nuitka_bool RICH_COMPARE_GT_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
@@ -2751,15 +2751,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2820,15 +2820,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -2842,15 +2842,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -2863,15 +2863,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2979,15 +2979,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -3002,15 +3002,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -3025,15 +3025,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3101,15 +3101,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3170,15 +3170,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -3192,15 +3192,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -3213,15 +3213,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3329,15 +3329,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -3352,15 +3352,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -3375,15 +3375,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3425,15 +3425,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -3453,15 +3453,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c > 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
         return COMPARE_GT_OBJECT_BYTES_BYTES(operand1, operand2);
@@ -3490,15 +3490,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3531,15 +3531,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3551,42 +3551,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3666,15 +3666,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
@@ -3686,63 +3686,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > bytes()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'bytes'", type1->tp_name);
@@ -3784,15 +3784,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3825,15 +3825,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3845,42 +3845,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -3960,15 +3960,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
@@ -3980,63 +3980,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: bytes() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'bytes' and '%s'", type2->tp_name);
@@ -4132,15 +4132,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4201,15 +4201,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -4223,15 +4223,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -4244,15 +4244,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4360,15 +4360,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -4383,15 +4383,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -4406,15 +4406,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4482,15 +4482,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4551,15 +4551,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -4573,15 +4573,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -4594,15 +4594,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4710,15 +4710,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -4733,15 +4733,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -4756,15 +4756,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4824,15 +4824,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4865,15 +4865,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -4885,42 +4885,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5000,15 +5000,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
@@ -5020,63 +5020,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > int()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'int'", type1->tp_name);
@@ -5118,15 +5118,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5159,15 +5159,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -5179,42 +5179,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5294,15 +5294,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
@@ -5314,63 +5314,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'int' and '%s'", type2->tp_name);
@@ -5420,15 +5420,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5489,15 +5489,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -5511,15 +5511,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -5532,15 +5532,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5648,15 +5648,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -5671,15 +5671,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -5694,15 +5694,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -5770,15 +5770,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5839,15 +5839,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -5861,15 +5861,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -5882,15 +5882,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5998,15 +5998,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -6021,15 +6021,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -6044,15 +6044,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -6113,15 +6113,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
         return COMPARE_GT_OBJECT_LONG_LONG(operand1, operand2);
@@ -6150,15 +6150,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6191,15 +6191,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6211,42 +6211,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6326,15 +6326,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
@@ -6346,63 +6346,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > int()", type1->tp_name);
@@ -6444,15 +6444,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6485,15 +6485,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6505,42 +6505,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6620,15 +6620,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
@@ -6640,63 +6640,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: long() > %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() > %s()", type2->tp_name);
@@ -6785,15 +6785,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6854,15 +6854,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -6876,15 +6876,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -6897,15 +6897,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7013,15 +7013,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -7036,15 +7036,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -7059,15 +7059,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7135,15 +7135,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7204,15 +7204,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -7226,15 +7226,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -7247,15 +7247,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7363,15 +7363,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -7386,15 +7386,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -7409,15 +7409,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7456,15 +7456,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     bool r = a > b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
         return COMPARE_GT_OBJECT_FLOAT_FLOAT(operand1, operand2);
@@ -7493,15 +7493,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7534,15 +7534,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7554,42 +7554,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7669,15 +7669,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
@@ -7689,63 +7689,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > float()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'float'", type1->tp_name);
@@ -7785,15 +7785,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7826,15 +7826,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7846,42 +7846,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -7961,15 +7961,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
@@ -7981,63 +7981,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: float() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'float' and '%s'", type2->tp_name);
@@ -8101,15 +8101,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8170,15 +8170,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -8192,15 +8192,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -8213,15 +8213,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8329,15 +8329,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -8352,15 +8352,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -8375,15 +8375,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8449,15 +8449,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8518,15 +8518,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -8540,15 +8540,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -8561,15 +8561,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8677,15 +8677,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -8700,15 +8700,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -8723,15 +8723,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8796,15 +8796,15 @@
     }
 
     if (found == false) {
         bool r = len_a > len_b;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_GT_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
@@ -8836,15 +8836,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8877,15 +8877,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -8897,42 +8897,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9012,15 +9012,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
@@ -9032,63 +9032,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > tuple()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'tuple'", type1->tp_name);
@@ -9128,15 +9128,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9169,15 +9169,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -9189,42 +9189,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9304,15 +9304,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
@@ -9324,63 +9324,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: tuple() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'tuple' and '%s'", type2->tp_name);
@@ -9481,15 +9481,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9550,15 +9550,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -9572,15 +9572,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -9593,15 +9593,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9709,15 +9709,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -9732,15 +9732,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -9755,15 +9755,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -9829,15 +9829,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9898,15 +9898,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -9920,15 +9920,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -9941,15 +9941,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10057,15 +10057,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -10080,15 +10080,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -10103,15 +10103,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -10183,15 +10183,15 @@
     }
 
     if (found == false) {
         bool r = Py_SIZE(a) > Py_SIZE(b);
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_GT_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
 PyObject *RICH_COMPARE_GT_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
@@ -10223,15 +10223,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10264,15 +10264,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10284,42 +10284,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10399,15 +10399,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
@@ -10419,63 +10419,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() > list()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of '%s' and 'list'", type1->tp_name);
@@ -10515,15 +10515,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10556,15 +10556,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10576,42 +10576,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10691,15 +10691,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
@@ -10711,63 +10711,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_GT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: list() > %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'>' not supported between instances of 'list' and '%s'", type2->tp_name);
@@ -10869,15 +10869,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10938,15 +10938,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -10960,15 +10960,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -10981,15 +10981,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11097,15 +11097,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -11120,15 +11120,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -11143,15 +11143,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11217,15 +11217,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11286,15 +11286,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
 
@@ -11308,15 +11308,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_LT);
 
         if (result != Py_NotImplemented) {
@@ -11329,15 +11329,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11445,15 +11445,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_GT);
@@ -11468,15 +11468,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_LT);
@@ -11491,15 +11491,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11583,15 +11583,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
 PyObject *RICH_COMPARE_GT_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
     return COMPARE_GT_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
@@ -11669,15 +11669,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
     bool r = a > b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
 PyObject *RICH_COMPARE_GT_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
     return COMPARE_GT_OBJECT_INT_CLONG(operand1, operand2);
 }
@@ -11731,15 +11731,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
 PyObject *RICH_COMPARE_GT_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
     return COMPARE_GT_OBJECT_LONG_DIGIT(operand1, operand2);
@@ -11792,15 +11792,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
     bool r = a > b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
 PyObject *RICH_COMPARE_GT_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
     return COMPARE_GT_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonLe.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonNe.c`

 * *Files 4% similar despite different names*

```diff
@@ -3,66 +3,66 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationComparison.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-/* C helpers for type specialized "<=" (LE) comparisons */
+/* C helpers for type specialized "!=" (NE) comparisons */
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_LE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_LE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 #endif
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
-        bool r = true;
+        bool r = false;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
@@ -78,23 +78,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -102,15 +102,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -127,62 +127,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -239,15 +239,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -262,109 +262,109 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
-        bool r = true;
+        bool r = false;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
@@ -382,15 +382,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -398,15 +398,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -414,15 +414,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -451,15 +451,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -467,21 +467,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -489,20 +489,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -510,15 +510,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -575,15 +575,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -610,15 +610,15 @@
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -626,22 +626,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -649,22 +649,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -672,99 +672,100 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_LE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
-    int c;
-
-    if (min_len > 0) {
-        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
+    if (len_a != len_b) {
+        bool r = true;
 
-        if (c == 0) {
-            c = memcmp(a->ob_sval, b->ob_sval, min_len);
-        }
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
     } else {
-        c = 0;
-    }
-
-    if (c == 0) {
-        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
-    }
+        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
+            bool r = false;
 
-    c = c <= 0;
+            // Convert to target type.
+            PyObject *result = BOOL_FROM(r);
+            Py_INCREF_IMMORTAL(result);
+            return result;
+        } else {
+            bool r = true;
 
-    // Convert to target type.
-    PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
-    return result;
+            // Convert to target type.
+            PyObject *result = BOOL_FROM(r);
+            Py_INCREF_IMMORTAL(result);
+            return result;
+        }
+    }
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_NE_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -778,23 +779,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -802,15 +803,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -827,62 +828,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -939,15 +940,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -962,103 +963,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_NE_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -1072,23 +1073,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1096,15 +1097,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1121,62 +1122,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1233,15 +1234,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1256,165 +1257,150 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-/* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
-PyObject *RICH_COMPARE_LE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_STR_STR(operand1, operand2);
-}
-#endif
-
-#if PYTHON_VERSION < 0x300
-static bool COMPARE_LE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
-    int c;
+    if (len_a != len_b) {
+        bool r = true;
 
-    if (min_len > 0) {
-        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
+        // Convert to target type.
+        bool result = r;
 
-        if (c == 0) {
-            c = memcmp(a->ob_sval, b->ob_sval, min_len);
-        }
+        return result;
     } else {
-        c = 0;
-    }
-
-    if (c == 0) {
-        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
-    }
+        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
+            bool r = false;
 
-    c = c <= 0;
+            // Convert to target type.
+            bool result = r;
 
-    // Convert to target type.
-    bool result = c != 0;
+            return result;
+        } else {
+            bool r = true;
 
-    return result;
-}
-/* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
-bool RICH_COMPARE_LE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+            // Convert to target type.
+            bool result = r;
 
-    return COMPARE_LE_CBOOL_STR_STR(operand1, operand2);
+            return result;
+        }
+    }
 }
-#endif
-
-#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_LE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1428,15 +1414,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1444,15 +1430,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1460,15 +1446,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1497,15 +1483,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1513,21 +1499,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1535,20 +1521,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1556,15 +1542,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1621,15 +1607,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1656,15 +1642,15 @@
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1672,22 +1658,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1695,22 +1681,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1718,53 +1704,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1778,15 +1764,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1794,15 +1780,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1810,15 +1796,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1847,15 +1833,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1863,21 +1849,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1885,20 +1871,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1906,15 +1892,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1971,15 +1957,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2006,15 +1992,15 @@
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2022,22 +2008,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2045,22 +2031,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2068,76 +2054,131 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_LE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
-    PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LE);
-    CHECK_OBJECT(r);
+#if PYTHON_VERSION >= 0x300
+    bool r;
+
+    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
+    if (PyUnicode_GET_LENGTH(b) != len) {
+        r = false;
+    } else {
+        int kind1 = PyUnicode_KIND(a);
+#if PYTHON_VERSION < 0x3c0
+        if (unlikely(kind1 == 0)) {
+            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)a);
+            assert(res != -1);
+            kind1 = PyUnicode_KIND(a);
+            assert(kind1 != 0);
+        }
+#endif
+
+        int kind2 = PyUnicode_KIND(b);
+#if PYTHON_VERSION < 0x3c0
+        if (unlikely(kind2 == 0)) {
+            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)b);
+            assert(res != -1);
+            kind2 = PyUnicode_KIND(b);
+            assert(kind2 != 0);
+        }
+#endif
+
+        if (kind1 != kind2) {
+            r = false;
+        } else {
+            const void *data1 = PyUnicode_DATA(a);
+            const void *data2 = PyUnicode_DATA(b);
 
-    return r;
+            int cmp = memcmp(data1, data2, len * kind1);
+            r = (cmp == 0);
+        }
+    }
+
+    PyObject *result = BOOL_FROM(r == false);
+    Py_INCREF_IMMORTAL(result);
+    return result;
+#else
+    bool r;
+
+    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
+    if (PyUnicode_GET_LENGTH(b) != len) {
+        r = false;
+    } else {
+        const Py_UNICODE *data1 = a->str;
+        const Py_UNICODE *data2 = b->str;
+
+        int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
+        r = (cmp == 0);
+    }
+
+    PyObject *result = BOOL_FROM(r == false);
+    Py_INCREF_IMMORTAL(result);
+    return result;
+#endif
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_NE_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2151,23 +2192,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2175,15 +2216,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2200,62 +2241,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2312,15 +2353,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2335,103 +2376,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_NE_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2445,23 +2486,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2469,15 +2510,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2494,62 +2535,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2606,15 +2647,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2629,145 +2670,182 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() != %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-/* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
- * Python3 'str'. */
-PyObject *RICH_COMPARE_LE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_UNICODE_UNICODE(operand1, operand2);
-}
-
-static bool COMPARE_LE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
-    PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LE);
-    CHECK_OBJECT(r);
+#if PYTHON_VERSION >= 0x300
+    bool r;
+
+    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
+    if (PyUnicode_GET_LENGTH(b) != len) {
+        r = false;
+    } else {
+        int kind1 = PyUnicode_KIND(a);
+#if PYTHON_VERSION < 0x3c0
+        if (unlikely(kind1 == 0)) {
+            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)a);
+            assert(res != -1);
+            kind1 = PyUnicode_KIND(a);
+            assert(kind1 != 0);
+        }
+#endif
+
+        int kind2 = PyUnicode_KIND(b);
+#if PYTHON_VERSION < 0x3c0
+        if (unlikely(kind2 == 0)) {
+            NUITKA_MAY_BE_UNUSED int res = _PyUnicode_Ready((PyObject *)b);
+            assert(res != -1);
+            kind2 = PyUnicode_KIND(b);
+            assert(kind2 != 0);
+        }
+#endif
+
+        if (kind1 != kind2) {
+            r = false;
+        } else {
+            const void *data1 = PyUnicode_DATA(a);
+            const void *data2 = PyUnicode_DATA(b);
 
-    // Convert to target type if necessary
-    bool result = r == Py_True;
-    Py_DECREF(r);
+            int cmp = memcmp(data1, data2, len * kind1);
+            r = (cmp == 0);
+        }
+    }
+
+    bool result = r == false;
 
     return result;
-}
-/* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
- * Python3 'str'. */
-bool RICH_COMPARE_LE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+#else
+    bool r;
 
-    return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2);
-}
+    Py_ssize_t len = PyUnicode_GET_LENGTH(a);
+    if (PyUnicode_GET_LENGTH(b) != len) {
+        r = false;
+    } else {
+        const Py_UNICODE *data1 = a->str;
+        const Py_UNICODE *data2 = b->str;
 
+        int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
+        r = (cmp == 0);
+    }
+
+    bool result = r == false;
+
+    return result;
+#endif
+}
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -2781,15 +2859,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2797,15 +2875,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2813,15 +2891,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2850,15 +2928,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2866,21 +2944,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2888,20 +2966,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2909,15 +2987,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2974,15 +3052,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3009,15 +3087,15 @@
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3025,22 +3103,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3048,22 +3126,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3071,53 +3149,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -3131,15 +3209,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3147,15 +3225,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3163,15 +3241,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3200,15 +3278,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3216,21 +3294,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3238,20 +3316,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3259,15 +3337,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3324,15 +3402,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3359,15 +3437,15 @@
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3375,22 +3453,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3398,22 +3476,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3421,100 +3499,101 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() != %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION >= 0x300
-static PyObject *COMPARE_LE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
-    int c;
-
-    if (min_len > 0) {
-        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
+    if (len_a != len_b) {
+        bool r = true;
 
-        if (c == 0) {
-            c = memcmp(a->ob_sval, b->ob_sval, min_len);
-        }
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
     } else {
-        c = 0;
-    }
+        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
+            bool r = false;
 
-    if (c == 0) {
-        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
-    }
-
-    c = c <= 0;
+            // Convert to target type.
+            PyObject *result = BOOL_FROM(r);
+            Py_INCREF_IMMORTAL(result);
+            return result;
+        } else {
+            bool r = true;
 
-    // Convert to target type.
-    PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
-    return result;
+            // Convert to target type.
+            PyObject *result = BOOL_FROM(r);
+            Py_INCREF_IMMORTAL(result);
+            return result;
+        }
+    }
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_NE_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3528,23 +3607,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3552,15 +3631,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3577,62 +3656,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3689,15 +3768,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3712,103 +3791,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_NE_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3822,23 +3901,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3846,15 +3925,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3871,62 +3950,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -3983,15 +4062,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4006,165 +4085,150 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
-/* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
-PyObject *RICH_COMPARE_LE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_BYTES_BYTES(operand1, operand2);
-}
-#endif
-
-#if PYTHON_VERSION >= 0x300
-static bool COMPARE_LE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
-    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
-    int c;
+    if (len_a != len_b) {
+        bool r = true;
 
-    if (min_len > 0) {
-        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
+        // Convert to target type.
+        bool result = r;
 
-        if (c == 0) {
-            c = memcmp(a->ob_sval, b->ob_sval, min_len);
-        }
+        return result;
     } else {
-        c = 0;
-    }
+        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
+            bool r = false;
 
-    if (c == 0) {
-        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
-    }
-
-    c = c <= 0;
+            // Convert to target type.
+            bool result = r;
 
-    // Convert to target type.
-    bool result = c != 0;
+            return result;
+        } else {
+            bool r = true;
 
-    return result;
-}
-/* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
-bool RICH_COMPARE_LE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+            // Convert to target type.
+            bool result = r;
 
-    return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2);
+            return result;
+        }
+    }
 }
-#endif
-
-#if PYTHON_VERSION >= 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4178,15 +4242,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4194,15 +4258,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4210,15 +4274,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4247,15 +4311,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4263,21 +4327,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4285,20 +4349,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4306,15 +4370,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4371,15 +4435,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4406,15 +4470,15 @@
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4422,22 +4486,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4445,22 +4509,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4468,53 +4532,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4528,15 +4592,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4544,15 +4608,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4560,15 +4624,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4597,15 +4661,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4613,21 +4677,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4635,20 +4699,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4656,15 +4720,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4721,15 +4785,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4756,15 +4820,15 @@
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4772,22 +4836,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4795,22 +4859,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4818,53 +4882,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -4878,23 +4942,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4902,15 +4966,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4927,62 +4991,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5039,15 +5103,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5062,103 +5126,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -5172,23 +5236,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5196,15 +5260,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5221,62 +5285,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5333,15 +5397,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5356,119 +5420,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-/* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_LE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_INT_INT(operand1, operand2);
-}
-#endif
-
-#if PYTHON_VERSION < 0x300
-/* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-bool RICH_COMPARE_LE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_CBOOL_INT_INT(operand1, operand2);
-}
-#endif
-
-#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5482,15 +5530,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5498,15 +5546,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5514,15 +5562,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5551,15 +5599,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5567,21 +5615,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5589,20 +5637,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5610,15 +5658,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5675,15 +5723,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5710,15 +5758,15 @@
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5726,22 +5774,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5749,22 +5797,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5772,53 +5820,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5832,15 +5880,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5848,15 +5896,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5864,15 +5912,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5901,15 +5949,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5917,21 +5965,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5939,20 +5987,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5960,15 +6008,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6025,15 +6073,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6060,15 +6108,15 @@
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6076,22 +6124,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6099,22 +6147,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6122,91 +6170,86 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_LE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     PyLongObject *operand2_long_object = (PyLongObject *)operand2;
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
-        r = true;
+        r = false;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - Nuitka_LongGetSignedDigitSize(operand2_long_object) <
-            0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] <
-                    Nuitka_LongGetDigitPointer(operand2_long_object)[i];
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_NE_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6220,23 +6263,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6244,15 +6287,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6269,62 +6312,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6381,15 +6424,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6404,103 +6447,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_NE_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6514,23 +6557,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6538,15 +6581,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6563,62 +6606,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6675,15 +6718,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6698,154 +6741,137 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() != %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-PyObject *RICH_COMPARE_LE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_LONG_LONG(operand1, operand2);
-}
-
-static bool COMPARE_LE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     PyLongObject *operand2_long_object = (PyLongObject *)operand2;
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
-        r = true;
+        r = false;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - Nuitka_LongGetSignedDigitSize(operand2_long_object) <
-            0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] <
-                    Nuitka_LongGetDigitPointer(operand2_long_object)[i];
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
-/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-bool RICH_COMPARE_LE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2);
-}
-
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -6859,15 +6885,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6875,15 +6901,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6891,15 +6917,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6928,15 +6954,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6944,21 +6970,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6966,20 +6992,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6987,15 +7013,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7052,15 +7078,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7087,15 +7113,15 @@
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7103,22 +7129,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7126,22 +7152,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7149,53 +7175,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -7209,15 +7235,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7225,15 +7251,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7241,15 +7267,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7278,15 +7304,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7294,21 +7320,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7316,20 +7342,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7337,15 +7363,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7402,15 +7428,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7437,15 +7463,15 @@
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7453,22 +7479,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7476,22 +7502,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7499,69 +7525,69 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() != %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_LE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_NE_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7575,23 +7601,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7599,15 +7625,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7624,62 +7650,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7736,15 +7762,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7759,101 +7785,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_NE_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7867,23 +7893,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7891,15 +7917,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7916,62 +7942,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8028,15 +8054,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8051,129 +8077,117 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-/* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_OBJECT_FLOAT_FLOAT(operand1, operand2);
-}
-
-static bool COMPARE_LE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_NE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
-/* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-bool RICH_COMPARE_LE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-
-    return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2);
-}
-
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8187,15 +8201,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8203,15 +8217,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8219,15 +8233,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8256,15 +8270,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8272,21 +8286,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8294,20 +8308,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8315,15 +8329,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8380,15 +8394,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8415,15 +8429,15 @@
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8431,22 +8445,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8454,22 +8468,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8477,51 +8491,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_NE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8535,15 +8549,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8551,15 +8565,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8567,15 +8581,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8604,15 +8618,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8620,21 +8634,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8642,20 +8656,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8663,15 +8677,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8728,15 +8742,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8763,15 +8777,15 @@
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8779,22 +8793,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8802,22 +8816,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8825,59 +8839,67 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_LE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
-    bool found = false;
+    if (len_a != len_b) {
+        bool r = true;
+
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
+    }
+
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < len_a && i < len_b; i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -8888,35 +8910,30 @@
         res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(aa, bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NULL;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
-            found = true;
             break;
         }
     }
 
-    if (found == false) {
-        bool r = len_a <= len_b;
-
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
-    }
+    bool r = res == NUITKA_BOOL_FALSE;
 
-    return RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
+    // Convert to target type.
+    PyObject *result = BOOL_FROM(r);
+    Py_INCREF_IMMORTAL(result);
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -8930,23 +8947,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8954,15 +8971,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8979,62 +8996,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9091,15 +9108,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9114,101 +9131,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -9222,23 +9239,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9246,15 +9263,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9271,62 +9288,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9383,15 +9400,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9406,115 +9423,123 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_LE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_LE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_NE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
-    bool found = false;
+    if (len_a != len_b) {
+        bool r = true;
+
+        // Convert to target type.
+        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+
+        return result;
+    }
+
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < len_a && i < len_b; i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -9525,35 +9550,30 @@
         res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(aa, bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NUITKA_BOOL_EXCEPTION;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
-            found = true;
             break;
         }
     }
 
-    if (found == false) {
-        bool r = len_a <= len_b;
-
-        // Convert to target type.
-        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+    bool r = res == NUITKA_BOOL_FALSE;
 
-        return result;
-    }
+    // Convert to target type.
+    nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
-    return RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -9567,15 +9587,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9583,15 +9603,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9599,15 +9619,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9636,15 +9656,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9652,21 +9672,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9674,20 +9694,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9695,15 +9715,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9760,15 +9780,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9795,15 +9815,15 @@
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9811,22 +9831,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9834,22 +9854,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9857,51 +9877,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -9915,15 +9935,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9931,15 +9951,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9947,15 +9967,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9984,15 +10004,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10000,21 +10020,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10022,20 +10042,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10043,15 +10063,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10108,15 +10128,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10143,15 +10163,15 @@
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10159,22 +10179,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10182,22 +10202,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10205,62 +10225,70 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
 }
 
-static PyObject *COMPARE_LE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_NE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
-    bool found = false;
+    if (Py_SIZE(a) != Py_SIZE(b)) {
+        bool r = true;
+
+        // Convert to target type.
+        PyObject *result = BOOL_FROM(r);
+        Py_INCREF_IMMORTAL(result);
+        return result;
+    }
+
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < Py_SIZE(a) && i < Py_SIZE(b); i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -10275,35 +10303,36 @@
         Py_DECREF(bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NULL;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
-            found = true;
             break;
         }
     }
 
-    if (found == false) {
-        bool r = Py_SIZE(a) <= Py_SIZE(b);
+    bool r;
 
-        // Convert to target type.
-        PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
-        return result;
+    if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
+        r = Py_SIZE(a) != Py_SIZE(b);
+    } else {
+        r = res == NUITKA_BOOL_FALSE;
     }
 
-    return RICH_COMPARE_LE_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
+    // Convert to target type.
+    PyObject *result = BOOL_FROM(r);
+    Py_INCREF_IMMORTAL(result);
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_LE_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10317,23 +10346,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10341,15 +10370,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10366,62 +10395,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10478,15 +10507,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10501,101 +10530,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_LE_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10609,23 +10638,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10633,15 +10662,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10658,62 +10687,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10770,15 +10799,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10793,112 +10822,120 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_LE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_OBJECT_LIST_LIST(operand1, operand2);
+    return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_LE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_NE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
-    bool found = false;
+    if (Py_SIZE(a) != Py_SIZE(b)) {
+        bool r = true;
+
+        // Convert to target type.
+        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+
+        return result;
+    }
+
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < Py_SIZE(a) && i < Py_SIZE(b); i++) {
         PyObject *aa = a->ob_item[i];
         PyObject *bb = b->ob_item[i];
 
@@ -10913,35 +10950,36 @@
         Py_DECREF(bb);
 
         if (res == NUITKA_BOOL_EXCEPTION) {
             return NUITKA_BOOL_EXCEPTION;
         }
 
         if (res == NUITKA_BOOL_FALSE) {
-            found = true;
             break;
         }
     }
 
-    if (found == false) {
-        bool r = Py_SIZE(a) <= Py_SIZE(b);
-
-        // Convert to target type.
-        nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+    bool r;
 
-        return result;
+    if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
+        r = Py_SIZE(a) != Py_SIZE(b);
+    } else {
+        r = res == NUITKA_BOOL_FALSE;
     }
 
-    return RICH_COMPARE_LE_NBOOL_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
+    // Convert to target type.
+    nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+
+    return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -10955,15 +10993,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10971,15 +11009,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10987,15 +11025,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11024,15 +11062,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11040,21 +11078,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11062,20 +11100,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11083,15 +11121,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11148,15 +11186,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11183,15 +11221,15 @@
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11199,22 +11237,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11222,22 +11260,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11245,51 +11283,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() <= list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -11303,15 +11341,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_LE);
+            PyObject *result = (*frich)(operand1, operand2, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11319,15 +11357,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11335,15 +11373,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_LE) {
+            switch (Py_NE) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11372,15 +11410,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11388,21 +11426,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11410,20 +11448,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_GE);
+        PyObject *result = (*f)(operand2, operand1, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11431,15 +11469,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11496,15 +11534,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11531,15 +11569,15 @@
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11547,22 +11585,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_LE);
+        PyObject *result = (*f)(operand1, operand2, Py_NE);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11570,22 +11608,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_GE);
+            PyObject *result = (*f)(operand2, operand1, Py_NE);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11593,54 +11631,54 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_LE) {
+    switch (Py_NE) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() <= %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() != %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'<=' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_LE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_NE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_NBOOL_LIST_LIST(operand1, operand2);
+    return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_LE_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_NE_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11668,43 +11706,40 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - operand2_size < 0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < operand2_digits[i];
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_LE_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_NE_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_LE_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_NE_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11732,203 +11767,190 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) - operand2_size < 0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < operand2_digits[i];
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-bool RICH_COMPARE_LE_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_NE_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_LE_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_NE_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_LE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_NE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-PyObject *RICH_COMPARE_LE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_LE_OBJECT_INT_CLONG(operand1, operand2);
+    return COMPARE_NE_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_LE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_NE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-bool RICH_COMPARE_LE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_NE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_LE_CBOOL_INT_CLONG(operand1, operand2);
+    return COMPARE_NE_CBOOL_INT_CLONG(operand1, operand2);
 }
 #endif
 
-static PyObject *COMPARE_LE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_NE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) -
-                (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1)) <
-            0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < (digit)Py_ABS(operand2);
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-PyObject *RICH_COMPARE_LE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_LE_OBJECT_LONG_DIGIT(operand1, operand2);
+    return COMPARE_NE_OBJECT_LONG_DIGIT(operand1, operand2);
 }
 
-static bool COMPARE_LE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+static bool COMPARE_NE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = Nuitka_LongGetSignedDigitSize(operand1_long_object) -
-                (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1)) <
-            0;
+        r = true;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = true;
+        r = false;
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = Nuitka_LongGetDigitPointer(operand1_long_object)[i] < (digit)Py_ABS(operand2);
-                if (Nuitka_LongIsNegative(operand1_long_object)) {
-                    r = !r;
-                }
+                r = true;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-bool RICH_COMPARE_LE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_NE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_LE_CBOOL_LONG_DIGIT(operand1, operand2);
+    return COMPARE_NE_CBOOL_LONG_DIGIT(operand1, operand2);
 }
 
-static PyObject *COMPARE_LE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *COMPARE_NE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-PyObject *RICH_COMPARE_LE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+PyObject *RICH_COMPARE_NE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_LE_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_NE_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
 
-static bool COMPARE_LE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static bool COMPARE_NE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a <= b;
+    bool r = a != b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-bool RICH_COMPARE_LE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+bool RICH_COMPARE_NE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_LE_CBOOL_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_NE_CBOOL_FLOAT_CFLOAT(operand1, operand2);
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonLt.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonLt.c`

 * *Files 9% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
     bool r = a < b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
 static bool COMPARE_LT_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
@@ -78,15 +78,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -119,15 +119,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -139,42 +139,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -254,15 +254,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
@@ -274,63 +274,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < %s()", type1->tp_name, type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and '%s'", type1->tp_name,
@@ -382,15 +382,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -451,15 +451,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -473,15 +473,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -494,15 +494,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -610,15 +610,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -633,15 +633,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -656,15 +656,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -705,15 +705,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -733,15 +733,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c < 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
         return COMPARE_LT_OBJECT_STR_STR(operand1, operand2);
@@ -770,15 +770,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -811,15 +811,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -831,42 +831,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -946,15 +946,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
@@ -966,63 +966,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < str()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'str'", type1->tp_name);
@@ -1064,15 +1064,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1105,15 +1105,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -1125,42 +1125,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1240,15 +1240,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
@@ -1260,63 +1260,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'str' and '%s'", type2->tp_name);
@@ -1428,15 +1428,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1497,15 +1497,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -1519,15 +1519,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -1540,15 +1540,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1656,15 +1656,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -1679,15 +1679,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -1702,15 +1702,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -1778,15 +1778,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1847,15 +1847,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -1869,15 +1869,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -1890,15 +1890,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -2006,15 +2006,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -2029,15 +2029,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -2052,15 +2052,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -2100,15 +2100,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LT);
     CHECK_OBJECT(r);
 
     return r;
@@ -2143,15 +2143,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2184,15 +2184,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2204,42 +2204,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2319,15 +2319,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
@@ -2339,63 +2339,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < str()", type1->tp_name);
@@ -2437,15 +2437,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2478,15 +2478,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -2498,42 +2498,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2613,15 +2613,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
@@ -2633,63 +2633,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: unicode() < %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: str() < %s()", type2->tp_name);
@@ -2728,15 +2728,15 @@
     }
 
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_LT);
     CHECK_OBJECT(r);
 
     // Convert to target type if necessary
     bool result = r == Py_True;
-    Py_DECREF(r);
+    Py_DECREF_IMMORTAL(r);
 
     return result;
 }
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
  * Python3 'str'. */
 bool RICH_COMPARE_LT_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
 
@@ -2781,15 +2781,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2850,15 +2850,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -2872,15 +2872,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -2893,15 +2893,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3009,15 +3009,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -3032,15 +3032,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -3055,15 +3055,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3131,15 +3131,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3200,15 +3200,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -3222,15 +3222,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -3243,15 +3243,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3359,15 +3359,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -3382,15 +3382,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -3405,15 +3405,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -3455,15 +3455,15 @@
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
         bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
@@ -3483,15 +3483,15 @@
         c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
     }
 
     c = c < 0;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(c != 0);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
         return COMPARE_LT_OBJECT_BYTES_BYTES(operand1, operand2);
@@ -3520,15 +3520,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3561,15 +3561,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3581,42 +3581,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3696,15 +3696,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
@@ -3716,63 +3716,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < bytes()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'bytes'", type1->tp_name);
@@ -3814,15 +3814,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3855,15 +3855,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -3875,42 +3875,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -3990,15 +3990,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
@@ -4010,63 +4010,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: bytes() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'bytes' and '%s'", type2->tp_name);
@@ -4178,15 +4178,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4247,15 +4247,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -4269,15 +4269,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -4290,15 +4290,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4406,15 +4406,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -4429,15 +4429,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -4452,15 +4452,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4528,15 +4528,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4597,15 +4597,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -4619,15 +4619,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -4640,15 +4640,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4756,15 +4756,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -4779,15 +4779,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -4802,15 +4802,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -4870,15 +4870,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4911,15 +4911,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -4931,42 +4931,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5046,15 +5046,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
@@ -5066,63 +5066,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < int()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'int'", type1->tp_name);
@@ -5164,15 +5164,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5205,15 +5205,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -5225,42 +5225,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5340,15 +5340,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
@@ -5360,63 +5360,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'int' and '%s'", type2->tp_name);
@@ -5482,15 +5482,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5551,15 +5551,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -5573,15 +5573,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -5594,15 +5594,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5710,15 +5710,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -5733,15 +5733,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -5756,15 +5756,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -5832,15 +5832,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5901,15 +5901,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -5923,15 +5923,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -5944,15 +5944,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6060,15 +6060,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -6083,15 +6083,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -6106,15 +6106,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -6175,15 +6175,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
         return COMPARE_LT_OBJECT_LONG_LONG(operand1, operand2);
@@ -6212,15 +6212,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6253,15 +6253,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6273,42 +6273,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6388,15 +6388,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
@@ -6408,63 +6408,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < int()", type1->tp_name);
@@ -6506,15 +6506,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6547,15 +6547,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -6567,42 +6567,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6682,15 +6682,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
@@ -6702,63 +6702,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unorderable types: long() < %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: int() < %s()", type2->tp_name);
@@ -6859,15 +6859,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6928,15 +6928,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -6950,15 +6950,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -6971,15 +6971,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7087,15 +7087,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -7110,15 +7110,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -7133,15 +7133,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7209,15 +7209,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7278,15 +7278,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -7300,15 +7300,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -7321,15 +7321,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7437,15 +7437,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -7460,15 +7460,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -7483,15 +7483,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -7530,15 +7530,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     bool r = a < b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
         return COMPARE_LT_OBJECT_FLOAT_FLOAT(operand1, operand2);
@@ -7567,15 +7567,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7608,15 +7608,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7628,42 +7628,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7743,15 +7743,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
@@ -7763,63 +7763,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < float()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'float'", type1->tp_name);
@@ -7859,15 +7859,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7900,15 +7900,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -7920,42 +7920,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8035,15 +8035,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
@@ -8055,63 +8055,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: float() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'float' and '%s'", type2->tp_name);
@@ -8187,15 +8187,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8256,15 +8256,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -8278,15 +8278,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -8299,15 +8299,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8415,15 +8415,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -8438,15 +8438,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -8461,15 +8461,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8535,15 +8535,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8604,15 +8604,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -8626,15 +8626,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -8647,15 +8647,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8763,15 +8763,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -8786,15 +8786,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -8809,15 +8809,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -8882,15 +8882,15 @@
     }
 
     if (found == false) {
         bool r = len_a < len_b;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_LT_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
@@ -8922,15 +8922,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8963,15 +8963,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -8983,42 +8983,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9098,15 +9098,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
@@ -9118,63 +9118,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < tuple()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'tuple'", type1->tp_name);
@@ -9214,15 +9214,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9255,15 +9255,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -9275,42 +9275,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9390,15 +9390,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
@@ -9410,63 +9410,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: tuple() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'tuple' and '%s'", type2->tp_name);
@@ -9567,15 +9567,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9636,15 +9636,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -9658,15 +9658,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -9679,15 +9679,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9795,15 +9795,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -9818,15 +9818,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -9841,15 +9841,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -9915,15 +9915,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9984,15 +9984,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -10006,15 +10006,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -10027,15 +10027,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10143,15 +10143,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -10166,15 +10166,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -10189,15 +10189,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -10269,15 +10269,15 @@
     }
 
     if (found == false) {
         bool r = Py_SIZE(a) < Py_SIZE(b);
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     return RICH_COMPARE_LT_OBJECT_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
 PyObject *RICH_COMPARE_LT_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
@@ -10309,15 +10309,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10350,15 +10350,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10370,42 +10370,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10485,15 +10485,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
@@ -10505,63 +10505,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: %s() < list()", type1->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of '%s' and 'list'", type1->tp_name);
@@ -10601,15 +10601,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10642,15 +10642,15 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -10662,42 +10662,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10777,15 +10777,15 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
@@ -10797,63 +10797,63 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch (Py_LT) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
         PyErr_Format(PyExc_TypeError, "unorderable types: list() < %s()", type2->tp_name);
 #else
         PyErr_Format(PyExc_TypeError, "'<' not supported between instances of 'list' and '%s'", type2->tp_name);
@@ -10955,15 +10955,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11024,15 +11024,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -11046,15 +11046,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -11067,15 +11067,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11183,15 +11183,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -11206,15 +11206,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -11229,15 +11229,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11303,15 +11303,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11372,15 +11372,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
 
@@ -11394,15 +11394,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_GT);
 
         if (result != Py_NotImplemented) {
@@ -11415,15 +11415,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11531,15 +11531,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_LT);
@@ -11554,15 +11554,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_GT);
@@ -11577,15 +11577,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
@@ -11669,15 +11669,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
 PyObject *RICH_COMPARE_LT_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
     return COMPARE_LT_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
@@ -11755,15 +11755,15 @@
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
     bool r = a < b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
 PyObject *RICH_COMPARE_LT_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
     return COMPARE_LT_OBJECT_INT_CLONG(operand1, operand2);
 }
@@ -11817,15 +11817,15 @@
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
 PyObject *RICH_COMPARE_LT_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
     return COMPARE_LT_OBJECT_LONG_DIGIT(operand1, operand2);
@@ -11878,15 +11878,15 @@
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
     bool r = a < b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
 PyObject *RICH_COMPARE_LT_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
     return COMPARE_LT_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersComparisonNe.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersComparisonEq.c`

 * *Files 4% similar despite different names*

```diff
@@ -3,66 +3,67 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationComparison.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-/* C helpers for type specialized "!=" (NE) comparisons */
+#include "HelpersComparisonEqUtils.c"
+/* C helpers for type specialized "==" (EQ) comparisons */
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_NE_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 #endif
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_NE_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
+static bool COMPARE_EQ_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 #endif
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
-        bool r = false;
+        bool r = true;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
@@ -78,23 +79,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -102,15 +103,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -127,62 +128,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -239,15 +240,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -262,109 +263,109 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
-        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 #endif
 
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && IS_SANE_TYPE(Py_TYPE(operand1))) {
-        bool r = false;
+        bool r = true;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
@@ -382,15 +383,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == type2 && !PyInstance_Check(operand1)) {
 
         richcmpfunc frich = RICHCOMPARE(type1);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -398,15 +399,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = type1->tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -414,15 +415,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -451,15 +452,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -467,21 +468,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -489,20 +490,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -510,15 +511,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -575,15 +576,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -610,15 +611,15 @@
 
     if (type1 != type2 && Nuitka_Type_IsSubtype(type2, type1)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -626,22 +627,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -649,22 +650,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -672,100 +673,100 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != %s()", type1->tp_name, type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == %s()", type1->tp_name, type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and '%s'", type1->tp_name,
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_NE_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     } else {
         if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = false;
+            bool r = true;
 
             // Convert to target type.
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         } else {
-            bool r = true;
+            bool r = false;
 
             // Convert to target type.
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_NE_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -779,23 +780,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -803,15 +804,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -828,62 +829,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -940,15 +941,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -963,103 +964,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_STR_STR(operand1, operand2);
+        return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -1073,23 +1074,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1097,15 +1098,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1122,62 +1123,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1234,15 +1235,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1257,150 +1258,166 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_NE_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+/* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_STR_STR(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_STR_STR(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION < 0x300
+static bool COMPARE_EQ_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyString_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyString_CheckExact(operand2));
 
     PyStringObject *a = (PyStringObject *)operand1;
     PyStringObject *b = (PyStringObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     } else {
         if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = false;
+            bool r = true;
 
             // Convert to target type.
             bool result = r;
 
             return result;
         } else {
-            bool r = true;
+            bool r = false;
 
             // Convert to target type.
             bool result = r;
 
             return result;
         }
     }
 }
+/* Code referring to "STR" corresponds to Python2 'str' and "STR" to Python2 'str'. */
+bool RICH_COMPARE_EQ_CBOOL_STR_STR(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "STR" to Python2 'str'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_STR(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyString_Type) {
-        return COMPARE_NE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1414,15 +1431,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyString_Type && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1430,15 +1447,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1446,15 +1463,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1483,15 +1500,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyString_Type && 0) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1499,21 +1516,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1521,20 +1538,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1542,15 +1559,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -1607,15 +1624,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1642,15 +1659,15 @@
 
     if (type1 != &PyString_Type && Nuitka_Type_IsSubtype(&PyString_Type, type1)) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1658,22 +1675,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1681,22 +1698,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyString_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1704,53 +1721,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "STR" corresponds to Python2 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_STR_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyString_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_STR_STR(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -1764,15 +1781,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyString_Type == type2 && !0) {
 
         richcmpfunc frich = PyString_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1780,15 +1797,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -1796,15 +1813,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -1833,15 +1850,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -1849,21 +1866,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1871,20 +1888,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -1892,15 +1909,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -1957,15 +1974,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -1992,15 +2009,15 @@
 
     if (&PyString_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyString_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2008,22 +2025,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyString_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2031,22 +2048,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2054,63 +2071,63 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_NE_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
 #if PYTHON_VERSION >= 0x300
     bool r;
 
     Py_ssize_t len = PyUnicode_GET_LENGTH(a);
@@ -2144,16 +2161,16 @@
             const void *data2 = PyUnicode_DATA(b);
 
             int cmp = memcmp(data1, data2, len * kind1);
             r = (cmp == 0);
         }
     }
 
-    PyObject *result = BOOL_FROM(r == false);
-    Py_INCREF(result);
+    PyObject *result = BOOL_FROM(r == true);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool r;
 
     Py_ssize_t len = PyUnicode_GET_LENGTH(a);
     if (PyUnicode_GET_LENGTH(b) != len) {
         r = false;
@@ -2161,24 +2178,24 @@
         const Py_UNICODE *data1 = a->str;
         const Py_UNICODE *data2 = b->str;
 
         int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
         r = (cmp == 0);
     }
 
-    PyObject *result = BOOL_FROM(r == false);
-    Py_INCREF(result);
+    PyObject *result = BOOL_FROM(r == true);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #endif
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_NE_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2192,23 +2209,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2216,15 +2233,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2241,62 +2258,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2353,15 +2370,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2376,103 +2393,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_UNICODE_UNICODE(operand1, operand2);
+        return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -2486,23 +2503,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2510,15 +2527,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2535,62 +2552,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -2647,15 +2664,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -2670,110 +2687,117 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() == %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-static bool COMPARE_NE_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+/* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
+ * Python3 'str'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_UNICODE_UNICODE(operand1, operand2);
+}
+
+static bool COMPARE_EQ_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyUnicode_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyUnicode_CheckExact(operand2));
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
@@ -2811,15 +2835,15 @@
             const void *data2 = PyUnicode_DATA(b);
 
             int cmp = memcmp(data1, data2, len * kind1);
             r = (cmp == 0);
         }
     }
 
-    bool result = r == false;
+    bool result = r == true;
 
     return result;
 #else
     bool r;
 
     Py_ssize_t len = PyUnicode_GET_LENGTH(a);
     if (PyUnicode_GET_LENGTH(b) != len) {
@@ -2828,24 +2852,31 @@
         const Py_UNICODE *data1 = a->str;
         const Py_UNICODE *data2 = b->str;
 
         int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
         r = (cmp == 0);
     }
 
-    bool result = r == false;
+    bool result = r == true;
 
     return result;
 #endif
 }
+/* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "UNICODE" to Python2 'unicode',
+ * Python3 'str'. */
+bool RICH_COMPARE_EQ_CBOOL_UNICODE_UNICODE(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2);
+}
+
 /* Code referring to "OBJECT" corresponds to any Python object and "UNICODE" to Python2 'unicode', Python3 'str'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_UNICODE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyUnicode_Type) {
-        return COMPARE_NE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -2859,15 +2890,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyUnicode_Type && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2875,15 +2906,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -2891,15 +2922,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -2928,15 +2959,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyUnicode_Type && 0) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -2944,21 +2975,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2966,20 +2997,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -2987,15 +3018,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3052,15 +3083,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3087,15 +3118,15 @@
 
     if (type1 != &PyUnicode_Type && Nuitka_Type_IsSubtype(&PyUnicode_Type, type1)) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3103,22 +3134,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3126,22 +3157,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyUnicode_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3149,53 +3180,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != unicode()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == unicode()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != str()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == str()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'str'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'str'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "UNICODE" corresponds to Python2 'unicode', Python3 'str' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_UNICODE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyUnicode_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_UNICODE_UNICODE(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -3209,15 +3240,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyUnicode_Type == type2 && !0) {
 
         richcmpfunc frich = PyUnicode_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3225,15 +3256,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3241,15 +3272,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3278,15 +3309,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3294,21 +3325,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3316,20 +3347,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3337,15 +3368,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyUnicode_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3402,15 +3433,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3437,15 +3468,15 @@
 
     if (&PyUnicode_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyUnicode_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3453,22 +3484,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyUnicode_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -3476,22 +3507,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -3499,101 +3530,101 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: unicode() == %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: str() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: str() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'str' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'str' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 #if PYTHON_VERSION >= 0x300
-static PyObject *COMPARE_NE_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     } else {
         if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = false;
+            bool r = true;
 
             // Convert to target type.
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         } else {
-            bool r = true;
+            bool r = false;
 
             // Convert to target type.
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_NE_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3607,23 +3638,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3631,15 +3662,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3656,62 +3687,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -3768,15 +3799,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -3791,103 +3822,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_BYTES_BYTES(operand1, operand2);
+        return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -3901,23 +3932,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -3925,15 +3956,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -3950,62 +3981,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4062,15 +4093,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4085,150 +4116,166 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
-static bool COMPARE_NE_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+/* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_BYTES_BYTES(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION >= 0x300
+static bool COMPARE_EQ_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyBytes_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyBytes_CheckExact(operand2));
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
     if (operand1 == operand2) {
-        bool r = false;
+        bool r = true;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         bool result = r;
 
         return result;
     } else {
         if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-            bool r = false;
+            bool r = true;
 
             // Convert to target type.
             bool result = r;
 
             return result;
         } else {
-            bool r = true;
+            bool r = false;
 
             // Convert to target type.
             bool result = r;
 
             return result;
         }
     }
 }
+/* Code referring to "BYTES" corresponds to Python3 'bytes' and "BYTES" to Python3 'bytes'. */
+bool RICH_COMPARE_EQ_CBOOL_BYTES_BYTES(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION >= 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "BYTES" to Python3 'bytes'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_BYTES(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyBytes_Type) {
-        return COMPARE_NE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4242,15 +4289,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyBytes_Type && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4258,15 +4305,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4274,15 +4321,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4311,15 +4358,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyBytes_Type && 0) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4327,21 +4374,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4349,20 +4396,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4370,15 +4417,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -4435,15 +4482,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4470,15 +4517,15 @@
 
     if (type1 != &PyBytes_Type && Nuitka_Type_IsSubtype(&PyBytes_Type, type1)) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4486,22 +4533,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4509,22 +4556,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyBytes_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4532,53 +4579,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != bytes()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == bytes()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'bytes'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'bytes'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION >= 0x300
 /* Code referring to "BYTES" corresponds to Python3 'bytes' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_BYTES_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyBytes_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_BYTES_BYTES(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -4592,15 +4639,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyBytes_Type == type2 && !0) {
 
         richcmpfunc frich = PyBytes_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4608,15 +4655,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4624,15 +4671,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4661,15 +4708,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4677,21 +4724,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4699,20 +4746,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4720,15 +4767,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -4785,15 +4832,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -4820,15 +4867,15 @@
 
     if (&PyBytes_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyBytes_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4836,22 +4883,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyBytes_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -4859,22 +4906,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -4882,53 +4929,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: bytes() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'bytes' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'bytes' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -4942,23 +4989,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -4966,15 +5013,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -4991,62 +5038,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5103,15 +5150,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5126,103 +5173,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_INT_INT(operand1, operand2);
+        return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -5236,23 +5283,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5260,15 +5307,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5285,62 +5332,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5397,15 +5444,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5420,103 +5467,119 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
+/* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_INT_INT(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION < 0x300
+/* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
+bool RICH_COMPARE_EQ_CBOOL_INT_INT(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2);
+}
+#endif
+
+#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyInt_Type) {
-        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5530,15 +5593,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyInt_Type && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5546,15 +5609,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5562,15 +5625,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5599,15 +5662,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyInt_Type && 0) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5615,21 +5678,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5637,20 +5700,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5658,15 +5721,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -5723,15 +5786,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -5758,15 +5821,15 @@
 
     if (type1 != &PyInt_Type && Nuitka_Type_IsSubtype(&PyInt_Type, type1)) {
         f = NULL;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5774,22 +5837,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5797,22 +5860,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = NULL;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5820,53 +5883,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyInt_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_INT_INT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -5880,15 +5943,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyInt_Type == type2 && !0) {
 
         richcmpfunc frich = NULL;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5896,15 +5959,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyInt_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -5912,15 +5975,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -5949,15 +6012,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -5965,21 +6028,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -5987,20 +6050,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6008,15 +6071,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyInt_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6073,15 +6136,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6108,15 +6171,15 @@
 
     if (&PyInt_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyInt_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6124,22 +6187,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = NULL;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6147,22 +6210,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6170,86 +6233,87 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 #endif
 
-static PyObject *COMPARE_NE_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     PyLongObject *operand2_long_object = (PyLongObject *)operand2;
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
-        r = false;
+        r = true;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_NE_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6263,23 +6327,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6287,15 +6351,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6312,62 +6376,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6424,15 +6488,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6447,103 +6511,103 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_LONG_LONG(operand1, operand2);
+        return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -6557,23 +6621,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6581,15 +6645,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6606,62 +6670,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -6718,15 +6782,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -6741,137 +6805,150 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() == %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-static bool COMPARE_NE_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_LONG_LONG(operand1, operand2);
+}
+
+static bool COMPARE_EQ_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     PyLongObject *operand2_long_object = (PyLongObject *)operand2;
 
     bool r;
 
     if (operand1_long_object == operand2_long_object) {
-        r = false;
+        r = true;
     } else if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
                Nuitka_LongGetSignedDigitSize(operand2_long_object)) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] !=
                 Nuitka_LongGetDigitPointer(operand2_long_object)[i]) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
+/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
+bool RICH_COMPARE_EQ_CBOOL_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2);
+}
+
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyLong_Type) {
-        return COMPARE_NE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -6885,15 +6962,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyLong_Type && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6901,15 +6978,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -6917,15 +6994,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -6954,15 +7031,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyLong_Type && 0) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -6970,21 +7047,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -6992,20 +7069,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7013,15 +7090,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7078,15 +7155,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7113,15 +7190,15 @@
 
     if (type1 != &PyLong_Type && Nuitka_Type_IsSubtype(&PyLong_Type, type1)) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7129,22 +7206,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7152,22 +7229,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7175,53 +7252,53 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != long()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == long()", type1->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != int()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == int()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'int'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'int'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyLong_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_LONG_LONG(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -7235,15 +7312,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyLong_Type == type2 && !0) {
 
         richcmpfunc frich = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7251,15 +7328,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = PyLong_Type.tp_compare;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7267,15 +7344,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7304,15 +7381,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7320,21 +7397,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7342,20 +7419,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7363,15 +7440,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = PyLong_Type.tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7428,15 +7505,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7463,15 +7540,15 @@
 
     if (&PyLong_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyLong_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7479,22 +7556,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = (PYTHON_VERSION < 0x300 ? NULL : PyLong_Type.tp_richcompare);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -7502,22 +7579,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -7525,69 +7602,69 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x300
-        PyErr_Format(PyExc_TypeError, "unorderable types: long() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: long() == %s()", type2->tp_name);
 #elif PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: int() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: int() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'int' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'int' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_NE_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_NE_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7601,23 +7678,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7625,15 +7702,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7650,62 +7727,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -7762,15 +7839,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -7785,101 +7862,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -7893,23 +7970,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -7917,15 +7994,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -7942,62 +8019,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8054,15 +8131,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8077,117 +8154,129 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
-static bool COMPARE_NE_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+/* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
+PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_OBJECT_FLOAT_FLOAT(operand1, operand2);
+}
+
+static bool COMPARE_EQ_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
+/* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
+bool RICH_COMPARE_EQ_CBOOL_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+
+    return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2);
+}
+
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyFloat_Type) {
-        return COMPARE_NE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8201,15 +8290,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyFloat_Type && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8217,15 +8306,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8233,15 +8322,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8270,15 +8359,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyFloat_Type && 0) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8286,21 +8375,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8308,20 +8397,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8329,15 +8418,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -8394,15 +8483,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8429,15 +8518,15 @@
 
     if (type1 != &PyFloat_Type && Nuitka_Type_IsSubtype(&PyFloat_Type, type1)) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8445,22 +8534,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8468,22 +8557,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyFloat_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8491,51 +8580,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != float()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == float()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'float'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'float'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyFloat_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
+        return COMPARE_EQ_CBOOL_FLOAT_FLOAT(operand1, operand2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -8549,15 +8638,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyFloat_Type == type2 && !0) {
 
         richcmpfunc frich = PyFloat_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8565,15 +8654,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8581,15 +8670,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8618,15 +8707,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8634,21 +8723,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8656,20 +8745,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8677,15 +8766,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -8742,15 +8831,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -8777,15 +8866,15 @@
 
     if (&PyFloat_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyFloat_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8793,22 +8882,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyFloat_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -8816,22 +8905,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -8839,64 +8928,64 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: float() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: float() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'float' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'float' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
-static PyObject *COMPARE_NE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < len_a && i < len_b; i++) {
@@ -8914,26 +9003,26 @@
         }
 
         if (res == NUITKA_BOOL_FALSE) {
             break;
         }
     }
 
-    bool r = res == NUITKA_BOOL_FALSE;
+    bool r = res == NUITKA_BOOL_TRUE;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -8947,23 +9036,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -8971,15 +9060,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -8996,62 +9085,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9108,15 +9197,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9131,101 +9220,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -9239,23 +9328,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9263,15 +9352,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9288,62 +9377,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -9400,15 +9489,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9423,116 +9512,116 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-PyObject *RICH_COMPARE_NE_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_OBJECT_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_EQ_OBJECT_TUPLE_TUPLE(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_NE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_EQ_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyTuple_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyTuple_CheckExact(operand2));
 
     PyTupleObject *a = (PyTupleObject *)operand1;
     PyTupleObject *b = (PyTupleObject *)operand2;
 
     Py_ssize_t len_a = Py_SIZE(a);
     Py_ssize_t len_b = Py_SIZE(b);
 
     if (len_a != len_b) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
 
@@ -9554,26 +9643,26 @@
         }
 
         if (res == NUITKA_BOOL_FALSE) {
             break;
         }
     }
 
-    bool r = res == NUITKA_BOOL_FALSE;
+    bool r = res == NUITKA_BOOL_TRUE;
 
     // Convert to target type.
     nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_TUPLE(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyTuple_Type) {
-        return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -9587,15 +9676,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyTuple_Type && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9603,15 +9692,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9619,15 +9708,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -9656,15 +9745,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyTuple_Type && 0) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9672,21 +9761,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9694,20 +9783,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9715,15 +9804,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -9780,15 +9869,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -9815,15 +9904,15 @@
 
     if (type1 != &PyTuple_Type && Nuitka_Type_IsSubtype(&PyTuple_Type, type1)) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9831,22 +9920,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -9854,22 +9943,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyTuple_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9877,51 +9966,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != tuple()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == tuple()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'tuple'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'tuple'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_TUPLE_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyTuple_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+        return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -9935,15 +10024,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyTuple_Type == type2 && !0) {
 
         richcmpfunc frich = PyTuple_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -9951,15 +10040,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -9967,15 +10056,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10004,15 +10093,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10020,21 +10109,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10042,20 +10131,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10063,15 +10152,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10128,15 +10217,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10163,15 +10252,15 @@
 
     if (&PyTuple_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyTuple_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10179,22 +10268,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyTuple_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -10202,22 +10291,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -10225,67 +10314,67 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: tuple() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'tuple' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'tuple' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "TUPLE" corresponds to Python 'tuple' and "TUPLE" to Python 'tuple'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_TUPLE_TUPLE(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_NBOOL_TUPLE_TUPLE(operand1, operand2);
+    return COMPARE_EQ_NBOOL_TUPLE_TUPLE(operand1, operand2);
 }
 
-static PyObject *COMPARE_NE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static PyObject *COMPARE_EQ_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
     if (Py_SIZE(a) != Py_SIZE(b)) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
 
     nuitka_bool res = NUITKA_BOOL_TRUE;
 
     Py_ssize_t i;
     for (i = 0; i < Py_SIZE(a) && i < Py_SIZE(b); i++) {
@@ -10308,31 +10397,30 @@
 
         if (res == NUITKA_BOOL_FALSE) {
             break;
         }
     }
 
     bool r;
-
     if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
-        r = Py_SIZE(a) != Py_SIZE(b);
+        r = Py_SIZE(a) == Py_SIZE(b);
     } else {
-        r = res == NUITKA_BOOL_FALSE;
+        r = res == NUITKA_BOOL_TRUE;
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_NE_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10346,23 +10434,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10370,15 +10458,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10395,62 +10483,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -10507,15 +10595,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10530,101 +10618,101 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-PyObject *RICH_COMPARE_NE_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
+        return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NULL;
     }
 #else
@@ -10638,23 +10726,23 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -10662,15 +10750,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NULL;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -10687,62 +10775,62 @@
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
             PyObject *result = BOOL_FROM(r);
-            Py_INCREF(result);
+            Py_INCREF_IMMORTAL(result);
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -10799,15 +10887,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NULL;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -10822,113 +10910,113 @@
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             return result;
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 return result;
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         PyObject *result = BOOL_FROM(r);
-        Py_INCREF(result);
+        Py_INCREF_IMMORTAL(result);
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NULL;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-PyObject *RICH_COMPARE_NE_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_OBJECT_LIST_LIST(operand1, operand2);
+    return COMPARE_EQ_OBJECT_LIST_LIST(operand1, operand2);
 }
 
-static nuitka_bool COMPARE_NE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+static nuitka_bool COMPARE_EQ_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
     if (Py_SIZE(a) != Py_SIZE(b)) {
-        bool r = true;
+        bool r = false;
 
         // Convert to target type.
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
 
@@ -10955,31 +11043,30 @@
 
         if (res == NUITKA_BOOL_FALSE) {
             break;
         }
     }
 
     bool r;
-
     if (i >= Py_SIZE(a) || i >= Py_SIZE(b)) {
-        r = Py_SIZE(a) != Py_SIZE(b);
+        r = Py_SIZE(a) == Py_SIZE(b);
     } else {
-        r = res == NUITKA_BOOL_FALSE;
+        r = res == NUITKA_BOOL_TRUE;
     }
 
     // Convert to target type.
     nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
     return result;
 }
 /* Code referring to "OBJECT" corresponds to any Python object and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_OBJECT_LIST(PyObject *operand1, PyObject *operand2) {
 
     if (Py_TYPE(operand1) == &PyList_Type) {
-        return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -10993,15 +11080,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (type1 == &PyList_Type && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11009,15 +11096,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11025,15 +11112,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11062,15 +11149,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (type1 != &PyList_Type && 0) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11078,21 +11165,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11100,20 +11187,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11121,15 +11208,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (PyInstance_Check(operand1)) {
         cmpfunc fcmp = type1->tp_compare;
         c = (*fcmp)(operand1, operand2);
@@ -11186,15 +11273,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11221,15 +11308,15 @@
 
     if (type1 != &PyList_Type && Nuitka_Type_IsSubtype(&PyList_Type, type1)) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11237,22 +11324,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = RICHCOMPARE(type1);
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11260,22 +11347,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = PyList_Type.tp_richcompare;
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11283,51 +11370,51 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: %s() != list()", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: %s() == list()", type1->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of '%s' and 'list'", type1->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of '%s' and 'list'", type1->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "OBJECT" to any Python object. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_LIST_OBJECT(PyObject *operand1, PyObject *operand2) {
 
     if (&PyList_Type == Py_TYPE(operand2)) {
-        return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
+        return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
     }
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return NUITKA_BOOL_EXCEPTION;
     }
 #else
@@ -11341,15 +11428,15 @@
 #if PYTHON_VERSION < 0x300
     // If the types are equal, we may get away immediately except for instances.
     if (&PyList_Type == type2 && !0) {
 
         richcmpfunc frich = PyList_Type.tp_richcompare;
 
         if (frich != NULL) {
-            PyObject *result = (*frich)(operand1, operand2, Py_NE);
+            PyObject *result = (*frich)(operand1, operand2, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11357,15 +11444,15 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
         cmpfunc fcmp = NULL;
 
         if (fcmp != NULL) {
             int c = (*fcmp)(operand1, operand2);
@@ -11373,15 +11460,15 @@
 
             Py_LeaveRecursiveCall();
 
             if (c == -2) {
                 return NUITKA_BOOL_EXCEPTION;
             }
 
-            switch (Py_NE) {
+            switch (Py_EQ) {
             case Py_LT:
                 c = c < 0;
                 break;
             case Py_LE:
                 c = c <= 0;
                 break;
             case Py_EQ:
@@ -11410,15 +11497,15 @@
     // Fast path was not successful or not taken
     richcmpfunc f;
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11426,21 +11513,21 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11448,20 +11535,20 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = RICHCOMPARE(type2);
     if (f != NULL) {
-        PyObject *result = (*f)(operand2, operand1, Py_NE);
+        PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11469,15 +11556,15 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if (0) {
         cmpfunc fcmp = NULL;
         c = (*fcmp)(operand1, operand2);
@@ -11534,15 +11621,15 @@
 
     Py_LeaveRecursiveCall();
 
     if (unlikely(c <= -2)) {
         return NUITKA_BOOL_EXCEPTION;
     }
 
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_LT:
         c = c < 0;
         break;
     case Py_LE:
         c = c <= 0;
         break;
     case Py_EQ:
@@ -11569,15 +11656,15 @@
 
     if (&PyList_Type != type2 && Nuitka_Type_IsSubtype(type2, &PyList_Type)) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
             checked_reverse_op = true;
 
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11585,22 +11672,22 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = PyList_Type.tp_richcompare;
 
     if (f != NULL) {
-        PyObject *result = (*f)(operand1, operand2, Py_NE);
+        PyObject *result = (*f)(operand1, operand2, Py_EQ);
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             if (unlikely(result == NULL)) {
                 return NUITKA_BOOL_EXCEPTION;
             }
@@ -11608,22 +11695,22 @@
             {
                 nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                 Py_DECREF(result);
                 return r;
             }
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = RICHCOMPARE(type2);
 
         if (f != NULL) {
-            PyObject *result = (*f)(operand2, operand1, Py_NE);
+            PyObject *result = (*f)(operand2, operand1, Py_EQ);
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 if (unlikely(result == NULL)) {
                     return NUITKA_BOOL_EXCEPTION;
                 }
@@ -11631,54 +11718,54 @@
                 {
                     nuitka_bool r = CHECK_IF_TRUE(result) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                     Py_DECREF(result);
                     return r;
                 }
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
-    switch (Py_NE) {
+    switch (Py_EQ) {
     case Py_EQ: {
         bool r = operand1 == operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
         nuitka_bool result = r ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
 
         return result;
     }
     default:
 #if PYTHON_VERSION < 0x360
-        PyErr_Format(PyExc_TypeError, "unorderable types: list() != %s()", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "unorderable types: list() == %s()", type2->tp_name);
 #else
-        PyErr_Format(PyExc_TypeError, "'!=' not supported between instances of 'list' and '%s'", type2->tp_name);
+        PyErr_Format(PyExc_TypeError, "'==' not supported between instances of 'list' and '%s'", type2->tp_name);
 #endif
         return NUITKA_BOOL_EXCEPTION;
     }
 #endif
 }
 
 /* Code referring to "LIST" corresponds to Python 'list' and "LIST" to Python 'list'. */
-nuitka_bool RICH_COMPARE_NE_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
+nuitka_bool RICH_COMPARE_EQ_NBOOL_LIST_LIST(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_NBOOL_LIST_LIST(operand1, operand2);
+    return COMPARE_EQ_NBOOL_LIST_LIST(operand1, operand2);
 }
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_NE_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_EQ_OBJECT_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11706,40 +11793,41 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-PyObject *RICH_COMPARE_NE_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_EQ_OBJECT_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_NE_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_EQ_CBOOL_LONG_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool operand2_is_negative;
     unsigned long operand2_abs_ival;
@@ -11767,190 +11855,193 @@
     }
 
     Py_ssize_t operand2_size = operand2_is_negative == false ? operand2_digit_count : -operand2_digit_count;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) != operand2_size) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != operand2_digits[i]) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-bool RICH_COMPARE_NE_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
+bool RICH_COMPARE_EQ_CBOOL_LONG_INT(PyObject *operand1, PyObject *operand2) {
 
-    return COMPARE_NE_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
+    return COMPARE_EQ_CBOOL_LONG_CLONG(operand1, PyInt_AS_LONG(operand1));
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static PyObject *COMPARE_NE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_EQ_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-PyObject *RICH_COMPARE_NE_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_NE_OBJECT_INT_CLONG(operand1, operand2);
+    return COMPARE_EQ_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
-static bool COMPARE_NE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+static bool COMPARE_EQ_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-bool RICH_COMPARE_NE_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_EQ_CBOOL_INT_CLONG(PyObject *operand1, long operand2) {
 
-    return COMPARE_NE_CBOOL_INT_CLONG(operand1, operand2);
+    return COMPARE_EQ_CBOOL_INT_CLONG(operand1, operand2);
 }
 #endif
 
-static PyObject *COMPARE_NE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+static PyObject *COMPARE_EQ_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-PyObject *RICH_COMPARE_NE_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_NE_OBJECT_LONG_DIGIT(operand1, operand2);
+    return COMPARE_EQ_OBJECT_LONG_DIGIT(operand1, operand2);
 }
 
-static bool COMPARE_NE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+static bool COMPARE_EQ_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
     bool r;
 
     if (Nuitka_LongGetSignedDigitSize(operand1_long_object) !=
         (Py_ssize_t)((operand2 == 0) ? 0 : ((operand2 < 0) ? -1 : 1))) {
-        r = true;
+        r = false;
     } else {
         Py_ssize_t i = Nuitka_LongGetDigitSize(operand1_long_object);
-        r = false;
+        r = true;
+
         while (--i >= 0) {
             if (Nuitka_LongGetDigitPointer(operand1_long_object)[i] != (digit)Py_ABS(operand2)) {
-                r = true;
+                r = false;
                 break;
             }
         }
     }
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
  * Python objects. */
-bool RICH_COMPARE_NE_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
+bool RICH_COMPARE_EQ_CBOOL_LONG_DIGIT(PyObject *operand1, long operand2) {
 
-    return COMPARE_NE_CBOOL_LONG_DIGIT(operand1, operand2);
+    return COMPARE_EQ_CBOOL_LONG_DIGIT(operand1, operand2);
 }
 
-static PyObject *COMPARE_NE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *COMPARE_EQ_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     PyObject *result = BOOL_FROM(r);
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-PyObject *RICH_COMPARE_NE_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+PyObject *RICH_COMPARE_EQ_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_NE_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_EQ_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
 
-static bool COMPARE_NE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static bool COMPARE_EQ_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    bool r = a != b;
+    bool r = a == b;
 
     // Convert to target type.
     bool result = r;
 
     return result;
 }
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-bool RICH_COMPARE_NE_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+bool RICH_COMPARE_EQ_CBOOL_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
 
-    return COMPARE_NE_CBOOL_FLOAT_CFLOAT(operand1, operand2);
+    return COMPARE_EQ_CBOOL_FLOAT_CFLOAT(operand1, operand2);
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersConstantsBlob.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersConstantsBlob.c`

 * *Files 0% similar despite different names*

```diff
@@ -109,15 +109,15 @@
         result = Py_False;
     } else if (memcmp(&list1->ob_item[0], &list2->ob_item[0], Py_SIZE(list1) * sizeof(PyObject *)) == 0) {
         result = Py_True;
     } else {
         result = Py_False;
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static Py_hash_t our_tuple_hash(PyTupleObject *tuple) {
     return Nuitka_FastHashBytes(&tuple->ob_item[0], Py_SIZE(tuple) * sizeof(PyObject *));
 }
 
@@ -132,15 +132,15 @@
         result = Py_False;
     } else if (memcmp(&tuple1->ob_item[0], &tuple2->ob_item[0], Py_SIZE(tuple1) * sizeof(PyObject *)) == 0) {
         result = Py_True;
     } else {
         result = Py_False;
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static Py_hash_t our_set_hash(PyObject *set) {
     Py_hash_t result = 0;
     PyObject *key;
     Py_ssize_t pos = 0;
@@ -206,15 +206,15 @@
                 result = Py_False;
                 break;
             }
         }
 #endif
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static PyObject *our_float_richcompare(PyFloatObject *a, PyFloatObject *b, int op) {
     assert(op == Py_EQ);
 
     PyObject *result;
@@ -222,15 +222,15 @@
     // Avoid the C math when comparing, for it makes too many values equal or unequal.
     if (memcmp(&a->ob_fval, &b->ob_fval, sizeof(b->ob_fval)) == 0) {
         result = Py_True;
     } else {
         result = Py_False;
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static Py_hash_t our_dict_hash(PyObject *dict) {
     Py_hash_t result = 0;
 
     Py_ssize_t pos = 0;
@@ -270,15 +270,15 @@
             if (key1 != key2 || value1 != value2) {
                 result = Py_False;
                 break;
             }
         }
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 // For creation of small long singleton long values as required by Python3.
 #if PYTHON_VERSION < 0x3b0
 #if PYTHON_VERSION >= 0x390
 PyObject **Nuitka_Long_SmallValues;
@@ -917,15 +917,15 @@
             break;
         }
         case ':': {
             // Slice object
             PyObject *items[3];
             data = _unpackBlobConstants(tstate, &items[0], data, 3);
 
-            PyObject *s = MAKE_SLICE_OBJECT3(items[0], items[1], items[2]);
+            PyObject *s = MAKE_SLICE_OBJECT3(tstate, items[0], items[1], items[2]);
 
             *output = s;
             is_object = true;
 
             break;
         }
         case ';': {
@@ -1142,16 +1142,20 @@
 
         // Discourage in-place operations from modifying these. These
         // might be put into containers, therefore take 2 refs to be
         // accounting for the container too.
         if (is_object == true) {
             CHECK_OBJECT(*output);
 
+#if PYTHON_VERSION < 0x3c0
             Py_INCREF(*output);
             Py_INCREF(*output);
+#else
+            Py_SET_REFCNT_IMMORTAL(*output);
+#endif
         }
 
         // PRINT_ITEM(*output);
         // PRINT_NEW_LINE();
 
         output += 1;
     }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDeepcopy.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDeepcopy.c`

 * *Files 0% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 
 static PyObject *DEEP_COPY_ITEM(PyThreadState *tstate, PyObject *value, PyTypeObject **type, copy_func *copy_function);
 
 PyObject *DEEP_COPY_LIST(PyThreadState *tstate, PyObject *value) {
     assert(PyList_CheckExact(value));
 
     Py_ssize_t n = PyList_GET_SIZE(value);
-    PyObject *result = MAKE_LIST_EMPTY(n);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, n);
 
     PyTypeObject *type = NULL;
     copy_func copy_function = NULL;
 
     for (Py_ssize_t i = 0; i < n; i++) {
         PyObject *item = PyList_GET_ITEM(value, i);
         if (i == 0) {
@@ -57,15 +57,15 @@
 }
 
 PyObject *DEEP_COPY_TUPLE(PyThreadState *tstate, PyObject *value) {
     assert(PyTuple_CheckExact(value));
 
     Py_ssize_t n = PyTuple_GET_SIZE(value);
 
-    PyObject *result = MAKE_TUPLE_EMPTY_VAR(n);
+    PyObject *result = MAKE_TUPLE_EMPTY_VAR(tstate, n);
 
     for (Py_ssize_t i = 0; i < n; i++) {
         PyTuple_SET_ITEM(result, i, DEEP_COPY(tstate, PyTuple_GET_ITEM(value, i)));
     }
 
     return result;
 }
@@ -142,16 +142,18 @@
 #if PYTHON_VERSION >= 0x390
     PyDict_SetItem(_deep_copy_dispatch, (PyObject *)&Py_GenericAliasType,
                    _makeDeepCopyFunctionCapsule(DEEP_COPY_GENERICALIAS));
 #endif
 
 #if PYTHON_VERSION >= 0x3a0
     {
+        PyThreadState *tstate = PyThreadState_GET();
+
         PyObject *args[2] = {(PyObject *)&PyFloat_Type, (PyObject *)&PyTuple_Type};
-        PyObject *args_tuple = MAKE_TUPLE(args, 2);
+        PyObject *args_tuple = MAKE_TUPLE(tstate, args, 2);
         PyObject *union_value = MAKE_UNION_TYPE(args_tuple);
 
         Nuitka_PyUnion_Type = Py_TYPE(union_value);
 
         PyDict_SetItem(_deep_copy_dispatch, (PyObject *)Nuitka_PyUnion_Type, _deep_noop);
 
         Py_DECREF(union_value);
@@ -545,23 +547,23 @@
     switch (code) {
     case 'i':
         Py_INCREF(value);
         return value;
     case 'L':
         return _DEEP_COPY_LIST_GUIDED(tstate, value, guide);
     case 'l':
-        return LIST_COPY(value);
+        return LIST_COPY(tstate, value);
     case 'T':
         return _DEEP_COPY_TUPLE_GUIDED(tstate, value, guide);
     case 't':
-        return TUPLE_COPY(value);
+        return TUPLE_COPY(tstate, value);
     case 'D':
         return DEEP_COPY_DICT(tstate, value);
     case 'd':
-        return DICT_COPY(value);
+        return DICT_COPY(tstate, value);
     case 'S':
         return DEEP_COPY_SET(tstate, value);
     case 'B':
         return BYTEARRAY_COPY(tstate, value);
     case '?':
         return DEEP_COPY(tstate, value);
     default:
@@ -571,15 +573,15 @@
 }
 
 static PyObject *_DEEP_COPY_LIST_GUIDED(PyThreadState *tstate, PyObject *value, char const **guide) {
     assert(PyList_CheckExact(value));
 
     Py_ssize_t size = PyList_GET_SIZE(value);
 
-    PyObject *result = MAKE_LIST_EMPTY(size);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, size);
 
     for (Py_ssize_t i = 0; i < size; i++) {
         PyObject *item = _DEEP_COPY_ELEMENT_GUIDED(tstate, PyList_GET_ITEM(value, i), guide);
 
         PyList_SET_ITEM(result, i, item);
     }
 
@@ -588,15 +590,15 @@
 
 static PyObject *_DEEP_COPY_TUPLE_GUIDED(PyThreadState *tstate, PyObject *value, char const **guide) {
     assert(PyTuple_CheckExact(value));
 
     Py_ssize_t size = PyTuple_GET_SIZE(value);
 
     // We cannot have size 0, so this is safe.
-    PyObject *result = MAKE_TUPLE_EMPTY(size);
+    PyObject *result = MAKE_TUPLE_EMPTY(tstate, size);
 
     for (Py_ssize_t i = 0; i < size; i++) {
         PyObject *item = _DEEP_COPY_ELEMENT_GUIDED(tstate, PyTuple_GET_ITEM(value, i), guide);
 
         PyTuple_SET_ITEM(result, i, item);
     }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDictionaries.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDictionaries.c`

 * *Files 2% similar despite different names*

```diff
@@ -181,31 +181,37 @@
 
     CHECK_OBJECT(result);
     Py_INCREF(result);
     return result;
 #endif
 }
 
+#if PYTHON_VERSION >= 0x3c0
+static PyObject *Nuitka_CreateKeyError(PyThreadState *tstate, PyObject *key) {
+    return (PyObject *)Nuitka_BaseExceptionSingleArg_new(tstate, (PyTypeObject *)PyExc_KeyError, key);
+}
+#endif
+
 static void SET_CURRENT_EXCEPTION_KEY_ERROR(PyThreadState *tstate, PyObject *key) {
 #if PYTHON_VERSION < 0x3c0
     /* Wrap all kinds of tuples, because normalization will later unwrap
      * it, but then that changes the key for the KeyError, which is not
      * welcome. The check is inexact, as the unwrapping one is too.
      */
     if (PyTuple_Check(key) || key == Py_None) {
         PyObject *tuple = PyTuple_Pack(1, key);
 
         SET_CURRENT_EXCEPTION_TYPE0_VALUE1(tstate, PyExc_KeyError, tuple);
     } else {
         SET_CURRENT_EXCEPTION_TYPE0_VALUE0(tstate, PyExc_KeyError, key);
     }
 #else
-    PyObject *exception_value = MAKE_EXCEPTION_FROM_TYPE_ARG0(tstate, PyExc_KeyError, key);
+    struct Nuitka_ExceptionPreservationItem exception_state = {Nuitka_CreateKeyError(tstate, key)};
 
-    SET_CURRENT_EXCEPTION_TYPE0_VALUE1(tstate, PyExc_KeyError, exception_value);
+    RESTORE_ERROR_OCCURRED_STATE(tstate, &exception_state);
 #endif
 }
 
 // TODO: This gives a reference, where would often be one time immediate users
 // of the value, forcing temporary variable releases on the outside. We need
 // to add indication of how long a value is going to be used, so in case where
 // we have the knowledge, we can provide the reference or not. Maybe we can
@@ -585,20 +591,20 @@
 
     /* Preallocate the list of tuples, to avoid allocations during
      * the loop over the items, which could trigger GC, which
      * could resize the dict. :-(
      */
 retry:
     size = mp->ma_used;
-    result = MAKE_LIST_EMPTY(size);
+    result = MAKE_LIST_EMPTY(tstate, size);
     CHECK_OBJECT(result);
 
     for (Py_ssize_t i = 0; i < size; i++) {
         // Later populated.
-        PyObject *item = MAKE_TUPLE_EMPTY(2);
+        PyObject *item = MAKE_TUPLE_EMPTY(tstate, 2);
         CHECK_OBJECT(item);
 
         PyList_SET_ITEM(result, i, item);
     }
 
     if (unlikely(size != mp->ma_used)) {
         // Garbage collection can compactify dictionaries.
@@ -639,15 +645,15 @@
 
     /* Preallocate the list of tuples, to avoid allocations during
      * the loop over the items, which could trigger GC, which
      * could resize the dict. :-(
      */
 retry:
     size = mp->ma_used;
-    result = MAKE_LIST_EMPTY(size);
+    result = MAKE_LIST_EMPTY(tstate, size);
     CHECK_OBJECT(result);
 
     if (unlikely(size != mp->ma_used)) {
         // Garbage collection can compactify dictionaries.
         Py_DECREF(result);
         goto retry;
     }
@@ -684,15 +690,15 @@
 
     /* Preallocate the list of tuples, to avoid allocations during
      * the loop over the items, which could trigger GC, which
      * could resize the dict. :-(
      */
 retry:
     size = mp->ma_used;
-    result = MAKE_LIST_EMPTY(size);
+    result = MAKE_LIST_EMPTY(tstate, size);
     CHECK_OBJECT(result);
 
     if (unlikely(size != mp->ma_used)) {
         // Garbage collection can compactify dictionaries.
         Py_DECREF(result);
         goto retry;
     }
@@ -1290,17 +1296,17 @@
     PyObject *result;
 
     if (seq_obj != NULL) {
         CHECK_OBJECT(seq_obj);
 
         // Fast path for dictionaries.
         if (PyDict_CheckExact(seq_obj)) {
-            result = DICT_COPY(seq_obj);
+            result = DICT_COPY(tstate, seq_obj);
         } else {
-            result = MAKE_DICT_EMPTY();
+            result = MAKE_DICT_EMPTY(tstate);
 
             Py_INCREF(seq_obj);
 
 #if PYTHON_VERSION >= 0x300
             int res = HAS_ATTR_BOOL2(tstate, seq_obj, const_str_plain_keys);
 
             if (unlikely(res == -1)) {
@@ -1320,15 +1326,15 @@
             Py_DECREF(seq_obj);
 
             if (unlikely(res == -1)) {
                 return NULL;
             }
         }
     } else {
-        result = MAKE_DICT_EMPTY();
+        result = MAKE_DICT_EMPTY(tstate);
     }
 
     // TODO: Should specialize for dict_obj/seq_obj presence to save a bit of time
     // and complexity.
     if (dict_obj != NULL) {
         CHECK_OBJECT(dict_obj);
 
@@ -1339,22 +1345,22 @@
         }
     }
 
     return result;
 }
 
 #if NUITKA_DICT_HAS_FREELIST
-PyObject *MAKE_DICT_EMPTY(void) {
+PyObject *MAKE_DICT_EMPTY(PyThreadState *tstate) {
     PyDictObject *empty_dict_mp = (PyDictObject *)const_dict_empty;
 
 #if PYTHON_VERSION < 0x3c0
     empty_dict_mp->ma_keys->dk_refcnt++;
 #endif
 
-    PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+    PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
 
     result_mp->ma_keys = empty_dict_mp->ma_keys;
     result_mp->ma_values = empty_dict_mp->ma_values;
     result_mp->ma_used = 0;
 #if PYTHON_VERSION >= 0x3c0
     result_mp->ma_version_tag = DICT_NEXT_VERSION(_PyInterpreterState_GET());
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDictionariesGenerated.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDictionariesGenerated.c`

 * *Files 8% similar despite different names*

```diff
@@ -29,46 +29,50 @@
 #define IS_COMPACT(dict_mp) (dict_mp->ma_used >= (dict_mp->ma_keys->dk_nentries * 2) / 3)
 #endif
 
 static inline PyDictValues *_Nuitka_PyDict_new_values(Py_ssize_t size) {
     Py_ssize_t values_size = sizeof(PyObject *) * size;
 
 #if PYTHON_VERSION < 0x3b0
-    return (PyDictValues *)PyMem_MALLOC(values_size);
+    return (PyDictValues *)NuitkaMem_Malloc(values_size);
 #else
     // With Python3.11 or higher a prefix is allocated too.
     size_t prefix_size = _Py_SIZE_ROUND_UP(size + 2, sizeof(PyObject *));
     size_t n = prefix_size + values_size;
-    uint8_t *mem = (uint8_t *)PyMem_MALLOC(n);
+    uint8_t *mem = (uint8_t *)NuitkaMem_Malloc(n);
 
     assert(mem != NULL);
 
     assert(prefix_size % sizeof(PyObject *) == 0);
     mem[prefix_size - 1] = (uint8_t)prefix_size;
 
     return (PyDictValues *)(mem + prefix_size);
 #endif
 }
 
-#if NUITKA_DICT_HAS_FREELIST
-static struct _Py_dict_state *_Nuitka_Py_get_dict_state(void) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
-    return &interp->dict_state;
-}
-#endif
-
 #if PYTHON_VERSION >= 0x300
-static PyDictObject *_Nuitka_AllocatePyDictObject(void) {
+static PyDictObject *_Nuitka_AllocatePyDictObject(PyThreadState *tstate) {
     PyDictObject *result_mp;
 
 #if NUITKA_DICT_HAS_FREELIST
-    struct _Py_dict_state *state = _Nuitka_Py_get_dict_state();
+    // This is the CPython name, spell-checker: ignore numfree
 
-    if (state->numfree) {
-        result_mp = state->free_list[--state->numfree];
+#if PYTHON_VERSION < 0x3d0
+    PyDictObject **items = tstate->interp->dict_state.free_list;
+    int *numfree = &tstate->interp->dict_state.numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_dict_freelist *state = &freelists->dicts;
+    PyDictObject **items = state->items;
+    int *numfree = &state->numfree;
+#endif
+
+    if (*numfree) {
+        (*numfree) -= 1;
+        result_mp = items[*numfree];
 
         Nuitka_Py_NewReference((PyObject *)result_mp);
 
         assert(PyDict_CheckExact((PyObject *)result_mp));
         assert(result_mp != NULL);
     } else
 #endif
@@ -76,14 +80,46 @@
         result_mp = (PyDictObject *)Nuitka_GC_New(&PyDict_Type);
     }
 
     return result_mp;
 }
 #endif
 
+#if PYTHON_VERSION >= 0x360
+static PyDictKeysObject *_Nuitka_AllocatePyDictKeysObject(PyThreadState *tstate, Py_ssize_t keys_size) {
+    // CPython names, spell-checker: ignore numfree,dictkeys
+    PyDictKeysObject *dk;
+
+// TODO: Cannot always use cached objects. Need to also consider
+// "log2_size == PyDict_LOG_MINSIZE && unicode" as a criterion,
+// seems it can only be used for the smallest keys type.
+#if NUITKA_DICT_HAS_FREELIST && 0
+#if PYTHON_VERSION < 0x3d0
+    PyDictKeysObject **items = tstate->interp->dict_state.keys_free_list;
+    int *numfree = &tstate->interp->dict_state.keys_numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_dictkeys_freelist *state = &freelists->dictkeys;
+    PyDictKeysObject **items = state->items;
+    int *numfree = &state->numfree;
+#endif
+
+    if (*numfree) {
+        (*numfree) -= 1;
+        dk = items[*numfree];
+    } else
+#endif
+    {
+        dk = (PyDictKeysObject *)NuitkaObject_Malloc(keys_size);
+    }
+
+    return dk;
+}
+#endif
+
 #if PYTHON_VERSION >= 0x360 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT)
 static Py_ssize_t _Nuitka_Py_PyDict_KeysSize(PyDictKeysObject *keys) {
 #if PYTHON_VERSION < 0x360
     return sizeof(PyDictKeysObject) + (DK_SIZE(keys) - 1) * sizeof(PyDictKeyEntry);
 #elif PYTHON_VERSION < 0x370
     return (sizeof(PyDictKeysObject) - Py_MEMBER_SIZE(PyDictKeysObject, dk_indices) + DK_IXSIZE(keys) * DK_SIZE(keys) +
             DK_USABLE_FRACTION(DK_SIZE(keys)) * sizeof(PyDictKeyEntry));
@@ -94,28 +130,28 @@
     size_t entry_size = keys->dk_kind == DICT_KEYS_GENERAL ? sizeof(PyDictKeyEntry) : sizeof(PyDictUnicodeEntry);
     return (sizeof(PyDictKeysObject) + ((size_t)1 << keys->dk_log2_index_bytes) +
             DK_USABLE_FRACTION(DK_SIZE(keys)) * entry_size);
 #endif
 }
 #endif
 
-PyObject *DICT_COPY(PyObject *dict_value) {
+PyObject *DICT_COPY(PyThreadState *tstate, PyObject *dict_value) {
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
     return PyDict_Copy(dict_value);
 #else
     PyObject *result;
 
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
     if (((PyDictObject *)dict_value)->ma_used == 0) {
-        result = MAKE_DICT_EMPTY();
+        result = MAKE_DICT_EMPTY(tstate);
     } else {
         PyDictObject *dict_mp = (PyDictObject *)dict_value;
 
 #if PYTHON_VERSION < 0x300
         // For Python3, this can be done much faster in the same way as it is
         // done in parameter parsing.
         result = _PyDict_NewPresized(dict_mp->ma_used);
@@ -132,15 +168,15 @@
                 assert(res == 0);
             }
         }
 #else
         /* Python 3 */
 #ifndef PY_NOGIL
         if (_PyDict_HasSplitTable(dict_mp)) {
-            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
             assert(result_mp != NULL);
             result = (PyObject *)result_mp;
 
             Py_ssize_t size = DK_ENTRIES_SIZE(dict_mp->ma_keys);
 
             PyDictValues *new_values = _Nuitka_PyDict_new_values(size);
             assert(new_values != NULL);
@@ -180,22 +216,22 @@
             // Fast dictionary copy if it has at least 2/3 space usage. This is most relevant
             // for the DICT_COPY, where it might even be the intention to trigger a shrink with
             // a fresh copy.
             if (dict_mp->ma_values == NULL && IS_COMPACT(dict_mp)) {
                 assert(dict_mp->ma_values == NULL);
                 assert(dict_mp->ma_keys->dk_refcnt == 1);
 
-                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
                 result = (PyObject *)result_mp;
 
                 result_mp->ma_values = NULL;
                 result_mp->ma_used = dict_mp->ma_used;
 
                 Py_ssize_t keys_size = _Nuitka_Py_PyDict_KeysSize(dict_mp->ma_keys);
-                result_mp->ma_keys = (PyDictKeysObject *)PyObject_MALLOC(keys_size);
+                result_mp->ma_keys = _Nuitka_AllocatePyDictKeysObject(tstate, keys_size);
                 assert(result_mp->ma_keys);
 
                 memcpy(result_mp->ma_keys, dict_mp->ma_keys, keys_size);
 
                 // Take reference of all keys and values.
 #if PYTHON_VERSION < 0x3b0
                 PyDictKeyEntry *entries = DK_ENTRIES(result_mp->ma_keys);
@@ -303,15 +339,15 @@
 PyObject *DEEP_COPY_DICT(PyThreadState *tstate, PyObject *dict_value) {
     PyObject *result;
 
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
-    result = DICT_COPY(dict_value);
+    result = DICT_COPY(tstate, dict_value);
 
     Py_ssize_t pos = 0;
     PyObject *key, *value;
 
     while (Nuitka_DictNext(dict_value, &pos, &key, &value)) {
         PyObject *dict_value_copy = DEEP_COPY(tstate, value);
 
@@ -320,15 +356,15 @@
         }
     }
 #else
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
     if (((PyDictObject *)dict_value)->ma_used == 0) {
-        result = MAKE_DICT_EMPTY();
+        result = MAKE_DICT_EMPTY(tstate);
     } else {
         PyDictObject *dict_mp = (PyDictObject *)dict_value;
 
 #if PYTHON_VERSION < 0x300
         // For Python3, this can be done much faster in the same way as it is
         // done in parameter parsing.
         result = _PyDict_NewPresized(dict_mp->ma_used);
@@ -348,15 +384,15 @@
                 Py_DECREF(value);
             }
         }
 #else
         /* Python 3 */
 #ifndef PY_NOGIL
         if (_PyDict_HasSplitTable(dict_mp)) {
-            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
             assert(result_mp != NULL);
             result = (PyObject *)result_mp;
 
             Py_ssize_t size = DK_ENTRIES_SIZE(dict_mp->ma_keys);
 
             PyDictValues *new_values = _Nuitka_PyDict_new_values(size);
             assert(new_values != NULL);
@@ -396,22 +432,22 @@
             // Fast dictionary copy if it has at least 2/3 space usage. This is most relevant
             // for the DICT_COPY, where it might even be the intention to trigger a shrink with
             // a fresh copy.
             if (dict_mp->ma_values == NULL && IS_COMPACT(dict_mp)) {
                 assert(dict_mp->ma_values == NULL);
                 assert(dict_mp->ma_keys->dk_refcnt == 1);
 
-                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
                 result = (PyObject *)result_mp;
 
                 result_mp->ma_values = NULL;
                 result_mp->ma_used = dict_mp->ma_used;
 
                 Py_ssize_t keys_size = _Nuitka_Py_PyDict_KeysSize(dict_mp->ma_keys);
-                result_mp->ma_keys = (PyDictKeysObject *)PyObject_MALLOC(keys_size);
+                result_mp->ma_keys = _Nuitka_AllocatePyDictKeysObject(tstate, keys_size);
                 assert(result_mp->ma_keys);
 
                 memcpy(result_mp->ma_keys, dict_mp->ma_keys, keys_size);
 
                 // Take reference of all keys and values.
 #if PYTHON_VERSION < 0x3b0
                 PyDictKeyEntry *entries = DK_ENTRIES(result_mp->ma_keys);
@@ -524,38 +560,38 @@
 
 #endif
 
     return result;
 }
 
 // Helper for function calls with star dict arguments. */
-static PyObject *COPY_DICT_KW(PyObject *dict_value) {
+static PyObject *COPY_DICT_KW(PyThreadState *tstate, PyObject *dict_value) {
     PyObject *result;
     bool had_kw_error = false;
 
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
-    result = DICT_COPY(dict_value);
+    result = DICT_COPY(tstate, dict_value);
 
     Py_ssize_t pos = 0;
     PyObject *key, *value;
 
     while (Nuitka_DictNext(dict_value, &pos, &key, &value)) {
         if (unlikely(!checkKeywordType(key))) {
             had_kw_error = true;
         }
     }
 #else
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
     if (((PyDictObject *)dict_value)->ma_used == 0) {
-        result = MAKE_DICT_EMPTY();
+        result = MAKE_DICT_EMPTY(tstate);
     } else {
         PyDictObject *dict_mp = (PyDictObject *)dict_value;
 
 #if PYTHON_VERSION < 0x300
         // For Python3, this can be done much faster in the same way as it is
         // done in parameter parsing.
         result = _PyDict_NewPresized(dict_mp->ma_used);
@@ -575,15 +611,15 @@
                 assert(res == 0);
             }
         }
 #else
         /* Python 3 */
 #ifndef PY_NOGIL
         if (_PyDict_HasSplitTable(dict_mp)) {
-            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+            PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
             assert(result_mp != NULL);
             result = (PyObject *)result_mp;
 
             Py_ssize_t size = DK_ENTRIES_SIZE(dict_mp->ma_keys);
 
 #if PYTHON_VERSION < 0x3b0
             for (Py_ssize_t i = 0; i < size; i++) {
@@ -647,22 +683,22 @@
             // Fast dictionary copy if it has at least 2/3 space usage. This is most relevant
             // for the DICT_COPY, where it might even be the intention to trigger a shrink with
             // a fresh copy.
             if (dict_mp->ma_values == NULL && IS_COMPACT(dict_mp)) {
                 assert(dict_mp->ma_values == NULL);
                 assert(dict_mp->ma_keys->dk_refcnt == 1);
 
-                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+                PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
                 result = (PyObject *)result_mp;
 
                 result_mp->ma_values = NULL;
                 result_mp->ma_used = dict_mp->ma_used;
 
                 Py_ssize_t keys_size = _Nuitka_Py_PyDict_KeysSize(dict_mp->ma_keys);
-                result_mp->ma_keys = (PyDictKeysObject *)PyObject_MALLOC(keys_size);
+                result_mp->ma_keys = _Nuitka_AllocatePyDictKeysObject(tstate, keys_size);
                 assert(result_mp->ma_keys);
 
                 memcpy(result_mp->ma_keys, dict_mp->ma_keys, keys_size);
 
                 // Take reference of all keys and values.
 #if PYTHON_VERSION < 0x3b0
                 PyDictKeyEntry *entries = DK_ENTRIES(result_mp->ma_keys);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersDumpBacktraces.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersDumpBacktraces.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersEnvironmentVariables.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersEnvironmentVariables.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersEnvironmentVariablesSystem.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersEnvironmentVariablesSystem.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersExceptions.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersExceptions.c`

 * *Files 14% similar despite different names*

```diff
@@ -42,21 +42,25 @@
     SET_CURRENT_EXCEPTION_TYPE0_FORMAT1(PyExc_TypeError, format, TYPE_NAME_DESC(mistyped));
 }
 
 void FORMAT_UNBOUND_LOCAL_ERROR(PyObject **exception_type, PyObject **exception_value, PyObject *variable_name) {
     *exception_type = PyExc_UnboundLocalError;
     Py_INCREF(*exception_type);
 
-#if PYTHON_VERSION < 0x3b0
+#if PYTHON_VERSION < 0x300
     char const *message = "local variable '%s' referenced before assignment";
+    *exception_value = Nuitka_String_FromFormat(message, Nuitka_String_AsString_Unchecked(variable_name));
+#elif PYTHON_VERSION < 0x3b0
+    char const *message = "local variable '%U' referenced before assignment";
+    *exception_value = Nuitka_String_FromFormat(message, variable_name);
 #else
-    char const *message = "cannot access local variable '%s' where it is not associated with a value";
+    char const *message = "cannot access local variable '%U' where it is not associated with a value";
+    *exception_value = Nuitka_String_FromFormat(message, variable_name);
 #endif
 
-    *exception_value = Nuitka_String_FromFormat(message, Nuitka_String_AsString_Unchecked(variable_name));
     CHECK_OBJECT(*exception_value);
 }
 
 void FORMAT_UNBOUND_CLOSURE_ERROR(PyObject **exception_type, PyObject **exception_value, PyObject *variable_name) {
     *exception_type = PyExc_NameError;
     Py_INCREF(*exception_type);
 
@@ -93,29 +97,115 @@
 
     return exc;
 }
 
 // Our replacement for PyErr_NormalizeException, that however does not attempt
 // to deal with recursion, i.e. exception during normalization, we just avoid
 // the API call overhead in the normal case.
+
+#if PYTHON_VERSION >= 0x3d0
+// TODO: Merge with old branch for enhancements.
+void Nuitka_Err_NormalizeException(PyThreadState *tstate, PyObject **exc, PyObject **val, PyTracebackObject **tb) {
+    int recursion_depth = 0;
+    tstate->recursion_headroom++;
+
+    PyObject *type, *value;
+    PyTracebackObject *initial_tb;
+
+restart:
+    type = *exc;
+
+    if (type == NULL) {
+        tstate->recursion_headroom--;
+        return;
+    }
+
+    value = *val;
+
+    if (!value) {
+        Py_INCREF_IMMORTAL(Py_None);
+        value = Py_None;
+    }
+
+    if (PyExceptionClass_Check(type)) {
+        PyObject *instance_class = NULL;
+
+        int is_subclass = 0;
+
+        if (PyExceptionInstance_Check(value)) {
+            instance_class = PyExceptionInstance_Class(value);
+
+            is_subclass = PyObject_IsSubclass(instance_class, type);
+            if (is_subclass < 0) {
+                goto error;
+            }
+        }
+
+        if (!is_subclass) {
+            PyObject *fixed_value = _Nuitka_Err_CreateException(tstate, type, value);
+
+            if (fixed_value == NULL) {
+                goto error;
+            }
+
+            Py_SETREF(value, fixed_value);
+        } else if (instance_class != type) {
+            Py_SETREF(type, Py_NewRef(instance_class));
+        }
+    }
+    *exc = type;
+    *val = value;
+    tstate->recursion_headroom--;
+    return;
+
+error:
+    Py_DECREF(type);
+    Py_DECREF(value);
+    recursion_depth++;
+    if (recursion_depth == 32) {
+        _PyErr_SetString(tstate, PyExc_RecursionError,
+                         "maximum recursion depth exceeded "
+                         "while normalizing an exception");
+    }
+
+    initial_tb = *tb;
+
+    FETCH_ERROR_OCCURRED(tstate, exc, val, tb);
+
+    assert(*exc != NULL);
+    if (initial_tb != NULL) {
+        if (*tb == NULL)
+            *tb = initial_tb;
+        else
+            Py_DECREF(initial_tb);
+    }
+    if (recursion_depth >= 32 + 2) {
+        if (PyErr_GivenExceptionMatches(*exc, PyExc_MemoryError)) {
+            Py_FatalError("Cannot recover from MemoryErrors "
+                          "while normalizing exceptions.");
+        } else {
+            Py_FatalError("Cannot recover from the recursive normalization "
+                          "of an exception.");
+        }
+    }
+    goto restart;
+}
+#else
 void Nuitka_Err_NormalizeException(PyThreadState *tstate, PyObject **exc, PyObject **val, PyTracebackObject **tb) {
     PyObject *type = *exc;
 
     // Dealt with in NORMALIZE_EXCEPTION
     assert(type != NULL && type != Py_None);
 
     PyObject *value = *val;
 
     // Allow setting the value to NULL for time savings with quick type only errors
     if (value == NULL) {
-        // TODO: For Python3.12, these kinds of assignments from immortal objects
-        // should be specialized, might need to check Python source for how they
-        // do that.
         value = Py_None;
-        Py_INCREF(value);
+        Py_INCREF_IMMORTAL(value);
     }
 
     // Normalize the exception from class to instance
     if (PyExceptionClass_Check(type)) {
         PyObject *instance_class = NULL;
 
         int is_subclass = 0;
@@ -178,35 +268,43 @@
 #if PYTHON_VERSION >= 0x380
     _PyErr_NormalizeException(tstate, exc, val, (PyObject **)tb);
 #else
     PyErr_NormalizeException(exc, val, (PyObject **)tb);
 #endif
 }
 
+#endif
+
 // Raise NameError for a given variable name.
 void SET_CURRENT_EXCEPTION_NAME_ERROR(PyThreadState *tstate, PyObject *variable_name) {
+#if PYTHON_VERSION >= 0x300
+    PyObject *exception_value_str = Nuitka_String_FromFormat("name '%U' is not defined", variable_name);
+#else
     PyObject *exception_value_str =
         Nuitka_String_FromFormat("name '%s' is not defined", Nuitka_String_AsString_Unchecked(variable_name));
-
+#endif
     PyObject *exception_value = MAKE_EXCEPTION_FROM_TYPE_ARG0(tstate, PyExc_NameError, exception_value_str);
     Py_DECREF(exception_value_str);
 
 #if PYTHON_VERSION >= 0x300
     CHAIN_EXCEPTION(tstate, exception_value);
 #endif
 
     SET_CURRENT_EXCEPTION_TYPE0_VALUE1(tstate, PyExc_NameError, exception_value);
 }
 
 // Raise NameError with "global" for a given variable name.
 #if PYTHON_VERSION < 0x340
 void SET_CURRENT_EXCEPTION_GLOBAL_NAME_ERROR(PyThreadState *tstate, PyObject *variable_name) {
+#if PYTHON_VERSION >= 0x300
+    PyObject *exception_value_str = Nuitka_String_FromFormat("global name '%U' is not defined", variable_name);
+#else
     PyObject *exception_value_str =
         Nuitka_String_FromFormat("global name '%s' is not defined", Nuitka_String_AsString_Unchecked(variable_name));
-
+#endif
     PyObject *exception_value = MAKE_EXCEPTION_FROM_TYPE_ARG0(tstate, PyExc_NameError, exception_value_str);
     Py_DECREF(exception_value_str);
 
     SET_CURRENT_EXCEPTION_TYPE0_VALUE1(tstate, PyExc_NameError, exception_value);
 }
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFiles.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFiles.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFilesystemPaths.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFilesystemPaths.c`

 * *Files 2% similar despite different names*

```diff
@@ -30,14 +30,70 @@
 #ifndef Py_MIN
 #define Py_MIN(x, y) (((x) > (y)) ? (y) : (x))
 #endif
 
 #include "nuitka/filesystem_paths.h"
 #include "nuitka/safe_string_ops.h"
 
+#if defined(__OpenBSD__)
+void _getBinaryPath2(char *epath) {
+    int mib[4];
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC_ARGS;
+    mib[2] = getpid();
+    mib[3] = KERN_PROC_ARGV;
+
+    size_t len;
+
+    if (sysctl(mib, 4, NULL, &len, NULL, 0) < 0) {
+        abort();
+    }
+
+    char **argv = argv = malloc(len);
+    if (argv == NULL) {
+        abort();
+    }
+
+    if (sysctl(mib, 4, argv, &len, NULL, 0) < 0) {
+        abort();
+    }
+
+    const char *comm = argv[0];
+
+    if (*comm == '/' || *comm == '.') {
+        if (realpath(comm, epath) == NULL) {
+            abort();
+        }
+    } else {
+        char *sp;
+        char *xpath = strdup(getenv("PATH"));
+        char *path = strtok_r(xpath, ":", &sp);
+        struct stat st;
+
+        if (xpath == NULL) {
+            abort();
+        }
+
+        while (path) {
+            snprintf(epath, PATH_MAX, "%s/%s", path, comm);
+
+            if (!stat(epath, &st) && (st.st_mode & S_IXUSR)) {
+                break;
+            }
+
+            path = strtok_r(NULL, ":", &sp);
+        }
+
+        free(xpath);
+    }
+
+    free(argv);
+}
+#endif
+
 filename_char_t *getBinaryPath(void) {
     static filename_char_t binary_filename[MAXPATHLEN];
 
 #if defined(_WIN32)
     DWORD res = GetModuleFileNameW(NULL, binary_filename, sizeof(binary_filename) / sizeof(wchar_t));
     if (res == 0) {
         abort();
@@ -45,15 +101,17 @@
 #elif defined(__APPLE__)
     uint32_t bufsize = sizeof(binary_filename);
     int res = _NSGetExecutablePath(binary_filename, &bufsize);
 
     if (res != 0) {
         abort();
     }
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
+#elif defined(__OpenBSD__)
+    _getBinaryPath2(binary_filename);
+#elif defined(__FreeBSD__)
     /* Not all of FreeBSD has /proc file system, so use the appropriate
      * "sysctl" instead.
      */
     int mib[4];
     mib[0] = CTL_KERN;
     mib[1] = KERN_PROC;
     mib[2] = KERN_PROC_PATHNAME;
@@ -163,15 +221,15 @@
     return (int64_t)file_size;
 }
 
 #if !defined(_WIN32)
 #if defined(__APPLE__)
 #include <copyfile.h>
 #else
-#if defined(__MSYS__) || defined(__HAIKU__)
+#if defined(__MSYS__) || defined(__HAIKU__) || defined(__OpenBSD__)
 static bool sendfile(int output_file, int input_file, off_t *bytesCopied, size_t count) {
     char buffer[32768];
 
     *bytesCopied = 0;
 
     while (count > 0) {
         ssize_t read_bytes = read(input_file, buffer, Py_MIN(sizeof(buffer), count));
@@ -613,16 +671,18 @@
 
     if (unlikely(res != 0)) {
         abort();
     }
 
     // Resolve any symlinks we were invoked via
     resolveFileSymbolicLink(binary_filename_target, binary_filename_target, buffer_size, resolve_symlinks);
-
-#elif defined(__FreeBSD__) || defined(__OpenBSD__)
+#elif defined(__OpenBSD__)
+    _getBinaryPath2(binary_filename_target);
+    resolveFileSymbolicLink(binary_filename_target, binary_filename_target, buffer_size, resolve_symlinks);
+#elif defined(__FreeBSD__)
     /* Not all of FreeBSD has /proc file system, so use the appropriate
      * "sysctl" instead.
      */
     int mib[4];
     mib[0] = CTL_KERN;
     mib[1] = KERN_PROC;
     mib[2] = KERN_PROC_PATHNAME;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersFloats.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersFloats.c`

 * *Files 15% similar despite different names*

```diff
@@ -31,42 +31,48 @@
     }
 
     return result;
 }
 
 #if NUITKA_FLOAT_HAS_FREELIST
 
-static struct _Py_float_state *_Nuitka_Py_get_float_state(void) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
-    return &interp->float_state;
-}
-
-static PyFloatObject *_Nuitka_AllocatePyFloatObject(void) {
-    struct _Py_float_state *state = _Nuitka_Py_get_float_state();
+static PyFloatObject *_Nuitka_AllocatePyFloatObject(PyThreadState *tstate) {
+    // This is the CPython name, spell-checker: ignore numfree
 
-    PyFloatObject *result_float = state->free_list;
+#if PYTHON_VERSION < 0x3d0
+    struct _Py_float_state *state = &tstate->interp->float_state;
+    PyFloatObject **free_list = &state->free_list;
+    int *numfree = &state->numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_float_freelist *state = &freelists->floats;
+    PyFloatObject **free_list = &state->items;
+    int *numfree = &state->numfree;
+#endif
+    PyFloatObject *result_float = *free_list;
 
     if (result_float) {
-        state->free_list = (PyFloatObject *)Py_TYPE(result_float);
-        state->numfree -= 1;
-
-        Py_SET_TYPE(result_float, &PyFloat_Type);
+        (*numfree) -= 1;
+        *free_list = (PyFloatObject *)Py_TYPE(result_float);
     } else {
-        result_float = (PyFloatObject *)PyObject_Malloc(sizeof(PyFloatObject));
+        result_float = (PyFloatObject *)NuitkaObject_Malloc(sizeof(PyFloatObject));
     }
 
     Py_SET_TYPE(result_float, &PyFloat_Type);
     Nuitka_Py_NewReference((PyObject *)result_float);
+
     assert(result_float != NULL);
 
     return result_float;
 }
 
 PyObject *MAKE_FLOAT_FROM_DOUBLE(double value) {
-    PyFloatObject *result = _Nuitka_AllocatePyFloatObject();
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyFloatObject *result = _Nuitka_AllocatePyFloatObject(tstate);
 
     PyFloat_SET_DOUBLE(result, value);
     return (PyObject *)result;
 }
 
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersHeapStorage.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersHeapStorage.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersImport.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersImport.c`

 * *Files 0% similar despite different names*

```diff
@@ -417,15 +417,15 @@
 
             if (unlikely(level_int < 0)) {
                 SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ValueError, "level must be >= 0");
                 return NULL;
             }
 
             if (level_int > 0) {
-                PyObject *fromlist = MAKE_TUPLE1(import_name);
+                PyObject *fromlist = MAKE_TUPLE1(tstate, import_name);
 
                 result = IMPORT_MODULE5(tstate, const_str_empty, globals, globals, fromlist, level);
 
                 Py_DECREF(fromlist);
 
                 // Look up in "sys.modules", because we will have returned the
                 // package of it from IMPORT_MODULE5.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersImportHard.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersImportHard.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersJitSources.c` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin/DillPlugin.c`

 * *Files 26% similar despite different names*

```diff
@@ -1,39 +1,30 @@
 //     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
-// This file is included from another C file, help IDEs to still parse it on
-// its own.
-#ifdef __IDE_ONLY__
-#include "nuitka/prelude.h"
-#endif
-
-#ifdef _NUITKA_STANDALONE
-
-static char const *uncompiled_sources_dict_attribute_name = "_uncompiled_function_sources_dict";
+// C code for use when the dill-plugin is active
 
-void SET_UNCOMPILED_FUNCTION_SOURCE_DICT(PyObject *name, PyObject *source) {
-    PyObject *uncompiled_function_sources_dict =
-        PyObject_GetAttrString((PyObject *)builtin_module, uncompiled_sources_dict_attribute_name);
-
-    if (uncompiled_function_sources_dict == NULL) {
-        PyThreadState *tstate = PyThreadState_GET();
+#include "nuitka/prelude.h"
 
-        DROP_ERROR_OCCURRED(tstate);
+void registerDillPluginTables(PyThreadState *tstate, char const *module_name, PyMethodDef *reduce_compiled_function,
+                              PyMethodDef *create_compiled_function) {
+    PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
 
-        uncompiled_function_sources_dict = MAKE_DICT_EMPTY();
+    if (function_tables == NULL) {
+        CLEAR_ERROR_OCCURRED(tstate);
 
-        PyObject_SetAttrString((PyObject *)builtin_module, uncompiled_sources_dict_attribute_name,
-                               uncompiled_function_sources_dict);
+        function_tables = MAKE_DICT_EMPTY(tstate);
+        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
     }
 
-    bool res = DICT_SET_ITEM(uncompiled_function_sources_dict, name, source);
-    assert(res == false);
+    PyObject *funcs = MAKE_TUPLE2_0(tstate, PyCFunction_New(reduce_compiled_function, NULL),
+                                    PyCFunction_New(create_compiled_function, NULL));
+
+    PyDict_SetItemString(function_tables, module_name, funcs);
 }
 
-#endif
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
 //
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersLists.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersLists.c`

 * *Files 8% similar despite different names*

```diff
@@ -11,39 +11,47 @@
 #endif
 
 // #include "richcomparisons.h"
 
 static PyObject *Nuitka_LongFromCLong(long ival);
 
 #if NUITKA_LIST_HAS_FREELIST
-static struct _Py_list_state *_Nuitka_Py_get_list_state(void) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
-    return &interp->list;
-}
 
-PyObject *MAKE_LIST_EMPTY(Py_ssize_t size) {
+PyObject *MAKE_LIST_EMPTY(PyThreadState *tstate, Py_ssize_t size) {
     assert(size >= 0);
 
-    struct _Py_list_state *state = _Nuitka_Py_get_list_state();
-    PyListObject *result_list;
+#if _NUITKA_EXPERIMENTAL_DISABLE_LIST_OPT
+    return PyList_New(size);
+#else
+    // This is the CPython name, spell-checker: ignore numfree
 
-    assert(state->numfree >= 0);
+#if PYTHON_VERSION < 0x3d0
+    PyListObject **items = tstate->interp->list.free_list;
+    int *numfree = &tstate->interp->list.numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_list_freelist *state = &freelists->lists;
+    PyListObject **items = state->items;
+    int *numfree = &state->numfree;
+#endif
+    assert(*numfree >= 0);
+    PyListObject *result_list;
 
-    if (state->numfree) {
-        state->numfree -= 1;
-        result_list = state->free_list[state->numfree];
+    if (*numfree) {
+        (*numfree) -= 1;
+        result_list = items[*numfree];
 
         Nuitka_Py_NewReference((PyObject *)result_list);
     } else {
         result_list = (PyListObject *)Nuitka_GC_New(&PyList_Type);
     }
 
     // Elements are allocated separately.
     if (size > 0) {
-        result_list->ob_item = (PyObject **)PyMem_Calloc(size, sizeof(PyObject *));
+        result_list->ob_item = (PyObject **)NuitkaMem_Calloc(size, sizeof(PyObject *));
 
         if (unlikely(result_list->ob_item == NULL)) {
             Py_DECREF(result_list);
             return PyErr_NoMemory();
         }
     } else {
         result_list->ob_item = NULL;
@@ -51,23 +59,24 @@
 
     Py_SET_SIZE(result_list, size);
     result_list->allocated = size;
 
     Nuitka_GC_Track(result_list);
 
     return (PyObject *)result_list;
+#endif
 }
 #endif
 
-PyObject *LIST_COPY(PyObject *list) {
+PyObject *LIST_COPY(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
 
     Py_ssize_t size = PyList_GET_SIZE(list);
-    PyObject *result = MAKE_LIST_EMPTY(size);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, size);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     for (Py_ssize_t i = 0; i < size; i++) {
         PyObject *item = PyList_GET_ITEM(list, i);
@@ -374,15 +383,16 @@
 
 bool LIST_REMOVE(PyObject *target, PyObject *item) {
     CHECK_OBJECT(target);
     assert(PyList_CheckExact(target));
 
     CHECK_OBJECT(item);
 
-#if _NUITKA_EXPERIMENTAL_DISABLE_LIST_OPT
+#if _NUITKA_EXPERIMENTAL_DISABLE_LIST_OPT && 0
+    // TODO: This is not exposed, would need to delete as slice instead.
     int res = PyList_Remove(target, item);
     return res == 0;
 #else
     PyListObject *list = (PyListObject *)target;
 
     Py_ssize_t cur_size = PyList_GET_SIZE(list);
 
@@ -515,15 +525,15 @@
         if (unlikely(nbool_res == NUITKA_BOOL_EXCEPTION)) {
             return NULL;
         }
     }
 
 #if PYTHON_VERSION < 0x300
     PyObject *err_format = PyString_FromString("%r is not in list");
-    PyObject *format_tuple = MAKE_TUPLE1_0(item);
+    PyObject *format_tuple = MAKE_TUPLE1_0(tstate, item);
     PyObject *err_string = PyString_Format(err_format, format_tuple);
     Py_DECREF(format_tuple);
 
     if (err_string == NULL) {
         return NULL;
     }
 
@@ -712,15 +722,15 @@
     PyListObject *list_object = (PyListObject *)list;
 
     if (Py_SIZE(list_object) > 1) {
         _Nuitka_ReverseObjectsSlice(list_object->ob_item, list_object->ob_item + Py_SIZE(list_object));
     }
 }
 
-#if PYTHON_VERSION >= 0x340
+#if PYTHON_VERSION >= 0x340 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_LIST_OPT)
 static bool allocateListItems(PyListObject *list, Py_ssize_t size) {
     PyObject **items = PyMem_New(PyObject *, size);
 
     if (unlikely(items == NULL)) {
         PyErr_NoMemory();
         return false;
     }
@@ -731,28 +741,28 @@
     return true;
 }
 #endif
 
 PyObject *MAKE_LIST(PyThreadState *tstate, PyObject *iterable) {
     // Can leave the size hinting to later functions, because the list is allocated empty without
     // items, and when then extending, etc. length hints can be used.
-    PyObject *list = MAKE_LIST_EMPTY(0);
+    PyObject *list = MAKE_LIST_EMPTY(tstate, 0);
 
 #if _NUITKA_EXPERIMENTAL_DISABLE_LIST_OPT
     PyObject *result = _PyList_Extend((PyListObject *)list, iterable);
     if (result == NULL) {
         Py_DECREF(list);
         return NULL;
     } else {
         Py_DECREF(result);
         return list;
     }
 #else
 #if PYTHON_VERSION >= 0x340
-    if (_PyObject_HasLen(iterable)) {
+    if (Nuitka_PyObject_HasLen(iterable)) {
         Py_ssize_t iter_len = Nuitka_PyObject_Size(iterable);
 
         if (unlikely(iter_len == -1)) {
             if (!PyErr_ExceptionMatches(PyExc_TypeError)) {
                 return NULL;
             }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersListsGenerated.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersListsGenerated.c`

 * *Files 6% similar despite different names*

```diff
@@ -3,31 +3,31 @@
 /* WARNING, this code is GENERATED. Modify the template CodeTemplateMakeListSmall.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-PyObject *MAKE_LIST1(PyObject *arg0) {
+PyObject *MAKE_LIST1(PyThreadState *tstate, PyObject *arg0) {
 
-    PyObject *result = MAKE_LIST_EMPTY(1);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 1);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     CHECK_OBJECT(arg0);
     Py_INCREF(arg0);
     PyList_SET_ITEM(result, 0, arg0);
 
     return result;
 }
-PyObject *MAKE_LIST2(PyObject *arg0, PyObject *arg1) {
+PyObject *MAKE_LIST2(PyThreadState *tstate, PyObject *arg0, PyObject *arg1) {
 
-    PyObject *result = MAKE_LIST_EMPTY(2);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 2);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     CHECK_OBJECT(arg0);
     Py_INCREF(arg0);
@@ -35,17 +35,17 @@
 
     CHECK_OBJECT(arg1);
     Py_INCREF(arg1);
     PyList_SET_ITEM(result, 1, arg1);
 
     return result;
 }
-PyObject *MAKE_LIST3(PyObject *arg0, PyObject *arg1, PyObject *arg2) {
+PyObject *MAKE_LIST3(PyThreadState *tstate, PyObject *arg0, PyObject *arg1, PyObject *arg2) {
 
-    PyObject *result = MAKE_LIST_EMPTY(3);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 3);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     CHECK_OBJECT(arg0);
     Py_INCREF(arg0);
@@ -57,20 +57,20 @@
 
     CHECK_OBJECT(arg2);
     Py_INCREF(arg2);
     PyList_SET_ITEM(result, 2, arg2);
 
     return result;
 }
-PyObject *MAKE_LIST4(PyObject *list) {
+PyObject *MAKE_LIST4(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 4);
 
-    PyObject *result = MAKE_LIST_EMPTY(4);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 4);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -91,20 +91,20 @@
         PyObject *item = PyList_GET_ITEM(list, 3);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 3, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST5(PyObject *list) {
+PyObject *MAKE_LIST5(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 5);
 
-    PyObject *result = MAKE_LIST_EMPTY(5);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 5);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -130,20 +130,20 @@
         PyObject *item = PyList_GET_ITEM(list, 4);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 4, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST6(PyObject *list) {
+PyObject *MAKE_LIST6(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 6);
 
-    PyObject *result = MAKE_LIST_EMPTY(6);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 6);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -174,20 +174,20 @@
         PyObject *item = PyList_GET_ITEM(list, 5);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 5, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST7(PyObject *list) {
+PyObject *MAKE_LIST7(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 7);
 
-    PyObject *result = MAKE_LIST_EMPTY(7);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 7);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -223,20 +223,20 @@
         PyObject *item = PyList_GET_ITEM(list, 6);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 6, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST8(PyObject *list) {
+PyObject *MAKE_LIST8(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 8);
 
-    PyObject *result = MAKE_LIST_EMPTY(8);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 8);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -277,20 +277,20 @@
         PyObject *item = PyList_GET_ITEM(list, 7);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 7, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST9(PyObject *list) {
+PyObject *MAKE_LIST9(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 9);
 
-    PyObject *result = MAKE_LIST_EMPTY(9);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 9);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -336,20 +336,20 @@
         PyObject *item = PyList_GET_ITEM(list, 8);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 8, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST10(PyObject *list) {
+PyObject *MAKE_LIST10(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 10);
 
-    PyObject *result = MAKE_LIST_EMPTY(10);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 10);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -400,20 +400,20 @@
         PyObject *item = PyList_GET_ITEM(list, 9);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 9, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST11(PyObject *list) {
+PyObject *MAKE_LIST11(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 11);
 
-    PyObject *result = MAKE_LIST_EMPTY(11);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 11);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
@@ -469,20 +469,20 @@
         PyObject *item = PyList_GET_ITEM(list, 10);
         Py_INCREF(item);
         PyList_SET_ITEM(result, 10, item);
     }
 
     return result;
 }
-PyObject *MAKE_LIST12(PyObject *list) {
+PyObject *MAKE_LIST12(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == 12);
 
-    PyObject *result = MAKE_LIST_EMPTY(12);
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 12);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     {
         PyObject *item = PyList_GET_ITEM(list, 0);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersMappings.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersMappings.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersMatching.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersMatching.c`

 * *Files 17% similar despite different names*

```diff
@@ -38,31 +38,28 @@
     } else if (CHECK_AND_CLEAR_ATTRIBUTE_ERROR_OCCURRED(tstate)) {
         if (PyType_HasFeature(type, _Py_TPFLAGS_MATCH_SELF)) {
             if (max_allowed > 1) {
                 FORMAT_MATCH_MISMATCH_ERROR(type, max_allowed, 1);
                 return NULL;
             }
 
-            // TODO: Specialize for single element maybe, but LTO solves
-            // this just fine.
-            PyObject *elements[1] = {matched};
-            return MAKE_TUPLE(elements, 1);
+            return MAKE_TUPLE1(tstate, matched);
         }
 
         actual = 0;
     } else {
         return NULL;
     }
 
     if (max_allowed > actual) {
         FORMAT_MATCH_MISMATCH_ERROR(type, max_allowed, actual);
         return NULL;
     }
 
-    PyObject *result = MAKE_TUPLE_EMPTY_VAR(actual);
+    PyObject *result = MAKE_TUPLE_EMPTY_VAR(tstate, actual);
 
     for (Py_ssize_t i = 0; i < max_allowed; i++) {
         PyObject *arg_name = PyTuple_GET_ITEM(match_args, i);
 
         if (unlikely(!PyUnicode_CheckExact(arg_name))) {
             PyErr_Format(PyExc_TypeError,
                          "__match_args__ elements must be strings "
@@ -85,14 +82,44 @@
 
         PyTuple_SET_ITEM(result, i, arg_value);
     }
 
     Py_DECREF(match_args);
     return result;
 }
+
+int MATCH_MAPPING_KEY(PyThreadState *tstate, PyObject *map, PyObject *key) {
+    // Need to use get_method with default value, so "defaultdict" do not
+    // mutate. TODO: Use a cached value across the "match".
+    PyObject *get_method = LOOKUP_ATTRIBUTE(tstate, map, const_str_plain_get);
+    if (unlikely(get_method == NULL)) {
+        return -1;
+    }
+
+    PyObject *args[] = {key, Nuitka_sentinel_value};
+
+    PyObject *value = CALL_FUNCTION_WITH_ARGS2(tstate, get_method, args);
+
+    Py_XDECREF(get_method);
+
+    if (unlikely(value == NULL)) {
+        return -1;
+    }
+
+    if (value == Nuitka_sentinel_value) {
+        Py_DECREF_IMMORTAL(value);
+
+        return 0;
+    }
+
+    Py_DECREF(value);
+
+    return 1;
+}
+
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
 //
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryAdd.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryAdd.c`

 * *Files 1% similar despite different names*

```diff
@@ -114,26 +114,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -337,38 +337,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -614,26 +614,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -825,38 +825,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1120,26 +1120,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1358,38 +1358,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1683,26 +1683,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1931,38 +1931,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2228,26 +2228,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2427,38 +2427,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2675,26 +2675,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2882,38 +2882,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -3083,15 +3083,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3138,15 +3138,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3202,15 +3202,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3255,15 +3255,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3316,15 +3316,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3369,15 +3369,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_concat available for this type.
     }
@@ -3826,15 +3826,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -3964,15 +3964,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4131,15 +4131,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -4274,15 +4274,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4442,15 +4442,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -4581,15 +4581,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4695,15 +4695,18 @@
     assert(PyTuple_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-    PyObject *x = TUPLE_CONCAT(operand1, operand2);
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = TUPLE_CONCAT(tstate, operand1, operand2);
 
     assert(x != Py_NotImplemented);
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -4745,15 +4748,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -4824,15 +4827,18 @@
         PyObject *result;
 
         // return _BINARY_OPERATION_ADD_OBJECT_TUPLE_TUPLE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = TUPLE_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = TUPLE_CONCAT(tstate, operand1, operand2);
 
         assert(x != Py_NotImplemented);
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -4882,15 +4888,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4956,15 +4962,18 @@
         PyObject *result;
 
         // return _BINARY_OPERATION_ADD_OBJECT_TUPLE_TUPLE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = TUPLE_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = TUPLE_CONCAT(tstate, operand1, operand2);
 
         assert(x != Py_NotImplemented);
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -4995,15 +5004,18 @@
     assert(PyList_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-    PyObject *x = LIST_CONCAT(operand1, operand2);
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
     assert(x != Py_NotImplemented);
 
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -5044,15 +5056,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5123,15 +5135,18 @@
         PyObject *result;
 
         // return _BINARY_OPERATION_ADD_OBJECT_LIST_LIST(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -5180,15 +5195,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5254,15 +5269,18 @@
         PyObject *result;
 
         // return _BINARY_OPERATION_ADD_OBJECT_LIST_LIST(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -5293,15 +5311,18 @@
     assert(PyList_CheckExact(operand2));
 
     nuitka_bool result;
 
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-    PyObject *x = LIST_CONCAT(operand1, operand2);
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
     assert(x != Py_NotImplemented);
 
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -5344,15 +5365,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5431,15 +5452,18 @@
         nuitka_bool result;
 
         // return _BINARY_OPERATION_ADD_NBOOL_LIST_LIST(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -5490,15 +5514,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5572,15 +5596,18 @@
         nuitka_bool result;
 
         // return _BINARY_OPERATION_ADD_NBOOL_LIST_LIST(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -5867,38 +5894,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -6077,38 +6104,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryAddUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryAddUtils.c`

 * *Files 1% similar despite different names*

```diff
@@ -8,23 +8,23 @@
 
 // This file is included from another C file, help IDEs to still parse it on
 // its own.
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-static PyObject *LIST_CONCAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *LIST_CONCAT(PyThreadState *tstate, PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyList_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyList_CheckExact(operand2));
 
     Py_ssize_t size = Py_SIZE(operand1) + Py_SIZE(operand2);
 
-    PyListObject *result = (PyListObject *)MAKE_LIST_EMPTY(size);
+    PyListObject *result = (PyListObject *)MAKE_LIST_EMPTY(tstate, size);
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     PyObject **src = ((PyListObject *)operand1)->ob_item;
     PyObject **dest = result->ob_item;
 
@@ -85,21 +85,21 @@
     assert(size >= 0);
 
 #if PYTHON_VERSION >= 0x3c0
     // The zero now is a single digit number.
     Py_ssize_t ndigits = size ? size : 1;
 
     PyLongObject *result =
-        (PyLongObject *)PyObject_MALLOC(offsetof(PyLongObject, long_value.ob_digit) + ndigits * sizeof(digit));
+        (PyLongObject *)NuitkaObject_Malloc(offsetof(PyLongObject, long_value.ob_digit) + ndigits * sizeof(digit));
     _PyLong_SetSignAndDigitCount(result, size != 0, size);
     PyObject_INIT(result, &PyLong_Type);
     result->long_value.ob_digit[0] = 0;
     return result;
 #elif PYTHON_VERSION >= 0x300
-    PyLongObject *result = (PyLongObject *)PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size * sizeof(digit));
+    PyLongObject *result = (PyLongObject *)NuitkaObject_Malloc(offsetof(PyLongObject, ob_digit) + size * sizeof(digit));
     return (PyLongObject *)PyObject_INIT_VAR(result, &PyLong_Type, size);
 #else
     return (PyLongObject *)PyObject_NEW_VAR(PyLongObject, &PyLong_Type, size);
 #endif
 }
 
 static PyObject *Nuitka_LongRealloc(PyObject *value, Py_ssize_t size) {
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitand.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitand.c`

 * *Files 2% similar despite different names*

```diff
@@ -86,26 +86,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -275,38 +275,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -520,26 +520,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -718,38 +718,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -977,26 +977,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1167,38 +1167,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1417,26 +1417,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1615,38 +1615,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1905,15 +1905,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for &: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -1954,15 +1954,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for &: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2056,26 +2056,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2200,38 +2200,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -2399,38 +2399,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2595,38 +2595,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitor.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitor.c`

 * *Files 2% similar despite different names*

```diff
@@ -86,26 +86,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -275,38 +275,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -520,26 +520,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -718,38 +718,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -977,26 +977,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1167,38 +1167,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1417,26 +1417,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1615,38 +1615,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1905,15 +1905,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for |: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -1954,15 +1954,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for |: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2056,26 +2056,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2200,38 +2200,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -2399,38 +2399,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2595,38 +2595,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryBitxor.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryBitxor.c`

 * *Files 4% similar despite different names*

```diff
@@ -86,26 +86,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -275,38 +275,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -520,26 +520,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -718,38 +718,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -977,26 +977,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1167,38 +1167,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1417,26 +1417,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1615,38 +1615,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1905,15 +1905,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ^: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -1954,15 +1954,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ^: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2056,26 +2056,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2200,38 +2200,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -2399,38 +2399,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2595,38 +2595,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryDivmod.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryOlddiv.c`

 * *Files 4% similar despite different names*

```diff
@@ -3,20 +3,19 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationBinary.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-#include "HelpersOperationBinaryDivmodUtils.c"
-/* C helpers for type specialized "divmod" (DIVMOD) operations */
+/* C helpers for type specialized "/" (OLDDIV) operations */
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
@@ -44,107 +43,116 @@
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
+    /* TODO: Isn't this a very specific value only, of which we could
+     * hardcode the constant result. Not sure how well the C compiler
+     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+     * -1 has to be rare anyway.
+     */
+
     if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
         long a_div_b = a / b;
         long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
         if (a_mod_b && (b ^ a_mod_b) < 0) {
             a_mod_b += b;
             a_div_b -= 1;
         }
 
-        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-        obj_result = r;
-        goto exit_result_object;
+        clong_result = a_div_b;
+        goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         obj_result = r;
         goto exit_result_object;
     }
 
+exit_result_ok_clong:
+    result = PyInt_FromLong(clong_result);
+    goto exit_result_ok;
+
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1,
                                                                                  PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyInt_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyInt_Type.tp_as_number->nb_divmod;
+        slot2 = PyInt_Type.tp_as_number->nb_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -158,15 +166,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -192,15 +200,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -213,34 +221,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyInt_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -262,83 +270,92 @@
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
             SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
+        /* TODO: Isn't this a very specific value only, of which we could
+         * hardcode the constant result. Not sure how well the C compiler
+         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+         * -1 has to be rare anyway.
+         */
+
         if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
             long a_div_b = a / b;
             long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
             if (a_mod_b && (b ^ a_mod_b) < 0) {
                 a_mod_b += b;
                 a_div_b -= 1;
             }
 
-            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-            obj_result = r;
-            goto exit_result_object;
+            clong_result = a_div_b;
+            goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
+    exit_result_ok_clong:
+        result = PyInt_FromLong(clong_result);
+        goto exit_result_ok;
+
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1,
                                                                                  PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyInt_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -347,38 +364,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -391,15 +408,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -426,15 +443,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -447,34 +464,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyInt_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -496,62 +513,72 @@
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
             SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
+        /* TODO: Isn't this a very specific value only, of which we could
+         * hardcode the constant result. Not sure how well the C compiler
+         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+         * -1 has to be rare anyway.
+         */
+
         if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
             long a_div_b = a / b;
             long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
             if (a_mod_b && (b ^ a_mod_b) < 0) {
                 a_mod_b += b;
                 a_div_b -= 1;
             }
 
-            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-            obj_result = r;
-            goto exit_result_object;
+            clong_result = a_div_b;
+            goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
+    exit_result_ok_clong:
+        result = PyInt_FromLong(clong_result);
+        goto exit_result_ok;
+
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(operand1, operand2);
 }
 #endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyObject *result;
 
@@ -562,15 +589,15 @@
 #endif
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
     NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
+    PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
     assert(x != Py_NotImplemented);
 
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -582,67 +609,69 @@
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1,
                                                                                   PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyLong_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_divmod;
+        slot2 = PyLong_Type.tp_as_number->nb_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -656,15 +685,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -690,15 +719,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -712,50 +741,50 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'long'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'long'", type1->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyLong_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
+        PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -767,43 +796,45 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1,
                                                                                   PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyLong_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -812,38 +843,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -856,15 +887,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -891,15 +922,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -913,50 +944,50 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and '%s'", type2->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyLong_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
+        PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -968,23 +999,25 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
@@ -1007,114 +1040,91 @@
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
         goto exit_result_exception;
     }
 
     {
-        double mod = fmod(a, b);
-        double div = (a - mod) / b;
+        double r = a / b;
 
-        if (mod) {
-            if ((b < 0) != (mod < 0)) {
-                mod += b;
-                div -= 1.0;
-            }
-        } else {
-            mod = copysign(0.0, b);
-        }
-
-        double floordiv;
-        if (div) {
-            floordiv = floor(div);
-            if (div - floordiv > 0.5) {
-                floordiv += 1.0;
-            }
-        } else {
-            floordiv = copysign(0.0, a / b);
-        }
-
-        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
-
-        obj_result = r;
-        goto exit_result_object;
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
 
-exit_result_object:
-    if (unlikely(obj_result == NULL)) {
-        goto exit_result_exception;
-    }
-    result = obj_result;
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1,
                                                                                    PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyFloat_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
+        slot2 = PyFloat_Type.tp_as_number->nb_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1128,15 +1138,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1162,15 +1172,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1183,34 +1193,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'float'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'float'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyFloat_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1227,90 +1237,67 @@
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
         if (unlikely(b == 0.0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
             goto exit_result_exception;
         }
 
         {
-            double mod = fmod(a, b);
-            double div = (a - mod) / b;
+            double r = a / b;
 
-            if (mod) {
-                if ((b < 0) != (mod < 0)) {
-                    mod += b;
-                    div -= 1.0;
-                }
-            } else {
-                mod = copysign(0.0, b);
-            }
-
-            double floordiv;
-            if (div) {
-                floordiv = floor(div);
-                if (div - floordiv > 0.5) {
-                    floordiv += 1.0;
-                }
-            } else {
-                floordiv = copysign(0.0, a / b);
-            }
-
-            PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
-
-            obj_result = r;
-            goto exit_result_object;
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
         }
 
-    exit_result_object:
-        if (unlikely(obj_result == NULL)) {
-            goto exit_result_exception;
-        }
-        result = obj_result;
+    exit_result_ok_cfloat:
+        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1,
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1,
                                                                                    PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyFloat_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -1319,38 +1306,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1363,15 +1350,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1398,15 +1385,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1419,34 +1406,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyFloat_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1463,70 +1450,47 @@
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
         if (unlikely(b == 0.0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
             goto exit_result_exception;
         }
 
         {
-            double mod = fmod(a, b);
-            double div = (a - mod) / b;
-
-            if (mod) {
-                if ((b < 0) != (mod < 0)) {
-                    mod += b;
-                    div -= 1.0;
-                }
-            } else {
-                mod = copysign(0.0, b);
-            }
-
-            double floordiv;
-            if (div) {
-                floordiv = floor(div);
-                if (div - floordiv > 0.5) {
-                    floordiv += 1.0;
-                }
-            } else {
-                floordiv = copysign(0.0, a / b);
-            }
-
-            PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
+            double r = a / b;
 
-            obj_result = r;
-            goto exit_result_object;
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
         }
 
-    exit_result_object:
-        if (unlikely(obj_result == NULL)) {
-            goto exit_result_exception;
-        }
-        result = obj_result;
+    exit_result_ok_cfloat:
+        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1534,50 +1498,52 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1591,51 +1557,52 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
+        slot2 = PyFloat_Type.tp_as_number->nb_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(operand1, operand2);
 }
+#endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1643,48 +1610,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1698,48 +1665,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
+        slot2 = PyFloat_Type.tp_as_number->nb_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1747,48 +1714,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divmod;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1802,48 +1769,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_divmod;
+        slot2 = PyLong_Type.tp_as_number->nb_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
@@ -1867,62 +1834,71 @@
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
+    /* TODO: Isn't this a very specific value only, of which we could
+     * hardcode the constant result. Not sure how well the C compiler
+     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+     * -1 has to be rare anyway.
+     */
+
     if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
         long a_div_b = a / b;
         long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
         if (a_mod_b && (b ^ a_mod_b) < 0) {
             a_mod_b += b;
             a_div_b -= 1;
         }
 
-        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-        obj_result = r;
-        goto exit_result_object;
+        clong_result = a_div_b;
+        goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = PyLong_FromLong(operand2);
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand2_object);
 
         obj_result = r;
         goto exit_result_object;
     }
 
+exit_result_ok_clong:
+    result = PyInt_FromLong(clong_result);
+    goto exit_result_ok;
+
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "CLONG" corresponds to C platform long value and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
@@ -1947,61 +1923,71 @@
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
+    /* TODO: Isn't this a very specific value only, of which we could
+     * hardcode the constant result. Not sure how well the C compiler
+     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+     * -1 has to be rare anyway.
+     */
+
     if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
         long a_div_b = a / b;
         long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
         if (a_mod_b && (b ^ a_mod_b) < 0) {
             a_mod_b += b;
             a_div_b -= 1;
         }
 
-        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-        obj_result = r;
-        goto exit_result_object;
+        clong_result = a_div_b;
+        goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = PyLong_FromLong(operand1);
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand1_object);
 
         obj_result = r;
         goto exit_result_object;
     }
 
+exit_result_ok_clong:
+    result = PyInt_FromLong(clong_result);
+    goto exit_result_ok;
+
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(operand1, operand2);
 }
 #endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     PyObject *result;
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -2020,67 +2006,44 @@
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
         goto exit_result_exception;
     }
 
     {
-        double mod = fmod(a, b);
-        double div = (a - mod) / b;
+        double r = a / b;
 
-        if (mod) {
-            if ((b < 0) != (mod < 0)) {
-                mod += b;
-                div -= 1.0;
-            }
-        } else {
-            mod = copysign(0.0, b);
-        }
-
-        double floordiv;
-        if (div) {
-            floordiv = floor(div);
-            if (div - floordiv > 0.5) {
-                floordiv += 1.0;
-            }
-        } else {
-            floordiv = copysign(0.0, a / b);
-        }
-
-        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
-
-        obj_result = r;
-        goto exit_result_object;
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
 
-exit_result_object:
-    if (unlikely(obj_result == NULL)) {
-        goto exit_result_exception;
-    }
-    result = obj_result;
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "CFLOAT" corresponds to C platform float value and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
 #ifdef _MSC_VER
@@ -2100,67 +2063,44 @@
 
     const double a = operand1;
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
         goto exit_result_exception;
     }
 
     {
-        double mod = fmod(a, b);
-        double div = (a - mod) / b;
-
-        if (mod) {
-            if ((b < 0) != (mod < 0)) {
-                mod += b;
-                div -= 1.0;
-            }
-        } else {
-            mod = copysign(0.0, b);
-        }
-
-        double floordiv;
-        if (div) {
-            floordiv = floor(div);
-            if (div - floordiv > 0.5) {
-                floordiv += 1.0;
-            }
-        } else {
-            floordiv = copysign(0.0, a / b);
-        }
-
-        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
+        double r = a / b;
 
-        obj_result = r;
-        goto exit_result_object;
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
 
-exit_result_object:
-    if (unlikely(obj_result == NULL)) {
-        goto exit_result_exception;
-    }
-    result = obj_result;
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(operand1, operand2);
 }
+#endif
 
+#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
         PyObject *result;
 
@@ -2188,38 +2128,47 @@
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
             SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
+        /* TODO: Isn't this a very specific value only, of which we could
+         * hardcode the constant result. Not sure how well the C compiler
+         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
+         * -1 has to be rare anyway.
+         */
+
         if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
             long a_div_b = a / b;
             long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
             if (a_mod_b && (b ^ a_mod_b) < 0) {
                 a_mod_b += b;
                 a_div_b -= 1;
             }
 
-            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
-            obj_result = r;
-            goto exit_result_object;
+            clong_result = a_div_b;
+            goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
+    exit_result_ok_clong:
+        result = PyInt_FromLong(clong_result);
+        goto exit_result_ok;
+
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
@@ -2241,21 +2190,21 @@
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -2264,38 +2213,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2309,15 +2258,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2344,15 +2293,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divmod;
+                    binaryfunc slot = mv->nb_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2365,28 +2314,28 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and '%s'", type1->tp_name,
-                 type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and '%s'", type1->tp_name, type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(operand1, operand2);
 }
+#endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryDivmodUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryDivmodUtils.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryFloordiv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryFloordiv.c`

 * *Files 2% similar despite different names*

```diff
@@ -133,26 +133,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -365,38 +365,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -650,26 +650,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -840,38 +840,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1115,26 +1115,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1332,38 +1332,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1550,15 +1550,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'float' and 'long'");
 #else
@@ -1607,15 +1607,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'long' and 'float'");
 #else
@@ -1659,15 +1659,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'float' and 'int'");
     goto exit_binary_exception;
 
@@ -1714,15 +1714,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'int' and 'float'");
     goto exit_binary_exception;
 
@@ -1763,15 +1763,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -1818,15 +1818,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2281,38 +2281,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryInplaceAdd.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryInplaceAdd.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryLshift.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryLshift.c`

 * *Files 0% similar despite different names*

```diff
@@ -86,26 +86,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -275,38 +275,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -520,26 +520,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -718,38 +718,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1029,26 +1029,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1271,38 +1271,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1625,26 +1625,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1875,38 +1875,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2127,15 +2127,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2182,15 +2182,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2231,15 +2231,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2294,15 +2294,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2455,38 +2455,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2703,38 +2703,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMatmult.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMatmult.c`

 * *Files 2% similar despite different names*

```diff
@@ -71,15 +71,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with Python3 only operator '@'
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and 'long'", type1->tp_name);
 #else
@@ -131,15 +131,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with Python3 only operator '@'
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: 'long' and '%s'", type2->tp_name);
 #else
@@ -217,15 +217,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with Python3 only operator '@'
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and 'float'", type1->tp_name);
     goto exit_binary_exception;
 
@@ -273,15 +273,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with Python3 only operator '@'
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: 'float' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
@@ -389,38 +389,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with Python3 only operator '@'
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and '%s'", type1->tp_name, type2->tp_name);
     goto exit_binary_exception;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMod.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMod.c`

 * *Files 2% similar despite different names*

```diff
@@ -124,26 +124,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -347,38 +347,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -663,26 +663,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -895,38 +895,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1180,26 +1180,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1369,38 +1369,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1614,26 +1614,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1813,38 +1813,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2087,26 +2087,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2294,38 +2294,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2576,26 +2576,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2791,38 +2791,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -3007,15 +3007,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'long'");
 #else
@@ -3064,15 +3064,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'float'");
 #else
@@ -3115,15 +3115,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'long'");
 #else
@@ -3180,15 +3180,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'float'");
 #else
@@ -3240,15 +3240,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'int'");
     goto exit_binary_exception;
 
@@ -3295,15 +3295,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'float'");
     goto exit_binary_exception;
 
@@ -3344,15 +3344,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'int'");
     goto exit_binary_exception;
 
@@ -3407,15 +3407,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'float'");
     goto exit_binary_exception;
 
@@ -3464,15 +3464,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -3519,15 +3519,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -3568,15 +3568,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -3631,15 +3631,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -4264,26 +4264,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'int'");
     goto exit_binary_exception;
 
@@ -4330,26 +4330,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'long'");
     goto exit_binary_exception;
 
@@ -4396,26 +4396,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'float'");
     goto exit_binary_exception;
 
@@ -4499,26 +4499,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'unicode'");
     goto exit_binary_exception;
 
@@ -4558,15 +4558,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'tuple'");
     goto exit_binary_exception;
 
@@ -4606,15 +4606,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'list'");
     goto exit_binary_exception;
 
@@ -4654,15 +4654,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'dict'");
     goto exit_binary_exception;
 
@@ -4713,38 +4713,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4865,26 +4865,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'int'");
     goto exit_binary_exception;
 
@@ -4931,26 +4931,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'long'");
 #else
@@ -4999,26 +4999,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'float'");
 #else
@@ -5068,26 +5068,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'str'");
     goto exit_binary_exception;
 
@@ -5134,26 +5134,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'bytes'");
     goto exit_binary_exception;
 
@@ -5228,15 +5228,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'tuple'");
 #else
@@ -5278,15 +5278,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'list'");
 #else
@@ -5328,15 +5328,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'dict'");
 #else
@@ -5390,38 +5390,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5545,26 +5545,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'int'");
     goto exit_binary_exception;
 
@@ -5611,26 +5611,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'float'");
     goto exit_binary_exception;
 
@@ -5715,26 +5715,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'str'");
     goto exit_binary_exception;
 
@@ -5774,15 +5774,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'tuple'");
     goto exit_binary_exception;
 
@@ -5822,15 +5822,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'list'");
     goto exit_binary_exception;
 
@@ -5870,15 +5870,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'dict'");
     goto exit_binary_exception;
 
@@ -5930,38 +5930,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -6163,38 +6163,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -6394,38 +6394,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMult.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMult.c`

 * *Files 2% similar despite different names*

```diff
@@ -125,26 +125,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -360,38 +360,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -462,15 +462,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -691,26 +692,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -936,38 +937,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1038,15 +1039,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -1236,26 +1238,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1438,38 +1440,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1540,15 +1542,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -1697,26 +1700,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1908,38 +1911,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2010,15 +2013,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -2177,26 +2181,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2377,38 +2381,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2479,15 +2483,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -2635,26 +2640,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2843,38 +2848,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2945,15 +2950,16 @@
             }
         }
     }
 #endif
 
     {
         // No sequence repeat slot sq_repeat available for this type.
-    } // Special case for "*", also work with sequence repeat from right argument.
+    }
+    // Special case for "*", also work with sequence repeat from right argument.
     {
         ssizeargfunc sq_slot = type2->tp_as_sequence != NULL ? type2->tp_as_sequence->sq_repeat : NULL;
 
         if (sq_slot != NULL) {
             PyObject *result = SEQUENCE_REPEAT(sq_slot, operand2, operand1);
 
             obj_result = result;
@@ -3054,15 +3060,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -3110,15 +3116,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -3175,15 +3181,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -3229,15 +3235,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -3291,15 +3297,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -3345,15 +3351,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     {
         // No sequence repeat slot sq_repeat available for this type.
     }
@@ -4651,15 +4657,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -4787,15 +4793,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4906,15 +4912,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5040,15 +5046,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5159,15 +5165,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5295,15 +5301,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5414,15 +5420,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5548,15 +5554,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -5666,15 +5672,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -5800,15 +5806,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c2 =
             (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -6003,38 +6009,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -6256,38 +6262,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryMultUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryMultUtils.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryOlddiv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinarySub.c`

 * *Files 5% similar despite different names*

```diff
@@ -3,19 +3,19 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationBinary.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-/* C helpers for type specialized "/" (OLDDIV) operations */
+/* C helpers for type specialized "-" (SUB) operations */
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
@@ -36,44 +36,25 @@
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    if (unlikely(b == 0)) {
-        PyThreadState *tstate = PyThreadState_GET();
-
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        goto exit_result_exception;
-    }
-
-    /* TODO: Isn't this a very specific value only, of which we could
-     * hardcode the constant result. Not sure how well the C compiler
-     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-     * -1 has to be rare anyway.
-     */
-
-    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-        long a_div_b = a / b;
-        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-        if (a_mod_b && (b ^ a_mod_b) < 0) {
-            a_mod_b += b;
-            a_div_b -= 1;
-        }
-
-        clong_result = a_div_b;
+    const long x = (long)((unsigned long)a - b);
+    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+    if (likely(no_overflow)) {
+        clong_result = x;
         goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         obj_result = r;
         goto exit_result_object;
     }
 
 exit_result_ok_clong:
@@ -90,69 +71,68 @@
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1,
-                                                                                 PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyInt_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyInt_Type.tp_as_number->nb_divide;
+        slot2 = PyInt_Type.tp_as_number->nb_subtract;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -166,15 +146,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -200,15 +180,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -221,34 +201,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'int'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyInt_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -263,44 +243,25 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        if (unlikely(b == 0)) {
-            PyThreadState *tstate = PyThreadState_GET();
-
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-            goto exit_result_exception;
-        }
-
-        /* TODO: Isn't this a very specific value only, of which we could
-         * hardcode the constant result. Not sure how well the C compiler
-         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-         * -1 has to be rare anyway.
-         */
-
-        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-            long a_div_b = a / b;
-            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-            if (a_mod_b && (b ^ a_mod_b) < 0) {
-                a_mod_b += b;
-                a_div_b -= 1;
-            }
-
-            clong_result = a_div_b;
+        const long x = (long)((unsigned long)a - b);
+        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+        if (likely(no_overflow)) {
+            clong_result = x;
             goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
     exit_result_ok_clong:
@@ -317,45 +278,44 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1,
-                                                                                 PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_subtract;
     binaryfunc slot2 = NULL;
 
     if (!(&PyInt_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -364,38 +324,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -408,15 +368,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -443,15 +403,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -464,34 +424,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyInt_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -506,44 +466,25 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        if (unlikely(b == 0)) {
-            PyThreadState *tstate = PyThreadState_GET();
-
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-            goto exit_result_exception;
-        }
-
-        /* TODO: Isn't this a very specific value only, of which we could
-         * hardcode the constant result. Not sure how well the C compiler
-         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-         * -1 has to be rare anyway.
-         */
-
-        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-            long a_div_b = a / b;
-            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-            if (a_mod_b && (b ^ a_mod_b) < 0) {
-                a_mod_b += b;
-                a_div_b -= 1;
-            }
-
-            clong_result = a_div_b;
+        const long x = (long)((unsigned long)a - b);
+        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+        if (likely(no_overflow)) {
+            clong_result = x;
             goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
     exit_result_ok_clong:
@@ -560,25 +501,24 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(operand1, operand2);
 }
 #endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyObject *result;
 
@@ -589,89 +529,125 @@
 #endif
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
     NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
-    assert(x != Py_NotImplemented);
+    PyLongObject *operand1_long_object = (PyLongObject *)operand1;
+
+    PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+
+    if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
+        long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
+
+        clong_result = r;
+        goto exit_result_ok_clong;
+    }
+
+    {
+        PyLongObject *z;
 
-    obj_result = x;
-    goto exit_result_object;
+        digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
+        Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
+        bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
+        digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
+        Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
+        bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
+
+        if (a_negative) {
+            if (b_negative) {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
+
+            Nuitka_LongFlipSign(z);
+        } else {
+            if (b_negative) {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
+        }
+
+        obj_result = (PyObject *)z;
+        goto exit_result_object;
+    }
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
+exit_result_ok_clong:
+    result = Nuitka_LongFromCLong(clong_result);
+    goto exit_result_ok;
+
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1,
-                                                                                  PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyLong_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_divide;
+        slot2 = PyLong_Type.tp_as_number->nb_subtract;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -685,15 +661,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -719,15 +695,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -741,100 +717,136 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'long'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'long'", type1->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'int'", type1->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyLong_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
-        assert(x != Py_NotImplemented);
+        PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
-        obj_result = x;
-        goto exit_result_object;
+        PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+
+        if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
+            long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
+
+            clong_result = r;
+            goto exit_result_ok_clong;
+        }
+
+        {
+            PyLongObject *z;
+
+            digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
+            Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
+            bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
+            digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
+            Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
+            bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
+
+            if (a_negative) {
+                if (b_negative) {
+                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                } else {
+                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                }
+
+                Nuitka_LongFlipSign(z);
+            } else {
+                if (b_negative) {
+                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                } else {
+                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                }
+            }
+
+            obj_result = (PyObject *)z;
+            goto exit_result_object;
+        }
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
+    exit_result_ok_clong:
+        result = Nuitka_LongFromCLong(clong_result);
+        goto exit_result_ok;
+
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1,
-                                                                                  PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_subtract;
     binaryfunc slot2 = NULL;
 
     if (!(&PyLong_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -843,38 +855,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -887,15 +899,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -922,15 +934,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -944,80 +956,117 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and '%s'", type2->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and '%s'", type2->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyLong_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_divide(operand1, operand2);
-        assert(x != Py_NotImplemented);
+        PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
-        obj_result = x;
-        goto exit_result_object;
+        PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+
+        if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
+            long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
+
+            clong_result = r;
+            goto exit_result_ok_clong;
+        }
+
+        {
+            PyLongObject *z;
+
+            digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
+            Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
+            bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
+            digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
+            Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
+            bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
+
+            if (a_negative) {
+                if (b_negative) {
+                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                } else {
+                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                }
+
+                Nuitka_LongFlipSign(z);
+            } else {
+                if (b_negative) {
+                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                } else {
+                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+                }
+            }
+
+            obj_result = (PyObject *)z;
+            goto exit_result_object;
+        }
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
+    exit_result_ok_clong:
+        result = Nuitka_LongFromCLong(clong_result);
+        goto exit_result_ok;
+
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
@@ -1037,94 +1086,80 @@
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    if (unlikely(b == 0.0)) {
-        PyThreadState *tstate = PyThreadState_GET();
-
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
-        goto exit_result_exception;
-    }
-
-    {
-        double r = a / b;
+    double r = a - b;
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
-    }
+    cfloat_result = r;
+    goto exit_result_ok_cfloat;
 
 exit_result_ok_cfloat:
     result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
-
-exit_result_exception:
-    return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1,
-                                                                                   PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1,
+                                                                                PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyFloat_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1138,15 +1173,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1172,15 +1207,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1193,34 +1228,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'float'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'float'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyFloat_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1234,70 +1269,56 @@
         assert(PyFloat_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyFloat_CheckExact(operand2));
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
-        if (unlikely(b == 0.0)) {
-            PyThreadState *tstate = PyThreadState_GET();
+        double r = a - b;
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
-            goto exit_result_exception;
-        }
-
-        {
-            double r = a / b;
-
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
-        }
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
 
     exit_result_ok_cfloat:
         result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
-
-    exit_result_exception:
-        return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1,
-                                                                                   PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1,
+                                                                                PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
     binaryfunc slot2 = NULL;
 
     if (!(&PyFloat_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -1306,38 +1327,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1350,15 +1371,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1385,15 +1406,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1406,34 +1427,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyFloat_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1447,50 +1468,36 @@
         assert(PyFloat_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyFloat_CheckExact(operand2));
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
-        if (unlikely(b == 0.0)) {
-            PyThreadState *tstate = PyThreadState_GET();
+        double r = a - b;
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
-            goto exit_result_exception;
-        }
-
-        {
-            double r = a / b;
-
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
-        }
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
 
     exit_result_ok_cfloat:
         result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
-
-    exit_result_exception:
-        return NULL;
     }
 
-    return __BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1498,52 +1505,50 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'long'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'int'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1557,52 +1562,51 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'float'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'float'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(operand1, operand2);
 }
-#endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1610,48 +1614,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1665,48 +1669,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'float'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1714,48 +1718,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divide;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_subtract;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_LONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_LONG_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1769,48 +1773,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_divide;
+        slot2 = PyLong_Type.tp_as_number->nb_subtract;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'long'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_INT_LONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
@@ -1827,44 +1831,25 @@
 
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    if (unlikely(b == 0)) {
-        PyThreadState *tstate = PyThreadState_GET();
-
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        goto exit_result_exception;
-    }
-
-    /* TODO: Isn't this a very specific value only, of which we could
-     * hardcode the constant result. Not sure how well the C compiler
-     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-     * -1 has to be rare anyway.
-     */
-
-    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-        long a_div_b = a / b;
-        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-        if (a_mod_b && (b ^ a_mod_b) < 0) {
-            a_mod_b += b;
-            a_div_b -= 1;
-        }
-
-        clong_result = a_div_b;
+    const long x = (long)((unsigned long)a - b);
+    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+    if (likely(no_overflow)) {
+        clong_result = x;
         goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = PyLong_FromLong(operand2);
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand2_object);
 
         obj_result = r;
         goto exit_result_object;
     }
@@ -1883,22 +1868,22 @@
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_INT_CLONG(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "CLONG" corresponds to C platform long value and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
@@ -1916,44 +1901,25 @@
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = operand1;
     const long b = PyInt_AS_LONG(operand2);
 
-    if (unlikely(b == 0)) {
-        PyThreadState *tstate = PyThreadState_GET();
-
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-        goto exit_result_exception;
-    }
-
-    /* TODO: Isn't this a very specific value only, of which we could
-     * hardcode the constant result. Not sure how well the C compiler
-     * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-     * -1 has to be rare anyway.
-     */
-
-    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-        long a_div_b = a / b;
-        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-        if (a_mod_b && (b ^ a_mod_b) < 0) {
-            a_mod_b += b;
-            a_div_b -= 1;
-        }
-
-        clong_result = a_div_b;
+    const long x = (long)((unsigned long)a - b);
+    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+    if (likely(no_overflow)) {
+        clong_result = x;
         goto exit_result_ok_clong;
     }
     {
         PyObject *operand1_object = PyLong_FromLong(operand1);
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand1_object);
 
         obj_result = r;
         goto exit_result_object;
     }
@@ -1972,78 +1938,225 @@
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_CLONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_CLONG_INT(operand1, operand2);
 }
 #endif
 
-#if PYTHON_VERSION < 0x300
-/* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
+ * Python objects. */
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
-    assert(PyFloat_CheckExact(operand1));
+    assert(PyLong_CheckExact(operand1));
+    assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
 
     PyObject *result;
 
+    // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
-    // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
     NUITKA_MAY_BE_UNUSED long clong_result;
-    NUITKA_MAY_BE_UNUSED double cfloat_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    CHECK_OBJECT(operand1);
-    assert(PyFloat_CheckExact(operand1));
+    PyLongObject *operand1_long_object = (PyLongObject *)operand1;
 
-    const double a = PyFloat_AS_DOUBLE(operand1);
-    const double b = operand2;
+    if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && (operand2 == 0 ? 0 : 1) <= 1) {
+        long r = (long)(MEDIUM_VALUE(operand1_long_object) - (sdigit)operand2);
+
+        clong_result = r;
+        goto exit_result_ok_clong;
+    }
+
+    {
+        PyLongObject *z;
+
+        digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
+        Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
+        bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
+        digit const *b_digits = (digit *)&operand2;
+        Py_ssize_t b_digit_count = (operand2 == 0 ? 0 : 1);
+        bool b_negative = operand2 < 0;
+
+        if (a_negative) {
+            if (b_negative) {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
 
-    if (unlikely(b == 0.0)) {
-        PyThreadState *tstate = PyThreadState_GET();
+            Nuitka_LongFlipSign(z);
+        } else {
+            if (b_negative) {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
+        }
+
+        obj_result = (PyObject *)z;
+        goto exit_result_object;
+    }
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+exit_result_object:
+    if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
+    result = obj_result;
+    goto exit_result_ok;
+
+exit_result_ok_clong:
+    result = Nuitka_LongFromCLong(clong_result);
+    goto exit_result_ok;
+
+exit_result_ok:
+    return result;
+
+exit_result_exception:
+    return NULL;
+}
+
+PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(operand1, operand2);
+}
+
+/* Code referring to "DIGIT" corresponds to C platform digit value for long Python objects and "LONG" to Python2 'long',
+ * Python3 'int'. */
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(long operand1, PyObject *operand2) {
+    assert(Py_ABS(operand1) < (1 << PyLong_SHIFT));
+    CHECK_OBJECT(operand2);
+    assert(PyLong_CheckExact(operand2));
+
+    PyObject *result;
+
+    // Not every code path will make use of all possible results.
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4101)
+#endif
+    NUITKA_MAY_BE_UNUSED PyObject *obj_result;
+    NUITKA_MAY_BE_UNUSED long clong_result;
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+    PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+
+    if ((operand1 == 0 ? 0 : 1) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
+        long r = (long)((sdigit)operand1 - MEDIUM_VALUE(operand2_long_object));
+
+        clong_result = r;
+        goto exit_result_ok_clong;
+    }
 
     {
-        double r = a / b;
+        PyLongObject *z;
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        digit const *a_digits = (digit *)&operand1;
+        Py_ssize_t a_digit_count = (operand1 == 0 ? 0 : 1);
+        bool a_negative = operand1 < 0;
+        digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
+        Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
+        bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
+
+        if (a_negative) {
+            if (b_negative) {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
+
+            Nuitka_LongFlipSign(z);
+        } else {
+            if (b_negative) {
+                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            } else {
+                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
+            }
+        }
+
+        obj_result = (PyObject *)z;
+        goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+exit_result_object:
+    if (unlikely(obj_result == NULL)) {
+        goto exit_result_exception;
+    }
+    result = obj_result;
+    goto exit_result_ok;
+
+exit_result_ok_clong:
+    result = Nuitka_LongFromCLong(clong_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(long operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(operand1, operand2);
 }
+
+/* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+    CHECK_OBJECT(operand1);
+    assert(PyFloat_CheckExact(operand1));
+
+    PyObject *result;
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4101)
+#endif
+    // Not every code path will make use of all possible results.
+    NUITKA_MAY_BE_UNUSED PyObject *obj_result;
+    NUITKA_MAY_BE_UNUSED long clong_result;
+    NUITKA_MAY_BE_UNUSED double cfloat_result;
+#ifdef _MSC_VER
+#pragma warning(pop)
 #endif
 
-#if PYTHON_VERSION < 0x300
+    CHECK_OBJECT(operand1);
+    assert(PyFloat_CheckExact(operand1));
+
+    const double a = PyFloat_AS_DOUBLE(operand1);
+    const double b = operand2;
+
+    double r = a - b;
+
+    cfloat_result = r;
+    goto exit_result_ok_cfloat;
+
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+    goto exit_result_ok;
+
+exit_result_ok:
+    return result;
+}
+
+PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+}
+
 /* Code referring to "CFLOAT" corresponds to C platform float value and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
 #ifdef _MSC_VER
@@ -2060,47 +2173,33 @@
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = operand1;
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    if (unlikely(b == 0.0)) {
-        PyThreadState *tstate = PyThreadState_GET();
+    double r = a - b;
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
-        goto exit_result_exception;
-    }
-
-    {
-        double r = a / b;
-
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
-    }
+    cfloat_result = r;
+    goto exit_result_ok_cfloat;
 
 exit_result_ok_cfloat:
     result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
-
-exit_result_exception:
-    return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_CFLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(operand1, operand2);
 }
-#endif
 
-#if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-static PyObject *_BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
         PyObject *result;
 
@@ -2121,44 +2220,25 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        if (unlikely(b == 0)) {
-            PyThreadState *tstate = PyThreadState_GET();
-
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
-            goto exit_result_exception;
-        }
-
-        /* TODO: Isn't this a very specific value only, of which we could
-         * hardcode the constant result. Not sure how well the C compiler
-         * optimizes UNARY_NEG_WOULD_OVERFLOW to this, but dividing by
-         * -1 has to be rare anyway.
-         */
-
-        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
-            long a_div_b = a / b;
-            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
-
-            if (a_mod_b && (b ^ a_mod_b) < 0) {
-                a_mod_b += b;
-                a_div_b -= 1;
-            }
-
-            clong_result = a_div_b;
+        const long x = (long)((unsigned long)a - b);
+        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
+        if (likely(no_overflow)) {
+            clong_result = x;
             goto exit_result_ok_clong;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
     exit_result_ok_clong:
@@ -2190,21 +2270,21 @@
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -2213,38 +2293,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2258,15 +2338,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2293,15 +2373,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_divide;
+                    binaryfunc slot = mv->nb_subtract;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2314,28 +2394,27 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and '%s'", type1->tp_name, type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and '%s'", type1->tp_name, type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_OLDDIV_OBJECT_OBJECT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(operand1, operand2);
 }
-#endif
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
 //     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryPow.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryPow.c`

 * *Files 2% similar despite different names*

```diff
@@ -210,26 +210,26 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -518,38 +518,38 @@
                 PyObject *x = slot2(operand1, operand2, Py_None);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -880,26 +880,26 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1068,38 +1068,38 @@
                 PyObject *x = slot2(operand1, operand2, Py_None);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1384,26 +1384,26 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1640,38 +1640,38 @@
                 PyObject *x = slot2(operand1, operand2, Py_None);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1898,15 +1898,15 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'float' and 'long'");
 #else
@@ -1955,15 +1955,15 @@
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'long' and 'float'");
 #else
@@ -2007,15 +2007,15 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'float' and 'int'");
     goto exit_binary_exception;
 
@@ -2062,15 +2062,15 @@
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'int' and 'float'");
     goto exit_binary_exception;
 
@@ -2111,15 +2111,15 @@
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2166,15 +2166,15 @@
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2334,38 +2334,38 @@
                 PyObject *x = slot2(operand1, operand2, Py_None);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2599,38 +2599,38 @@
                 PyObject *x = slot2(operand1, operand2, Py_None);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryPowUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryPowUtils.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryRshift.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryRshift.c`

 * *Files 3% similar despite different names*

```diff
@@ -86,26 +86,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -275,38 +275,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -520,26 +520,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -718,38 +718,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1013,26 +1013,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1239,38 +1239,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1558,26 +1558,26 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1789,38 +1789,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -2022,15 +2022,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2077,15 +2077,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2126,15 +2126,15 @@
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'long' and 'int'");
     goto exit_binary_exception;
 
@@ -2189,15 +2189,15 @@
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
     PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'int' and 'long'");
     goto exit_binary_exception;
 
@@ -2334,38 +2334,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2563,38 +2563,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinarySub.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryTruediv.c`

 * *Files 10% similar despite different names*

```diff
@@ -3,19 +3,19 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationBinary.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-/* C helpers for type specialized "-" (SUB) operations */
+/* C helpers for type specialized "/" (TRUEDIV) operations */
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
@@ -36,103 +36,136 @@
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
-    const long x = (long)((unsigned long)a - b);
-    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-    if (likely(no_overflow)) {
-        clong_result = x;
-        goto exit_result_ok_clong;
+    if (unlikely(b == 0)) {
+        PyThreadState *tstate = PyThreadState_GET();
+
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+        goto exit_result_exception;
+    }
+
+    if (a == 0) {
+        if (b < 0) {
+            goto exit_result_ok_const_float_minus_0_0;
+        } else {
+            goto exit_result_ok_const_float_0_0;
+        }
+    }
+
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+    } else
+#endif
+    {
+        double r = (double)a / (double)b;
+
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         obj_result = r;
         goto exit_result_object;
     }
 
-exit_result_ok_clong:
-    result = PyInt_FromLong(clong_result);
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
+exit_result_ok_const_float_0_0:
+    Py_INCREF(const_float_0_0);
+    result = const_float_0_0;
+    goto exit_result_ok;
+
+exit_result_ok_const_float_minus_0_0:
+    Py_INCREF(const_float_minus_0_0);
+    result = const_float_minus_0_0;
+    goto exit_result_ok;
+
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1,
+                                                                                  PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyInt_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyInt_Type.tp_as_number->nb_subtract;
+        slot2 = PyInt_Type.tp_as_number->nb_true_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -146,15 +179,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -180,15 +213,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -201,34 +234,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyInt_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -243,79 +276,113 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        const long x = (long)((unsigned long)a - b);
-        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-        if (likely(no_overflow)) {
-            clong_result = x;
-            goto exit_result_ok_clong;
+        if (unlikely(b == 0)) {
+            PyThreadState *tstate = PyThreadState_GET();
+
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            goto exit_result_exception;
+        }
+
+        if (a == 0) {
+            if (b < 0) {
+                goto exit_result_ok_const_float_minus_0_0;
+            } else {
+                goto exit_result_ok_const_float_0_0;
+            }
+        }
+
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+        } else
+#endif
+        {
+            double r = (double)a / (double)b;
+
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_clong:
-        result = PyInt_FromLong(clong_result);
+    exit_result_ok_cfloat:
+        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
+    exit_result_ok_const_float_0_0:
+        Py_INCREF(const_float_0_0);
+        result = const_float_0_0;
+        goto exit_result_ok;
+
+    exit_result_ok_const_float_minus_0_0:
+        Py_INCREF(const_float_minus_0_0);
+        result = const_float_minus_0_0;
+        goto exit_result_ok;
+
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1,
+                                                                                  PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_true_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyInt_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
+        slot2 =
+            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -324,38 +391,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -368,15 +435,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -403,15 +470,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -424,34 +491,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyInt_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -466,59 +533,91 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        const long x = (long)((unsigned long)a - b);
-        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-        if (likely(no_overflow)) {
-            clong_result = x;
-            goto exit_result_ok_clong;
+        if (unlikely(b == 0)) {
+            PyThreadState *tstate = PyThreadState_GET();
+
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            goto exit_result_exception;
+        }
+
+        if (a == 0) {
+            if (b < 0) {
+                goto exit_result_ok_const_float_minus_0_0;
+            } else {
+                goto exit_result_ok_const_float_0_0;
+            }
+        }
+
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+        } else
+#endif
+        {
+            double r = (double)a / (double)b;
+
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_clong:
-        result = PyInt_FromLong(clong_result);
+    exit_result_ok_cfloat:
+        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
+    exit_result_ok_const_float_0_0:
+        Py_INCREF(const_float_0_0);
+        result = const_float_0_0;
+        goto exit_result_ok;
+
+    exit_result_ok_const_float_minus_0_0:
+        Py_INCREF(const_float_minus_0_0);
+        result = const_float_minus_0_0;
+        goto exit_result_ok;
+
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_INT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(operand1, operand2);
 }
 #endif
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyObject *result;
 
@@ -529,125 +628,87 @@
 #endif
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
     NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    PyLongObject *operand1_long_object = (PyLongObject *)operand1;
-
-    PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+    PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+    assert(x != Py_NotImplemented);
 
-    if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
-        long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
-
-        clong_result = r;
-        goto exit_result_ok_clong;
-    }
-
-    {
-        PyLongObject *z;
-
-        digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
-        Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
-        bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
-        digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
-        Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
-        bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
-
-        if (a_negative) {
-            if (b_negative) {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
-
-            Nuitka_LongFlipSign(z);
-        } else {
-            if (b_negative) {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
-        }
-
-        obj_result = (PyObject *)z;
-        goto exit_result_object;
-    }
+    obj_result = x;
+    goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
-exit_result_ok_clong:
-    result = Nuitka_LongFromCLong(clong_result);
-    goto exit_result_ok;
-
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1,
+                                                                                   PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyLong_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_subtract;
+        slot2 = PyLong_Type.tp_as_number->nb_true_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -661,15 +722,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -695,15 +756,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -717,136 +778,99 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'long'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'long'", type1->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyLong_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyLongObject *operand1_long_object = (PyLongObject *)operand1;
-
-        PyLongObject *operand2_long_object = (PyLongObject *)operand2;
+        PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+        assert(x != Py_NotImplemented);
 
-        if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
-            long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
-
-            clong_result = r;
-            goto exit_result_ok_clong;
-        }
-
-        {
-            PyLongObject *z;
-
-            digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
-            Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
-            bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
-            digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
-            Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
-            bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
-
-            if (a_negative) {
-                if (b_negative) {
-                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                } else {
-                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                }
-
-                Nuitka_LongFlipSign(z);
-            } else {
-                if (b_negative) {
-                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                } else {
-                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                }
-            }
-
-            obj_result = (PyObject *)z;
-            goto exit_result_object;
-        }
+        obj_result = x;
+        goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
-    exit_result_ok_clong:
-        result = Nuitka_LongFromCLong(clong_result);
-        goto exit_result_ok;
-
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1,
+                                                                                   PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_true_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyLong_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
+        slot2 =
+            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -855,38 +879,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -899,15 +923,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -934,15 +958,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -956,117 +980,78 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and '%s'", type2->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyLong_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyLongObject *operand1_long_object = (PyLongObject *)operand1;
+        PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+        assert(x != Py_NotImplemented);
 
-        PyLongObject *operand2_long_object = (PyLongObject *)operand2;
-
-        if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
-            long r = (long)(MEDIUM_VALUE(operand1_long_object) - MEDIUM_VALUE(operand2_long_object));
-
-            clong_result = r;
-            goto exit_result_ok_clong;
-        }
-
-        {
-            PyLongObject *z;
-
-            digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
-            Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
-            bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
-            digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
-            Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
-            bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
-
-            if (a_negative) {
-                if (b_negative) {
-                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                } else {
-                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                }
-
-                Nuitka_LongFlipSign(z);
-            } else {
-                if (b_negative) {
-                    z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                } else {
-                    z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-                }
-            }
-
-            obj_result = (PyObject *)z;
-            goto exit_result_object;
-        }
+        obj_result = x;
+        goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
-    exit_result_ok_clong:
-        result = Nuitka_LongFromCLong(clong_result);
-        goto exit_result_ok;
-
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_LONG_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
@@ -1086,80 +1071,92 @@
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    double r = a - b;
+    if (unlikely(b == 0.0)) {
+        PyThreadState *tstate = PyThreadState_GET();
 
-    cfloat_result = r;
-    goto exit_result_ok_cfloat;
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        goto exit_result_exception;
+    }
+
+    {
+        double r = a / b;
+
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
+    }
 
 exit_result_ok_cfloat:
     result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
+
+exit_result_exception:
+    return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1,
-                                                                                PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1,
+                                                                                    PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyFloat_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
+        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1173,15 +1170,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1207,15 +1204,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1228,34 +1225,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and 'float'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'float'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyFloat_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1269,56 +1266,69 @@
         assert(PyFloat_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyFloat_CheckExact(operand2));
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
-        double r = a - b;
+        if (unlikely(b == 0.0)) {
+            PyThreadState *tstate = PyThreadState_GET();
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+            goto exit_result_exception;
+        }
+
+        {
+            double r = a / b;
+
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
+        }
 
     exit_result_ok_cfloat:
         result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
+
+    exit_result_exception:
+        return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1,
-                                                                                PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1,
+                                                                                    PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
     binaryfunc slot2 = NULL;
 
     if (!(&PyFloat_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
+        slot2 =
+            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -1327,38 +1337,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1371,15 +1381,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1406,15 +1416,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1427,34 +1437,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyFloat_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_SUB_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1468,36 +1478,48 @@
         assert(PyFloat_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyFloat_CheckExact(operand2));
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
-        double r = a - b;
+        if (unlikely(b == 0.0)) {
+            PyThreadState *tstate = PyThreadState_GET();
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+            goto exit_result_exception;
+        }
+
+        {
+            double r = a / b;
+
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
+        }
 
     exit_result_ok_cfloat:
         result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
+
+    exit_result_exception:
+        return NULL;
     }
 
-    return __BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1505,50 +1527,50 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(operand1, operand2);
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1562,51 +1584,51 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
+        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_LONG_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(operand1, operand2);
 }
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1614,48 +1636,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1669,48 +1691,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_subtract;
+        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_INT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1718,48 +1740,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_subtract;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_true_divide;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_LONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1773,48 +1795,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_subtract;
+        slot2 = PyLong_Type.tp_as_number->nb_true_divide;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_INT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
@@ -1831,59 +1853,91 @@
 
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
-    const long x = (long)((unsigned long)a - b);
-    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-    if (likely(no_overflow)) {
-        clong_result = x;
-        goto exit_result_ok_clong;
+    if (unlikely(b == 0)) {
+        PyThreadState *tstate = PyThreadState_GET();
+
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+        goto exit_result_exception;
+    }
+
+    if (a == 0) {
+        if (b < 0) {
+            goto exit_result_ok_const_float_minus_0_0;
+        } else {
+            goto exit_result_ok_const_float_0_0;
+        }
+    }
+
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+    } else
+#endif
+    {
+        double r = (double)a / (double)b;
+
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = PyLong_FromLong(operand2);
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand2_object);
 
         obj_result = r;
         goto exit_result_object;
     }
 
-exit_result_ok_clong:
-    result = PyInt_FromLong(clong_result);
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
+exit_result_ok_const_float_0_0:
+    Py_INCREF(const_float_0_0);
+    result = const_float_0_0;
+    goto exit_result_ok;
+
+exit_result_ok_const_float_minus_0_0:
+    Py_INCREF(const_float_minus_0_0);
+    result = const_float_minus_0_0;
+    goto exit_result_ok;
+
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_INT_CLONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "CLONG" corresponds to C platform long value and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
@@ -1901,220 +1955,90 @@
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     const long a = operand1;
     const long b = PyInt_AS_LONG(operand2);
 
-    const long x = (long)((unsigned long)a - b);
-    bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-    if (likely(no_overflow)) {
-        clong_result = x;
-        goto exit_result_ok_clong;
-    }
-    {
-        PyObject *operand1_object = PyLong_FromLong(operand1);
-        PyObject *operand2_object = operand2;
-
-        PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
-        assert(r != Py_NotImplemented);
-
-        Py_DECREF(operand1_object);
-
-        obj_result = r;
-        goto exit_result_object;
-    }
-
-exit_result_ok_clong:
-    result = PyInt_FromLong(clong_result);
-    goto exit_result_ok;
+    if (unlikely(b == 0)) {
+        PyThreadState *tstate = PyThreadState_GET();
 
-exit_result_object:
-    if (unlikely(obj_result == NULL)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
         goto exit_result_exception;
     }
-    result = obj_result;
-    goto exit_result_ok;
 
-exit_result_ok:
-    return result;
-
-exit_result_exception:
-    return NULL;
-}
-
-PyObject *BINARY_OPERATION_SUB_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_CLONG_INT(operand1, operand2);
-}
-#endif
-
-/* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "DIGIT" to C platform digit value for long
- * Python objects. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
-    CHECK_OBJECT(operand1);
-    assert(PyLong_CheckExact(operand1));
-    assert(Py_ABS(operand2) < (1 << PyLong_SHIFT));
-
-    PyObject *result;
-
-    // Not every code path will make use of all possible results.
-#ifdef _MSC_VER
-#pragma warning(push)
-#pragma warning(disable : 4101)
-#endif
-    NUITKA_MAY_BE_UNUSED PyObject *obj_result;
-    NUITKA_MAY_BE_UNUSED long clong_result;
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-    PyLongObject *operand1_long_object = (PyLongObject *)operand1;
-
-    if (Nuitka_LongGetDigitSize(operand1_long_object) <= 1 && (operand2 == 0 ? 0 : 1) <= 1) {
-        long r = (long)(MEDIUM_VALUE(operand1_long_object) - (sdigit)operand2);
-
-        clong_result = r;
-        goto exit_result_ok_clong;
-    }
-
-    {
-        PyLongObject *z;
-
-        digit const *a_digits = Nuitka_LongGetDigitPointer(operand1_long_object);
-        Py_ssize_t a_digit_count = Nuitka_LongGetDigitSize(operand1_long_object);
-        bool a_negative = Nuitka_LongIsNegative(operand1_long_object);
-        digit const *b_digits = (digit *)&operand2;
-        Py_ssize_t b_digit_count = (operand2 == 0 ? 0 : 1);
-        bool b_negative = operand2 < 0;
-
-        if (a_negative) {
-            if (b_negative) {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
-
-            Nuitka_LongFlipSign(z);
+    if (a == 0) {
+        if (b < 0) {
+            goto exit_result_ok_const_float_minus_0_0;
         } else {
-            if (b_negative) {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
+            goto exit_result_ok_const_float_0_0;
         }
-
-        obj_result = (PyObject *)z;
-        goto exit_result_object;
-    }
-
-exit_result_object:
-    if (unlikely(obj_result == NULL)) {
-        goto exit_result_exception;
     }
-    result = obj_result;
-    goto exit_result_ok;
-
-exit_result_ok_clong:
-    result = Nuitka_LongFromCLong(clong_result);
-    goto exit_result_ok;
-
-exit_result_ok:
-    return result;
-
-exit_result_exception:
-    return NULL;
-}
-
-PyObject *BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(PyObject *operand1, long operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_LONG_DIGIT(operand1, operand2);
-}
 
-/* Code referring to "DIGIT" corresponds to C platform digit value for long Python objects and "LONG" to Python2 'long',
- * Python3 'int'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(long operand1, PyObject *operand2) {
-    assert(Py_ABS(operand1) < (1 << PyLong_SHIFT));
-    CHECK_OBJECT(operand2);
-    assert(PyLong_CheckExact(operand2));
-
-    PyObject *result;
-
-    // Not every code path will make use of all possible results.
-#ifdef _MSC_VER
-#pragma warning(push)
-#pragma warning(disable : 4101)
-#endif
-    NUITKA_MAY_BE_UNUSED PyObject *obj_result;
-    NUITKA_MAY_BE_UNUSED long clong_result;
-#ifdef _MSC_VER
-#pragma warning(pop)
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+    } else
 #endif
+    {
+        double r = (double)a / (double)b;
 
-    PyLongObject *operand2_long_object = (PyLongObject *)operand2;
-
-    if ((operand1 == 0 ? 0 : 1) <= 1 && Nuitka_LongGetDigitSize(operand2_long_object) <= 1) {
-        long r = (long)((sdigit)operand1 - MEDIUM_VALUE(operand2_long_object));
-
-        clong_result = r;
-        goto exit_result_ok_clong;
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
     }
-
     {
-        PyLongObject *z;
+        PyObject *operand1_object = PyLong_FromLong(operand1);
+        PyObject *operand2_object = operand2;
 
-        digit const *a_digits = (digit *)&operand1;
-        Py_ssize_t a_digit_count = (operand1 == 0 ? 0 : 1);
-        bool a_negative = operand1 < 0;
-        digit const *b_digits = Nuitka_LongGetDigitPointer(operand2_long_object);
-        Py_ssize_t b_digit_count = Nuitka_LongGetDigitSize(operand2_long_object);
-        bool b_negative = Nuitka_LongIsNegative(operand2_long_object);
-
-        if (a_negative) {
-            if (b_negative) {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
+        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+        assert(r != Py_NotImplemented);
 
-            Nuitka_LongFlipSign(z);
-        } else {
-            if (b_negative) {
-                z = _Nuitka_LongAddDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            } else {
-                z = _Nuitka_LongSubDigits(a_digits, a_digit_count, b_digits, b_digit_count);
-            }
-        }
+        Py_DECREF(operand1_object);
 
-        obj_result = (PyObject *)z;
+        obj_result = r;
         goto exit_result_object;
     }
 
+exit_result_ok_cfloat:
+    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+    goto exit_result_ok;
+
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
-exit_result_ok_clong:
-    result = Nuitka_LongFromCLong(clong_result);
+exit_result_ok_const_float_0_0:
+    Py_INCREF(const_float_0_0);
+    result = const_float_0_0;
+    goto exit_result_ok;
+
+exit_result_ok_const_float_minus_0_0:
+    Py_INCREF(const_float_minus_0_0);
+    result = const_float_minus_0_0;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(long operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_DIGIT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(operand1, operand2);
 }
+#endif
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     PyObject *result;
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -2130,33 +2054,45 @@
 
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
-    double r = a - b;
+    if (unlikely(b == 0.0)) {
+        PyThreadState *tstate = PyThreadState_GET();
 
-    cfloat_result = r;
-    goto exit_result_ok_cfloat;
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        goto exit_result_exception;
+    }
+
+    {
+        double r = a / b;
+
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
+    }
 
 exit_result_ok_cfloat:
     result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
+
+exit_result_exception:
+    return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
 
 /* Code referring to "CFLOAT" corresponds to C platform float value and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
 #ifdef _MSC_VER
@@ -2173,33 +2109,45 @@
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     const double a = operand1;
     const double b = PyFloat_AS_DOUBLE(operand2);
 
-    double r = a - b;
+    if (unlikely(b == 0.0)) {
+        PyThreadState *tstate = PyThreadState_GET();
 
-    cfloat_result = r;
-    goto exit_result_ok_cfloat;
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        goto exit_result_exception;
+    }
+
+    {
+        double r = a / b;
+
+        cfloat_result = r;
+        goto exit_result_ok_cfloat;
+    }
 
 exit_result_ok_cfloat:
     result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
+
+exit_result_exception:
+    return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_CFLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-static PyObject *_BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
         PyObject *result;
 
@@ -2220,42 +2168,74 @@
         assert(PyInt_CheckExact(operand1));
         CHECK_OBJECT(operand2);
         assert(PyInt_CheckExact(operand2));
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
-        const long x = (long)((unsigned long)a - b);
-        bool no_overflow = ((x ^ a) >= 0 || (x ^ ~b) >= 0);
-        if (likely(no_overflow)) {
-            clong_result = x;
-            goto exit_result_ok_clong;
+        if (unlikely(b == 0)) {
+            PyThreadState *tstate = PyThreadState_GET();
+
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            goto exit_result_exception;
+        }
+
+        if (a == 0) {
+            if (b < 0) {
+                goto exit_result_ok_const_float_minus_0_0;
+            } else {
+                goto exit_result_ok_const_float_0_0;
+            }
+        }
+
+/* May need to resort to LONG code, which we currently do not
+ * specialize yet. TODO: Once we do that, call it here instead.
+ */
+#if DBL_MANT_DIG < WIDTH_OF_ULONG
+        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
+        } else
+#endif
+        {
+            double r = (double)a / (double)b;
+
+            cfloat_result = r;
+            goto exit_result_ok_cfloat;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_subtract(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_clong:
-        result = PyInt_FromLong(clong_result);
+    exit_result_ok_cfloat:
+        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
         goto exit_result_ok;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
+    exit_result_ok_const_float_0_0:
+        Py_INCREF(const_float_0_0);
+        result = const_float_0_0;
+        goto exit_result_ok;
+
+    exit_result_ok_const_float_minus_0_0:
+        Py_INCREF(const_float_minus_0_0);
+        result = const_float_minus_0_0;
+        goto exit_result_ok;
+
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 #endif
@@ -2270,21 +2250,22 @@
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_subtract : NULL;
+        slot2 =
+            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -2293,38 +2274,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2338,15 +2319,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2373,15 +2354,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_subtract;
+                    binaryfunc slot = mv->nb_true_divide;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2394,26 +2375,26 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: '%s' and '%s'", type1->tp_name, type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and '%s'", type1->tp_name, type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(operand1, operand2);
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationBinaryTruediv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationBinaryDivmod.c`

 * *Files 11% similar despite different names*

```diff
@@ -3,19 +3,20 @@
 /* WARNING, this code is GENERATED. Modify the template HelperOperationBinary.c.j2 instead! */
 
 /* This file is included from another C file, help IDEs to still parse it on its own. */
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
-/* C helpers for type specialized "/" (TRUEDIV) operations */
+#include "HelpersOperationBinaryDivmodUtils.c"
+/* C helpers for type specialized "divmod" (DIVMOD) operations */
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
@@ -39,133 +40,111 @@
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = PyInt_AS_LONG(operand2);
 
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
-    if (a == 0) {
-        if (b < 0) {
-            goto exit_result_ok_const_float_minus_0_0;
-        } else {
-            goto exit_result_ok_const_float_0_0;
-        }
-    }
+    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+        long a_div_b = a / b;
+        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-    } else
-#endif
-    {
-        double r = (double)a / (double)b;
+        if (a_mod_b && (b ^ a_mod_b) < 0) {
+            a_mod_b += b;
+            a_div_b -= 1;
+        }
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+        obj_result = r;
+        goto exit_result_object;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         obj_result = r;
         goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-    goto exit_result_ok;
-
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
-exit_result_ok_const_float_0_0:
-    Py_INCREF(const_float_0_0);
-    result = const_float_0_0;
-    goto exit_result_ok;
-
-exit_result_ok_const_float_minus_0_0:
-    Py_INCREF(const_float_minus_0_0);
-    result = const_float_minus_0_0;
-    goto exit_result_ok;
-
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "OBJECT" corresponds to any Python object and "INT" to Python2 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1,
-                                                                                  PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1,
+                                                                                 PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyInt_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyInt_Type.tp_as_number->nb_true_divide;
+        slot2 = PyInt_Type.tp_as_number->nb_divmod;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -179,15 +158,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -213,15 +192,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -234,34 +213,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'int'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyInt_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -279,110 +258,87 @@
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
-        if (a == 0) {
-            if (b < 0) {
-                goto exit_result_ok_const_float_minus_0_0;
-            } else {
-                goto exit_result_ok_const_float_0_0;
-            }
-        }
+        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+            long a_div_b = a / b;
+            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-        } else
-#endif
-        {
-            double r = (double)a / (double)b;
+            if (a_mod_b && (b ^ a_mod_b) < 0) {
+                a_mod_b += b;
+                a_div_b -= 1;
+            }
 
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
+            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+            obj_result = r;
+            goto exit_result_object;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_cfloat:
-        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-        goto exit_result_ok;
-
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
-    exit_result_ok_const_float_0_0:
-        Py_INCREF(const_float_0_0);
-        result = const_float_0_0;
-        goto exit_result_ok;
-
-    exit_result_ok_const_float_minus_0_0:
-        Py_INCREF(const_float_minus_0_0);
-        result = const_float_minus_0_0;
-        goto exit_result_ok;
-
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1,
-                                                                                  PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1,
+                                                                                 PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyInt_Type.tp_as_number->nb_divmod;
     binaryfunc slot2 = NULL;
 
     if (!(&PyInt_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 =
-            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -391,38 +347,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -435,15 +391,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -470,15 +426,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -491,34 +447,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyInt_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_INT(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_INT_INT(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED bool cbool_result;
@@ -536,88 +492,66 @@
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
-        if (a == 0) {
-            if (b < 0) {
-                goto exit_result_ok_const_float_minus_0_0;
-            } else {
-                goto exit_result_ok_const_float_0_0;
-            }
-        }
+        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+            long a_div_b = a / b;
+            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-        } else
-#endif
-        {
-            double r = (double)a / (double)b;
+            if (a_mod_b && (b ^ a_mod_b) < 0) {
+                a_mod_b += b;
+                a_div_b -= 1;
+            }
 
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
+            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+            obj_result = r;
+            goto exit_result_object;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_cfloat:
-        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-        goto exit_result_ok;
-
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
-    exit_result_ok_const_float_0_0:
-        Py_INCREF(const_float_0_0);
-        result = const_float_0_0;
-        goto exit_result_ok;
-
-    exit_result_ok_const_float_minus_0_0:
-        Py_INCREF(const_float_minus_0_0);
-        result = const_float_minus_0_0;
-        goto exit_result_ok;
-
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_OBJECT(operand1, operand2);
 }
 #endif
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyObject *result;
 
@@ -628,15 +562,15 @@
 #endif
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
     NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+    PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
     assert(x != Py_NotImplemented);
 
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -648,67 +582,67 @@
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "LONG" to Python2 'long', Python3 'int'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1,
-                                                                                   PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1,
+                                                                                  PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyLong_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_true_divide;
+        slot2 = PyLong_Type.tp_as_number->nb_divmod;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -722,15 +656,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -756,15 +690,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -778,50 +712,50 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'long'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'long'", type1->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'int'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'int'", type1->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyLong_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+        PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -833,44 +767,43 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_LONG(operand1, operand2);
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1,
-                                                                                   PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1,
+                                                                                  PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divmod;
     binaryfunc slot2 = NULL;
 
     if (!(&PyLong_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 =
-            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -879,38 +812,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -923,15 +856,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -958,15 +891,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -980,50 +913,50 @@
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and '%s'", type2->tp_name);
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and '%s'", type2->tp_name);
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyLong_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_LONG(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_LONG(operand1, operand2);
 
         // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
         NUITKA_MAY_BE_UNUSED long clong_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-        PyObject *x = PyLong_Type.tp_as_number->nb_true_divide(operand1, operand2);
+        PyObject *x = PyLong_Type.tp_as_number->nb_divmod(operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -1035,23 +968,23 @@
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_OBJECT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
@@ -1074,89 +1007,114 @@
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
         goto exit_result_exception;
     }
 
     {
-        double r = a / b;
+        double mod = fmod(a, b);
+        double div = (a - mod) / b;
+
+        if (mod) {
+            if ((b < 0) != (mod < 0)) {
+                mod += b;
+                div -= 1.0;
+            }
+        } else {
+            mod = copysign(0.0, b);
+        }
+
+        double floordiv;
+        if (div) {
+            floordiv = floor(div);
+            if (div - floordiv > 0.5) {
+                floordiv += 1.0;
+            }
+        } else {
+            floordiv = copysign(0.0, a / b);
+        }
+
+        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        obj_result = r;
+        goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+exit_result_object:
+    if (unlikely(obj_result == NULL)) {
+        goto exit_result_exception;
+    }
+    result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "FLOAT" to Python 'float'. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1,
-                                                                                    PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1,
+                                                                                   PyObject *operand2) {
     PyTypeObject *type1 = Py_TYPE(operand1);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == &PyFloat_Type)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1170,15 +1128,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1204,15 +1162,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1225,34 +1183,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and 'float'", type1->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and 'float'", type1->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyTypeObject *type1 = Py_TYPE(operand1);
 
     if (type1 == &PyFloat_Type) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1269,66 +1227,90 @@
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
         if (unlikely(b == 0.0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
             goto exit_result_exception;
         }
 
         {
-            double r = a / b;
+            double mod = fmod(a, b);
+            double div = (a - mod) / b;
 
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
+            if (mod) {
+                if ((b < 0) != (mod < 0)) {
+                    mod += b;
+                    div -= 1.0;
+                }
+            } else {
+                mod = copysign(0.0, b);
+            }
+
+            double floordiv;
+            if (div) {
+                floordiv = floor(div);
+                if (div - floordiv > 0.5) {
+                    floordiv += 1.0;
+                }
+            } else {
+                floordiv = copysign(0.0, a / b);
+            }
+
+            PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
+
+            obj_result = r;
+            goto exit_result_object;
         }
 
-    exit_result_ok_cfloat:
-        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+    exit_result_object:
+        if (unlikely(obj_result == NULL)) {
+            goto exit_result_exception;
+        }
+        result = obj_result;
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "OBJECT" to any Python object. */
-static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1,
-                                                                                    PyObject *operand2) {
+static HEDLEY_NEVER_INLINE PyObject *__BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1,
+                                                                                   PyObject *operand2) {
     PyTypeObject *type2 = Py_TYPE(operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
     binaryfunc slot2 = NULL;
 
     if (!(&PyFloat_Type == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 =
-            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -1337,38 +1319,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
         if (c1 != NULL) {
@@ -1381,15 +1363,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1416,15 +1398,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -1437,34 +1419,34 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and '%s'", type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and '%s'", type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
 
     PyTypeObject *type2 = Py_TYPE(operand2);
 
     if (&PyFloat_Type == type2) {
         PyObject *result;
 
-        // return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_FLOAT(operand1, operand2);
+        // return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_FLOAT(operand1, operand2);
 
 #ifdef _MSC_VER
 #pragma warning(push)
 #pragma warning(disable : 4101)
 #endif
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
@@ -1481,45 +1463,70 @@
 
         const double a = PyFloat_AS_DOUBLE(operand1);
         const double b = PyFloat_AS_DOUBLE(operand2);
 
         if (unlikely(b == 0.0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
             goto exit_result_exception;
         }
 
         {
-            double r = a / b;
+            double mod = fmod(a, b);
+            double div = (a - mod) / b;
+
+            if (mod) {
+                if ((b < 0) != (mod < 0)) {
+                    mod += b;
+                    div -= 1.0;
+                }
+            } else {
+                mod = copysign(0.0, b);
+            }
 
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
+            double floordiv;
+            if (div) {
+                floordiv = floor(div);
+                if (div - floordiv > 0.5) {
+                    floordiv += 1.0;
+                }
+            } else {
+                floordiv = copysign(0.0, a / b);
+            }
+
+            PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
+
+            obj_result = r;
+            goto exit_result_object;
         }
 
-    exit_result_ok_cfloat:
-        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+    exit_result_object:
+        if (unlikely(obj_result == NULL)) {
+            goto exit_result_exception;
+        }
+        result = obj_result;
         goto exit_result_ok;
 
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 
-    return __BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
+    return __BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_OBJECT(operand1, operand2);
 }
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1527,50 +1534,50 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'long'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'int'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_LONG(operand1, operand2);
 }
 
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1584,51 +1591,51 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and 'float'");
 #else
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'float'");
 #endif
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_FLOAT(operand1, operand2);
 }
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "FLOAT" corresponds to Python 'float' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1636,48 +1643,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyFloat_Type.tp_as_number->nb_divmod;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'float' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1691,48 +1698,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyFloat_Type.tp_as_number->nb_true_divide;
+        slot2 = PyFloat_Type.tp_as_number->nb_divmod;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'float'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_FLOAT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "LONG" corresponds to Python2 'long', Python3 'int' and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyLong_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1740,48 +1747,48 @@
 #endif
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
-    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_true_divide;
+    binaryfunc slot1 = PyLong_Type.tp_as_number->nb_divmod;
     // Slot2 ignored on purpose, type1 takes precedence.
 
     if (slot1 != NULL) {
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'long' and 'int'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_LONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_LONG_INT(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "LONG" to Python2 'long', Python3 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
     CHECK_OBJECT(operand2);
     assert(PyLong_CheckExact(operand2));
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -1795,48 +1802,48 @@
 
     // Slot1 ignored on purpose, type2 takes precedence.
     binaryfunc slot2 = NULL;
 
     if (!(0)) {
         // Different types, need to consider second value slot.
 
-        slot2 = PyLong_Type.tp_as_number->nb_true_divide;
+        slot2 = PyLong_Type.tp_as_number->nb_divmod;
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     // Statically recognized that coercion is not possible with these types
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): 'int' and 'long'");
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_LONG(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_LONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "INT" corresponds to Python2 'int' and "CLONG" to C platform long value. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
     CHECK_OBJECT(operand1);
     assert(PyInt_CheckExact(operand1));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
 #ifdef _MSC_VER
@@ -1856,88 +1863,66 @@
 
     const long a = PyInt_AS_LONG(operand1);
     const long b = operand2;
 
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
-    if (a == 0) {
-        if (b < 0) {
-            goto exit_result_ok_const_float_minus_0_0;
-        } else {
-            goto exit_result_ok_const_float_0_0;
-        }
-    }
+    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+        long a_div_b = a / b;
+        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-    } else
-#endif
-    {
-        double r = (double)a / (double)b;
+        if (a_mod_b && (b ^ a_mod_b) < 0) {
+            a_mod_b += b;
+            a_div_b -= 1;
+        }
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+        obj_result = r;
+        goto exit_result_object;
     }
     {
         PyObject *operand1_object = operand1;
         PyObject *operand2_object = PyLong_FromLong(operand2);
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand2_object);
 
         obj_result = r;
         goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-    goto exit_result_ok;
-
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
-exit_result_ok_const_float_0_0:
-    Py_INCREF(const_float_0_0);
-    result = const_float_0_0;
-    goto exit_result_ok;
-
-exit_result_ok_const_float_minus_0_0:
-    Py_INCREF(const_float_minus_0_0);
-    result = const_float_minus_0_0;
-    goto exit_result_ok;
-
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_INT_CLONG(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(PyObject *operand1, long operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_INT_CLONG(operand1, operand2);
 }
 #endif
 
 #if PYTHON_VERSION < 0x300
 /* Code referring to "CLONG" corresponds to C platform long value and "INT" to Python2 'int'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyInt_CheckExact(operand2));
 
     PyObject *result;
 
     // Not every code path will make use of all possible results.
@@ -1958,87 +1943,65 @@
 
     const long a = operand1;
     const long b = PyInt_AS_LONG(operand2);
 
     if (unlikely(b == 0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
         goto exit_result_exception;
     }
 
-    if (a == 0) {
-        if (b < 0) {
-            goto exit_result_ok_const_float_minus_0_0;
-        } else {
-            goto exit_result_ok_const_float_0_0;
-        }
-    }
+    if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+        long a_div_b = a / b;
+        long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-    if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-    } else
-#endif
-    {
-        double r = (double)a / (double)b;
+        if (a_mod_b && (b ^ a_mod_b) < 0) {
+            a_mod_b += b;
+            a_div_b -= 1;
+        }
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+        obj_result = r;
+        goto exit_result_object;
     }
     {
         PyObject *operand1_object = PyLong_FromLong(operand1);
         PyObject *operand2_object = operand2;
 
-        PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+        PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
         assert(r != Py_NotImplemented);
 
         Py_DECREF(operand1_object);
 
         obj_result = r;
         goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-    goto exit_result_ok;
-
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         goto exit_result_exception;
     }
     result = obj_result;
     goto exit_result_ok;
 
-exit_result_ok_const_float_0_0:
-    Py_INCREF(const_float_0_0);
-    result = const_float_0_0;
-    goto exit_result_ok;
-
-exit_result_ok_const_float_minus_0_0:
-    Py_INCREF(const_float_minus_0_0);
-    result = const_float_minus_0_0;
-    goto exit_result_ok;
-
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_CLONG_INT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(long operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_CLONG_INT(operand1, operand2);
 }
 #endif
 
 /* Code referring to "FLOAT" corresponds to Python 'float' and "CFLOAT" to C platform float value. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
     CHECK_OBJECT(operand1);
     assert(PyFloat_CheckExact(operand1));
 
     PyObject *result;
 
 #ifdef _MSC_VER
 #pragma warning(push)
@@ -2057,42 +2020,67 @@
 
     const double a = PyFloat_AS_DOUBLE(operand1);
     const double b = operand2;
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
         goto exit_result_exception;
     }
 
     {
-        double r = a / b;
+        double mod = fmod(a, b);
+        double div = (a - mod) / b;
+
+        if (mod) {
+            if ((b < 0) != (mod < 0)) {
+                mod += b;
+                div -= 1.0;
+            }
+        } else {
+            mod = copysign(0.0, b);
+        }
+
+        double floordiv;
+        if (div) {
+            floordiv = floor(div);
+            if (div - floordiv > 0.5) {
+                floordiv += 1.0;
+            }
+        } else {
+            floordiv = copysign(0.0, a / b);
+        }
+
+        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        obj_result = r;
+        goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+exit_result_object:
+    if (unlikely(obj_result == NULL)) {
+        goto exit_result_exception;
+    }
+    result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_FLOAT_CFLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(PyObject *operand1, double operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_FLOAT_CFLOAT(operand1, operand2);
 }
 
 /* Code referring to "CFLOAT" corresponds to C platform float value and "FLOAT" to Python 'float'. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
 
     CHECK_OBJECT(operand2);
     assert(PyFloat_CheckExact(operand2));
 
     PyObject *result;
 
 #ifdef _MSC_VER
@@ -2112,42 +2100,67 @@
 
     const double a = operand1;
     const double b = PyFloat_AS_DOUBLE(operand2);
 
     if (unlikely(b == 0.0)) {
         PyThreadState *tstate = PyThreadState_GET();
 
-        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float division by zero");
+        SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "float modulo");
         goto exit_result_exception;
     }
 
     {
-        double r = a / b;
+        double mod = fmod(a, b);
+        double div = (a - mod) / b;
+
+        if (mod) {
+            if ((b < 0) != (mod < 0)) {
+                mod += b;
+                div -= 1.0;
+            }
+        } else {
+            mod = copysign(0.0, b);
+        }
+
+        double floordiv;
+        if (div) {
+            floordiv = floor(div);
+            if (div - floordiv > 0.5) {
+                floordiv += 1.0;
+            }
+        } else {
+            floordiv = copysign(0.0, a / b);
+        }
+
+        PyObject *r = Py_BuildValue("(dd)", floordiv, mod);
 
-        cfloat_result = r;
-        goto exit_result_ok_cfloat;
+        obj_result = r;
+        goto exit_result_object;
     }
 
-exit_result_ok_cfloat:
-    result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
+exit_result_object:
+    if (unlikely(obj_result == NULL)) {
+        goto exit_result_exception;
+    }
+    result = obj_result;
     goto exit_result_ok;
 
 exit_result_ok:
     return result;
 
 exit_result_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_CFLOAT_FLOAT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(double operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_CFLOAT_FLOAT(operand1, operand2);
 }
 
 /* Code referring to "OBJECT" corresponds to any Python object and "OBJECT" to any Python object. */
-static PyObject *_BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+static PyObject *_BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
     CHECK_OBJECT(operand1);
     CHECK_OBJECT(operand2);
 
 #if PYTHON_VERSION < 0x300
     if (PyInt_CheckExact(operand1) && PyInt_CheckExact(operand2)) {
         PyObject *result;
 
@@ -2171,71 +2184,49 @@
 
         const long a = PyInt_AS_LONG(operand1);
         const long b = PyInt_AS_LONG(operand2);
 
         if (unlikely(b == 0)) {
             PyThreadState *tstate = PyThreadState_GET();
 
-            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "division by zero");
+            SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ZeroDivisionError, "integer division or modulo by zero");
             goto exit_result_exception;
         }
 
-        if (a == 0) {
-            if (b < 0) {
-                goto exit_result_ok_const_float_minus_0_0;
-            } else {
-                goto exit_result_ok_const_float_0_0;
-            }
-        }
+        if (likely(b != -1 || !UNARY_NEG_WOULD_OVERFLOW(a))) {
+            long a_div_b = a / b;
+            long a_mod_b = (long)(a - (unsigned long)a_div_b * b);
 
-/* May need to resort to LONG code, which we currently do not
- * specialize yet. TODO: Once we do that, call it here instead.
- */
-#if DBL_MANT_DIG < WIDTH_OF_ULONG
-        if ((a >= 0 ? 0UL + a : 0UL - a) >> DBL_MANT_DIG || (b >= 0 ? 0UL + b : 0UL - b) >> DBL_MANT_DIG) {
-        } else
-#endif
-        {
-            double r = (double)a / (double)b;
+            if (a_mod_b && (b ^ a_mod_b) < 0) {
+                a_mod_b += b;
+                a_div_b -= 1;
+            }
 
-            cfloat_result = r;
-            goto exit_result_ok_cfloat;
+            PyObject *r = Py_BuildValue("(ll)", a_div_b, a_mod_b);
+            obj_result = r;
+            goto exit_result_object;
         }
         {
             PyObject *operand1_object = operand1;
             PyObject *operand2_object = operand2;
 
-            PyObject *r = PyLong_Type.tp_as_number->nb_true_divide(operand1_object, operand2_object);
+            PyObject *r = PyLong_Type.tp_as_number->nb_divmod(operand1_object, operand2_object);
             assert(r != Py_NotImplemented);
 
             obj_result = r;
             goto exit_result_object;
         }
 
-    exit_result_ok_cfloat:
-        result = MAKE_FLOAT_FROM_DOUBLE(cfloat_result);
-        goto exit_result_ok;
-
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
             goto exit_result_exception;
         }
         result = obj_result;
         goto exit_result_ok;
 
-    exit_result_ok_const_float_0_0:
-        Py_INCREF(const_float_0_0);
-        result = const_float_0_0;
-        goto exit_result_ok;
-
-    exit_result_ok_const_float_minus_0_0:
-        Py_INCREF(const_float_minus_0_0);
-        result = const_float_minus_0_0;
-        goto exit_result_ok;
-
     exit_result_ok:
         return result;
 
     exit_result_exception:
         return NULL;
     }
 #endif
@@ -2250,22 +2241,21 @@
     NUITKA_MAY_BE_UNUSED bool cbool_result;
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
 
     binaryfunc slot1 =
-        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
+        (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divmod : NULL;
     binaryfunc slot2 = NULL;
 
     if (!(type1 == type2)) {
         // Different types, need to consider second value slot.
 
-        slot2 =
-            (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_true_divide : NULL;
+        slot2 = (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_divmod : NULL;
 
         if (slot1 == slot2) {
             slot2 = NULL;
         }
     }
 
     if (slot1 != NULL) {
@@ -2274,38 +2264,38 @@
                 PyObject *x = slot2(operand1, operand2);
 
                 if (x != Py_NotImplemented) {
                     obj_result = x;
                     goto exit_binary_result_object;
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
         PyObject *x = slot1(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     if (slot2 != NULL) {
         PyObject *x = slot2(operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_binary_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
 #if PYTHON_VERSION < 0x300
     if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
         coercion c1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2319,15 +2309,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2354,15 +2344,15 @@
                 goto exit_binary_exception;
             }
 
             if (err == 0) {
                 PyNumberMethods *mv = Py_TYPE(coerced1)->tp_as_number;
 
                 if (likely(mv == NULL)) {
-                    binaryfunc slot = mv->nb_true_divide;
+                    binaryfunc slot = mv->nb_divmod;
 
                     if (likely(slot != NULL)) {
                         PyObject *x = slot(coerced1, coerced2);
 
                         Py_DECREF(coerced1);
                         Py_DECREF(coerced2);
 
@@ -2375,26 +2365,27 @@
                 Py_DECREF(coerced1);
                 Py_DECREF(coerced2);
             }
         }
     }
 #endif
 
-    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: '%s' and '%s'", type1->tp_name, type2->tp_name);
+    PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for divmod(): '%s' and '%s'", type1->tp_name,
+                 type2->tp_name);
     goto exit_binary_exception;
 
 exit_binary_result_object:
     return obj_result;
 
 exit_binary_exception:
     return NULL;
 }
 
-PyObject *BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
-    return _BINARY_OPERATION_TRUEDIV_OBJECT_OBJECT_OBJECT(operand1, operand2);
+PyObject *BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(PyObject *operand1, PyObject *operand2) {
+    return _BINARY_OPERATION_DIVMOD_OBJECT_OBJECT_OBJECT(operand1, operand2);
 }
 
 //     Part of "Nuitka", an optimizing Python compiler that is compatible and
 //     integrates with CPython, but also works on its own.
 //
 //     Licensed under the Apache License, Version 2.0 (the "License");
 //     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceAdd.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceAdd.c`

 * *Files 1% similar despite different names*

```diff
@@ -112,15 +112,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
         binaryfunc slot2 = NULL;
 
@@ -138,26 +138,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -388,38 +388,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -747,15 +747,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
         binaryfunc slot2 = NULL;
 
@@ -773,26 +773,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1070,38 +1070,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1407,15 +1407,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1433,26 +1433,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1656,38 +1656,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1874,15 +1874,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -1953,15 +1953,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -2027,15 +2027,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -2104,15 +2104,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -2175,15 +2175,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -2252,15 +2252,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_concat available for this type.
             // No inplace sequence repeat slot sq_inplace_concat available for this type.
@@ -2626,30 +2626,30 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
 
         if (slot1 != NULL) {
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -2810,15 +2810,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3018,30 +3018,30 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
 
         if (slot1 != NULL) {
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -3210,15 +3210,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3420,30 +3420,30 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
 
         if (slot1 != NULL) {
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -3605,15 +3605,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3758,15 +3758,18 @@
 
         return true;
     }
 
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-    PyObject *x = TUPLE_CONCAT(*operand1, operand2);
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = TUPLE_CONCAT(tstate, *operand1, operand2);
 
     assert(x != Py_NotImplemented);
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -3810,30 +3813,30 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
 
         if (slot1 != NULL) {
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -3919,15 +3922,18 @@
 
     if (type1 == &PyTuple_Type) {
         // return _BINARY_OPERATION_ADD_TUPLE_TUPLE_INPLACE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = TUPLE_CONCAT(*operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = TUPLE_CONCAT(tstate, *operand1, operand2);
 
         assert(x != Py_NotImplemented);
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -3982,15 +3988,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4081,15 +4087,18 @@
 
     if (&PyTuple_Type == type2) {
         // return _BINARY_OPERATION_ADD_TUPLE_TUPLE_INPLACE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = TUPLE_CONCAT(*operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = TUPLE_CONCAT(tstate, *operand1, operand2);
 
         assert(x != Py_NotImplemented);
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -4140,15 +4149,18 @@
 
         return true;
     }
 
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-    PyObject *x = LIST_CONCAT(*operand1, operand2);
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = LIST_CONCAT(tstate, *operand1, operand2);
     assert(x != Py_NotImplemented);
 
     obj_result = x;
     goto exit_result_object;
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
@@ -4193,30 +4205,30 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
 
         if (slot1 != NULL) {
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -4306,15 +4318,18 @@
 
     if (type1 == &PyList_Type) {
         // return _BINARY_OPERATION_ADD_LIST_LIST_INPLACE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(*operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, *operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -4370,15 +4385,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4478,15 +4493,18 @@
 
     if (&PyList_Type == type2) {
         // return _BINARY_OPERATION_ADD_LIST_LIST_INPLACE(operand1, operand2);
 
         // Not every code path will make use of all possible results.
         NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
-        PyObject *x = LIST_CONCAT(*operand1, operand2);
+        // TODO: Have this more globally passed in
+        PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *x = LIST_CONCAT(tstate, *operand1, operand2);
         assert(x != Py_NotImplemented);
 
         obj_result = x;
         goto exit_result_object;
 
     exit_result_object:
         if (unlikely(obj_result == NULL)) {
@@ -4779,15 +4797,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_add : NULL;
         binaryfunc slot2 = NULL;
 
@@ -4807,38 +4825,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceAddUtils.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceAddUtils.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitand.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitand.c`

 * *Files 1% similar despite different names*

```diff
@@ -76,15 +76,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_and : NULL;
         binaryfunc slot2 = NULL;
 
@@ -102,26 +102,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -307,38 +307,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -565,15 +565,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_and : NULL;
         binaryfunc slot2 = NULL;
 
@@ -591,26 +591,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -801,38 +801,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1067,15 +1067,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for &: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1139,15 +1139,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for &: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -1236,15 +1236,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_and : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1262,26 +1262,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1407,15 +1407,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = PySet_Type.tp_as_number->nb_and;
         binaryfunc slot2 = NULL;
 
         if (!(&PySet_Type == type2)) {
@@ -1434,38 +1434,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -1650,15 +1650,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_and : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1678,38 +1678,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitor.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitor.c`

 * *Files 2% similar despite different names*

```diff
@@ -76,15 +76,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_or : NULL;
         binaryfunc slot2 = NULL;
 
@@ -102,26 +102,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -307,38 +307,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -565,15 +565,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_or : NULL;
         binaryfunc slot2 = NULL;
 
@@ -591,26 +591,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -801,38 +801,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1067,15 +1067,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for |: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1139,15 +1139,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for |: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -1236,15 +1236,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_or : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1262,26 +1262,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1407,15 +1407,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = PySet_Type.tp_as_number->nb_or;
         binaryfunc slot2 = NULL;
 
         if (!(&PySet_Type == type2)) {
@@ -1434,38 +1434,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -1650,15 +1650,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_or : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1678,38 +1678,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceBitxor.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceBitxor.c`

 * *Files 1% similar despite different names*

```diff
@@ -76,15 +76,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_xor : NULL;
         binaryfunc slot2 = NULL;
 
@@ -102,26 +102,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -307,38 +307,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -565,15 +565,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_xor : NULL;
         binaryfunc slot2 = NULL;
 
@@ -591,26 +591,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -801,38 +801,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1067,15 +1067,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ^: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1139,15 +1139,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ^: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -1236,15 +1236,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_xor : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1262,26 +1262,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !0) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1407,15 +1407,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = PySet_Type.tp_as_number->nb_xor;
         binaryfunc slot2 = NULL;
 
         if (!(&PySet_Type == type2)) {
@@ -1434,38 +1434,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -1650,15 +1650,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_xor : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1678,38 +1678,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceFloordiv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceFloordiv.c`

 * *Files 1% similar despite different names*

```diff
@@ -131,15 +131,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_floor_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -157,26 +157,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -412,38 +412,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -709,15 +709,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_floor_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -735,26 +735,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -941,38 +941,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1226,15 +1226,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_floor_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1252,26 +1252,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1490,38 +1490,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1732,15 +1732,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'float' and 'long'");
 #else
@@ -1806,15 +1806,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'long' and 'float'");
 #else
@@ -1875,15 +1875,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1947,15 +1947,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -2013,15 +2013,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2085,15 +2085,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for //: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2423,15 +2423,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_floor_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -2452,38 +2452,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceLshift.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceLshift.c`

 * *Files 4% similar despite different names*

```diff
@@ -76,15 +76,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_lshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -102,26 +102,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -308,38 +308,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -619,15 +619,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_lshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -645,26 +645,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -909,38 +909,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1177,15 +1177,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1249,15 +1249,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for <<: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -1417,15 +1417,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_lshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1446,38 +1446,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMatmult.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMatmult.c`

 * *Files 2% similar despite different names*

```diff
@@ -81,15 +81,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1))
                                ? type1->tp_as_number->nb_matrix_multiply
                                : NULL;
 
@@ -97,15 +97,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with Python3 only operator '@'
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and 'long'", type1->tp_name);
 #else
@@ -175,15 +175,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with Python3 only operator '@'
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: 'long' and '%s'", type2->tp_name);
 #else
@@ -283,15 +283,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1))
                                ? type1->tp_as_number->nb_matrix_multiply
                                : NULL;
 
@@ -299,15 +299,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with Python3 only operator '@'
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and 'float'", type1->tp_name);
         goto exit_inplace_exception;
     }
@@ -373,15 +373,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with Python3 only operator '@'
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: 'float' and '%s'", type2->tp_name);
         goto exit_inplace_exception;
     }
@@ -495,15 +495,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 = (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1))
                                ? type1->tp_as_number->nb_matrix_multiply
                                : NULL;
         binaryfunc slot2 = NULL;
@@ -526,38 +526,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with Python3 only operator '@'
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for @: '%s' and '%s'", type1->tp_name,
                      type2->tp_name);
         goto exit_inplace_exception;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMod.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMod.c`

 * *Files 3% similar despite different names*

```diff
@@ -123,15 +123,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_remainder : NULL;
         binaryfunc slot2 = NULL;
 
@@ -149,26 +149,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -396,38 +396,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -685,15 +685,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_remainder : NULL;
         binaryfunc slot2 = NULL;
 
@@ -711,26 +711,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -917,38 +917,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1192,15 +1192,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_remainder : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1218,26 +1218,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1446,38 +1446,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1678,15 +1678,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'long'");
 #else
@@ -1752,15 +1752,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'float'");
 #else
@@ -1821,15 +1821,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1893,15 +1893,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -1959,15 +1959,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2031,15 +2031,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2260,26 +2260,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2343,26 +2343,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2426,26 +2426,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'float'");
         goto exit_inplace_exception;
     }
@@ -2549,26 +2549,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'unicode'");
         goto exit_inplace_exception;
     }
@@ -2625,15 +2625,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'tuple'");
         goto exit_inplace_exception;
     }
@@ -2690,15 +2690,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'list'");
         goto exit_inplace_exception;
     }
@@ -2755,15 +2755,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'dict'");
         goto exit_inplace_exception;
     }
@@ -2829,38 +2829,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3001,26 +3001,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'int'");
         goto exit_inplace_exception;
     }
@@ -3084,26 +3084,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'long'");
 #else
@@ -3169,26 +3169,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'float'");
 #else
@@ -3255,26 +3255,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'str'");
         goto exit_inplace_exception;
     }
@@ -3338,26 +3338,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'str' and 'bytes'");
         goto exit_inplace_exception;
     }
@@ -3452,15 +3452,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'tuple'");
 #else
@@ -3519,15 +3519,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'list'");
 #else
@@ -3586,15 +3586,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'unicode' and 'dict'");
 #else
@@ -3662,38 +3662,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3837,26 +3837,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'int'");
         goto exit_inplace_exception;
     }
@@ -3920,26 +3920,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'float'");
         goto exit_inplace_exception;
     }
@@ -4044,26 +4044,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'str'");
         goto exit_inplace_exception;
     }
@@ -4120,15 +4120,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'tuple'");
         goto exit_inplace_exception;
     }
@@ -4185,15 +4185,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'list'");
         goto exit_inplace_exception;
     }
@@ -4250,15 +4250,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for %%: 'bytes' and 'dict'");
         goto exit_inplace_exception;
     }
@@ -4324,38 +4324,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4580,15 +4580,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_remainder : NULL;
         binaryfunc slot2 = NULL;
 
@@ -4609,38 +4609,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceMult.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceMult.c`

 * *Files 4% similar despite different names*

```diff
@@ -122,15 +122,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_multiply : NULL;
         binaryfunc slot2 = NULL;
 
@@ -148,26 +148,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -411,38 +411,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -715,15 +715,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_multiply : NULL;
         binaryfunc slot2 = NULL;
 
@@ -741,26 +741,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -963,38 +963,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1234,15 +1234,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_multiply : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1260,26 +1260,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1485,38 +1485,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1714,15 +1714,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -1794,15 +1794,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -1869,15 +1869,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -1947,15 +1947,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -2019,15 +2019,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -2097,15 +2097,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         {
             // No sequence repeat slot sq_repeat available for this type.
             // No inplace sequence repeat slot sq_inplace_repeat available for this type.
@@ -3676,15 +3676,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3821,15 +3821,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -3966,15 +3966,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4111,15 +4111,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4255,15 +4255,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!0 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c2 =
                 (type2->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type2)) ? type2->tp_as_number->nb_coerce : NULL;
 
@@ -4481,15 +4481,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_multiply : NULL;
         binaryfunc slot2 = NULL;
 
@@ -4510,38 +4510,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceOlddiv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceOlddiv.c`

 * *Files 2% similar despite different names*

```diff
@@ -130,15 +130,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -156,26 +156,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -411,38 +411,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -710,15 +710,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -736,26 +736,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -944,38 +944,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1215,15 +1215,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1241,26 +1241,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1464,38 +1464,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1691,15 +1691,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
 #else
@@ -1767,15 +1767,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
 #else
@@ -1837,15 +1837,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1909,15 +1909,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -1975,15 +1975,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2047,15 +2047,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2370,15 +2370,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -2399,38 +2399,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplacePow.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplacePow.c`

 * *Files 1% similar despite different names*

```diff
@@ -206,15 +206,15 @@
         PyObject *x = islot(*operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         ternaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_power : NULL;
         ternaryfunc slot2 = NULL;
 
@@ -232,26 +232,26 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -564,38 +564,38 @@
                     PyObject *x = slot2(*operand1, operand2, Py_None);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -938,15 +938,15 @@
         PyObject *x = islot(*operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         ternaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_power : NULL;
         ternaryfunc slot2 = NULL;
 
@@ -964,26 +964,26 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1170,38 +1170,38 @@
                     PyObject *x = slot2(*operand1, operand2, Py_None);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1498,15 +1498,15 @@
         PyObject *x = islot(*operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         ternaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_power : NULL;
         ternaryfunc slot2 = NULL;
 
@@ -1524,26 +1524,26 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1805,38 +1805,38 @@
                     PyObject *x = slot2(*operand1, operand2, Py_None);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -2089,15 +2089,15 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'float' and 'long'");
 #else
@@ -2163,15 +2163,15 @@
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'long' and 'float'");
 #else
@@ -2232,15 +2232,15 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2304,15 +2304,15 @@
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -2370,15 +2370,15 @@
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2442,15 +2442,15 @@
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for ** or pow(): 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2630,15 +2630,15 @@
         PyObject *x = islot(*operand1, operand2, Py_None);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         ternaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_power : NULL;
         ternaryfunc slot2 = NULL;
 
@@ -2659,38 +2659,38 @@
                     PyObject *x = slot2(*operand1, operand2, Py_None);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2, Py_None);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceRshift.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceRshift.c`

 * *Files 2% similar despite different names*

```diff
@@ -76,15 +76,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_rshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -102,26 +102,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -308,38 +308,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -604,15 +604,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_rshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -630,26 +630,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -879,38 +879,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1132,15 +1132,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1204,15 +1204,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for >>: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -1357,15 +1357,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_rshift : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1386,38 +1386,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceSub.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceSub.c`

 * *Files 2% similar despite different names*

```diff
@@ -111,15 +111,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
         binaryfunc slot2 = NULL;
 
@@ -137,26 +137,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -373,38 +373,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -728,15 +728,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
         binaryfunc slot2 = NULL;
 
@@ -754,26 +754,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1038,38 +1038,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1371,15 +1371,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1397,26 +1397,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1606,38 +1606,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1819,15 +1819,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'long'");
 #else
@@ -1893,15 +1893,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'float'");
 #else
@@ -1962,15 +1962,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2034,15 +2034,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -2100,15 +2100,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2172,15 +2172,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for -: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2564,15 +2564,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_subtract : NULL;
         binaryfunc slot2 = NULL;
 
@@ -2593,38 +2593,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersOperationInplaceTruediv.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersOperationInplaceTruediv.c`

 * *Files 1% similar despite different names*

```diff
@@ -146,15 +146,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -172,26 +172,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -442,38 +442,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyInt_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -754,15 +754,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -780,26 +780,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -986,38 +986,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyLong_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1254,15 +1254,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -1280,26 +1280,26 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !1) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
 
@@ -1501,38 +1501,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!1 || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 = PyFloat_Type.tp_as_number->nb_coerce;
 
             if (c1 != NULL) {
@@ -1726,15 +1726,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'long'");
 #else
@@ -1800,15 +1800,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
 #if PYTHON_VERSION < 0x300
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'float'");
 #else
@@ -1869,15 +1869,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'float' and 'int'");
         goto exit_inplace_exception;
     }
@@ -1941,15 +1941,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'float'");
         goto exit_inplace_exception;
     }
@@ -2007,15 +2007,15 @@
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'long' and 'int'");
         goto exit_inplace_exception;
     }
@@ -2079,15 +2079,15 @@
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         // Statically recognized that coercion is not possible with these types
 
         PyErr_Format(PyExc_TypeError, "unsupported operand type(s) for /: 'int' and 'long'");
         goto exit_inplace_exception;
     }
@@ -2430,15 +2430,15 @@
         PyObject *x = islot(*operand1, operand2);
 
         if (x != Py_NotImplemented) {
             obj_result = x;
             goto exit_inplace_result_object;
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 
     {
         binaryfunc slot1 =
             (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_true_divide : NULL;
         binaryfunc slot2 = NULL;
 
@@ -2459,38 +2459,38 @@
                     PyObject *x = slot2(*operand1, operand2);
 
                     if (x != Py_NotImplemented) {
                         obj_result = x;
                         goto exit_inplace_result_object;
                     }
 
-                    Py_DECREF(x);
+                    Py_DECREF_IMMORTAL(x);
                     slot2 = NULL;
                 }
             }
 
             PyObject *x = slot1(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
         if (slot2 != NULL) {
             PyObject *x = slot2(*operand1, operand2);
 
             if (x != Py_NotImplemented) {
                 obj_result = x;
                 goto exit_inplace_result_object;
             }
 
-            Py_DECREF(x);
+            Py_DECREF_IMMORTAL(x);
         }
 
 #if PYTHON_VERSION < 0x300
         if (!NEW_STYLE_NUMBER_TYPE(type1) || !NEW_STYLE_NUMBER_TYPE(type2)) {
             coercion c1 =
                 (type1->tp_as_number != NULL && NEW_STYLE_NUMBER_TYPE(type1)) ? type1->tp_as_number->nb_coerce : NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersProfiling.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersProfiling.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersPythonPgo.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersPythonPgo.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersRaising.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersRaising.c`

 * *Files 1% similar despite different names*

```diff
@@ -110,15 +110,15 @@
                                 PyTracebackObject **exception_tb, PyObject *exception_cause) {
     CHECK_OBJECT(*exception_type);
     CHECK_OBJECT(exception_cause);
     *exception_tb = NULL;
 
     // None is not a cause.
     if (exception_cause == Py_None) {
-        Py_DECREF(exception_cause);
+        Py_DECREF_IMMORTAL(exception_cause);
         exception_cause = NULL;
     } else if (PyExceptionClass_Check(exception_cause)) {
         PyObject *old_exception_cause = exception_cause;
         exception_cause = PyObject_CallObject(exception_cause, NULL);
         Py_DECREF(old_exception_cause);
 
         if (unlikely(exception_cause == NULL)) {
@@ -309,15 +309,15 @@
 
 void RAISE_EXCEPTION_WITH_TRACEBACK(PyThreadState *tstate, PyObject **exception_type, PyObject **exception_value,
                                     PyTracebackObject **exception_tb) {
     CHECK_OBJECT(*exception_type);
     CHECK_OBJECT(*exception_value);
 
     if (*exception_tb == (PyTracebackObject *)Py_None) {
-        Py_DECREF(*exception_tb);
+        Py_DECREF_IMMORTAL(*exception_tb);
         *exception_tb = NULL;
     }
 
     // Non-empty tuple exceptions are the first element.
     while (unlikely(PyTuple_Check(*exception_type) && PyTuple_GET_SIZE(*exception_type) > 0)) {
         *exception_type = PyTuple_GET_ITEM(*exception_type, 0);
     }
@@ -427,16 +427,20 @@
 
     return true;
 }
 
 // Raise NameError for a given variable name.
 void RAISE_CURRENT_EXCEPTION_NAME_ERROR(PyThreadState *tstate, PyObject *variable_name, PyObject **exception_type,
                                         PyObject **exception_value) {
+#if PYTHON_VERSION < 0x300
     PyObject *exception_value_str =
         Nuitka_String_FromFormat("name '%s' is not defined", Nuitka_String_AsString_Unchecked(variable_name));
+#else
+    PyObject *exception_value_str = Nuitka_String_FromFormat("name '%U' is not defined", variable_name);
+#endif
 
     *exception_value = MAKE_EXCEPTION_FROM_TYPE_ARG0(tstate, PyExc_NameError, exception_value_str);
     Py_DECREF(exception_value_str);
 
     *exception_type = PyExc_NameError;
     Py_INCREF(PyExc_NameError);
 
@@ -444,17 +448,20 @@
     CHAIN_EXCEPTION(tstate, *exception_value);
 #endif
 }
 
 #if PYTHON_VERSION < 0x340
 void RAISE_CURRENT_EXCEPTION_GLOBAL_NAME_ERROR(PyThreadState *tstate, PyObject *variable_name,
                                                PyObject **exception_type, PyObject **exception_value) {
+#if PYTHON_VERSION < 0x300
     PyObject *exception_value_str =
         Nuitka_String_FromFormat("global name '%s' is not defined", Nuitka_String_AsString_Unchecked(variable_name));
-
+#else
+    PyObject *exception_value_str = Nuitka_String_FromFormat("global name '%U' is not defined", variable_name);
+#endif
     *exception_value = MAKE_EXCEPTION_FROM_TYPE_ARG0(tstate, PyExc_NameError, exception_value_str);
     Py_DECREF(exception_value_str);
 
     *exception_type = PyExc_NameError;
     Py_INCREF(PyExc_NameError);
 }
 #endif
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSafeStrings.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSafeStrings.c`

 * *Files 4% similar despite different names*

```diff
@@ -77,28 +77,38 @@
         *target++ = *source++;
         buffer_size -= 1;
     }
 
     *target = 0;
 }
 
-void appendCharSafeW(wchar_t *target, char c, size_t buffer_size) {
+void appendWCharSafeW(wchar_t *target, wchar_t c, size_t buffer_size) {
     while (*target != 0) {
         target++;
         buffer_size -= 1;
     }
 
     if (buffer_size < 1) {
         abort();
     }
 
-    target += wcslen(target);
+    *target++ = c;
+    *target = 0;
+}
+
+void appendCharSafeW(wchar_t *target, char c, size_t buffer_size) {
     char buffer_c[2] = {c, 0};
-    NUITKA_MAY_BE_UNUSED size_t res = mbstowcs(target, buffer_c, 2);
-    assert(res == 1);
+    wchar_t wide_buffer_c[2];
+
+    size_t res = mbstowcs(wide_buffer_c, buffer_c, 2);
+    if (res != 1) {
+        abort();
+    }
+
+    appendWCharSafeW(target, wide_buffer_c[0], buffer_size);
 }
 
 void appendStringSafeW(wchar_t *target, char const *source, size_t buffer_size) {
     while (*target != 0) {
         target++;
         buffer_size -= 1;
     }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSequences.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSequences.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersSlices.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersSlices.c`

 * *Files 12% similar despite different names*

```diff
@@ -5,22 +5,29 @@
 // This file is included from another C file, help IDEs to still parse it on
 // its own.
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
 #if PYTHON_VERSION >= 0x3a0
-PyObject *Nuitka_Slice_New(PyObject *start, PyObject *stop, PyObject *step) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
 
+PyObject *Nuitka_Slice_New(PyThreadState *tstate, PyObject *start, PyObject *stop, PyObject *step) {
     PySliceObject *result_slice;
 
-    if (interp->slice_cache != NULL) {
-        result_slice = interp->slice_cache;
-        interp->slice_cache = NULL;
+#if PYTHON_VERSION >= 0x3d0
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    PySliceObject **slice_cache_ptr = &freelists->slices.slice_cache;
+#else
+    PyInterpreterState *interp = tstate->interp;
+    PySliceObject **slice_cache_ptr = &interp->slice_cache;
+#endif
+
+    if (*slice_cache_ptr != NULL) {
+        result_slice = *slice_cache_ptr;
+        *slice_cache_ptr = NULL;
 
         Nuitka_Py_NewReference((PyObject *)result_slice);
     } else {
         result_slice = (PySliceObject *)Nuitka_GC_New(&PySlice_Type);
 
         if (result_slice == NULL) {
             return NULL;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersStrings.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersStrings.c`

 * *Files 0% similar despite different names*

```diff
@@ -257,15 +257,15 @@
     _PyUnicode_STATE(unicode).ready = 0;
     _PyUnicode_STATE(unicode).ascii = 0;
     _PyUnicode_DATA_ANY(unicode) = NULL;
     _PyUnicode_LENGTH(unicode) = 0;
     _PyUnicode_UTF8(unicode) = NULL;
     _PyUnicode_UTF8_LENGTH(unicode) = 0;
 
-    _PyUnicode_WSTR(unicode) = (Py_UNICODE *)PyObject_MALLOC(new_size);
+    _PyUnicode_WSTR(unicode) = (Py_UNICODE *)NuitkaObject_Malloc(new_size);
     if (!_PyUnicode_WSTR(unicode)) {
         Py_DECREF(unicode);
         PyErr_NoMemory();
         return NULL;
     }
 
     _PyUnicode_WSTR(unicode)[0] = 0;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersTuples.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersTuples.c`

 * *Files 12% similar despite different names*

```diff
@@ -7,36 +7,41 @@
 // This file is included from another C file, help IDEs to still parse it on
 // its own.
 #ifdef __IDE_ONLY__
 #include "nuitka/prelude.h"
 #endif
 
 #if NUITKA_TUPLE_HAS_FREELIST
-static struct _Py_tuple_state *_Nuitka_Py_get_tuple_state(void) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
-    return &interp->tuple;
-}
 
-PyObject *MAKE_TUPLE_EMPTY(Py_ssize_t size) {
+PyObject *MAKE_TUPLE_EMPTY(PyThreadState *tstate, Py_ssize_t size) {
     PyTupleObject *result_tuple;
 
     // Lets not get called other than this
     assert(size > 0);
 
-    struct _Py_tuple_state *state = _Nuitka_Py_get_tuple_state();
+    // This is the CPython name, spell-checker: ignore numfree
+#if PYTHON_VERSION < 0x3d0
+    PyTupleObject **items = tstate->interp->tuple.free_list;
+    int *numfree = tstate->interp->tuple.numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_tuple_freelist *state = &freelists->tuples;
+    PyTupleObject **items = state->items;
+    int(*numfree) = state->numfree;
+#endif
 
 #if PYTHON_VERSION < 0x3b0
     Py_ssize_t index = size;
 #else
     Py_ssize_t index = size - 1;
 #endif
 
-    if ((size < PyTuple_MAXSAVESIZE) && (result_tuple = state->free_list[index]) != NULL) {
-        state->free_list[index] = (PyTupleObject *)result_tuple->ob_item[0];
-        state->numfree[index] -= 1;
+    if ((size < PyTuple_MAXSAVESIZE) && (result_tuple = items[index]) != NULL) {
+        items[index] = (PyTupleObject *)result_tuple->ob_item[0];
+        numfree[index] -= 1;
 
         assert(Py_SIZE(result_tuple) == size);
         assert(Py_TYPE(result_tuple) == &PyTuple_Type);
 
         Nuitka_Py_NewReference((PyObject *)result_tuple);
     } else {
         // Check for overflow
@@ -61,31 +66,31 @@
 
     assert(PyTuple_CheckExact(result_tuple));
     assert(PyTuple_GET_SIZE(result_tuple) == size);
 
     return (PyObject *)result_tuple;
 }
 
-PyObject *MAKE_TUPLE_EMPTY_VAR(Py_ssize_t size) {
+PyObject *MAKE_TUPLE_EMPTY_VAR(PyThreadState *tstate, Py_ssize_t size) {
     if (size == 0) {
         PyObject *result = const_tuple_empty;
         Py_INCREF(result);
         return result;
     } else {
-        return MAKE_TUPLE_EMPTY(size);
+        return MAKE_TUPLE_EMPTY(tstate, size);
     }
 }
 
 #endif
 
-PyObject *TUPLE_CONCAT(PyObject *tuple1, PyObject *tuple2) {
+PyObject *TUPLE_CONCAT(PyThreadState *tstate, PyObject *tuple1, PyObject *tuple2) {
     Py_ssize_t size = Py_SIZE(tuple1) + Py_SIZE(tuple2);
 
     // Do not ignore MemoryError, may actually happen.
-    PyTupleObject *result = (PyTupleObject *)MAKE_TUPLE_EMPTY_VAR(size);
+    PyTupleObject *result = (PyTupleObject *)MAKE_TUPLE_EMPTY_VAR(tstate, size);
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     PyObject **src = ((PyTupleObject *)tuple1)->ob_item;
     PyObject **dest = result->ob_item;
 
@@ -103,20 +108,20 @@
         Py_INCREF(v);
         dest[i] = v;
     }
 
     return (PyObject *)result;
 }
 
-PyObject *TUPLE_COPY(PyObject *tuple) {
+PyObject *TUPLE_COPY(PyThreadState *tstate, PyObject *tuple) {
     CHECK_OBJECT(tuple);
     assert(PyTuple_CheckExact(tuple));
 
     Py_ssize_t size = PyTuple_GET_SIZE(tuple);
-    PyObject *result = MAKE_TUPLE_EMPTY(size);
+    PyObject *result = MAKE_TUPLE_EMPTY(tstate, size);
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
     for (Py_ssize_t i = 0; i < size; i++) {
         PyObject *item = PyTuple_GET_ITEM(tuple, i);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/HelpersTypes.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/HelpersTypes.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/InspectPatcher.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/InspectPatcher.c`

 * *Files 6% similar despite different names*

```diff
@@ -25,14 +25,16 @@
 static PyObject *_inspect_getgeneratorstate_replacement(PyObject *self, PyObject *args, PyObject *kwds) {
     PyObject *object;
 
     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:getgeneratorstate", kw_list_object, &object, NULL)) {
         return NULL;
     }
 
+    CHECK_OBJECT(object);
+
     if (Nuitka_Generator_Check(object)) {
         struct Nuitka_GeneratorObject *generator = (struct Nuitka_GeneratorObject *)object;
 
         if (generator->m_running) {
             return PyObject_GetAttrString(module_inspect, "GEN_RUNNING");
         } else if (generator->m_status == status_Finished) {
             return PyObject_GetAttrString(module_inspect, "GEN_CLOSED");
@@ -108,14 +110,72 @@
     "getcoroutinestate", (PyCFunction)_inspect_getcoroutinestate_replacement, METH_VARARGS | METH_KEYWORDS, NULL};
 
 static PyMethodDef _method_def_types_coroutine_replacement = {"coroutine", (PyCFunction)_types_coroutine_replacement,
                                                               METH_VARARGS | METH_KEYWORDS, NULL};
 
 #endif
 
+#if PYTHON_VERSION >= 0x3c0
+
+static char *kw_list_depth[] = {(char *)"depth", NULL};
+
+static bool Nuitka_FrameIsCompiled(_PyInterpreterFrame *frame) {
+    return ((frame->frame_obj != NULL) && Nuitka_Frame_Check((PyObject *)frame->frame_obj));
+}
+
+static bool Nuitka_FrameIsIncomplete(_PyInterpreterFrame *frame) {
+    bool r = _PyFrame_IsIncomplete(frame);
+
+    return r;
+}
+
+static PyObject *orig_sys_getframemodulename = NULL;
+
+static PyObject *_sys_getframemodulename_replacement(PyObject *self, PyObject *args, PyObject *kwds) {
+    PyObject *depth_arg = NULL;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:_getframemodulename", kw_list_depth, &depth_arg)) {
+        return NULL;
+    }
+
+    PyObject *index_value = Nuitka_Number_IndexAsLong(depth_arg ? depth_arg : const_int_0);
+
+    if (unlikely(index_value == NULL)) {
+        return NULL;
+    }
+
+    Py_ssize_t depth_ssize = PyLong_AsSsize_t(index_value);
+
+    Py_DECREF(index_value);
+
+    PyThreadState *tstate = _PyThreadState_GET();
+
+    _PyInterpreterFrame *frame = CURRENT_TSTATE_INTERPRETER_FRAME(tstate);
+    while ((frame != NULL) && ((Nuitka_FrameIsIncomplete(frame)) || depth_ssize-- > 0)) {
+        frame = frame->previous;
+    }
+
+    if ((frame != NULL) && (Nuitka_FrameIsCompiled(frame))) {
+        PyObject *frame_globals = PyObject_GetAttrString((PyObject *)frame->frame_obj, "f_globals");
+
+        PyObject *result = LOOKUP_ATTRIBUTE(tstate, frame_globals, const_str_plain___name__);
+        Py_DECREF(frame_globals);
+
+        return result;
+    }
+
+    return CALL_FUNCTION_WITH_SINGLE_ARG(tstate, orig_sys_getframemodulename, depth_arg);
+}
+
+// spell-checker: ignore getframemodulename
+static PyMethodDef _method_def_sys_getframemodulename_replacement = {
+    "getcoroutinestate", (PyCFunction)_sys_getframemodulename_replacement, METH_VARARGS | METH_KEYWORDS, NULL};
+
+#endif
+
 /* Replace inspect functions with ones that handle compiles types too. */
 void patchInspectModule(PyThreadState *tstate) {
     static bool is_done = false;
     if (is_done) {
         return;
     }
 
@@ -145,21 +205,19 @@
     }
     CHECK_OBJECT(module_inspect);
 
     // Patch "inspect.getgeneratorstate" unless it is already patched.
     old_getgeneratorstate = PyObject_GetAttrString(module_inspect, "getgeneratorstate");
     CHECK_OBJECT(old_getgeneratorstate);
 
-    if (PyFunction_Check(old_getgeneratorstate)) {
-        PyObject *inspect_getgeneratorstate_replacement =
-            PyCFunction_New(&_method_def_inspect_getgeneratorstate_replacement, NULL);
-        CHECK_OBJECT(inspect_getgeneratorstate_replacement);
+    PyObject *inspect_getgeneratorstate_replacement =
+        PyCFunction_New(&_method_def_inspect_getgeneratorstate_replacement, NULL);
+    CHECK_OBJECT(inspect_getgeneratorstate_replacement);
 
-        PyObject_SetAttrString(module_inspect, "getgeneratorstate", inspect_getgeneratorstate_replacement);
-    }
+    PyObject_SetAttrString(module_inspect, "getgeneratorstate", inspect_getgeneratorstate_replacement);
 
 #if PYTHON_VERSION >= 0x350
     // Patch "inspect.getcoroutinestate" unless it is already patched.
     old_getcoroutinestate = PyObject_GetAttrString(module_inspect, "getcoroutinestate");
     CHECK_OBJECT(old_getcoroutinestate);
 
     if (PyFunction_Check(old_getcoroutinestate)) {
@@ -215,14 +273,24 @@
         assert(bool_res != false);
     }
 
 #endif
 
 #endif
 
+#if PYTHON_VERSION >= 0x3c0
+    orig_sys_getframemodulename = Nuitka_SysGetObject("_getframemodulename");
+
+    PyObject *sys_getframemodulename_replacement =
+        PyCFunction_New(&_method_def_sys_getframemodulename_replacement, NULL);
+    CHECK_OBJECT(sys_getframemodulename_replacement);
+
+    Nuitka_SysSetObject("_getframemodulename", sys_getframemodulename_replacement);
+#endif
+
     is_done = true;
 }
 #endif
 
 static richcmpfunc original_PyType_tp_richcompare = NULL;
 
 static PyObject *Nuitka_type_tp_richcompare(PyObject *a, PyObject *b, int op) {
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/MainProgram.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/MainProgram.c`

 * *Files 3% similar despite different names*

```diff
@@ -30,28 +30,33 @@
 #define SYSFLAG_NO_SITE 0
 #define SYSFLAG_VERBOSE 0
 #define SYSFLAG_BYTES_WARNING 0
 #define SYSFLAG_UTF8 0
 #define SYSFLAG_UNBUFFERED 0
 #define NUITKA_MAIN_MODULE_NAME "__main__"
 #define NUITKA_MAIN_IS_PACKAGE_BOOL false
+#define _NUITKA_ATTACH_CONSOLE_WINDOW 1
 #endif
 
 // It doesn't work for MinGW64 to update the standard output handles early on,
 // so make a difference here.
 #if defined(NUITKA_FORCED_STDOUT_PATH) || defined(NUITKA_FORCED_STDERR_PATH)
 #if defined(__MINGW64__) || defined(__MINGW32__)
 #define NUITKA_STANDARD_HANDLES_EARLY 0
 #else
 #define NUITKA_STANDARD_HANDLES_EARLY 1
 #endif
 #else
 #define NUITKA_STANDARD_HANDLES_EARLY 0
 #endif
 
+#if defined(_WIN32) && defined(_NUITKA_ATTACH_CONSOLE_WINDOW)
+#include "HelpersConsole.c"
+#endif
+
 extern PyCodeObject *codeobj_main;
 
 /* For later use in "Py_GetArgcArgv" we expose the needed value  */
 #if PYTHON_VERSION >= 0x300
 static wchar_t **orig_argv;
 #else
 static char **orig_argv;
@@ -324,28 +329,31 @@
             }
         }
     }
 
     return IMPORT_EMBEDDED_MODULE(tstate, module_name);
 }
 
-#ifdef _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
+#if _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
 #include "nuitka_windows_service.h"
 
 // Callback from Windows Service logic.
-bool SvcStartPython(void) {
+void SvcStartPython(void) {
     PyThreadState *tstate = PyThreadState_GET();
 
     EXECUTE_MAIN_MODULE(tstate, NUITKA_MAIN_MODULE_NAME, NUITKA_MAIN_IS_PACKAGE_BOOL);
 
-    if (HAS_ERROR_OCCURRED(tstate)) {
-        return true;
-    } else {
-        return false;
-    }
+    NUITKA_PRINT_TIMING("SvcStartPython() Python exited.")
+
+    int exit_code = HANDLE_PROGRAM_EXIT(tstate);
+
+    // TODO: Log exception and call ReportSvcStatus
+
+    NUITKA_PRINT_TIMING("SvcStartPython(): Calling Py_Exit.");
+    Py_Exit(exit_code);
 }
 
 void SvcStopPython(void) { PyErr_SetInterrupt(); }
 
 #endif
 
 // This is a multiprocessing fork
@@ -405,20 +413,20 @@
 #else
             multiprocessing_resource_tracker_arg = _wtoi(argv[i + 1]);
 #endif
             break;
         }
 
         if (i == 1) {
-#ifdef _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
+#if _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
             if (strcmpFilename(argv[i], FILENAME_EMPTY_STR "install") == 0) {
                 NUITKA_PRINT_TRACE("main(): Calling plugin SvcInstall().");
 
                 SvcInstall();
-                NUITKA_CANNOT_GET_HERE("SvcInstall must not return");
+                NUITKA_CANNOT_GET_HERE("main(): SvcInstall must not return");
             }
 #endif
         }
 
         if ((i + 1 < argc) && (strcmpFilename(argv[i], FILENAME_EMPTY_STR "-c") == 0)) {
             // The joblib loky resource tracker is launched like this.
             if (scanFilename(argv[i + 1],
@@ -797,15 +805,15 @@
     PyObject *encoding = NULL;
 
 // Reconfigure stdout for line buffering, for mixing traces and Python IO
 // better, and force it to utf-8, it often becomes platform IO for no good
 // reason.
 #if NUITKA_STANDARD_HANDLES_EARLY == 1 && PYTHON_VERSION >= 0x370
 #if defined(NUITKA_FORCED_STDOUT_PATH) || defined(NUITKA_FORCED_STDERR_PATH)
-    PyObject *args = MAKE_DICT_EMPTY();
+    PyObject *args = MAKE_DICT_EMPTY(tstate);
 
     DICT_SET_ITEM(args, const_str_plain_encoding, Nuitka_String_FromString("utf-8"));
     DICT_SET_ITEM(args, const_str_plain_line_buffering, Py_True);
 
 #if defined(NUITKA_FORCED_STDOUT_PATH)
     {
         PyObject *sys_stdout = Nuitka_SysGetObject("stdout");
@@ -833,15 +841,15 @@
     Py_DECREF(args);
 #endif
 #endif
 
 #if NUITKA_STANDARD_HANDLES_EARLY == 0
 #if defined(NUITKA_FORCED_STDOUT_PATH)
     {
-#ifdef _WIN32
+#if defined(_WIN32)
         PyObject *filename = getExpandedTemplatePath(L"" NUITKA_FORCED_STDOUT_PATH);
 #else
         PyObject *filename = getExpandedTemplatePath(NUITKA_FORCED_STDOUT_PATH);
 #endif
         PyObject *stdout_file = BUILTIN_OPEN_SIMPLE(tstate, filename, "w", SYSFLAG_UNBUFFERED != 1, encoding);
         if (unlikely(stdout_file == NULL)) {
             PyErr_PrintEx(1);
@@ -908,23 +916,31 @@
     setStderrHandle(tstate, Py_None);
 #endif
 
     Py_XDECREF(encoding);
 }
 
 static void Nuitka_Py_Initialize(void) {
+#if PYTHON_VERSION > 0x350 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_ALLOCATORS)
+    initNuitkaAllocators();
+#endif
+
 #if PYTHON_VERSION < 0x380 || defined(_NUITKA_EXPERIMENTAL_OLD_PY_INITIALIZE)
     Py_Initialize();
 #else
+#if PYTHON_VERSION < 0x3d0
     PyStatus status = _PyRuntime_Initialize();
     if (unlikely(status._type != 0)) {
         Py_ExitStatusException(status);
     }
     NUITKA_MAY_BE_UNUSED _PyRuntimeState *runtime = &_PyRuntime;
     assert(!runtime->initialized);
+#else
+    PyStatus status;
+#endif
 
     PyConfig config;
     _PyConfig_InitCompatConfig(&config);
 
     assert(orig_argv[0]);
     status = PyConfig_SetArgv(&config, orig_argc, orig_argv);
 
@@ -994,31 +1010,21 @@
 
 #if NUITKA_STANDARD_HANDLES_EARLY == 1
 #if defined(_WIN32)
 
 static void changeStandardHandleTarget(int std_handle_id, FILE *std_handle, filename_char_t const *template_path) {
     filename_char_t filename_buffer[1024];
 
-    // TODO: We should only have one that works with filename_char_t rather than having
-    // to make a difference here.
-#ifdef _WIN32
-    bool res = expandTemplatePathW(filename_buffer, template_path, sizeof(filename_buffer) / sizeof(filename_char_t));
+    bool res =
+        expandTemplatePathFilename(filename_buffer, template_path, sizeof(filename_buffer) / sizeof(filename_char_t));
 
     if (res == false) {
-        wprintf(L"Error, couldn't expand pattern '%lS'\n", template_path);
+        printf("Error, couldn't expand pattern '" FILENAME_FORMAT_STR "'\n", template_path);
         abort();
     }
-#else
-    bool res = expandTemplatePath(filename_buffer, template_path, sizeof(filename_buffer) / sizeof(filename_char_t));
-
-    if (res == false) {
-        printf("Error, couldn't expand pattern: '%s'\n", template_path);
-        abort();
-    }
-#endif
 
     if (GetStdHandle(std_handle_id) == 0) {
         FILE *file_handle;
 
         if (std_handle_id == STD_INPUT_HANDLE) {
             file_handle = _wfreopen(filename_buffer, L"rb", std_handle);
         } else {
@@ -1125,15 +1131,21 @@
     DUMP_C_BACKTRACE();
 #endif
     // Trace when the process exits.
 #if defined(_NUITKA_EXPERIMENTAL_SHOW_STARTUP_TIME)
     atexit(Nuitka_at_exit);
 #endif
 
-    // First things, set up stdout/stderr according to user specification.
+    // Attach to the parent console respecting redirection only, otherwise we
+    // cannot even output traces.
+#if defined(_WIN32) && defined(_NUITKA_ATTACH_CONSOLE_WINDOW)
+    inheritAttachedConsole();
+#endif
+
+    // Set up stdout/stderr according to user specification.
 #if NUITKA_STANDARD_HANDLES_EARLY == 1
 #if defined(NUITKA_FORCED_STDOUT_PATH)
 #ifdef _WIN32
     changeStandardHandleTarget(STD_OUTPUT_HANDLE, stdout, L"" NUITKA_FORCED_STDOUT_PATH);
 #else
     changeStandardHandleTarget(stdout, NUITKA_FORCED_STDOUT_PATH);
 #endif
@@ -1412,14 +1424,65 @@
     char const *ticker_value = getenv("NUITKA_TICKER");
     if (ticker_value != NULL) {
         _Py_Ticker = atoi(ticker_value);
         assert(_Py_Ticker >= 20);
     }
 #endif
 
+#if defined(_WIN32) && defined(_NUITKA_ATTACH_CONSOLE_WINDOW)
+    if (needs_stdout_attaching) {
+        PyObject *filename = Nuitka_String_FromString("CONOUT$");
+        // This defaults to "utf-8" internally. We may add an argument of use
+        // platform ones in the future.
+        PyObject *encoding = NULL;
+
+        PyObject *stdout_file = BUILTIN_OPEN_SIMPLE(tstate, filename, "w", SYSFLAG_UNBUFFERED != 1, encoding);
+        if (unlikely(stdout_file == NULL)) {
+            PyErr_PrintEx(1);
+            Py_Exit(1);
+        }
+
+        Py_DECREF(filename);
+
+        Nuitka_SysSetObject("stdout", stdout_file);
+    }
+
+    if (needs_stderr_attaching) {
+        PyObject *filename = Nuitka_String_FromString("CONOUT$");
+        // This defaults to "utf-8" internally. We may add an argument of use
+        // platform ones in the future.
+        PyObject *encoding = NULL;
+
+        PyObject *stderr_file = BUILTIN_OPEN_SIMPLE(tstate, filename, "w", SYSFLAG_UNBUFFERED != 1, encoding);
+        if (unlikely(stderr_file == NULL)) {
+            PyErr_PrintEx(1);
+            Py_Exit(1);
+        }
+
+        Py_DECREF(filename);
+
+        Nuitka_SysSetObject("stderr", stderr_file);
+    }
+
+    if (needs_stdin_attaching) {
+        PyObject *filename = Nuitka_String_FromString("CONIN$");
+        // This defaults to "utf-8" internally. We may add an argument of use
+        // platform ones in the future.
+        PyObject *encoding = NULL;
+
+        // CPython core requires stdin to be buffered due to methods usage, and it won't matter
+        // here much.
+        PyObject *stdin_file = BUILTIN_OPEN_SIMPLE(tstate, filename, "r", true, encoding);
+
+        Py_DECREF(filename);
+
+        Nuitka_SysSetObject("stdin", stdin_file);
+    }
+#endif
+
     NUITKA_PRINT_TRACE("main(): Setting Python input/output handles.");
     setInputOutputHandles(tstate);
 
 #ifdef _NUITKA_STANDALONE
 
 #if PYTHON_VERSION >= 0x300
     // Make sure the importlib fully bootstraps as we couldn't load it with the
@@ -1440,16 +1503,18 @@
     PyImport_FrozenModules = old_frozen;
 #endif
 
     NUITKA_PRINT_TRACE("main(): Calling setupMetaPathBasedLoader().");
     /* Enable meta path based loader. */
     setupMetaPathBasedLoader(tstate);
 
+#if PYTHON_VERSION < 0x3d0
     /* Initialize warnings module. */
     _PyWarnings_Init();
+#endif
 
 #if NO_PYTHON_WARNINGS && PYTHON_VERSION >= 0x342 && PYTHON_VERSION < 0x3a0 && defined(_NUITKA_FULL_COMPAT)
     // For full compatibility bump the warnings registry version,
     // otherwise modules "__warningregistry__" will mismatch.
     PyObject *warnings_module = PyImport_ImportModule("warnings");
     PyObject *meth = PyObject_GetAttrString(warnings_module, "_filters_mutated");
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoader.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoader.c`

 * *Files 2% similar despite different names*

```diff
@@ -18,14 +18,17 @@
 #endif
 
 #include "nuitka/unfreezing.h"
 
 #ifdef _WIN32
 #undef SEP
 #define SEP '\\'
+#define SEP_L L'\\'
+#else
+#define SEP_L SEP
 #endif
 
 #ifdef _WIN32
 #include <windows.h>
 #endif
 
 extern PyTypeObject Nuitka_Loader_Type;
@@ -62,14 +65,15 @@
     return true;
 }
 
 static char *appendModuleNameAsPath(char *buffer, char const *module_name, size_t buffer_size) {
     // Skip to the end
     while (*buffer != 0) {
         buffer++;
+        buffer_size -= 1;
     }
 
     while (*module_name) {
         if (buffer_size < 1) {
             abort();
         }
 
@@ -86,28 +90,25 @@
     *buffer = 0;
 
     return buffer;
 }
 
 #if defined(_WIN32) && defined(_NUITKA_STANDALONE)
 
-static void appendModuleNameAsPathW(wchar_t *buffer, char const *module_name, size_t buffer_size) {
-    // Skip to the end
-    while (*buffer != 0) {
-        buffer++;
-    }
+static void appendModuleNameAsPathW(wchar_t *buffer, PyObject *module_name, size_t buffer_size) {
+    wchar_t const *module_name_wstr = PyUnicode_AsWideCharString(module_name, NULL);
 
-    while (*module_name) {
-        char c = *module_name++;
+    while (*module_name_wstr != 0) {
+        wchar_t c = *module_name_wstr++;
 
-        if (c == '.') {
-            c = SEP;
+        if (c == L'.') {
+            c = SEP_L;
         }
 
-        appendCharSafeW(buffer, c, buffer_size);
+        appendWCharSafeW(buffer, c, buffer_size);
     }
 }
 #endif
 
 // TODO: This updates the wrong absolute path. We ought to change it to
 // the "module_path_name" at the time of writing it, then we save a few
 // bytes in the blob, and don't have to create that string here.
@@ -195,15 +196,17 @@
     PyObject *module_path_name = Nuitka_String_FromString(buffer);
 
     PyObject *module_path = MAKE_RELATIVE_PATH(module_path_name);
     Py_DECREF(module_path_name);
 
     if (is_package) {
         /* Set __path__ properly, unlike frozen module importer does. */
-        PyObject *path_list = MAKE_LIST_EMPTY(1);
+        NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+
+        PyObject *path_list = MAKE_LIST_EMPTY(tstate, 1);
         if (unlikely(path_list == NULL)) {
             return NULL;
         }
 
         int res = PyList_SetItem(path_list, 0, module_path_entry);
         if (unlikely(res != 0)) {
             return NULL;
@@ -309,15 +312,15 @@
 }
 
 #if PYTHON_VERSION < 0x300
 static PyObject *_getImportingSuffixesByPriority(PyThreadState *tstate, int kind) {
     static PyObject *result = NULL;
 
     if (result == NULL) {
-        result = MAKE_LIST_EMPTY(0);
+        result = MAKE_LIST_EMPTY(tstate, 0);
 
         PyObject *imp_module = PyImport_ImportModule("imp");
         PyObject *get_suffixes_func = PyObject_GetAttrString(imp_module, "get_suffixes");
 
         PyObject *suffix_list = CALL_FUNCTION_NO_ARGS(tstate, get_suffixes_func);
 
         for (int i = 0; i < PyList_GET_SIZE(suffix_list); i++) {
@@ -367,15 +370,15 @@
     PyObject *parent_path = PyObject_GetAttr(parent_module, const_str_plain___path__);
 
     // Accept that it might be deleted.
     if (parent_path == NULL || !PyList_Check(parent_path)) {
         return false;
     }
 
-    PyObject *candidates = MAKE_LIST_EMPTY(0);
+    PyObject *candidates = MAKE_LIST_EMPTY(tstate, 0);
 
     // Search only relative to the parent name of course.
     char const *module_relative_name_str = Nuitka_String_AsString(module_name) + strlen(parent_module_name) + 1;
 
     Py_ssize_t parent_path_size = PyList_GET_SIZE(parent_path);
 
     for (Py_ssize_t i = 0; i < parent_path_size; i += 1) {
@@ -430,15 +433,15 @@
 
             char const *candidate_str = Nuitka_String_AsString(candidate);
 
             if (strcmp(suffix_str, candidate_str + strlen(module_relative_name_str)) == 0) {
                 PyObject *fullpath = JOIN_PATH2(directory, candidate);
 
                 if (installed_extension_modules == NULL) {
-                    installed_extension_modules = MAKE_DICT_EMPTY();
+                    installed_extension_modules = MAKE_DICT_EMPTY(tstate);
                 }
 
 // Force path to unicode, to have easier consumption, as we need a wchar_t or char *
 // from it later, and we don't want to test there.
 #if PYTHON_VERSION < 0x300 && defined(_WIN32)
                 PyObject *tmp = PyUnicode_FromObject(fullpath);
                 Py_DECREF(fullpath);
@@ -454,19 +457,15 @@
     }
 
     Py_DECREF(candidates);
 
     return result;
 }
 
-#ifdef _WIN32
-static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name, const wchar_t *filename);
-#else
-static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name, const char *filename);
-#endif
+static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name, const filename_char_t *filename);
 
 static PyObject *callIntoInstalledExtensionModule(PyThreadState *tstate, PyObject *module_name,
                                                   PyObject *extension_module_filename) {
 #if _WIN32
     // We can rely on unicode object to be there in case of Windows, to have an easier time to
     // create the string needed.
     assert(PyUnicode_CheckExact(extension_module_filename));
@@ -557,15 +556,15 @@
     }
 #endif
 
     if (isVerbose()) {
         PySys_WriteStderr("import %s # denied responsibility\n", name);
     }
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
     return Py_None;
 }
 
 static char const *_kw_list_get_data[] = {"filename", NULL};
 
 static PyObject *_nuitka_loader_get_data(PyObject *self, PyObject *args, PyObject *kwds) {
     PyObject *filename;
@@ -634,19 +633,54 @@
 #include <dlfcn.h>
 #endif
 
 #if PYTHON_VERSION >= 0x350
 static PyObject *createModuleSpec(PyThreadState *tstate, PyObject *module_name, PyObject *origin, bool is_package);
 #endif
 
-#ifdef _WIN32
-static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name, const wchar_t *filename) {
+static void _fillExtensionModuleDllEntryFunctionName(PyThreadState *tstate, char *buffer, size_t buffer_size,
+                                                     char const *name) {
+
+#if PYTHON_VERSION >= 0x350
+    PyObject *name_bytes_obj = PyBytes_FromString(name);
+    PyObject *name_obj = BYTES_DECODE2(tstate, name_bytes_obj, Nuitka_String_FromString("utf8"));
+    Py_DECREF(name_bytes_obj);
+
+    PyObject *name_ascii = UNICODE_ENCODE2(tstate, name_obj, const_str_plain_ascii);
+
+    if (name_ascii == NULL) {
+        DROP_ERROR_OCCURRED(tstate);
+
+        PyObject *name_punycode = UNICODE_ENCODE2(tstate, name_obj, const_str_plain_punycode);
+
+        CHECK_OBJECT(name_punycode);
+
+        snprintf(buffer, buffer_size, "PyInitU_%s", PyBytes_AsString(name_punycode));
+
+        Py_DECREF(name_punycode);
+    } else {
+        Py_DECREF(name_ascii);
+
+        snprintf(buffer, buffer_size, "PyInit_%s", name);
+    }
+    Py_DECREF(name_obj);
 #else
-static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name, const char *filename) {
+
+    snprintf(buffer, buffer_size,
+#if PYTHON_VERSION < 0x300
+             "init%s",
+#else
+             "PyInit_%s",
+#endif
+             name);
 #endif
+}
+
+static PyObject *callIntoExtensionModule(PyThreadState *tstate, char const *full_name,
+                                         const filename_char_t *filename) {
     // Determine the package name and basename of the module to load.
     char const *dot = strrchr(full_name, '.');
     char const *name;
     char const *package;
 
     if (dot == NULL) {
         package = NULL;
@@ -654,21 +688,15 @@
     } else {
         // The extension modules do expect it to be full name in context.
         package = (char *)full_name;
         name = dot + 1;
     }
 
     char entry_function_name[1024];
-    snprintf(entry_function_name, sizeof(entry_function_name),
-#if PYTHON_VERSION < 0x300
-             "init%s",
-#else
-             "PyInit_%s",
-#endif
-             name);
+    _fillExtensionModuleDllEntryFunctionName(tstate, entry_function_name, sizeof(entry_function_name), name);
 
 #ifdef _WIN32
     if (isVerbose()) {
         PySys_WriteStderr("import %s # LoadLibraryExW(\"%S\");\n", full_name, filename);
     }
 
 #ifndef _NUITKA_EXPERIMENTAL_DEBUG_STANDALONE
@@ -697,23 +725,26 @@
         unsigned int error_code = GetLastError();
 
         size = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error_code, 0,
                              (LPTSTR)error_message, sizeof(error_message), NULL);
 
         // Report either way even if failed to get error message.
         if (size == 0) {
-            PyOS_snprintf(buffer, sizeof(buffer), "LoadLibraryExW '%S' failed with error code %d", filename,
-                          error_code);
+            int ret = PyOS_snprintf(buffer, sizeof(buffer), "LoadLibraryExW '%S' failed with error code %d", filename,
+                                    error_code);
+
+            assert(ret >= 0);
         } else {
             // Strip trailing newline.
             if (size >= 2 && error_message[size - 2] == '\r' && error_message[size - 1] == '\n') {
                 size -= 2;
                 error_message[size] = '\0';
             }
-            PyOS_snprintf(buffer, sizeof(buffer), "LoadLibraryExW '%S' failed: %s", filename, error_message);
+            int ret = PyOS_snprintf(buffer, sizeof(buffer), "LoadLibraryExW '%S' failed: %s", filename, error_message);
+            assert(ret >= 0);
         }
 
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_ImportError, buffer);
         return NULL;
     }
 
     entrypoint_t entrypoint = (entrypoint_t)GetProcAddress(hDLL, entry_function_name);
@@ -907,29 +938,32 @@
 #ifdef _WIN32
     PyObject *filename_obj = NuitkaUnicode_FromWideChar(filename, -1);
 #else
     PyObject *filename_obj = PyUnicode_FromString(filename);
 #endif
     CHECK_OBJECT(filename_obj);
 
+#if PYTHON_VERSION < 0x3d0
     int res = _PyImport_FixupExtensionObject(module, full_name_obj, filename_obj
 #if PYTHON_VERSION >= 0x370
                                              ,
                                              Nuitka_GetSysModules()
 #endif
-
     );
+#endif
 
     Py_DECREF(full_name_obj);
     Py_DECREF(filename_obj);
 
+#if PYTHON_VERSION < 0x3d0
     if (unlikely(res == -1)) {
         return NULL;
     }
 #endif
+#endif
 
     return module;
 }
 
 static void loadTriggeredModule(PyThreadState *tstate, char const *name, char const *trigger_name) {
     char trigger_module_name[2048];
 
@@ -980,15 +1014,15 @@
         // Append the the entry name from full path module name with dots,
         // and translate these into directory separators.
 #ifdef _WIN32
         wchar_t filename[MAXPATHLEN + 1] = {0};
 
         appendWStringSafeW(filename, getBinaryDirectoryWideChars(true), sizeof(filename) / sizeof(wchar_t));
         appendCharSafeW(filename, SEP, sizeof(filename) / sizeof(wchar_t));
-        appendModuleNameAsPathW(filename, entry->name, sizeof(filename) / sizeof(wchar_t));
+        appendModuleNameAsPathW(filename, module_name, sizeof(filename) / sizeof(wchar_t));
         appendStringSafeW(filename, ".pyd", sizeof(filename) / sizeof(wchar_t));
 #else
         char filename[MAXPATHLEN + 1] = {0};
 
         appendStringSafe(filename, getBinaryDirectoryHostEncoded(true), sizeof(filename));
         appendCharSafe(filename, SEP, sizeof(filename));
         appendModuleNameAsPath(filename, entry->name, sizeof(filename));
@@ -1110,15 +1144,15 @@
         // after loading, to e.g. set a plug-in path, or do some monkey patching
         // in order to make things compatible.
         loadTriggeredModule(tstate, name, "-postLoad");
 
         return result;
     }
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
     return Py_None;
 }
 
 // Note: This may become an entry point for hard coded imports of compiled
 // stuff.
 PyObject *IMPORT_EMBEDDED_MODULE(PyThreadState *tstate, char const *name) {
     PyObject *module_name = Nuitka_String_FromString(name);
@@ -1218,30 +1252,32 @@
     if (entry) {
         result = BOOL_FROM((entry->flags & NUITKA_PACKAGE_FLAG) != 0);
     } else {
         // TODO: Maybe needs to be an exception.
         result = Py_None;
     }
 
-    Py_INCREF(result);
+    Py_INCREF_IMMORTAL(result);
     return result;
 }
 
 static char const *_kw_list_iter_modules[] = {"package", NULL};
 
 static PyObject *_nuitka_loader_iter_modules(struct Nuitka_LoaderObject *self, PyObject *args, PyObject *kwds) {
     PyObject *prefix;
 
     int res = PyArg_ParseTupleAndKeywords(args, kwds, "O:iter_modules", (char **)_kw_list_iter_modules, &prefix);
 
     if (unlikely(res == 0)) {
         return NULL;
     }
 
-    PyObject *result = MAKE_LIST_EMPTY(0);
+    NUITKA_MAY_BE_UNUSED PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *result = MAKE_LIST_EMPTY(tstate, 0);
 
     struct Nuitka_MetaPathBasedLoaderEntry *current = loader_entries;
     assert(current);
 
     char const *s;
 
     if (self->m_loader_entry) {
@@ -1289,17 +1325,17 @@
 
         if (CHECK_IF_TRUE(prefix)) {
             PyObject *old = name;
             name = PyUnicode_Concat(prefix, name);
             Py_DECREF(old);
         }
 
-        PyObject *r = MAKE_TUPLE_EMPTY(2);
+        PyObject *r = MAKE_TUPLE_EMPTY(tstate, 2);
         PyTuple_SET_ITEM(r, 0, name);
-        PyTuple_SET_ITEM0(r, 1, BOOL_FROM((current->flags & NUITKA_PACKAGE_FLAG) != 0));
+        PyTuple_SET_ITEM_IMMORTAL(r, 1, BOOL_FROM((current->flags & NUITKA_PACKAGE_FLAG) != 0));
 
         LIST_APPEND1(result, r);
 
         current++;
     }
 
     return result;
@@ -1444,15 +1480,15 @@
 
     PyObject *module_spec_class = getModuleSpecClass(importlib_module);
 
     if (unlikely(module_spec_class == NULL)) {
         return NULL;
     }
 
-    PyObject *args = MAKE_TUPLE2(module_name, (PyObject *)&Nuitka_Loader_Type);
+    PyObject *args = MAKE_TUPLE2(tstate, module_name, (PyObject *)&Nuitka_Loader_Type);
 
     PyObject *kw_values[] = {is_package ? Py_True : Py_False, origin};
 
     char const *kw_keys[] = {"is_package", "origin"};
 
     PyObject *kw_args = MAKE_DICT_X_CSTR(kw_keys, kw_values, sizeof(kw_values) / sizeof(PyObject *));
 
@@ -1530,15 +1566,15 @@
 #endif
 
     if (entry == NULL) {
         if (isVerbose()) {
             PySys_WriteStderr("import %s # denied responsibility\n", full_name);
         }
 
-        Py_INCREF(Py_None);
+        Py_INCREF_IMMORTAL(Py_None);
         return Py_None;
     }
 
     if (isVerbose()) {
         PySys_WriteStderr("import %s # claimed responsibility (%s)\n", Nuitka_String_AsString(module_name),
                           getEntryModeString(entry));
     }
@@ -1670,21 +1706,21 @@
 
     PyObject *name = PyObject_GetAttr(context, const_str_plain_name);
 
     if (unlikely(name == NULL)) {
         return NULL;
     }
 
-    PyObject *temp = MAKE_LIST_EMPTY(0);
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *temp = MAKE_LIST_EMPTY(tstate, 0);
 
     Py_ssize_t pos = 0;
     PyObject *distribution_name;
 
-    PyThreadState *tstate = PyThreadState_GET();
-
     while (Nuitka_DistributionNext(&pos, &distribution_name)) {
         bool include = false;
         if (name == Py_None) {
             include = true;
         } else {
             nuitka_bool cmp_res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(name, distribution_name);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderImportlibMetadataDistribution.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderImportlibMetadataDistribution.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReader.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReader.c`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReaderFiles.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/MetaPathBasedLoaderResourceReaderFiles.c`

 * *Files 1% similar despite different names*

```diff
@@ -107,15 +107,15 @@
 
     // TODO: Actually we ought to behave like a generator and delay this error,
     // but we currently spare us the effort and raise this immediately.
     if (unlikely(file_names == NULL)) {
         return NULL;
     }
 
-    PyObject *files_objects = MAKE_LIST_EMPTY(0);
+    PyObject *files_objects = MAKE_LIST_EMPTY(tstate, 0);
 
     Py_ssize_t n = PyList_GET_SIZE(file_names);
     for (Py_ssize_t i = 0; i < n; i++) {
         PyObject *file_name = PyList_GET_ITEM(file_names, i);
         CHECK_OBJECT(file_name);
 
         PyObject *joined = JOIN_PATH2(files->m_path, file_name);
@@ -414,15 +414,15 @@
     Py_INCREF(files);
     return (PyObject *)files;
 }
 
 static PyObject *Nuitka_ResourceReaderFiles_exit(struct Nuitka_ResourceReaderFilesObject *files) {
     CHECK_OBJECT(files);
 
-    Py_INCREF(Py_None);
+    Py_INCREF_IMMORTAL(Py_None);
     return Py_None;
 }
 
 static PyObject *Nuitka_ResourceReaderFiles_fspath(struct Nuitka_ResourceReaderFilesObject *files) {
     PyThreadState *tstate = PyThreadState_GET();
 
     return _Nuitka_ResourceReaderFiles_GetPath(tstate, files);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/OnefileBootstrap.c` & `nuitka_winsvc-2.3/nuitka/build/static_src/OnefileBootstrap.c`

 * *Files 2% similar despite different names*

```diff
@@ -63,14 +63,15 @@
 #define _NUITKA_ONEFILE_CHILD_GRACE_TIME_INT 5000
 #define _NUITKA_ONEFILE_TEMP_SPEC "{TEMP}/onefile_{PID}_{TIME}"
 
 #define _NUITKA_AUTO_UPDATE_BOOL 1
 #define _NUITKA_AUTO_UPDATE_DEBUG_BOOL 1
 #define _NUITKA_AUTO_UPDATE_URL_SPEC "https://..."
 
+#define _NUITKA_ATTACH_CONSOLE_WINDOW 1
 #endif
 
 #if _NUITKA_ONEFILE_COMPRESSION_BOOL == 1
 // Header of zstd goes first
 #define ZSTDERRORLIB_VISIBILITY
 #define ZSTDLIB_VISIBILITY
 #include "zstd.h"
@@ -101,14 +102,18 @@
 #endif
 
 #include "HelpersChecksumTools.c"
 #include "HelpersEnvironmentVariablesSystem.c"
 #include "HelpersFilesystemPaths.c"
 #include "HelpersSafeStrings.c"
 
+#if defined(_WIN32) && defined(_NUITKA_ATTACH_CONSOLE_WINDOW)
+#include "HelpersConsole.c"
+#endif
+
 // For tracing outputs if enabled at compile time.
 #include "nuitka/tracing.h"
 
 static void fatalError(char const *message) {
     puts(message);
     exit(2);
 }
@@ -133,30 +138,14 @@
 #if !defined(_WIN32) || _NUITKA_ONEFILE_COMPRESSION_BOOL == 1
 static void fatalErrorMemory(void) { fatalError("Error, couldn't allocate memory."); }
 #endif
 
 // Could not launch child process.
 static void fatalErrorChild(char const *message, error_code_t error_code) { fatalIOError(message, error_code); }
 
-#if defined(_WIN32)
-static void appendWCharSafeW(wchar_t *target, wchar_t c, size_t buffer_size) {
-    while (*target != 0) {
-        target++;
-        buffer_size -= 1;
-    }
-
-    if (buffer_size < 1) {
-        abort();
-    }
-
-    *target++ = c;
-    *target = 0;
-}
-#endif
-
 static void fatalErrorTempFileCreate(filename_char_t const *filename) {
     fprintf(stderr, "Error, failed to open '" FILENAME_FORMAT_STR "' for writing.\n", filename);
     exit(2);
 }
 
 static void fatalErrorSpec(filename_char_t const *spec) {
     fprintf(stderr, "Error, couldn't runtime expand spec '" FILENAME_FORMAT_STR "'.\n", spec);
@@ -989,14 +978,20 @@
 #else
 int wmain(int argc, wchar_t **argv) {
 #endif
 #else
 int main(int argc, char **argv) {
 #endif
 #endif
+    // Attach to the parent console respecting redirection only, otherwise we cannot
+    // even output traces.
+#if defined(_WIN32) && defined(_NUITKA_ATTACH_CONSOLE_WINDOW)
+    inheritAttachedConsole();
+#endif
+
     NUITKA_PRINT_TIMING("ONEFILE: Entered main().");
 
     filename_char_t const *pattern = FILENAME_EMPTY_STR _NUITKA_ONEFILE_TEMP_SPEC;
     bool bool_res = expandTemplatePathFilename(payload_path, pattern, sizeof(payload_path) / sizeof(filename_char_t));
 
     if (unlikely(bool_res == false)) {
         fatalErrorSpec(pattern);
@@ -1236,23 +1231,27 @@
 
     NUITKA_PRINT_TIMING("ONEFILE: Preparing forking of slave process.");
 
 #if defined(_WIN32)
 
     STARTUPINFOW si;
     memset(&si, 0, sizeof(si));
+    si.dwFlags = STARTF_USESTDHANDLES;
+    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
+    si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
+    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
     si.cb = sizeof(si);
 
     PROCESS_INFORMATION pi;
 
     bool_res = CreateProcessW(first_filename,        // application name
                               GetCommandLineW(),     // command line
                               NULL,                  // process attributes
                               NULL,                  // thread attributes
-                              FALSE,                 // inherit handles
+                              TRUE,                  // inherit handles
                               NORMAL_PRIORITY_CLASS, // creation flags
                               NULL, NULL, &si, &pi);
 
     NUITKA_PRINT_TIMING("ONEFILE: Started slave process.");
 
     if (bool_res == false) {
         fatalErrorChild("Error, couldn't launch child", GetLastError());
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/build/static_src/OnefileSplashScreen.cpp` & `nuitka_winsvc-2.3/nuitka/build/static_src/OnefileSplashScreen.cpp`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/AsyncgenCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/AsyncgenCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/AttributeCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/AttributeCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/BinaryOperationHelperDefinitions.py` & `nuitka_winsvc-2.3/nuitka/code_generation/BinaryOperationHelperDefinitions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/BranchCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/BranchCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/BuiltinCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/BuiltinCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CallCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CallCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ClassCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ClassCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CodeGeneration.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CodeGeneration.py`

 * *Files 1% similar despite different names*

```diff
@@ -279,14 +279,15 @@
     generateOsPathAbspathCallCode,
     generateOsPathBasenameCallCode,
     generateOsPathDirnameCallCode,
     generateOsPathExistsCallCode,
     generateOsPathIsabsCallCode,
     generateOsPathIsdirCallCode,
     generateOsPathIsfileCallCode,
+    generateOsPathNormpathCallCode,
     generateOsUnameCallCode,
     generatePkglibGetDataCallCode,
     generatePkgResourcesDistributionValueCode,
     generatePkgResourcesEntryPointValueCode,
     generatePkgResourcesGetDistributionCallCode,
     generatePkgResourcesIterEntryPointsCallCode,
     generatePkgResourcesRequireCallCode,
@@ -335,15 +336,15 @@
     generateStrFormatMethodCode,
     generateStringConcatenationCode,
     generateStrOperationCode,
 )
 from .SubscriptCodes import (
     generateAssignmentSubscriptCode,
     generateDelSubscriptCode,
-    generateSubscriptCheckCode,
+    generateMatchSubscriptCheckCode,
     generateSubscriptLookupCode,
 )
 from .TensorflowCodes import generateTensorflowFunctionCallCode
 from .TryCodes import generateTryCode
 from .TupleCodes import generateBuiltinTupleCode, generateTupleCreationCode
 from .TypeAliasCodes import generateTypeAliasCode
 from .VariableCodes import (
@@ -843,15 +844,15 @@
         "EXPRESSION_OUTLINE_BODY": generateFunctionOutlineCode,
         "EXPRESSION_OUTLINE_FUNCTION": generateFunctionOutlineCode,
         # TODO: Rename to make more clear it is an outline
         "EXPRESSION_CLASS_BODY_P2": generateFunctionOutlineCode,
         "EXPRESSION_CLASS_BODY_P3": generateFunctionOutlineCode,
         "EXPRESSION_SUBSCRIPT_LOOKUP": generateSubscriptLookupCode,
         "EXPRESSION_SUBSCRIPT_LOOKUP_FOR_UNPACK": generateSubscriptLookupCode,
-        "EXPRESSION_SUBSCRIPT_CHECK": generateSubscriptCheckCode,
+        "EXPRESSION_MATCH_SUBSCRIPT_CHECK": generateMatchSubscriptCheckCode,
         "EXPRESSION_SLICE_LOOKUP": generateSliceLookupCode,
         "EXPRESSION_SET_OPERATION_UPDATE": generateSetOperationUpdateCode,
         "EXPRESSION_SIDE_EFFECTS": generateSideEffectsCode,
         "EXPRESSION_SPECIAL_UNPACK": generateSpecialUnpackCode,
         "EXPRESSION_TEMP_VARIABLE_REF": generateVariableReferenceCode,
         "EXPRESSION_VARIABLE_REF": generateVariableReferenceCode,
         "EXPRESSION_VARIABLE_OR_BUILTIN_REF": generateVariableReferenceCode,
@@ -907,14 +908,15 @@
         "EXPRESSION_OS_LISTDIR_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_EXISTS_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_ISFILE_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_ISDIR_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_DIRNAME_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_BASENAME_REF": generateImportModuleNameHardCode,
         "EXPRESSION_OS_PATH_ABSPATH_REF": generateImportModuleNameHardCode,
+        "EXPRESSION_OS_PATH_NORMPATH_REF": generateImportModuleNameHardCode,
         "EXPRESSION_BUILTINS_OPEN_REF": generateImportModuleNameHardCode,
         "EXPRESSION_CTYPES_CDLL_REF": generateImportModuleNameHardCode,
         "EXPRESSION_CTYPES_CDLL_SINCE38_CALL": generateCtypesCdllCallCode,
         "EXPRESSION_CTYPES_CDLL_BEFORE38_CALL": generateCtypesCdllCallCode,
         "EXPRESSION_PKGUTIL_GET_DATA_CALL": generatePkglibGetDataCallCode,
         "EXPRESSION_PKG_RESOURCES_REQUIRE_CALL": generatePkgResourcesRequireCallCode,
         "EXPRESSION_PKG_RESOURCES_GET_DISTRIBUTION_CALL": generatePkgResourcesGetDistributionCallCode,
@@ -936,14 +938,15 @@
         "EXPRESSION_OS_UNAME_CALL": generateOsUnameCallCode,
         "EXPRESSION_OS_PATH_EXISTS_CALL": generateOsPathExistsCallCode,
         "EXPRESSION_OS_PATH_ISFILE_CALL": generateOsPathIsfileCallCode,
         "EXPRESSION_OS_PATH_ISDIR_CALL": generateOsPathIsdirCallCode,
         "EXPRESSION_OS_PATH_BASENAME_CALL": generateOsPathBasenameCallCode,
         "EXPRESSION_OS_PATH_DIRNAME_CALL": generateOsPathDirnameCallCode,
         "EXPRESSION_OS_PATH_ABSPATH_CALL": generateOsPathAbspathCallCode,
+        "EXPRESSION_OS_PATH_NORMPATH_CALL": generateOsPathNormpathCallCode,
         "EXPRESSION_OS_PATH_ISABS_CALL": generateOsPathIsabsCallCode,
         "EXPRESSION_OS_LISTDIR_CALL": generateOsListdirCallCode,
         "EXPRESSION_MATCH_ARGS": generateMatchArgsCode,
         "EXPRESSION_TYPE_ALIAS": generateTypeAliasCode,
         "EXPRESSION_STR_OPERATION_FORMAT": generateStrFormatMethodCode,
         # TODO: Should have all of these generically or not. This one is required for now.
         "EXPRESSION_DICT_OPERATION_FROMKEYS_REF": generateDictOperationFromkeysRefCode,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CodeHelperSelection.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CodeHelperSelection.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CodeHelpers.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CodeHelpers.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CodeObjectCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CodeObjectCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ComparisonCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ComparisonCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ComparisonHelperDefinitions.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ComparisonHelperDefinitions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ConditionalCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ConditionalCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ConstantCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ConstantCodes.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 import os
 import sys
 
 from nuitka import Options
 from nuitka.ModuleRegistry import getRootTopModule
 from nuitka.PythonVersions import python_version
-from nuitka.Serialization import ConstantAccessor
+from nuitka.Serialization import GlobalConstantAccessor
 from nuitka.utils.CStrings import encodePythonStringToC
 from nuitka.utils.Distributions import getDistributionTopLevelPackageNames
 from nuitka.Version import getNuitkaVersionTuple
 
 from .CodeHelpers import withObjectCodeTemporaryAssignment
 from .ErrorCodes import getAssertionCode
 from .GlobalConstants import getConstantDefaultPopulation
@@ -82,15 +82,15 @@
 
     This needs to create code to make all global constants (used in more
     than one module) and create them.
 
     """
     # Somewhat detail rich, pylint: disable=too-many-locals
 
-    constant_accessor = ConstantAccessor(
+    constant_accessor = GlobalConstantAccessor(
         data_filename="__constants.const", top_level_name="global_constants"
     )
 
     lines = []
 
     for constant_value in getConstantDefaultPopulation():
         identifier = constant_accessor.getConstantCode(constant_value)
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/Contexts.py` & `nuitka_winsvc-2.3/nuitka/code_generation/Contexts.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CoroutineCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CoroutineCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/CtypesCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/CtypesCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/DictCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/DictCodes.py`

 * *Files 0% similar despite different names*

```diff
@@ -268,15 +268,15 @@
 %(value_name)s = DICT_GET_ITEM1(tstate, %(dict_name)s, %(key_name)s);
 if (%(value_name)s == NULL) {
 {% else %}
 %(value_name)s = DICT_GET_ITEM_WITH_HASH_ERROR1(tstate, %(dict_name)s, %(key_name)s);
 if (%(value_name)s == NULL && !HAS_ERROR_OCCURRED(tstate)) {
 {% endif %}
     %(value_name)s = Py_None;
-    Py_INCREF(%(value_name)s);
+    Py_INCREF_IMMORTAL(%(value_name)s);
 }
 """,
                 expression=expression,
             )
             % {
                 "value_name": value_name,
                 "dict_name": dict_name,
@@ -537,15 +537,15 @@
     assignConstantNoneResult(to_name, emit, context)
 
 
 def generateDictOperationCopyCode(to_name, expression, emit, context):
     generateCAPIObjectCode(
         to_name=to_name,
         capi="DICT_COPY",
-        tstate=False,
+        tstate=True,
         arg_desc=(("dict_arg", expression.subnode_dict_arg),),
         may_raise=False,
         conversion_check=decideConversionCheckNeeded(to_name, expression),
         source_ref=expression.getCompatibleSourceReference(),
         emit=emit,
         context=context,
     )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/Emission.py` & `nuitka_winsvc-2.3/nuitka/code_generation/Emission.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ErrorCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ErrorCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/EvalCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/EvalCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ExceptionCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ExceptionCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ExpressionCTypeSelectionHelpers.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ExpressionCTypeSelectionHelpers.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ExpressionCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ExpressionCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/FrameCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/FrameCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/FunctionCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/FunctionCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/GeneratorCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/GeneratorCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/GlobalConstants.py` & `nuitka_winsvc-2.3/nuitka/code_generation/GlobalConstants.py`

 * *Files 1% similar despite different names*

```diff
@@ -78,14 +78,15 @@
         "sum",
         "format",
         "__import__",
         "bytearray",
         "staticmethod",
         "classmethod",
         "keys",
+        "get",
         # Arguments of __import__ built-in used in helper code.
         "name",
         "globals",
         "locals",
         "fromlist",
         "level",
         # Meta path based loader.
@@ -178,14 +179,18 @@
         # Work with the __spec__ module attribute.
         result += ("__spec__", "_initializing", "parent")
 
     if python_version >= 0x350:
         # Patching the types module.
         result.append("types")
 
+        # Converting module names
+        result.append("ascii")
+        result.append("punycode")
+
     if not Options.shallMakeModule():
         result.append("__main__")
 
     # Resource reader files interface, including for backport
     if python_version >= 0x390:
         result.append("as_file")
         result.append("register")
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/GlobalsLocalsCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/GlobalsLocalsCodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -58,24 +58,24 @@
             locals_declaration = context.addLocalsDictName(locals_scope.getCodeName())
             is_dict = locals_scope.hasShapeDictionaryExact()
             # For Python3 it may really not be a dictionary.
 
             # TODO: Creation is not needed for classes.
             emit(
                 """\
-if (%(locals_dict)s == NULL) %(locals_dict)s = MAKE_DICT_EMPTY();
+if (%(locals_dict)s == NULL) %(locals_dict)s = MAKE_DICT_EMPTY(tstate);
 %(to_name)s = %(locals_dict)s;
 Py_INCREF(%(to_name)s);"""
                 % {"to_name": value_name, "locals_dict": locals_declaration}
             )
             context.addCleanupTempName(value_name)
 
             initial = False
         else:
-            emit("%s = MAKE_DICT_EMPTY();" % (to_name,))
+            emit("%s = MAKE_DICT_EMPTY(tstate);" % (to_name,))
 
             context.addCleanupTempName(value_name)
 
             initial = True
             is_dict = True
 
         for local_var, variable_trace in _sorted(variable_traces):
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/IdCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/IdCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ImportCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ImportCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/Indentation.py` & `nuitka_winsvc-2.3/nuitka/code_generation/Indentation.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/IndexCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/IndexCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/InjectCCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/InjectCCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/IntegerCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/IntegerCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/IteratorCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/IteratorCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/JitCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/JitCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/LabelCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/LabelCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/LineNumberCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/LineNumberCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ListCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ListCodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -50,15 +50,15 @@
             else:
                 helper_code = "PyList_SET_ITEM0"
 
             return helper_code
 
         helper_code = generateElementCode(elements[0])
 
-        emit("%s = MAKE_LIST_EMPTY(%d);" % (result_name, len(elements)))
+        emit("%s = MAKE_LIST_EMPTY(tstate, %d);" % (result_name, len(elements)))
 
         needs_exception_exit = any(
             element.mayRaiseException(BaseException) for element in elements[1:]
         )
 
         with withCleanupFinally(
             "list_build", result_name, needs_exception_exit, emit, context
@@ -183,15 +183,15 @@
     (list_arg_name,) = generateChildExpressionsCode(
         expression=expression, emit=emit, context=context
     )
 
     with withObjectCodeTemporaryAssignment(
         to_name, "list_copy_result", expression, emit, context
     ) as result_name:
-        emit("%s = LIST_COPY(%s);" % (result_name, list_arg_name))
+        emit("%s = LIST_COPY(tstate, %s);" % (result_name, list_arg_name))
 
         getErrorExitCode(
             check_name=result_name,
             release_name=list_arg_name,
             emit=emit,
             needs_check=False,
             context=context,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/LoaderCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/LoaderCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/LocalsDictCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/LocalsDictCodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -30,15 +30,15 @@
 def generateSetLocalsDictCode(statement, emit, context):
     locals_declaration = context.addLocalsDictName(
         statement.getLocalsScope().getCodeName()
     )
 
     emit(
         """\
-%(locals_dict)s = MAKE_DICT_EMPTY();"""
+%(locals_dict)s = MAKE_DICT_EMPTY(tstate);"""
         % {"locals_dict": locals_declaration}
     )
 
 
 def generateSetLocalsMappingCode(statement, emit, context):
     new_locals_name = context.allocateTempName("set_locals")
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/LoopCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/LoopCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/MatchCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/MatchCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ModuleCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ModuleCodes.py`

 * *Files 11% similar despite different names*

```diff
@@ -112,14 +112,31 @@
 
     is_dunder_main = module.isMainModule()
 
     dunder_main_package = context.getConstantCode(
         module.getRuntimePackageValue() if is_dunder_main else ""
     )
 
+    if str is bytes:
+        module_dll_entry_point = "init" + module_identifier
+        module_def_size = -1
+    else:
+        try:
+            module_dll_entry_point = module_name.encode("ascii")
+            module_dll_entry_point_prefix = "PyInit_"
+            module_def_size = -1
+        except UnicodeEncodeError:
+            module_dll_entry_point = module_name.encode("punycode")
+            module_dll_entry_point_prefix = "PyInitU_"
+            module_def_size = 0
+
+        module_dll_entry_point = (
+            module_dll_entry_point_prefix + module_dll_entry_point.decode("ascii")
+        )
+
     return template % {
         "module_name_cstr": encodePythonStringToC(
             module_name.asString().encode("utf8")
         ),
         "version": getNuitkaVersion(),
         "year": getNuitkaVersionYear(),
         "is_top": 1 if module.isTopModule() else 0,
@@ -134,14 +151,16 @@
         "module_init_codes": indented(context.getModuleInitCodes()),
         "module_codes": indented(module_codes.codes),
         "module_exit": module_exit,
         "module_code_objects_decl": indented(module_code_objects_decl, 0),
         "module_code_objects_init": indented(module_code_objects_init, 1),
         "constants_count": context.getConstantsCount(),
         "module_const_blob_name": module_const_blob_name,
+        "module_dll_entry_point": module_dll_entry_point,
+        "module_def_size": module_def_size,
     }
 
 
 def generateModuleAttributeFileCode(to_name, expression, emit, context):
     # TODO: Special treatment justified?
     with withObjectCodeTemporaryAssignment(
         to_name, "module_fileattr_value", expression, emit, context
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/Namify.py` & `nuitka_winsvc-2.3/nuitka/code_generation/Namify.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/NetworkxCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/NetworkxCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/OperationCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/OperationCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/PackageResourceCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/PackageResourceCodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -874,14 +874,28 @@
         conversion_check=decideConversionCheckNeeded(to_name, expression),
         source_ref=expression.getCompatibleSourceReference(),
         emit=emit,
         context=context,
     )
 
 
+def generateOsPathNormpathCallCode(to_name, expression, emit, context):
+    generateCAPIObjectCode(
+        to_name=to_name,
+        capi="OS_PATH_NORMPATH",
+        tstate=True,
+        arg_desc=(("path_arg", expression.subnode_path),),
+        may_raise=expression.mayRaiseException(BaseException),
+        conversion_check=decideConversionCheckNeeded(to_name, expression),
+        source_ref=expression.getCompatibleSourceReference(),
+        emit=emit,
+        context=context,
+    )
+
+
 def generateOsPathAbspathCallCode(to_name, expression, emit, context):
     generateCAPIObjectCode(
         to_name=to_name,
         capi="OS_PATH_ABSPATH",
         tstate=True,
         arg_desc=(("path_arg", expression.subnode_path),),
         may_raise=expression.mayRaiseException(BaseException),
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/PrintCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/PrintCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/PythonAPICodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/PythonAPICodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/RaisingCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/RaisingCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/Reports.py` & `nuitka_winsvc-2.3/nuitka/code_generation/Reports.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/ReturnCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/ReturnCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/SetCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/SetCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/SliceCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/SliceCodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -255,15 +255,15 @@
         expression=expression, emit=emit, context=context
     )
 
     with withObjectCodeTemporaryAssignment(
         to_name, "slice_obj_value", expression, emit, context
     ) as result_name:
         emit(
-            "%s = MAKE_SLICE_OBJECT3(%s, %s, %s);"
+            "%s = MAKE_SLICE_OBJECT3(tstate, %s, %s, %s);"
             % (
                 result_name,
                 lower_name,
                 upper_name,
                 step_name,
             )
         )
@@ -284,15 +284,15 @@
         expression=expression, emit=emit, context=context
     )
 
     with withObjectCodeTemporaryAssignment(
         to_name, "slice_obj_value", expression, emit, context
     ) as result_name:
         emit(
-            "%s = MAKE_SLICE_OBJECT2(%s, %s);"
+            "%s = MAKE_SLICE_OBJECT2(tstate, %s, %s);"
             % (
                 result_name,
                 lower_name,
                 upper_name,
             )
         )
 
@@ -312,15 +312,15 @@
         expression=expression, emit=emit, context=context
     )
 
     with withObjectCodeTemporaryAssignment(
         to_name, "slice_obj_value", expression, emit, context
     ) as result_name:
         emit(
-            "%s = MAKE_SLICE_OBJECT1(%s);"
+            "%s = MAKE_SLICE_OBJECT1(tstate, %s);"
             % (
                 result_name,
                 upper_name,
             )
         )
 
         getErrorExitCode(
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/StringCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/StringCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/SubscriptCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/SubscriptCodes.py`

 * *Files 3% similar despite different names*

```diff
@@ -132,40 +132,32 @@
                 subscribed_name=subscribed_name,
                 subscript_name=subscript_name,
                 emit=emit,
                 context=context,
             )
 
 
-def generateSubscriptCheckCode(to_name, expression, emit, context):
+def generateMatchSubscriptCheckCode(to_name, expression, emit, context):
     subscribed = expression.subnode_expression
     subscript = expression.subnode_subscript
 
     subscribed_name = generateChildExpressionCode(
         expression=subscribed, emit=emit, context=context
     )
 
     subscript_name = generateChildExpressionCode(
         expression=subscript, emit=emit, context=context
     )
 
-    subscript_constant, integer_subscript = decideIntegerSubscript(subscript)
-
     res_name = context.getBoolResName()
 
-    if integer_subscript:
-        emit(
-            "%s = HAS_SUBSCRIPT_CONST(tstate, %s, %s, %s);"
-            % (res_name, subscribed_name, subscript_name, subscript_constant)
-        )
-    else:
-        emit(
-            "%s = HAS_SUBSCRIPT(tstate, %s, %s);"
-            % (res_name, subscribed_name, subscript_name)
-        )
+    emit(
+        "%s = MATCH_MAPPING_KEY(tstate, %s, %s);"
+        % (res_name, subscribed_name, subscript_name)
+    )
 
     getReleaseCodes((subscript_name, subscribed_name), emit, context)
 
     to_name.getCType().emitAssignmentCodeFromBoolCondition(
         to_name=to_name,
         condition=res_name,
         emit=emit,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/TensorflowCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/TensorflowCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/TryCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/TryCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/TupleCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/TupleCodes.py`

 * *Files 0% similar despite different names*

```diff
@@ -63,15 +63,15 @@
                 helper_code = "PyTuple_SET_ITEM0"
 
             return helper_code
 
         helper_code = generateElementCode(elements[0])
 
         # TODO: Consider more compact tuple creation helpers
-        emit("%s = MAKE_TUPLE_EMPTY(%d);" % (to_name, len(elements)))
+        emit("%s = MAKE_TUPLE_EMPTY(tstate, %d);" % (to_name, len(elements)))
 
         needs_exception_exit = any(
             element.mayRaiseException(BaseException) for element in elements[1:]
         )
 
         with withCleanupFinally(
             "tuple_build", to_name, needs_exception_exit, emit, context
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/TypeAliasCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/TypeAliasCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/VariableCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/VariableCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/VariableDeclarations.py` & `nuitka_winsvc-2.3/nuitka/code_generation/VariableDeclarations.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/YieldCodes.py` & `nuitka_winsvc-2.3/nuitka/code_generation/YieldCodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/__init__.py` & `nuitka_winsvc-2.3/nuitka/code_generation/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeBases.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeBases.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeBooleans.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeBooleans.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeCFloats.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeCFloats.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeCLongs.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeCLongs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeModuleDictVariables.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeModuleDictVariables.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaBooleans.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaBooleans.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaInts.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaInts.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeNuitkaVoids.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeNuitkaVoids.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypePyObjectPointers.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypePyObjectPointers.py`

 * *Files 0% similar despite different names*

```diff
@@ -177,20 +177,20 @@
 
                 if needs_deep:
                     code = "DEEP_COPY_DICT(tstate, %s)" % context.getConstantCode(
                         constant, deep_check=False
                     )
                     ref_count = 1
                 else:
-                    code = "DICT_COPY(%s)" % context.getConstantCode(
+                    code = "DICT_COPY(tstate, %s)" % context.getConstantCode(
                         constant, deep_check=False
                     )
                     ref_count = 1
             else:
-                code = "MAKE_DICT_EMPTY()"
+                code = "MAKE_DICT_EMPTY(tstate)"
                 ref_count = 1
         elif type(constant) is set:
             if not may_escape:
                 code = context.getConstantCode(constant)
                 ref_count = 0
             elif constant:
                 code = "PySet_New(%s)" % context.getConstantCode(constant)
@@ -218,40 +218,40 @@
                     ref_count = 1
                 else:
                     constant_size = len(constant)
 
                     if constant_size > 1 and all(
                         constant[i] is constant[0] for i in xrange(1, len(constant))
                     ):
-                        code = "MAKE_LIST_REPEATED(%s, %s)" % (
+                        code = "MAKE_LIST_REPEATED(tstate, %s, %s)" % (
                             constant_size,
                             context.getConstantCode(constant[0], deep_check=False),
                         )
                     elif constant_size < make_list_constant_direct_threshold:
-                        code = "MAKE_LIST%d(%s)" % (
+                        code = "MAKE_LIST%d(tstate, %s)" % (
                             constant_size,
                             ",".join(
                                 context.getConstantCode(constant[i], deep_check=False)
                                 for i in xrange(constant_size)
                             ),
                         )
                     elif constant_size < make_list_constant_hinted_threshold:
-                        code = "MAKE_LIST%d(%s)" % (
+                        code = "MAKE_LIST%d(tstate, %s)" % (
                             constant_size,
                             context.getConstantCode(constant, deep_check=False),
                         )
                     else:
-                        code = "LIST_COPY(%s)" % context.getConstantCode(
+                        code = "LIST_COPY(tstate, %s)" % context.getConstantCode(
                             constant, deep_check=False
                         )
                     ref_count = 1
             else:
                 # TODO: For the zero elements list, maybe have a dedicated function, which
                 # avoids a bit of tests, not sure we want LTO do this.
-                code = "MAKE_LIST_EMPTY(0)"
+                code = "MAKE_LIST_EMPTY(tstate, 0)"
                 ref_count = 1
         elif type(constant) is tuple:
             needs_deep = False
 
             if may_escape:
                 for value in constant:
                     if isMutable(value):
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/CTypeVoids.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/CTypeVoids.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/c_types/__init__.py` & `nuitka_winsvc-2.3/nuitka/code_generation/c_types/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesAsyncgens.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesAsyncgens.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesConstants.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesConstants.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 
 // Global constants storage
 PyObject *global_constants[%(global_constants_count)d];
 
 // Sentinel PyObject to be used for all our call iterator endings. It will
 // become a PyCObject pointing to NULL. It's address is unique, and that's
 // enough for us to use it as sentinel value.
-PyObject *_sentinel_value = NULL;
+PyObject *Nuitka_sentinel_value = NULL;
 
 PyObject *Nuitka_dunder_compiled_value = NULL;
 
 
 #ifdef _NUITKA_STANDALONE
 extern PyObject *getStandaloneSysExecutablePath(PyObject *basename);
 
@@ -239,22 +239,24 @@
 void checkGlobalConstants(void) {
 // TODO: Ask constant code to check values.
 
 }
 #endif
 
 void createGlobalConstants(PyThreadState *tstate) {
-    if (_sentinel_value == NULL) {
+    if (Nuitka_sentinel_value == NULL) {
 #if PYTHON_VERSION < 0x300
-        _sentinel_value = PyCObject_FromVoidPtr(NULL, NULL);
+        Nuitka_sentinel_value = PyCObject_FromVoidPtr(NULL, NULL);
 #else
         // The NULL value is not allowed for a capsule, so use something else.
-        _sentinel_value = PyCapsule_New((void *)27, "sentinel", NULL);
+        Nuitka_sentinel_value = PyCapsule_New((void *)27, "sentinel", NULL);
 #endif
-        assert(_sentinel_value);
+        assert(Nuitka_sentinel_value);
+
+        Py_SET_REFCNT_IMMORTAL(Nuitka_sentinel_value);
 
         _createGlobalConstants(tstate);
     }
 }
 """
 
 from . import TemplateDebugWrapper  # isort:skip
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesCoroutines.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesCoroutines.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesExceptions.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesExceptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesFrames.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesFrames.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesFunction.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesFunction.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesGeneratorFunction.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesGeneratorFunction.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesIterators.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesIterators.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesLoader.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesLoader.py`

 * *Files 1% similar despite different names*

```diff
@@ -120,16 +120,18 @@
     for (;;) {
         destination->name = (char *)current->name;
         destination->code = bytecode_data[current->index];
         destination->size = current->size;
 #if PYTHON_VERSION >= 0x3b0
         destination->is_package = current->size < 0;
         destination->size = Py_ABS(destination->size);
+#if PYTHON_VERSION < 0x3d0
         destination->get_code = NULL;
 #endif
+#endif
         if (destination->name == NULL) break;
 
         current += 1;
         destination += 1;
     };
 }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesModules.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesModules.py`

 * *Files 4% similar despite different names*

```diff
@@ -124,69 +124,68 @@
 static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
     PyObject *func;
 
     if (!PyArg_ParseTuple(args, "O:reduce_compiled_function", &func, NULL)) {
         return NULL;
     }
 
-    if (Nuitka_Function_Check(func) == false) {
-        PyThreadState *tstate = PyThreadState_GET();
+    PyThreadState *tstate = PyThreadState_GET();
 
+    if (Nuitka_Function_Check(func) == false) {
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "not a compiled function");
         return NULL;
     }
 
     struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;
 
     int offset = Nuitka_Function_GetFunctionCodeIndex(function, function_table_%(module_identifier)s);
 
     if (unlikely(offset == -1)) {
-        PyThreadState *tstate = PyThreadState_GET();
 #if 0
         PRINT_STRING("Looking for:");
         PRINT_ITEM(func);
         PRINT_NEW_LINE();
 #endif
         SET_CURRENT_EXCEPTION_TYPE0_STR(tstate, PyExc_TypeError, "Cannot find compiled function in module.");
         return NULL;
     }
 
-    PyObject *code_object_desc = MAKE_TUPLE_EMPTY(6);
+    PyObject *code_object_desc = MAKE_TUPLE_EMPTY(tstate, 6);
     PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
     PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
     PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
     PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
     PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
     PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));
 
     CHECK_OBJECT_DEEP(code_object_desc);
 
 
-    PyObject *result = MAKE_TUPLE_EMPTY(8);
+    PyObject *result = MAKE_TUPLE_EMPTY(tstate, 8);
     PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
     PyTuple_SET_ITEM(result, 1, code_object_desc);
     PyTuple_SET_ITEM0(result, 2, function->m_defaults);
 #if PYTHON_VERSION >= 0x300
     PyTuple_SET_ITEM0(result, 3, function->m_kwdefaults ? function->m_kwdefaults : Py_None);
 #else
-    PyTuple_SET_ITEM0(result, 3, Py_None);
+    PyTuple_SET_ITEM_IMMORTAL(result, 3, Py_None);
 #endif
     PyTuple_SET_ITEM0(result, 4, function->m_doc != NULL ? function->m_doc : Py_None);
 
     if (offset == -5) {
         CHECK_OBJECT(function->m_constant_return_value);
         PyTuple_SET_ITEM0(result, 5, function->m_constant_return_value);
     } else {
-        PyTuple_SET_ITEM0(result, 5, Py_None);
+        PyTuple_SET_ITEM_IMMORTAL(result, 5, Py_None);
     }
 
 #if PYTHON_VERSION >= 0x300
     PyTuple_SET_ITEM0(result, 6, function->m_qualname);
 #else
-    PyTuple_SET_ITEM0(result, 6, Py_None);
+    PyTuple_SET_ITEM_IMMORTAL(result, 6, Py_None);
 #endif
 
     PyObject *closure = PyObject_GetAttr(
         (PyObject *)function,
         const_str_plain___closure__
     );
 
@@ -273,15 +272,17 @@
     static bool init_done = false;
 
     if (init_done == false) {
 #if defined(_NUITKA_MODULE) && %(is_top)d
         // In case of an extension module loaded into a process, we need to call
         // initialization here because that's the first and potentially only time
         // we are going called.
-
+#if PYTHON_VERSION > 0x350 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_ALLOCATORS)
+        initNuitkaAllocators();
+#endif
         // Initialize the constant values used.
         _initBuiltinModule();
         createGlobalConstants(tstate);
 
         /* Initialize the compiled types of Nuitka. */
         _initCompiledCellType();
         _initCompiledGeneratorType();
@@ -502,23 +503,14 @@
 #endif
 #endif
 
 #else
 #define NUITKA_MODULE_INIT_FUNCTION PyMODINIT_FUNC
 #endif
 
-/* The name of the entry point for DLLs changed between CPython versions, and
- * this is here to hide that.
- */
-#if PYTHON_VERSION < 0x300
-#define MOD_INIT_DECL(name) NUITKA_MODULE_INIT_FUNCTION init##name(void)
-#else
-#define MOD_INIT_DECL(name) NUITKA_MODULE_INIT_FUNCTION PyInit_##name(void)
-#endif
-
 static PyObject *orig_dunder_file_value;
 
 #if PYTHON_VERSION >= 0x300
 static setattrofunc orig_PyModule_Type_tp_setattro;
 
 /* This is used one time only. */
 static int Nuitka_TopLevelModule_tp_setattro(PyObject *module, PyObject *name, PyObject *value) {
@@ -544,28 +536,23 @@
 #endif
 
 #if PYTHON_VERSION >= 0x300
 static struct PyModuleDef mdef_%(module_identifier)s = {
     PyModuleDef_HEAD_INIT,
     NULL,                /* m_name, filled later */
     NULL,                /* m_doc */
-    -1,                  /* m_size */
+    %(module_def_size)s, /* m_size */
     NULL,                /* m_methods */
-    NULL,                /* m_reload */
+    NULL,                /* m_slots */
     NULL,                /* m_traverse */
     NULL,                /* m_clear */
     NULL,                /* m_free */
 };
 #endif
 
-/* The exported interface to CPython. On import of the module, this function
- * gets called. It has to have an exact function name, in cases it's a shared
- * library export. This is hidden behind the MOD_INIT_DECL macro.
- */
-
 // Actual name might be different when loaded as a package.
 static char const *module_full_name = %(module_name_cstr)s;
 
 #if PYTHON_VERSION < 0x300
 static void onModuleFileValueRelease(void *v) {
     if (orig_dunder_file_value != NULL) {
         UPDATE_STRING_DICT0(
@@ -573,46 +560,26 @@
             (Nuitka_StringObject *)const_str_plain___file__,
             orig_dunder_file_value
         );
     }
 }
 #endif
 
-MOD_INIT_DECL(%(module_identifier)s) {
-    if (_Py_PackageContext != NULL) {
-        module_full_name = _Py_PackageContext;
-    }
-
-#if PYTHON_VERSION < 0x300
-    PyObject *module = Py_InitModule4(
-        module_full_name,        // Module Name
-        NULL,                    // No methods initially, all are added
-                                 // dynamically in actual module code only.
-        NULL,                    // No "__doc__" is initially set, as it could
-                                 // not contain NUL this way, added early in
-                                 // actual code.
-        NULL,                    // No self for modules, we don't use it.
-        PYTHON_API_VERSION
-    );
-#else
-    mdef_%(module_identifier)s.m_name = module_full_name;
-    PyObject *module = PyModule_Create(&mdef_%(module_identifier)s);
-    CHECK_OBJECT(module);
+/* The exported interface to CPython. On import of the module, this function
+ * gets called. It has to have an exact function name, in cases it's a shared
+ * library export.
+ */
 
-    {
-        NUITKA_MAY_BE_UNUSED bool res = Nuitka_SetModuleString(module_full_name, module);
-        assert(res != false);
-    }
-#endif
 
+static PyObject *%(module_dll_entry_point)s_phase2(PyObject *module) {
     PyThreadState *tstate = PyThreadState_GET();
 
-#if PYTHON_VERSION < 0x300
-    modulecode_%(module_identifier)s(tstate, module, NULL);
+    PyObject *result = modulecode_%(module_identifier)s(tstate, module, NULL);
 
+#if PYTHON_VERSION < 0x300
     // Our "__file__" value will not be respected by CPython and one
     // way we can avoid it, is by having a capsule type, that when
     // it gets released, we are called and repair the value.
 
     if (HAS_ERROR_OCCURRED(tstate) == false) {
         orig_dunder_file_value = DICT_GET_ITEM_WITH_HASH_ERROR1(tstate, (PyObject *)moduledict_%(module_identifier)s, const_str_plain___file__);
 
@@ -621,26 +588,83 @@
         UPDATE_STRING_DICT1(
             moduledict_%(module_identifier)s,
             (Nuitka_StringObject *)const_str_plain___file__,
             fake_file_value
         );
     }
 #else
-    PyObject *result = modulecode_%(module_identifier)s(tstate, module, NULL);
-
     if (result != NULL) {
         // Make sure we undo the change of the "__file__" attribute during importing. We do not
         // know how to achieve it for Python2 though. TODO: Find something for Python2 too.
         orig_PyModule_Type_tp_setattro = PyModule_Type.tp_setattro;
         PyModule_Type.tp_setattro = Nuitka_TopLevelModule_tp_setattro;
 
         orig_dunder_file_value = DICT_GET_ITEM_WITH_HASH_ERROR1(tstate, (PyObject *)moduledict_%(module_identifier)s, const_str_plain___file__);
     }
+#endif
 
     return result;
+}
+
+#if %(module_def_size)s >= 0
+static int %(module_dll_entry_point)s_slot(PyObject *module) {
+    PyObject *result = %(module_dll_entry_point)s_phase2(module);
+
+    if (result == NULL) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+#endif
+
+NUITKA_MODULE_INIT_FUNCTION (%(module_dll_entry_point)s)(void) {
+    if (_Py_PackageContext != NULL) {
+        module_full_name = _Py_PackageContext;
+    }
+
+#if PYTHON_VERSION < 0x300
+    PyObject *module = Py_InitModule4(
+        module_full_name,        // Module Name
+        NULL,                    // No methods initially, all are added
+                                 // dynamically in actual module code only.
+        NULL,                    // No "__doc__" is initially set, as it could
+                                 // not contain NUL this way, added early in
+                                 // actual code.
+        NULL,                    // No self for modules, we don't use it.
+        PYTHON_API_VERSION
+    );
+#else
+    mdef_%(module_identifier)s.m_name = module_full_name;
+
+#if %(module_def_size)s == -1
+    PyObject *module = PyModule_Create(&mdef_%(module_identifier)s);
+    CHECK_OBJECT(module);
+
+    {
+        NUITKA_MAY_BE_UNUSED bool res = Nuitka_SetModuleString(module_full_name, module);
+        assert(res != false);
+    }
+
+#endif
+#endif
+
+#if %(module_def_size)s >= 0
+    static PyModuleDef_Slot _module_slots[] = {
+        {Py_mod_exec, %(module_dll_entry_point)s_slot},
+        {0, NULL}
+    };
+
+    mdef_%(module_identifier)s.m_slots = _module_slots;
+
+    return PyModuleDef_Init(&mdef_%(module_identifier)s);
+#elif PYTHON_VERSION >= 0x300
+    return %(module_dll_entry_point)s_phase2(module);
+#else
+    %(module_dll_entry_point)s_phase2(module);
 #endif
 }
 """
 
 template_module_exception_exit = """\
     module_exception_exit:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/CodeTemplatesVariables.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/CodeTemplatesVariables.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/TemplateDebugWrapper.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/TemplateDebugWrapper.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates/__init__.py` & `nuitka_winsvc-2.3/nuitka/code_generation/templates/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMethodPositional.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMethodPositional.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMixed.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsMixed.c.j2`

 * *Files 2% similar despite different names*

```diff
@@ -89,15 +89,15 @@
     if (unlikely(Py_EnterRecursiveCall((char *)" while calling a Python object"))) {
         return NULL;
     }
 
 {% if args_count == 0 %}
     PyObject *pos_args = const_tuple_empty;
 {% elif not has_tuple_arg or not has_dict_values %}
-    PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% endif %}
 
     PyObject *named_args = _PyDict_NewPresized(nkwargs);
 
     for (Py_ssize_t i = 0; i < nkwargs; i++) {
         PyObject *key = PyTuple_GET_ITEM(kw_names, i);
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositional.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositional.c.j2`

 * *Files 2% similar despite different names*

```diff
@@ -226,15 +226,15 @@
             PyCFunction method = PyCFunction_GET_FUNCTION(called);
             PyObject *self = PyCFunction_GET_SELF(called);
 
             PyObject *result;
 
 #if PYTHON_VERSION < 0x360
 {% if not has_tuple_arg and args_count != 0 %}
-            PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% elif not has_tuple_arg %}
             PyObject *pos_args = const_tuple_empty;
 {% endif %}
             if (flags & METH_KEYWORDS) {
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             } else {
                 result = (*method)(self, pos_args);
@@ -242,15 +242,15 @@
 
 {% if not has_tuple_arg and args_count != 0 %}
             Py_DECREF(pos_args);
 {% endif %}
 #else
             if (flags == (METH_VARARGS|METH_KEYWORDS)) {
 {% if not has_tuple_arg and args_count != 0 %}
-            PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% elif not has_tuple_arg %}
             PyObject *pos_args = const_tuple_empty;
 {% endif %}
                 result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
 {% if not has_tuple_arg and args_count != 0 %}
             Py_DECREF(pos_args);
 {% endif %}
@@ -259,26 +259,26 @@
 {% if args_count != 0 %}
                 result = (*(_PyCFunctionFast)method)(self, (PyObject **)args, {{args_count}}, NULL);
 {% else %}
                 result = (*(_PyCFunctionFast)method)(self, NULL, 0, NULL);
 {% endif %}
 #else
 {% if not has_tuple_arg and args_count != 0 %}
-            PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% elif not has_tuple_arg %}
             PyObject *pos_args = const_tuple_empty;
 {% endif %}
                 result = (*(_PyCFunctionFast)method)(self, &pos_args, {{args_count}});
 {% if not has_tuple_arg and args_count != 0 %}
             Py_DECREF(pos_args);
 {% endif %}
 #endif
             } else {
 {% if not has_tuple_arg and args_count != 0 %}
-            PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% elif not has_tuple_arg %}
             PyObject *pos_args = const_tuple_empty;
 {% endif %}
                 result = (*method)(self, pos_args);
 {% if not has_tuple_arg and args_count != 0 %}
             Py_DECREF(pos_args);
 {% endif %}
@@ -290,15 +290,15 @@
 #endif
 
             CHECK_OBJECT_X(result);
 
             return Nuitka_CheckFunctionResult(tstate, called, result);
         }
 #endif
-#if !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
+#if PYTHON_VERSION < 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_UNCOMPILED_FUNCTION_CALL_OPT)
     } else if (PyFunction_Check(called)) {
 #if PYTHON_VERSION < 0x3b0
 {% if args_count == 0 %}
         PyObject *result = callPythonFunctionNoArgs(called);
 {% else %}
         PyObject *result = callPythonFunction(
             called,
@@ -352,15 +352,15 @@
                     return NULL;
                 }
 
                 obj = called_type->tp_alloc(called_type, 0);
                 CHECK_OBJECT(obj);
             } else {
 {% if not has_tuple_arg and args_count != 0 %}
-                pos_args = MAKE_TUPLE(args, {{args_count}});
+                pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% endif %}
                 obj = called_type->tp_new(called_type, pos_args, NULL);
                 {# TODO: obj = _Py_CheckFunctionResult(obj) for Python3 in debug mode #}
             }
 
             if (likely(obj != NULL)) {
                 if (!Nuitka_Type_IsSubtype(obj->ob_type, called_type)) {
@@ -456,15 +456,15 @@
 
                             SET_CURRENT_EXCEPTION_TYPE_COMPLAINT("__init__() should return None, not '%s'", result);
                             return NULL;
                         }
                     } else {
 {% if not has_tuple_arg and args_count != 0 %}
                         if (pos_args == NULL) {
-                            pos_args = MAKE_TUPLE(args, {{args_count}});
+                            pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
                         }
 {% endif %}
 
                         if (unlikely(type->tp_init(obj, pos_args, NULL) < 0)) {
                             Py_DECREF(obj);
 {% if not has_tuple_arg and args_count != 0 %}
                             Py_XDECREF(pos_args);
@@ -591,15 +591,15 @@
     PRINT_NEW_LINE();
 #endif
 
 {% if args_count == 0 %}
     PyObject *result = CALL_FUNCTION(tstate, called, const_tuple_empty, NULL);
 {% else %}
 {% if not has_tuple_arg %}
-    PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 {% endif %}
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
 {% if not has_tuple_arg %}
     Py_DECREF(pos_args);
 {% endif %}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositionalMethodDescr.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateCallsPositionalMethodDescr.c.j2`

 * *Files 2% similar despite different names*

```diff
@@ -65,38 +65,38 @@
     } else if (flags & METH_VARARGS) {
         PyCFunction method = method_def->ml_meth;
         PyObject *self = args[0];
 
         PyObject *result;
 
 #if PYTHON_VERSION < 0x360
-        PyObject *pos_args = MAKE_TUPLE(args+1, {{args_count-1}});
+        PyObject *pos_args = MAKE_TUPLE(tstate, args+1, {{args_count-1}});
 
         if (flags & METH_KEYWORDS) {
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
         } else {
             result = (*method)(self, pos_args);
         }
 
         Py_DECREF(pos_args);
 #else
         if (flags == (METH_VARARGS|METH_KEYWORDS)) {
-            PyObject *pos_args = MAKE_TUPLE(args+1, {{args_count-1}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args+1, {{args_count-1}});
             result = (*(PyCFunctionWithKeywords)method)(self, pos_args, NULL);
             Py_DECREF(pos_args);
         } else if (flags == METH_FASTCALL) {
 #if PYTHON_VERSION < 0x370
             result = (*(_PyCFunctionFast)method)(self, (PyObject **)args+1, {{args_count-1}}, NULL);
 #else
-            PyObject *pos_args = MAKE_TUPLE(args+1, {{args_count-1}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args+1, {{args_count-1}});
             result = (*(_PyCFunctionFast)method)(self, &pos_args, {{args_count}});
             Py_DECREF(pos_args);
 #endif
         } else {
-            PyObject *pos_args = MAKE_TUPLE(args+1, {{args_count-1}});
+            PyObject *pos_args = MAKE_TUPLE(tstate, args+1, {{args_count-1}});
             result = (*method)(self, pos_args);
             Py_DECREF(pos_args);
         }
 #endif
 #ifndef __NUITKA_NO_ASSERT__
         return Nuitka_CheckFunctionResult(tstate, called, result);
 #else
@@ -114,15 +114,15 @@
 
 {# TODO: How come the PyCFunction call does not cover all cases, that should
    be doable. #}
 
 {% if args_count == 0 %}
     PyObject *result = CALL_FUNCTION(tstate, called, const_tuple_empty, NULL);
 {% else %}
-    PyObject *pos_args = MAKE_TUPLE(args, {{args_count}});
+    PyObject *pos_args = MAKE_TUPLE(tstate, args, {{args_count}});
 
     PyObject *result = CALL_FUNCTION(tstate, called, pos_args, NULL);
 
     Py_DECREF(pos_args);
 {% endif %}
 
     return result;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListHinted.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListHinted.c.j2`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-PyObject *MAKE_LIST{{args_count}}(PyObject *list) {
+PyObject *MAKE_LIST{{args_count}}(PyThreadState *tstate, PyObject *list) {
     CHECK_OBJECT(list);
     assert(PyList_CheckExact(list));
     assert(PyList_GET_SIZE(list) == {{args_count}});
 
-    PyObject *result = MAKE_LIST_EMPTY({{args_count}});
+    PyObject *result = MAKE_LIST_EMPTY(tstate, {{args_count}});
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
 {% for i in range(args_count) %}
     {
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListSmall.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/CodeTemplateMakeListSmall.c.j2`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-PyObject *MAKE_LIST{{args_count}}(
+PyObject *MAKE_LIST{{args_count}}(PyThreadState *tstate,
 {% for i in range(args_count) %}
 {% if i != 0 %}
     ,
 {% endif %}
     PyObject *arg{{i}}
 {% endfor %}
 ) {
 
-    PyObject *result = MAKE_LIST_EMPTY({{args_count}});
+    PyObject *result = MAKE_LIST_EMPTY(tstate, {{args_count}});
 
     if (unlikely(result == NULL)) {
         return NULL;
     }
 
 {% for i in range(args_count) %}
     CHECK_OBJECT(arg{{i}});
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperBuiltinMethodOperation.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperBuiltinMethodOperation.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperDictionaryCopy.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperDictionaryCopy.c.j2`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
 {% macro dict_copy_iteration(result, dict_value, per_key_code, per_value_code, value_ref) %}
 CHECK_OBJECT({{dict_value}});
 assert(PyDict_CheckExact({{dict_value}}));
 
 if (((PyDictObject *){{dict_value}})->ma_used == 0) {
-    {{ result }} = MAKE_DICT_EMPTY();
+    {{ result }} = MAKE_DICT_EMPTY(tstate);
 }
 else
 {
     PyDictObject *dict_mp = (PyDictObject *){{dict_value}};
 
 #if PYTHON_VERSION < 0x300
     // For Python3, this can be done much faster in the same way as it is
@@ -34,15 +34,15 @@
 {% endif %}
         }
     }
 #else
     /* Python 3 */
 #ifndef PY_NOGIL
     if (_PyDict_HasSplitTable(dict_mp)) {
-        PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+        PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
         assert(result_mp != NULL);
         {{ result }} = (PyObject *)result_mp;
 
         Py_ssize_t size = DK_ENTRIES_SIZE(dict_mp->ma_keys);
 
 {% if per_key_code %}
 #if PYTHON_VERSION < 0x3b0
@@ -111,22 +111,22 @@
     // Fast dictionary copy if it has at least 2/3 space usage. This is most relevant
     // for the DICT_COPY, where it might even be the intention to trigger a shrink with
     // a fresh copy.
     if (dict_mp->ma_values == NULL && IS_COMPACT(dict_mp)) {
         assert(dict_mp->ma_values == NULL);
         assert(dict_mp->ma_keys->dk_refcnt == 1);
 
-        PyDictObject *result_mp = _Nuitka_AllocatePyDictObject();
+        PyDictObject *result_mp = _Nuitka_AllocatePyDictObject(tstate);
         {{ result }} = (PyObject *)result_mp;
 
         result_mp->ma_values = NULL;
         result_mp->ma_used = dict_mp->ma_used;
 
         Py_ssize_t keys_size = _Nuitka_Py_PyDict_KeysSize(dict_mp->ma_keys);
-        result_mp->ma_keys = (PyDictKeysObject *)PyObject_MALLOC(keys_size);
+        result_mp->ma_keys = _Nuitka_AllocatePyDictKeysObject(tstate, keys_size);
         assert(result_mp->ma_keys);
 
         memcpy(result_mp->ma_keys, dict_mp->ma_keys, keys_size);
 
         // Take reference of all keys and values.
 #if PYTHON_VERSION < 0x3b0
         PyDictKeyEntry *entries = DK_ENTRIES(result_mp->ma_keys);
@@ -284,46 +284,50 @@
 #endif
 
 
 static inline PyDictValues *_Nuitka_PyDict_new_values(Py_ssize_t size) {
     Py_ssize_t values_size = sizeof(PyObject *) * size;
 
 #if PYTHON_VERSION < 0x3b0
-    return (PyDictValues *)PyMem_MALLOC(values_size);
+    return (PyDictValues *)NuitkaMem_Malloc(values_size);
 #else
     // With Python3.11 or higher a prefix is allocated too.
     size_t prefix_size = _Py_SIZE_ROUND_UP(size + 2, sizeof(PyObject *));
     size_t n = prefix_size + values_size;
-    uint8_t *mem = (uint8_t *)PyMem_MALLOC(n);
+    uint8_t *mem = (uint8_t *)NuitkaMem_Malloc(n);
 
     assert(mem != NULL);
 
     assert(prefix_size % sizeof(PyObject *) == 0);
     mem[prefix_size - 1] = (uint8_t)prefix_size;
 
     return (PyDictValues *)(mem + prefix_size);
 #endif
 }
 
-#if NUITKA_DICT_HAS_FREELIST
-static struct _Py_dict_state *_Nuitka_Py_get_dict_state(void) {
-    PyInterpreterState *interp = _PyInterpreterState_GET();
-    return &interp->dict_state;
-}
-#endif
-
 #if PYTHON_VERSION >= 0x300
-static PyDictObject *_Nuitka_AllocatePyDictObject(void) {
+static PyDictObject *_Nuitka_AllocatePyDictObject(PyThreadState *tstate) {
     PyDictObject *result_mp;
 
 #if NUITKA_DICT_HAS_FREELIST
-    struct _Py_dict_state *state = _Nuitka_Py_get_dict_state();
+    // This is the CPython name, spell-checker: ignore numfree
+
+#if PYTHON_VERSION < 0x3d0
+    PyDictObject **items = tstate->interp->dict_state.free_list;
+    int *numfree = &tstate->interp->dict_state.numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_dict_freelist *state = &freelists->dicts;
+    PyDictObject **items = state->items;
+    int *numfree = &state->numfree;
+#endif
 
-    if (state->numfree) {
-        result_mp = state->free_list[--state->numfree];
+    if (*numfree) {
+        (*numfree) -= 1;
+        result_mp = items[*numfree];
 
         Nuitka_Py_NewReference((PyObject *)result_mp);
 
         assert(PyDict_CheckExact((PyObject *)result_mp));
         assert(result_mp != NULL);
     } else
 #endif
@@ -331,14 +335,46 @@
         result_mp = (PyDictObject *)Nuitka_GC_New(&PyDict_Type);
     }
 
     return result_mp;
 }
 #endif
 
+#if PYTHON_VERSION >= 0x360
+static PyDictKeysObject *_Nuitka_AllocatePyDictKeysObject(PyThreadState *tstate, Py_ssize_t keys_size) {
+    // CPython names, spell-checker: ignore numfree,dictkeys
+    PyDictKeysObject *dk;
+
+// TODO: Cannot always use cached objects. Need to also consider
+// "log2_size == PyDict_LOG_MINSIZE && unicode" as a criterion,
+// seems it can only be used for the smallest keys type.
+#if NUITKA_DICT_HAS_FREELIST && 0
+#if PYTHON_VERSION < 0x3d0
+    PyDictKeysObject **items = tstate->interp->dict_state.keys_free_list;
+    int *numfree = &tstate->interp->dict_state.keys_numfree;
+#else
+    struct _Py_object_freelists *freelists = _Nuitka_object_freelists_GET(tstate);
+    struct _Py_dictkeys_freelist *state = &freelists->dictkeys;
+    PyDictKeysObject **items = state->items;
+    int *numfree = &state->numfree;
+#endif
+
+    if (*numfree) {
+        (*numfree) -= 1;
+        dk = items[*numfree];
+    } else
+#endif
+    {
+        dk = (PyDictKeysObject *)NuitkaObject_Malloc(keys_size);
+    }
+
+    return dk;
+}
+#endif
+
 #if PYTHON_VERSION >= 0x360 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT)
 static Py_ssize_t _Nuitka_Py_PyDict_KeysSize(PyDictKeysObject *keys) {
 #if PYTHON_VERSION < 0x360
     return sizeof(PyDictKeysObject) + (DK_SIZE(keys)-1) * sizeof(PyDictKeyEntry);
 #elif PYTHON_VERSION < 0x370
     return (sizeof(PyDictKeysObject) -
             Py_MEMBER_SIZE(PyDictKeysObject, dk_indices) +
@@ -353,15 +389,15 @@
     return (sizeof(PyDictKeysObject)
             + ((size_t)1 << keys->dk_log2_index_bytes)
             + DK_USABLE_FRACTION(DK_SIZE(keys)) * entry_size);
 #endif
 }
 #endif
 
-PyObject *DICT_COPY(PyObject *dict_value) {
+PyObject *DICT_COPY(PyThreadState *tstate, PyObject *dict_value) {
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
     return PyDict_Copy(dict_value);
 #else
     PyObject *result;
@@ -375,15 +411,15 @@
 PyObject *DEEP_COPY_DICT(PyThreadState *tstate, PyObject *dict_value) {
     PyObject *result;
 
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
-    result = DICT_COPY(dict_value);
+    result = DICT_COPY(tstate, dict_value);
 
     Py_ssize_t pos = 0;
     PyObject *key, *value;
 
     while (Nuitka_DictNext(dict_value, &pos, &key, &value)) {
         PyObject *dict_value_copy = DEEP_COPY(tstate, value);
 
@@ -395,23 +431,23 @@
     {{ dict_copy_iteration("result", "dict_value", "", "value = DEEP_COPY(tstate, value);", 1) }}
 #endif
 
     return result;
 }
 
 // Helper for function calls with star dict arguments. */
-static PyObject *COPY_DICT_KW(PyObject *dict_value) {
+static PyObject *COPY_DICT_KW(PyThreadState *tstate, PyObject *dict_value) {
     PyObject *result;
     bool had_kw_error = false;
 
 #if _NUITKA_EXPERIMENTAL_DISABLE_DICT_OPT
     CHECK_OBJECT(dict_value);
     assert(PyDict_CheckExact(dict_value));
 
-    result = DICT_COPY(dict_value);
+    result = DICT_COPY(tstate, dict_value);
 
     Py_ssize_t pos = 0;
     PyObject *key, *value;
 
     while (Nuitka_DictNext(dict_value, &pos, &key, &value)) {
         if (unlikely(!checkKeywordType(key))) {
             had_kw_error = true;
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperImportHard.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperImportHard.c.j2`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-{{target.getTypeDecl()}} {{module_code_name}}(void) {
+{{ target.getTypeDecl() }} {{module_code_name}}(void) {
     static PyObject *module_{{module_code_name.lower()}} = NULL;
 
     if (module_{{module_code_name.lower()}} == NULL) {
         module_{{module_code_name.lower()}} = PyImport_ImportModule("{{module_name}}");
 
         if (unlikely(module_{{module_code_name.lower()}} == NULL)) {
 {% if is_stdlib %}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperLongTools.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperLongTools.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperObjectTools.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperObjectTools.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationBinary.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationBinary.c.j2`

 * *Files 3% similar despite different names*

```diff
@@ -35,35 +35,35 @@
     return {{target.getExceptionResultIndicatorValue()}};
 {% if "all" not in props["exits"]["exit_binary_exception"] %}
 #endif
 {% endif %}
 {% endif %}
 {% endmacro %}
 {% if not left.hasTypeSpecializationCode(right, nb_slot, sq_slot) and left.getSameTypeType(right).hasSameTypeOperationSpecializationCode(right.getSameTypeType(left), nb_slot, sq_slot) %}
-static HEDLEY_NEVER_INLINE {{target.getTypeDecl()}} __BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static HEDLEY_NEVER_INLINE {{ target.getTypeDecl() }} __BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
 {% set props = {"exits": {}} %}
 {% if left == object_desc %}
     PyTypeObject *type1 = {{ left.getTypeValueExpression("operand1") }};
 {% endif %}
 {% if right == object_desc %}
     PyTypeObject *type2 = {{ right.getTypeValueExpression("operand2") }};
 {% endif %}
 
     {{ binary_fallback_operation(props, target, left, right, "type1", "type2") }}
 }
 {% endif %}
-static {{target.getTypeDecl()}} _BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} _BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{ left.getCheckValueCode("operand1") }}
     {{ right.getCheckValueCode("operand2") }}
 
 {% if left.type_name == "object" and right.type_name == "object" %}
     {# CPython2 treats integer values with fast path. #}
 #if PYTHON_VERSION < 0x300
     if ({{ left.getIntCheckExpression("operand1") }} && {{ right.getIntCheckExpression("operand2") }}) {
-        {{target.getTypeDecl()}} result;
+        {{ target.getTypeDecl() }} result;
 
         {% set props = {"exits": {}} %}
         {{ int_slot(props, operator, nb_slot, target, int_desc, int_desc, "result", "operand1", "operand2", "exit_result_ok", "exit_result_exception") }}
 
         exit_result_ok:
         return result;
 
@@ -94,15 +94,15 @@
     PyTypeObject *type1 = {{ left.getTypeValueExpression("operand1") }};
 {% endif %}
 {% if right == object_desc %}
     PyTypeObject *type2 = {{ right.getTypeValueExpression("operand2") }};
 {% endif %}
 
     if ({{ left.getTypeIdenticalCheckExpression(right, "type1", "type2") }}) {
-        {{target.getTypeDecl()}} result;
+        {{ target.getTypeDecl() }} result;
 
         {# There is special code for same types. #}
         // return _BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getSameTypeType(right).getHelperCodeName()}}_{{right.getSameTypeType(left).getHelperCodeName()}}(operand1, operand2);
 
         {{ call_binary_slot(props, operator, nb_slot, nb_slot, left.getSameTypeType(right), right.getSameTypeType(left), "result", "operand1", "operand2", "exit_result_ok", "exit_result_exception") }}
 
         exit_result_ok:
@@ -124,15 +124,15 @@
     PyTypeObject *type2 = {{ right.getTypeValueExpression("operand2") }};
 {% endif %}
 
     {{ binary_fallback_operation(props, target, left, right, "type1", "type2") }}
 {% endif %}
 }
 
-{{target.getTypeDecl()}} BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+{{ target.getTypeDecl() }} BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     return _BINARY_OPERATION_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}(operand1, operand2);
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
 {#                                                                              #}
 {#     Licensed under the Apache License, Version 2.0 (the "License");          #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparison.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparison.c.j2`

 * *Files 4% similar despite different names*

```diff
@@ -12,16 +12,16 @@
 #endif
 {% endif %}
 
 {% if op_code in ("EQ", "GE", "LE", "NE") and left.type_name == "object" and right.type_name == "object" %}
     // Quick path for avoidable checks, compatible with CPython.
     if (operand1 == operand2 && {{left.getMostSpecificType(right).getSaneTypeCheckCode("operand1")}}) {
         bool r = {% if op_code == "NE" %} false {% else %} true {%endif %};
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
 {% endif %}
 
 #if PYTHON_VERSION < 0x300
     if (unlikely(Py_EnterRecursiveCall((char *)" in cmp"))) {
         return {{target.getExceptionResultIndicatorValue()}};
@@ -57,15 +57,15 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 {{ target.getReturnFromObjectExpressionCode("result") }}
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
 
         // No rich comparison worked, but maybe compare works.
 {% if left.getMostSpecificType(right) == left %}
         cmpfunc fcmp = {{left.getSlotValueExpression("type1", "tp_compare")}};
 {% else %}
         cmpfunc fcmp = {{right.getSlotValueExpression("type2", "tp_compare")}};
@@ -101,16 +101,16 @@
                 c = c >= 0;
                 break;
             default:
                 NUITKA_CANNOT_GET_HERE("wrong op_code");
             }
 
             bool r = c != 0;
-            {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-            {{target.getTakeReferenceStatement("result")}}
+            {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+            {{ target.getTakeReferenceStatement("result", immortal=True) }}
             return result;
         }
     }
 
     // Fast path was not successful or not taken
     richcmpfunc f;
 
@@ -122,42 +122,42 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 {{ target.getReturnFromObjectExpressionCode("result") }}
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = {{left.getSlotValueExpression("type1", "tp_richcompare")}};
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_{{op_code}});
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             {{ target.getReturnFromObjectExpressionCode("result") }}
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     f = {{right.getSlotValueExpression("type2", "tp_richcompare")}};
     if (f != NULL) {
         PyObject *result = (*f)(operand2, operand1, Py_{{reversed_args_op_code}});
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             {{ target.getReturnFromObjectExpressionCode("result") }}
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     int c;
 
     if ({{left.getInstanceCheckCode("operand1")}}) {
         cmpfunc fcmp = {{left.getSlotValueExpression("type1", "tp_compare")}};
         c = (*fcmp)(operand1, operand2);
@@ -236,16 +236,16 @@
         break;
     case Py_GE:
         c = c >= 0;
         break;
     }
 
     bool r = c != 0;
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 #else
     bool checked_reverse_op = false;
     richcmpfunc f;
 
     if ({{left.getTypeNonIdenticalCheckExpression(right, "type1", "type2")}} && {{ left.getTypeSubTypeCheckExpression(right, "type2", "type1") }}) {
         f = {{right.getSlotValueExpression("type2", "tp_richcompare")}};
@@ -257,72 +257,72 @@
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 {{ target.getReturnFromObjectExpressionCode("result") }}
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     f = {{left.getSlotValueExpression("type1", "tp_richcompare")}};
 
     if (f != NULL) {
         PyObject *result = (*f)(operand1, operand2, Py_{{op_code}});
 
         if (result != Py_NotImplemented) {
             Py_LeaveRecursiveCall();
 
             {{ target.getReturnFromObjectExpressionCode("result") }}
         }
 
-        Py_DECREF(result);
+        Py_DECREF_IMMORTAL(result);
     }
 
     if (checked_reverse_op == false) {
         f = {{right.getSlotValueExpression("type2", "tp_richcompare")}};
 
         if (f != NULL) {
             PyObject *result = (*f)(operand2, operand1, Py_{{reversed_args_op_code}});
 
             if (result != Py_NotImplemented) {
                 Py_LeaveRecursiveCall();
 
                 {{ target.getReturnFromObjectExpressionCode("result") }}
             }
 
-            Py_DECREF(result);
+            Py_DECREF_IMMORTAL(result);
         }
     }
 
     Py_LeaveRecursiveCall();
 
     // If it is not implemented, do pointer identity checks as "==" and "!=" and
     // otherwise give an error
     switch(Py_{{op_code}}) {
     case Py_EQ: {
         bool r = operand1 == operand2;
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
     case Py_NE: {
         bool r = operand1 != operand2;
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
     default:
         {{target.getReturnUnorderableTypeErrorCode(operator, left, right, "type1", "type2")}}
     }
 #endif
 {% endif %}
 {% endmacro %}
-{{target.getTypeDecl()}} RICH_COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+{{ target.getTypeDecl() }} RICH_COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
 
 {# Divert to more special implementation immediately if possible. #}
 {% if left.getTypeComparisonSpecializationCode(right, op_code, target, "operand1", "operand2") %}
 {% if left != right and object_desc in (left, right) %}
     if ({{left.getTypeIdenticalCheckExpression(right, left.getTypeValueExpression("operand1"), right.getTypeValueExpression("operand2"))}}) {
         {{left.getTypeComparisonSpecializationCode(right, op_code, target, "operand1", "operand2")}}
     }
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonBytes.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonBytes.c.j2`

 * *Files 21% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{left.getCheckValueCode("operand1")}}
     {{right.getCheckValueCode("operand2")}}
 
     PyBytesObject *a = (PyBytesObject *)operand1;
     PyBytesObject *b = (PyBytesObject *)operand2;
 
     // Same object has fast path for all operations.
@@ -12,16 +12,16 @@
 {% if operand in ("==", ">=", "<=") %}
         bool r = true;
 {% else %}
         bool r = false;
 {% endif %}
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
 
     Py_ssize_t len_a = Py_SIZE(operand1);
     Py_ssize_t len_b = Py_SIZE(operand2);
 
 {% if operand in ("==", "!=") %}
@@ -30,39 +30,39 @@
 {% if operand == "==" %}
         bool r = false;
 {% else %}
         bool r = true;
 {% endif %}
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     } else {
         if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
 {% if operand == "==" %}
             bool r = true;
 {% else %}
             bool r = false;
 {% endif %}
 
             // Convert to target type.
-            {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-            {{target.getTakeReferenceStatement("result")}}
+            {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+            {{ target.getTakeReferenceStatement("result", immortal=True) }}
             return result;
         } else {
 {% if operand == "==" %}
             bool r = false;
 {% else %}
             bool r = true;
 {% endif %}
 
             // Convert to target type.
-            {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-            {{target.getTakeReferenceStatement("result")}}
+            {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+            {{ target.getTakeReferenceStatement("result", immortal=True) }}
             return result;
         }
     }
 {% else %}
 
     Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
     int c;
@@ -88,16 +88,16 @@
 {% elif operand == ">" %}
     c = c > 0;
 {% elif operand == ">=" %}
     c = c >= 0;
 {% endif %}
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("c != 0")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("c != 0")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 
 {% endif %}
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonFloat.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonFloat.c.j2`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{ left.getCheckValueCode("operand1") }}
     {{ right.getCheckValueCode("operand2") }}
 
     const double a = {{ left.getAsDoubleValueExpression("operand1") }};
     const double b = {{ right.getAsDoubleValueExpression("operand2") }};
 
     bool r = a {{operand}} b;
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
 {#                                                                              #}
 {#     Licensed under the Apache License, Version 2.0 (the "License");          #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonInt.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonInt.c.j2`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{left.getCheckValueCode("operand1")}}
     {{right.getCheckValueCode("operand2")}}
 
     {# This is supposed to be Python2 code #}
     const long a = {{left.getAsLongValueExpression("operand1")}};
     const long b = {{right.getAsLongValueExpression("operand2")}};
 
     bool r = a {{operand}} b;
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
 {#                                                                              #}
 {#     Licensed under the Apache License, Version 2.0 (the "License");          #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonList.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonList.c.j2`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{left.getCheckValueCode("operand1")}}
     {{right.getCheckValueCode("operand2")}}
 
     {# TODO: Unify with tuple, seems the iteration part is only difference #}
     PyListObject *a = (PyListObject *)operand1;
     PyListObject *b = (PyListObject *)operand2;
 
@@ -14,16 +14,16 @@
 {% if operand == "==" %}
         bool r = false;
 {% else %}
         bool r = true;
 {% endif %}
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
 {% endif %}
 
 {# Find the first non-identical object. #}
 {% if operand not in ("==", "!=") %}
     bool found = false;
@@ -59,16 +59,16 @@
 
 {# If size mismatches, but all is equal at the start, compare sizes to order lists. #}
 {% if operand not in ("==", "!=") %}
     if (found == false) {
         bool r = Py_SIZE(a) {{operand}} Py_SIZE(b);
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
 
     return RICH_COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
 {% else %}
 {% if operand == "==" %}
     bool r;
@@ -84,16 +84,16 @@
         r = Py_SIZE(a) {{operand}} Py_SIZE(b);
     } else {
         r = res == NUITKA_BOOL_FALSE;
     }
 {% endif %}
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 
 {% endif %}
 
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonLong.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonLong.c.j2`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
 {% from 'HelperLongTools.c.j2' import declare_long_access with context %}
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{ left.getCheckValueCode("operand1") }}
     {{ right.getCheckValueCode("operand2") }}
 
     {{ declare_long_access(left, "operand1") }}
     {{ declare_long_access(right, "operand2") }}
 
     bool r;
@@ -132,16 +132,16 @@
         }
     }
 {% else %}
 # error unknown operand {{operand}}
 {% endif %}
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
 {#                                                                              #}
 {#     Licensed under the Apache License, Version 2.0 (the "License");          #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonStr.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonTuple.c.j2`

 * *Files 21% similar despite different names*

```diff
@@ -1,106 +1,90 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{left.getCheckValueCode("operand1")}}
     {{right.getCheckValueCode("operand2")}}
 
-    PyStringObject *a = (PyStringObject *)operand1;
-    PyStringObject *b = (PyStringObject *)operand2;
+    PyTupleObject *a = (PyTupleObject *)operand1;
+    PyTupleObject *b = (PyTupleObject *)operand2;
 
-    // Same object has fast path for all operations.
-    if (operand1 == operand2) {
-{% if operand in ("==", ">=", "<=") %}
-        bool r = true;
-{% else %}
-        bool r = false;
-{% endif %}
-
-        // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
-        return result;
-    }
-
-    Py_ssize_t len_a = Py_SIZE(operand1);
-    Py_ssize_t len_b = Py_SIZE(operand2);
+    Py_ssize_t len_a = Py_SIZE(a);
+    Py_ssize_t len_b = Py_SIZE(b);
 
+{# Shortcut for equality, driven by length check. #}
 {% if operand in ("==", "!=") %}
     if (len_a != len_b) {
-        {# Shortcut for equality/inequality, driven by length divergence. #}
 {% if operand == "==" %}
         bool r = false;
 {% else %}
         bool r = true;
 {% endif %}
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
-    } else {
-        if ((a->ob_sval[0] == b->ob_sval[0]) && (memcmp(a->ob_sval, b->ob_sval, len_a) == 0)) {
-{% if operand == "==" %}
-            bool r = true;
-{% else %}
-            bool r = false;
+    }
 {% endif %}
 
-            // Convert to target type.
-            {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-            {{target.getTakeReferenceStatement("result")}}
-            return result;
-        } else {
-{% if operand == "==" %}
-            bool r = false;
-{% else %}
-            bool r = true;
-{% endif %}
+{# Find the first non-identical object. #}
+{% if operand not in ("==", "!=") %}
+    bool found = false;
+{% endif %}
+    nuitka_bool res = NUITKA_BOOL_TRUE;
+
+    Py_ssize_t i;
+    for (i = 0; i < len_a && i < len_b; i++) {
+        PyObject *aa = a->ob_item[i];
+        PyObject *bb = b->ob_item[i];
 
-            // Convert to target type.
-            {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-            {{target.getTakeReferenceStatement("result")}}
-            return result;
+        if (aa == bb) {
+            continue;
         }
-    }
-{% else %}
 
-    Py_ssize_t min_len = (len_a < len_b) ? len_a : len_b;
-    int c;
+        res = RICH_COMPARE_EQ_NBOOL_OBJECT_OBJECT(aa, bb);
 
-    if (min_len > 0) {
-        c = Py_CHARMASK(*a->ob_sval) - Py_CHARMASK(*b->ob_sval);
+        if (res == NUITKA_BOOL_EXCEPTION) {
+            return {{target.getExceptionResultIndicatorValue()}};
+        }
 
-        if (c==0) {
-            c = memcmp(a->ob_sval, b->ob_sval, min_len);
+        if (res == NUITKA_BOOL_FALSE) {
+{% if operand not in ("==", "!=") %}
+            found = true;
+{% endif %}
+            break;
         }
-    } else {
-        c = 0;
     }
 
-    if (c == 0) {
-        c = (len_a < len_b) ? -1 : (len_a > len_b) ? 1 : 0;
+{# If size mismatches, but all is equal at the start, compare sizes to order tuples. #}
+{% if operand not in ("==", "!=") %}
+    if (found == false) {
+        bool r = len_a {{operand}} len_b;
+
+        // Convert to target type.
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
+        return result;
     }
 
-{% if operand == "<" %}
-    c = c < 0;
-{% elif operand == "<=" %}
-    c = c <= 0;
-{% elif operand == ">" %}
-    c = c > 0;
-{% elif operand == ">=" %}
-    c = c >= 0;
+    return RICH_COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_OBJECT_OBJECT(a->ob_item[i], b->ob_item[i]);
+{% else %}
+{% if operand == "==" %}
+    bool r = res == NUITKA_BOOL_TRUE;
+{% else %}
+    bool r = res == NUITKA_BOOL_FALSE;
 {% endif %}
 
     // Convert to target type.
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("c != 0")}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 
 {% endif %}
+
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
 {#                                                                              #}
 {#     Licensed under the Apache License, Version 2.0 (the "License");          #}
 {#     you may not use this file except in compliance with the License.         #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationComparisonUnicode.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationComparisonUnicode.c.j2`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
-static {{target.getTypeDecl()}} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
+static {{ target.getTypeDecl() }} COMPARE_{{op_code}}_{{target.getHelperCodeName()}}_{{left.getHelperCodeName()}}_{{right.getHelperCodeName()}}({{left.getVariableDecl("operand1")}}, {{right.getVariableDecl("operand2")}}) {
     {{left.getCheckValueCode("operand1")}}
     {{right.getCheckValueCode("operand2")}}
 
     PyUnicodeObject *a = (PyUnicodeObject *)operand1;
     PyUnicodeObject *b = (PyUnicodeObject *)operand2;
 
     // Same object has fast path for all operations.
@@ -12,16 +12,16 @@
 {% if operand in ("==", ">=", "<=") %}
         bool r = true;
 {% else %}
         bool r = false;
 {% endif %}
 
         // Convert to target type.
-        {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r")}};
-        {{target.getTakeReferenceStatement("result")}}
+        {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r")}};
+        {{ target.getTakeReferenceStatement("result", immortal=True) }}
         return result;
     }
 
 {% if operand in ("==", "!=") %}
 #if PYTHON_VERSION >= 0x300
     bool r;
 
@@ -56,16 +56,16 @@
             const void *data2 = PyUnicode_DATA(b);
 
             int cmp = memcmp(data1, data2, len * kind1);
             r = (cmp == 0);
         }
     }
 
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r == " + ("true" if operand == "==" else "false"))}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r == " + ("true" if operand == "==" else "false"))}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 #else
     bool r;
 
     Py_ssize_t len = PyUnicode_GET_LENGTH(a);
     if (PyUnicode_GET_LENGTH(b) != len) {
         r = false;
@@ -73,31 +73,31 @@
         const Py_UNICODE *data1 = a->str;
         const Py_UNICODE *data2 = b->str;
 
         int cmp = memcmp(data1, data2, len * sizeof(Py_UNICODE));
         r = (cmp == 0);
     }
 
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r == " + ("true" if operand == "==" else "false"))}};
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r == " + ("true" if operand == "==" else "false"))}};
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 #endif
 {% else %}
     {# TODO: Make these specialized for Python versions, if only because we have no
        way of going to C bool quickly otherwise #}
     PyObject *r = PyUnicode_RichCompare((PyObject *)a, (PyObject *)b, Py_{{op_code}});
     CHECK_OBJECT(r);
 
 {% if target.type_name == "object" %}
     return r;
 {% else %}
     // Convert to target type if necessary
-    {{target.getTypeDecl()}} result = {{target.getToValueFromBoolExpression("r == Py_True")}};
-    Py_DECREF(r);
-    {{target.getTakeReferenceStatement("result")}}
+    {{ target.getTypeDecl() }} result = {{target.getToValueFromBoolExpression("r == Py_True")}};
+    Py_DECREF_IMMORTAL(r);
+    {{ target.getTakeReferenceStatement("result", immortal=True) }}
     return result;
 {% endif %}
 {% endif %}
 }
 
 {#     Part of "Nuitka", an optimizing Python compiler that is compatible and   #}
 {#     integrates with CPython, but also works on its own.                      #}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperOperationInplace.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperOperationInplace.c.j2`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     if (islot != NULL) {
         PyObject *x = {{ left.getSlotCallExpression(nb_inplace_slot, "islot", "*operand1", "operand2") }};
 
         if (x != Py_NotImplemented) {
             {{ goto_exit(props, "exit_inplace_result_object", "x") }}
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 {% else %}
     // No inplace number slot {{ nb_inplace_slot }} available for this type.
 {% endif %}
 
     {
         {{ binary_operation(props, operator, nb_slot, left, right, "type1", "type2", "*operand1", "operand2", "exit_inplace_result_object", "exit_inplace_result_cbool_ok", "exit_inplace_result_nbool", "exit_inplace_exception") }}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsBinary.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsBinary.c.j2`

 * *Files 2% similar despite different names*

```diff
@@ -167,39 +167,39 @@
             if ({{ left.getTypeSubTypeCheckExpression(right, type2, type1) }}) {
                 PyObject *x = {{ left.getSlotCallExpression(nb_slot, "slot2", operand1, operand2) }};
 
                 if (x != Py_NotImplemented) {
                     {{ goto_exit(props, exit_result_object, "x") }}
                 }
 
-                Py_DECREF(x);
+                Py_DECREF_IMMORTAL(x);
                 slot2 = NULL;
             }
         }
 
 {% endif %}
         PyObject *x = {{ left.getSlotCallExpression(nb_slot, "slot1", operand1, operand2) }};
 
         if (x != Py_NotImplemented) {
             {{ goto_exit(props, exit_result_object, "x") }}
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 {% endif %}
 
 {% if slot2_relevant %}
     if (slot2 != NULL) {
         PyObject *x = {{ left.getSlotCallExpression(nb_slot, "slot2", operand1, operand2) }};
 
         if (x != Py_NotImplemented) {
             {{ goto_exit(props, exit_result_object, "x") }}
         }
 
-        Py_DECREF(x);
+        Py_DECREF_IMMORTAL(x);
     }
 {% endif %}
 
 {% if operator != "@" %}
 {% if not left.isKnownToNotCoerce(right) or not right.isKnownToNotCoerce(left) %}
 #if PYTHON_VERSION < 0x300
     if (!{{ left.getNewStyleNumberTypeCheckExpression(type1) }} || !{{ right.getNewStyleNumberTypeCheckExpression(type2)}} ) {
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsBytes.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsBytes.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsCommon.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsCommon.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsFloat.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsFloat.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsInt.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsInt.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsList.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsTuple.c.j2`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,41 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
 {% from 'HelperSlotsCommon.c.j2' import goto_exit %}
 
-{% macro list_slot(props, operator, nb_slot, target, left, right, result, operand1, operand2, exit_result_ok, exit_result_exception) %}
+{% macro tuple_slot(props, operator, nb_slot, target, left, right, result, operand1, operand2, exit_result_ok, exit_result_exception) %}
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
     {# TODO: Could and should in-line and specialize this per slot too. #}
 {% if nb_slot == "nb_add" %}
-{% if left.type_name == "list" == right.type_name %}
-    PyObject *x = LIST_CONCAT({{ operand1 }}, {{ operand2 }});
+{% if left.type_name == "tuple" == right.type_name %}
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = TUPLE_CONCAT(tstate, {{ operand1 }}, {{ operand2 }});
 {% else %}
-    PyObject *x = {{ left.getSlotCallExpression("sq_concat", "PyList_Type.tp_as_sequence->sq_concat", operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression("sq_concat", "PyTuple_Type.tp_as_sequence->sq_concat", operand1, operand2) }};
 {% endif %}
 {% elif nb_slot == "nb_multiply" %}
-    PyObject *x = {{ left.getSlotCallExpression("sq_repeat", "PyList_Type.tp_as_sequence->sq_repeat", operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression("sq_repeat", "PyTuple_Type.tp_as_sequence->sq_repeat", operand1, operand2) }};
 {% else %}
-    PyObject *x = {{ left.getSlotCallExpression(nb_slot, "PyList_Type.tp_as_number->" + nb_slot, operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression(nb_slot, "PyTuple_Type.tp_as_number->" + nb_slot, operand1, operand2) }};
 {% endif %}
-    assert(x != Py_NotImplemented);
 
+    assert(x != Py_NotImplemented);
     {{ goto_exit(props, "exit_result_object", "x") }}
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         {{ goto_exit(props, exit_result_exception) }}
     }
 {% if target %}
     {{ target.getAssignFromObjectExpressionCode(result, "obj_result") }}
 {% else %}
-
     {# TODO: Check the reference we were handed down and do it in-place really. #}
     // We got an object handed, that we have to release.
     Py_DECREF({{ operand1 }});
 
     {{ operand1 }} = obj_result;
 {% endif %}
     {{ goto_exit(props, exit_result_ok) }}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsLong.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsLong.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsSet.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsSet.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsStr.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsStr.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsTuple.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsList.c.j2`

 * *Files 6% similar despite different names*

```diff
@@ -1,38 +1,42 @@
 {#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file #}
 
 {% from 'HelperSlotsCommon.c.j2' import goto_exit %}
 
-{% macro tuple_slot(props, operator, nb_slot, target, left, right, result, operand1, operand2, exit_result_ok, exit_result_exception) %}
+{% macro list_slot(props, operator, nb_slot, target, left, right, result, operand1, operand2, exit_result_ok, exit_result_exception) %}
     // Not every code path will make use of all possible results.
     NUITKA_MAY_BE_UNUSED PyObject *obj_result;
 
     {# TODO: Could and should in-line and specialize this per slot too. #}
 {% if nb_slot == "nb_add" %}
-{% if left.type_name == "tuple" == right.type_name %}
-    PyObject *x = TUPLE_CONCAT({{ operand1 }}, {{ operand2 }});
+{% if left.type_name == "list" == right.type_name %}
+    // TODO: Have this more globally passed in
+    PyThreadState *tstate = PyThreadState_GET();
+
+    PyObject *x = LIST_CONCAT(tstate, {{ operand1 }}, {{ operand2 }});
 {% else %}
-    PyObject *x = {{ left.getSlotCallExpression("sq_concat", "PyTuple_Type.tp_as_sequence->sq_concat", operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression("sq_concat", "PyList_Type.tp_as_sequence->sq_concat", operand1, operand2) }};
 {% endif %}
 {% elif nb_slot == "nb_multiply" %}
-    PyObject *x = {{ left.getSlotCallExpression("sq_repeat", "PyTuple_Type.tp_as_sequence->sq_repeat", operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression("sq_repeat", "PyList_Type.tp_as_sequence->sq_repeat", operand1, operand2) }};
 {% else %}
-    PyObject *x = {{ left.getSlotCallExpression(nb_slot, "PyTuple_Type.tp_as_number->" + nb_slot, operand1, operand2) }};
+    PyObject *x = {{ left.getSlotCallExpression(nb_slot, "PyList_Type.tp_as_number->" + nb_slot, operand1, operand2) }};
 {% endif %}
-
     assert(x != Py_NotImplemented);
+
     {{ goto_exit(props, "exit_result_object", "x") }}
 
 exit_result_object:
     if (unlikely(obj_result == NULL)) {
         {{ goto_exit(props, exit_result_exception) }}
     }
 {% if target %}
     {{ target.getAssignFromObjectExpressionCode(result, "obj_result") }}
 {% else %}
+
     {# TODO: Check the reference we were handed down and do it in-place really. #}
     // We got an object handed, that we have to release.
     Py_DECREF({{ operand1 }});
 
     {{ operand1 }} = obj_result;
 {% endif %}
     {{ goto_exit(props, exit_result_ok) }}
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/code_generation/templates_c/HelperSlotsUnicode.c.j2` & `nuitka_winsvc-2.3/nuitka/code_generation/templates_c/HelperSlotsUnicode.c.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/containers/Namedtuples.py` & `nuitka_winsvc-2.3/nuitka/containers/Namedtuples.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/containers/OrderedDicts.py` & `nuitka_winsvc-2.3/nuitka/containers/OrderedDicts.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/containers/OrderedSets.py` & `nuitka_winsvc-2.3/nuitka/containers/OrderedSets.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/containers/OrderedSetsFallback.py` & `nuitka_winsvc-2.3/nuitka/containers/OrderedSetsFallback.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/containers/__init__.py` & `nuitka_winsvc-2.3/nuitka/containers/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/distutils/Build.py` & `nuitka_winsvc-2.3/nuitka/distutils/Build.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/distutils/DistutilCommands.py` & `nuitka_winsvc-2.3/nuitka/distutils/DistutilCommands.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/distutils/__init__.py` & `nuitka_winsvc-2.3/nuitka/distutils/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/finalizations/Finalization.py` & `nuitka_winsvc-2.3/nuitka/finalizations/Finalization.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/finalizations/FinalizeMarkups.py` & `nuitka_winsvc-2.3/nuitka/finalizations/FinalizeMarkups.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,25 +14,17 @@
 
 Set a flag on re-raises of exceptions if they can be simple throws or if they
 are in another context.
 
 """
 
 from nuitka import Tracing
-from nuitka.__past__ import unicode
-from nuitka.containers.OrderedSets import OrderedSet
 from nuitka.PythonVersions import python_version
 from nuitka.tree.Operations import VisitorNoopMixin
 
-imported_names = OrderedSet()
-
-
-def getImportedNames():
-    return imported_names
-
 
 class FinalizeMarkups(VisitorNoopMixin):
     def onEnterNode(self, node):
         try:
             self._onEnterNode(node)
         except Exception:
             Tracing.printError(
@@ -62,24 +54,14 @@
                 or search.isExpressionAsyncgenObjectBody()
             ):
                 if in_tried_block:
                     search.markAsNeedsGeneratorReturnHandling(2)
                 else:
                     search.markAsNeedsGeneratorReturnHandling(1)
 
-        if node.isExpressionBuiltinImport() and node.follow_attempted:
-            module_name = node.subnode_name
-
-            if module_name.isCompileTimeConstant():
-                imported_module_name = module_name.getCompileTimeConstant()
-
-                if type(imported_module_name) in (str, unicode):
-                    if imported_module_name:
-                        imported_names.add(imported_module_name)
-
         if node.isExpressionFunctionCreation():
             if (
                 not node.getParent().isExpressionFunctionCall()
                 or node.getParent().subnode_function is not node
             ):
                 node.subnode_function_ref.getFunctionBody().markAsNeedsCreation()
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/finalizations/__init__.py` & `nuitka_winsvc-2.3/nuitka/finalizations/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/DependsExe.py` & `nuitka_winsvc-2.3/nuitka/freezer/DependsExe.py`

 * *Files 4% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from nuitka.utils.Execution import executeProcess, withEnvironmentVarOverridden
 from nuitka.utils.FileOperations import (
     deleteFile,
     getExternalUsePath,
     getFileContentByLine,
     getWindowsLongPathName,
     isFilenameBelowPath,
+    isFilesystemEncodable,
     putTextFileContents,
     withFileLock,
 )
 from nuitka.utils.SharedLibraries import getWindowsRunningProcessDLLPaths
 from nuitka.utils.Utils import getArchitecture
 
 
@@ -156,18 +157,22 @@
 
 
 def parseDependsExeOutput(filename):
     return _parseDependsExeOutput2(getFileContentByLine(filename, encoding="latin1"))
 
 
 def detectDLLsWithDependencyWalker(binary_filename, source_dir, scan_dirs):
-    dwp_filename = os.path.join(source_dir, os.path.basename(binary_filename) + ".dwp")
-    output_filename = os.path.join(
-        source_dir, os.path.basename(binary_filename) + ".depends"
-    )
+    source_dir = getExternalUsePath(source_dir)
+    temp_base_name = os.path.basename(binary_filename)
+
+    if not isFilesystemEncodable(temp_base_name):
+        temp_base_name = "dependency_walker"
+
+    dwp_filename = os.path.join(source_dir, temp_base_name + ".dwp")
+    output_filename = os.path.join(source_dir, temp_base_name + ".depends")
 
     # User query should only happen once if at all.
     with withFileLock(
         "Finding out dependency walker path and creating DWP file for %s"
         % binary_filename
     ):
         depends_exe = getDependsExePath()
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesCommon.py` & `nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesCommon.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesMacOS.py` & `nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesMacOS.py`

 * *Files 1% similar despite different names*

```diff
@@ -171,15 +171,15 @@
             library_name = path[7:]
 
             for rpath in rpaths:
                 if os.path.exists(os.path.join(rpath, library_name)):
                     resolved_path = os.path.normpath(os.path.join(rpath, path[7:]))
                     break
             else:
-                # These have become virtual in later macOS.
+                # These have become virtual in later macOS, spell-checker: ignore libz
                 if library_name in ("libc++.1.dylib", "libz.1.dylib"):
                     continue
 
                 # This is only a guess, might be missing package specific directories.
                 resolved_path = os.path.normpath(os.path.join(original_dir, path[7:]))
         elif path.startswith("@loader_path/"):
             resolved_path = os.path.normpath(os.path.join(original_dir, path[13:]))
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesPosix.py` & `nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesPosix.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/DllDependenciesWin32.py` & `nuitka_winsvc-2.3/nuitka/freezer/DllDependenciesWin32.py`

 * *Files 2% similar despite different names*

```diff
@@ -96,15 +96,15 @@
     # pylint: disable=too-many-branches
 
     cache_key = package_name, original_dir
 
     if cache_key in _scan_dir_cache:
         return _scan_dir_cache[cache_key]
 
-    scan_dirs = [getSystemPrefixPath()]
+    scan_dirs = [os.path.dirname(sys.executable), getSystemPrefixPath()]
 
     if package_name is not None:
         scan_dirs.extend(getPackageSpecificDLLDirectories(package_name))
 
     if original_dir is not None:
         scan_dirs.append(original_dir)
         scan_dirs.extend(getSubDirectoriesWithDlls(original_dir))
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/ImportDetection.py` & `nuitka_winsvc-2.3/nuitka/freezer/ImportDetection.py`

 * *Files 0% similar despite different names*

```diff
@@ -206,14 +206,15 @@
     # Not for startup.
     for non_locale_encoding in (
         "bz2_codec",
         "idna",
         "base64_codec",
         "hex_codec",
         "rot_13",
+        "punycode",
     ):
         if non_locale_encoding in encoding_names:
             encoding_names.remove(non_locale_encoding)
 
     import_code = ";".join(
         "import encodings.%s" % encoding_name
         for encoding_name in sorted(encoding_names)
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/IncludedDataFiles.py` & `nuitka_winsvc-2.3/nuitka/freezer/IncludedDataFiles.py`

 * *Files 2% similar despite different names*

```diff
@@ -223,21 +223,30 @@
     tracer,
     tags,
     ignore_dirs=(),
     ignore_filenames=(),
     ignore_suffixes=(),
     only_suffixes=(),
     normalize=True,
+    raw=False,
 ):
     assert isRelativePath(dest_path), dest_path
     assert os.path.isdir(source_path), source_path
 
-    ignore_dirs = tuple(ignore_dirs) + default_ignored_dirs
-    ignore_filenames = tuple(ignore_filenames) + default_ignored_filenames
-    ignore_suffixes = tuple(ignore_suffixes) + default_ignored_suffixes
+    ignore_dirs = tuple(ignore_dirs)
+    if not raw:
+        ignore_dirs += default_ignored_dirs
+
+    ignore_filenames = tuple(ignore_filenames)
+    if not raw:
+        ignore_filenames += default_ignored_filenames
+
+    ignore_suffixes = tuple(ignore_suffixes)
+    if not raw:
+        ignore_suffixes += default_ignored_suffixes
 
     for filename in getFileList(
         source_path,
         ignore_dirs=ignore_dirs,
         ignore_filenames=ignore_filenames,
         ignore_suffixes=ignore_suffixes,
         only_suffixes=only_suffixes,
@@ -251,15 +260,15 @@
             source_path=filename,
             dest_path=filename_dest,
             reason=reason,
             tracer=tracer,
             tags=tags,
         )
 
-        included_datafile.tags.add("data-dir-contents")
+        included_datafile.tags.add("raw-dir-contents" if raw else "data-dir-contents")
 
         yield included_datafile
 
 
 def makeIncludedGeneratedDataFile(data, dest_path, reason, tracer, tags):
     assert isRelativePath(dest_path), dest_path
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/IncludedEntryPoints.py` & `nuitka_winsvc-2.3/nuitka/freezer/IncludedEntryPoints.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/Onefile.py` & `nuitka_winsvc-2.3/nuitka/freezer/Onefile.py`

 * *Files 1% similar despite different names*

```diff
@@ -57,15 +57,14 @@
 def _runOnefileScons(onefile_compression, onefile_archive):
     source_dir = OutputDirectories.getSourceDirectoryPath(onefile=True)
 
     # Let plugins do their thing for onefile mode too.
     Plugins.writeExtraCodeFiles(onefile=True)
 
     options = {
-        "result_name": OutputDirectories.getResultBasePath(onefile=True),
         "result_exe": OutputDirectories.getResultFullpath(onefile=True),
         "source_dir": source_dir,
         "debug_mode": asBoolStr(Options.is_debug),
         "trace_mode": asBoolStr(Options.shallTraceExecution()),
         "onefile_splash_screen": asBoolStr(
             Options.getWindowsSplashScreen() is not None
         ),
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/Standalone.py` & `nuitka_winsvc-2.3/nuitka/freezer/Standalone.py`

 * *Files 0% similar despite different names*

```diff
@@ -247,15 +247,17 @@
             original_filename=standalone_entry_point.source_path,
             binary_filename=standalone_entry_point.source_path,
             package_name=standalone_entry_point.package_name,
             use_cache=not shallNotUseDependsExeCachedResults(),
             update_cache=not shallNotStoreDependsExeCachedResults(),
         )
     except NuitkaForbiddenDLLEncounter:
-        inclusion_logger.info("Not including forbidden DLL '%s'." % binary_filename)
+        inclusion_logger.info(
+            "Not including due to forbidden DLL '%s'." % binary_filename
+        )
     else:
         # Plugins generally decide if they allow dependencies from the outside
         # based on the package name.
 
         if standalone_entry_point.module_name is not None and used_dlls:
             module_name, module_filename, _kind, finding = locateModule(
                 standalone_entry_point.module_name, parent_package=None, level=0
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/freezer/__init__.py` & `nuitka_winsvc-2.3/nuitka/freezer/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/IgnoreListing.py` & `nuitka_winsvc-2.3/nuitka/importing/IgnoreListing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/ImportCache.py` & `nuitka_winsvc-2.3/nuitka/importing/ImportCache.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,23 +10,24 @@
 and then later active again, via another import, and in this case, we should
 not start anew, but reuse what we already found out about it.
 """
 
 import os
 
 from nuitka.plugins.Plugins import Plugins
+from nuitka.utils.Importing import hasPackageDirFilename
 
 imported_modules = {}
 imported_by_name = {}
 
 
 def addImportedModule(imported_module):
     module_filename = os.path.abspath(imported_module.getFilename())
 
-    if os.path.basename(module_filename) == "__init__.py":
+    if hasPackageDirFilename(module_filename):
         module_filename = os.path.dirname(module_filename)
 
     key = (module_filename, imported_module.getFullName())
 
     if key in imported_modules:
         assert imported_module is imported_modules[key], key
     else:
@@ -51,15 +52,15 @@
     if module_filename is None:
         # pyi deps only
         return getImportedModuleByName(full_name)
 
     # For caching we use absolute paths only.
     module_filename = os.path.abspath(module_filename)
 
-    if os.path.basename(module_filename) == "__init__.py":
+    if hasPackageDirFilename(module_filename):
         module_filename = os.path.dirname(module_filename)
 
     # KeyError is valid result.
     return imported_modules[module_filename, full_name]
 
 
 def replaceImportedModule(old, new):
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/ImportResolving.py` & `nuitka_winsvc-2.3/nuitka/importing/ImportResolving.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/Importing.py` & `nuitka_winsvc-2.3/nuitka/importing/Importing.py`

 * *Files 2% similar despite different names*

```diff
@@ -37,14 +37,15 @@
 from nuitka.tree.ReformulationMultidist import locateMultidistModule
 from nuitka.utils.AppDirs import getCacheDir
 from nuitka.utils.FileOperations import listDir, removeDirectory
 from nuitka.utils.Hashing import getFileContentsHash
 from nuitka.utils.Importing import (
     builtin_module_names,
     getModuleFilenameSuffixes,
+    getPackageDirFilename,
     getSharedLibrarySuffixes,
     isBuiltinModuleName,
 )
 from nuitka.utils.ModuleNames import ModuleName
 from nuitka.utils.SharedLibraries import (
     hasUniversalOrMatchingMacOSArchitecture,
 )
@@ -224,14 +225,24 @@
         if module_filename.endswith(suffix):
             return (
                 ModuleName(os.path.basename(module_filename)[: -len(suffix)]),
                 "extension",
             )
 
     if os.path.isdir(module_filename):
+        package_filename = getPackageDirFilename(module_filename)
+
+        if package_filename is not None:
+            for suffix in getSharedLibrarySuffixes():
+                if package_filename.endswith(suffix):
+                    return (
+                        ModuleName(os.path.basename(module_filename)),
+                        "extension",
+                    )
+
         return ModuleName(os.path.basename(module_filename)), "py"
 
     return None, None
 
 
 def isIgnoreListedImportMaker(source_ref):
     if isNuitkaPython():
@@ -503,17 +514,14 @@
 
         # First, check for a package with an init file, that would be the
         # first choice.
         if os.path.isdir(package_directory):
             found = False
 
             for suffix, module_type in getModuleFilenameSuffixes():
-                if module_type == "C_EXTENSION":
-                    continue
-
                 package_file_name = "__init__" + suffix
 
                 file_path = os.path.join(package_directory, package_file_name)
 
                 if os.path.isfile(file_path):
                     candidates.add(
                         ImportScanFinding(
@@ -1012,14 +1020,19 @@
     "unicodedata": False,
     "winreg": False,
     "xxsubtype": False,
     "zipimport": False,
     "zlib": False,
     "_ssl": True,
     "_xxinterpchannels": False,
+    # TODO: 3.13 clarify if this is actually true
+    "_interpchannels": False,
+    "_interpreters": False,
+    "_interpqueues": False,
+    "_sysconfig": False,
 }
 
 
 def isNonRaisingBuiltinModule(module_name):
     assert isBuiltinModuleName(module_name), module_name
 
     # Return None, if we don't know.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/PreloadedPackages.py` & `nuitka_winsvc-2.3/nuitka/importing/PreloadedPackages.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/Recursion.py` & `nuitka_winsvc-2.3/nuitka/importing/Recursion.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/StandardLibrary.py` & `nuitka_winsvc-2.3/nuitka/importing/StandardLibrary.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 
 import os
 
 from nuitka.PythonVersions import python_version
 from nuitka.utils.FileOperations import getFileContents, isFilenameBelowPath
 from nuitka.utils.ModuleNames import ModuleName
 from nuitka.utils.Utils import (
+    isMacOS,
     isNetBSD,
     isPosixWindows,
     isWin32OrPosixWindows,
     isWin32Windows,
 )
 
 
@@ -171,14 +172,17 @@
                 dirs.remove("turtledemo")
 
             if "ensurepip" in filenames:
                 filenames.remove("ensurepip")
             if "ensurepip" in dirs:
                 dirs.remove("ensurepip")
 
+            if "_ios_support.py" in filenames and not isMacOS():
+                filenames.remove("_ios_support.py")
+
             # Ignore "lib-dynload" and "lib-tk" and alike.
             dirs[:] = [
                 dirname
                 for dirname in dirs
                 if not dirname.startswith("lib-")
                 if dirname != "Tools"
                 if not dirname.startswith("plat-")
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/importing/__init__.py` & `nuitka_winsvc-2.3/nuitka/importing/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/AsyncgenNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/AsyncgenNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/AttributeLookupNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/AttributeLookupNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/AttributeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/AttributeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/AttributeNodesGenerated.py` & `nuitka_winsvc-2.3/nuitka/nodes/AttributeNodesGenerated.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinAllNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinAllNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinAnyNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinAnyNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinComplexNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinComplexNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDecodingNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinDecodingNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDecoratorNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinDecoratorNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinDictNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinDictNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinFormatNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinFormatNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinHashNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinHashNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinInputNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinInputNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinIntegerNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinIntegerNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinIteratorNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinIteratorNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinLenNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinLenNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinNextNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinNextNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinOpenNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinOpenNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinOperationNodeBasesGenerated.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinOperationNodeBasesGenerated.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinRangeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinRangeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinRefNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinRefNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinSumNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinSumNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinTypeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinTypeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BuiltinVarsNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BuiltinVarsNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/BytesNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/BytesNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/CallNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/CallNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/Checkers.py` & `nuitka_winsvc-2.3/nuitka/nodes/Checkers.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ChildrenHavingMixins.py` & `nuitka_winsvc-2.3/nuitka/nodes/ChildrenHavingMixins.py`

 * *Files 0% similar despite different names*

```diff
@@ -13849,14 +13849,15 @@
     __slots__ = ()
 
     # This is generated for use in
     #   ExpressionOsPathAbspath
     #   ExpressionOsPathExists
     #   ExpressionOsPathIsdir
     #   ExpressionOsPathIsfile
+    #   ExpressionOsPathNormpath
 
     def __init__(
         self,
         path,
     ):
         path.parent = self
 
@@ -13935,14 +13936,15 @@
 
 
 # Assign the names that are easier to import with a stable name.
 ChildrenExpressionOsPathAbspathMixin = ChildHavingPathMixin
 ChildrenExpressionOsPathExistsMixin = ChildHavingPathMixin
 ChildrenExpressionOsPathIsdirMixin = ChildHavingPathMixin
 ChildrenExpressionOsPathIsfileMixin = ChildHavingPathMixin
+ChildrenExpressionOsPathNormpathMixin = ChildHavingPathMixin
 
 
 class ChildHavingPathOptionalMixin(object):
     # Mixins are not allowed to specify slots, pylint: disable=assigning-non-slot
     __slots__ = ()
 
     # This is generated for use in
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ClassNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ClassNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/CodeObjectSpecs.py` & `nuitka_winsvc-2.3/nuitka/nodes/CodeObjectSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ComparisonNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ComparisonNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ConditionalNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ConditionalNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ConstantRefNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ConstantRefNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ContainerMakingNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ContainerMakingNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ContainerOperationNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ContainerOperationNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/CoroutineNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/CoroutineNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/CtypesNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/CtypesNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/DictionaryNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/DictionaryNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ExceptionNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ExceptionNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ExecEvalNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ExecEvalNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionBases.py` & `nuitka_winsvc-2.3/nuitka/nodes/ExpressionBases.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionBasesGenerated.py` & `nuitka_winsvc-2.3/nuitka/nodes/ExpressionBasesGenerated.py`

 * *Files 1% similar despite different names*

```diff
@@ -202,14 +202,15 @@
 
 class ChildrenHavingArgsTupleNameOptionalPathOptionalFinalNoRaiseMixin(ExpressionBase):
     # Mixins are not allowed to specify slots, pylint: disable=assigning-non-slot
     __slots__ = ()
 
     # This is generated for use in
     #   ExpressionBuiltinMakeExceptionImportError
+    #   ExpressionBuiltinMakeExceptionModuleNotFoundError
 
     def __init__(self, args, name, path, source_ref):
         assert type(args) is tuple
 
         for val in args:
             val.parent = self
 
@@ -386,14 +387,17 @@
             self.subnode_path.collectVariableAccesses(emit_read, emit_write)
 
 
 # Assign the names that are easier to import with a stable name.
 ExpressionBuiltinMakeExceptionImportErrorBase = (
     ChildrenHavingArgsTupleNameOptionalPathOptionalFinalNoRaiseMixin
 )
+ExpressionBuiltinMakeExceptionModuleNotFoundErrorBase = (
+    ChildrenHavingArgsTupleNameOptionalPathOptionalFinalNoRaiseMixin
+)
 
 
 class ChildrenHavingCallableArgSentinelFinalMixin(ExpressionBase):
     # Mixins are not allowed to specify slots, pylint: disable=assigning-non-slot
     __slots__ = ()
 
     # This is generated for use in
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ExpressionShapeMixins.py` & `nuitka_winsvc-2.3/nuitka/nodes/ExpressionShapeMixins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/FrameNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/FrameNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/FunctionAttributeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/FunctionAttributeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/FunctionNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/FunctionNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/FutureSpecs.py` & `nuitka_winsvc-2.3/nuitka/nodes/FutureSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/GeneratorNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/GeneratorNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/GlobalsLocalsNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/GlobalsLocalsNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/HardImportNodesGenerated.py` & `nuitka_winsvc-2.3/nuitka/nodes/HardImportNodesGenerated.py`

 * *Files 0% similar despite different names*

```diff
@@ -59,14 +59,15 @@
     os_path_abspath_spec,
     os_path_basename_spec,
     os_path_dirname_spec,
     os_path_exists_spec,
     os_path_isabs_spec,
     os_path_isdir_spec,
     os_path_isfile_spec,
+    os_path_normpath_spec,
     os_uname_spec,
     pkg_resources_get_distribution_spec,
     pkg_resources_iter_entry_points_spec,
     pkg_resources_require_spec,
     pkg_resources_resource_stream_spec,
     pkg_resources_resource_string_spec,
     pkgutil_get_data_spec,
@@ -2472,14 +2473,96 @@
             (self.subnode_path,)
         ):
             trace_collection.onExceptionRaiseExit(BaseException)
 
             return self, None, None
 
         try:
+            return self.replaceWithCompileTimeValue(trace_collection)
+        finally:
+            self.attempted = True
+
+    @abstractmethod
+    def replaceWithCompileTimeValue(self, trace_collection):
+        pass
+
+    @staticmethod
+    def mayRaiseExceptionOperation():
+        return True
+
+
+class ExpressionOsPathNormpathRef(ExpressionImportModuleNameHardExistsSpecificBase):
+    """Function reference os.path.normpath"""
+
+    kind = "EXPRESSION_OS_PATH_NORMPATH_REF"
+
+    def __init__(self, source_ref):
+        ExpressionImportModuleNameHardExistsSpecificBase.__init__(
+            self,
+            module_name=os.path.__name__,
+            import_name="normpath",
+            module_guaranteed=True,
+            source_ref=source_ref,
+        )
+
+    def computeExpressionCall(self, call_node, call_args, call_kw, trace_collection):
+        # Anything may happen on call trace before this. On next pass, if
+        # replaced, we might be better but not now.
+        trace_collection.onExceptionRaiseExit(BaseException)
+
+        from .OsSysNodes import ExpressionOsPathNormpathCall
+
+        result = extractBuiltinArgs(
+            node=call_node,
+            builtin_class=ExpressionOsPathNormpathCall,
+            builtin_spec=os_path_normpath_spec,
+        )
+
+        return (
+            result,
+            "new_expression",
+            "Call to 'os.path.normpath' recognized.",
+        )
+
+
+hard_import_node_classes[ExpressionOsPathNormpathRef] = os_path_normpath_spec
+
+
+class ExpressionOsPathNormpathCallBase(ChildHavingPathMixin, ExpressionBase):
+    """Base class for OsPathNormpathCall
+
+    Generated boiler plate code.
+    """
+
+    named_children = ("path",)
+
+    __slots__ = ("attempted",)
+
+    spec = os_path_normpath_spec
+
+    def __init__(self, path, source_ref):
+
+        ChildHavingPathMixin.__init__(
+            self,
+            path=path,
+        )
+
+        ExpressionBase.__init__(self, source_ref)
+
+        self.attempted = False
+
+    def computeExpression(self, trace_collection):
+        if self.attempted or not os_path_normpath_spec.isCompileTimeComputable(
+            (self.subnode_path,)
+        ):
+            trace_collection.onExceptionRaiseExit(BaseException)
+
+            return self, None, None
+
+        try:
             return self.replaceWithCompileTimeValue(trace_collection)
         finally:
             self.attempted = True
 
     @abstractmethod
     def replaceWithCompileTimeValue(self, trace_collection):
         pass
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ImportHardNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ImportHardNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ImportNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ImportNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/IndicatorMixins.py` & `nuitka_winsvc-2.3/nuitka/nodes/IndicatorMixins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/InjectCNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/InjectCNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/IterationHandles.py` & `nuitka_winsvc-2.3/nuitka/nodes/IterationHandles.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/KeyValuePairNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/KeyValuePairNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ListOperationNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ListOperationNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/LocalsDictNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/LocalsDictNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/LocalsScopes.py` & `nuitka_winsvc-2.3/nuitka/nodes/LocalsScopes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/LoopNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/LoopNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/MatchNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/MatchNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ModuleAttributeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ModuleAttributeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ModuleNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ModuleNodes.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from nuitka.ModuleRegistry import getModuleByName, getOwnerFromCodeName
 from nuitka.optimizations.TraceCollections import TraceCollectionModule
 from nuitka.Options import hasPythonFlagIsolated
 from nuitka.PythonVersions import python_version
 from nuitka.SourceCodeReferences import fromFilename
 from nuitka.tree.SourceHandling import parsePyIFile, readSourceCodeFromFilename
 from nuitka.utils.CStrings import encodePythonIdentifierToC
+from nuitka.utils.Importing import getSharedLibrarySuffix
 from nuitka.utils.ModuleNames import ModuleName
 
 from .ChildrenHavingMixins import (
     ModuleChildrenHavingBodyOptionalStatementsOrNoneFunctionsTupleMixin,
 )
 from .FutureSpecs import fromFlags
 from .IndicatorMixins import EntryPointMixin, MarkNeedsAnnotationsMixin
@@ -967,21 +968,22 @@
                 )
             )
 
 
 class PythonExtensionModule(PythonModuleBase):
     kind = "PYTHON_EXTENSION_MODULE"
 
-    __slots__ = ("used_modules", "technical")
+    __slots__ = ("used_modules", "module_filename", "technical")
 
     avoid_duplicates = set()
 
     def __init__(
         self,
         module_name,
+        module_filename,
         reason,
         technical,
         source_ref,
     ):
         PythonModuleBase.__init__(
             self,
             module_name=module_name,
@@ -1001,19 +1003,25 @@
         self.avoid_duplicates.add(self.getFullName())
 
         # Required to startup
         self.technical = technical
 
         self.used_modules = None
 
+        if os.path.isdir(module_filename):
+            module_filename = os.path.join(
+                module_filename, "__init__" + getSharedLibrarySuffix(preferred=False)
+            )
+        self.module_filename = module_filename
+
     def finalize(self):
         del self.used_modules
 
     def getFilename(self):
-        return self.source_ref.getFilename()
+        return self.module_filename
 
     @staticmethod
     def startTraversal():
         pass
 
     def isTechnical(self):
         """Must be present as it's used in CPython library initialization."""
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/NetworkxNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/NetworkxNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/NodeBases.py` & `nuitka_winsvc-2.3/nuitka/nodes/NodeBases.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/NodeMakingHelpers.py` & `nuitka_winsvc-2.3/nuitka/nodes/NodeMakingHelpers.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/NodeMetaClasses.py` & `nuitka_winsvc-2.3/nuitka/nodes/NodeMetaClasses.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/OperatorNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/OperatorNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/OperatorNodesUnary.py` & `nuitka_winsvc-2.3/nuitka/nodes/OperatorNodesUnary.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/OsSysNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/OsSysNodes.py`

 * *Files 3% similar despite different names*

```diff
@@ -108,14 +108,30 @@
         # Nothing we can do really
 
         trace_collection.onExceptionRaiseExit(BaseException)
 
         return self, None, None
 
 
+class ExpressionOsPathNormpathCall(ExpressionOsPathAbspathCallBase):
+    kind = "EXPRESSION_OS_PATH_NORMPATH_CALL"
+
+    def replaceWithCompileTimeValue(self, trace_collection):
+        result = makeConstantRefNode(
+            constant=os.path.normpath(self.subnode_path.getCompileTimeConstant()),
+            source_ref=self.source_ref,
+        )
+
+        return (
+            result,
+            "new_expression",
+            "Compile time resolved 'os.path.normpath' call.",
+        )
+
+
 class ExpressionOsPathIsabsCall(ExpressionOsPathIsabsCallBase):
     kind = "EXPRESSION_OS_PATH_ISABS_CALL"
 
     def replaceWithCompileTimeValue(self, trace_collection):
         result = makeConstantRefNode(
             constant=os.path.isabs(self.subnode_s.getCompileTimeConstant()),
             source_ref=self.source_ref,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/OutlineNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/OutlineNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/PackageMetadataNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/PackageMetadataNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/PackageResourceNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/PackageResourceNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/PrintNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/PrintNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/ReturnNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/ReturnNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/SideEffectNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/SideEffectNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/SliceNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/SliceNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/StatementBasesGenerated.py` & `nuitka_winsvc-2.3/nuitka/nodes/StatementBasesGenerated.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/StatementNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/StatementNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/StrNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/StrNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/StringConcatenationNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/StringConcatenationNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/SubscriptNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/SubscriptNodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -114,21 +114,21 @@
         value[subscript]
     except Exception:  # Catch all the things, pylint: disable=broad-except
         return False
     else:
         return True
 
 
-class ExpressionSubscriptCheck(
+class ExpressionMatchSubscriptCheck(
     ExpressionBoolShapeExactMixin,
     SideEffectsFromChildrenMixin,
     ChildrenHavingExpressionSubscriptMixin,
     ExpressionBase,
 ):
-    kind = "EXPRESSION_SUBSCRIPT_CHECK"
+    kind = "EXPRESSION_MATCH_SUBSCRIPT_CHECK"
 
     named_children = ("expression", "subscript")
 
     def __init__(self, expression, subscript, source_ref):
         ChildrenHavingExpressionSubscriptMixin.__init__(
             self,
             expression=expression,
@@ -149,15 +149,15 @@
                 tags,
                 change_desc,
             ) = trace_collection.getCompileTimeComputationResult(
                 node=self,
                 computation=lambda: hasSubscript(
                     source.getCompileTimeConstant(), subscript.getCompileTimeConstant()
                 ),
-                description="Subscript check has been pre-computed.",
+                description="Subscript match check has been pre-computed.",
             )
 
             # If source has side effects, they must be evaluated.
             result = wrapExpressionWithNodeSideEffects(new_node=result, old_node=source)
 
             return result, tags, change_desc
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/TensorflowNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/TensorflowNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/TryNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/TryNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/TypeMatchNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/TypeMatchNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/TypeNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/TypeNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/VariableAssignNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/VariableAssignNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/VariableDelNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/VariableDelNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/VariableNameNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/VariableNameNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/VariableRefNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/VariableRefNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/VariableReleaseNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/VariableReleaseNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/YieldNodes.py` & `nuitka_winsvc-2.3/nuitka/nodes/YieldNodes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/__init__.py` & `nuitka_winsvc-2.3/nuitka/nodes/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/shapes/BuiltinTypeShapes.py` & `nuitka_winsvc-2.3/nuitka/nodes/shapes/BuiltinTypeShapes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/shapes/ControlFlowDescriptions.py` & `nuitka_winsvc-2.3/nuitka/nodes/shapes/ControlFlowDescriptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/shapes/ShapeMixins.py` & `nuitka_winsvc-2.3/nuitka/nodes/shapes/ShapeMixins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/shapes/StandardShapes.py` & `nuitka_winsvc-2.3/nuitka/nodes/shapes/StandardShapes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/nodes/shapes/__init__.py` & `nuitka_winsvc-2.3/nuitka/nodes/shapes/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/BytecodeDemotion.py` & `nuitka_winsvc-2.3/nuitka/optimizations/BytecodeDemotion.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/FunctionInlining.py` & `nuitka_winsvc-2.3/nuitka/optimizations/FunctionInlining.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/Graphs.py` & `nuitka_winsvc-2.3/nuitka/optimizations/Graphs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/Optimization.py` & `nuitka_winsvc-2.3/nuitka/optimizations/Optimization.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/OptimizeBuiltinCalls.py` & `nuitka_winsvc-2.3/nuitka/optimizations/OptimizeBuiltinCalls.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/Tags.py` & `nuitka_winsvc-2.3/nuitka/optimizations/Tags.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/TraceCollections.py` & `nuitka_winsvc-2.3/nuitka/optimizations/TraceCollections.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/ValueTraces.py` & `nuitka_winsvc-2.3/nuitka/optimizations/ValueTraces.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/optimizations/__init__.py` & `nuitka_winsvc-2.3/nuitka/optimizations/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/pgo/PGO.py` & `nuitka_winsvc-2.3/nuitka/pgo/PGO.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/pgo/__init__.py` & `nuitka_winsvc-2.3/nuitka/pgo/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/PluginBase.py` & `nuitka_winsvc-2.3/nuitka/plugins/PluginBase.py`

 * *Files 1% similar despite different names*

```diff
@@ -891,26 +891,28 @@
         reason,
         tags="",
         ignore_dirs=(),
         ignore_filenames=(),
         ignore_suffixes=(),
         only_suffixes=(),
         normalize=True,
+        raw=False,
     ):
         return makeIncludedDataDirectory(
             source_path=source_path,
             dest_path=dest_path,
             reason=reason,
             tracer=self,
             tags=tags,
             ignore_dirs=ignore_dirs,
             ignore_filenames=ignore_filenames,
             ignore_suffixes=ignore_suffixes,
             only_suffixes=only_suffixes,
             normalize=normalize,
+            raw=raw,
         )
 
     def makeIncludedEmptyDirectory(self, dest_path, reason, tags):
         return makeIncludedEmptyDirectory(
             dest_path=dest_path,
             reason=reason,
             tracer=self,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/Plugins.py` & `nuitka_winsvc-2.3/nuitka/plugins/Plugins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/__init__.py` & `nuitka_winsvc-2.3/nuitka/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/AntiBloatPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/AntiBloatPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/ConsiderPyLintAnnotationsPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/ConsiderPyLintAnnotationsPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DataFilesPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DataFilesPlugin.py`

 * *Files 6% similar despite different names*

```diff
@@ -116,15 +116,15 @@
             ):
                 yield included_data_file
 
         dirs = data_file_config.get("dirs")
         if dirs is not None:
             if type(dirs) is not list or not dirs:
                 self.sysexit(
-                    "Error, requiring list below 'empty_dirs_structure' entry for '%s' entry."
+                    "Error, requiring list below 'dirs' entry for '%s' entry."
                     % module_name
                 )
 
             for data_dir in dirs:
                 source_path = os.path.join(module_folder, data_dir)
 
                 if os.path.isdir(source_path):
@@ -132,14 +132,35 @@
                         source_path=source_path,
                         dest_path=os.path.join(target_dir, data_dir),
                         reason="package data directory '%s' for %r"
                         % (data_dir, module_name.asString()),
                         tags="config",
                     )
 
+        raw_dirs = data_file_config.get("raw_dirs")
+        if raw_dirs is not None:
+            if type(raw_dirs) is not list or not raw_dirs:
+                self.sysexit(
+                    "Error, requiring list below 'raw_dirs' entry for '%s' entry."
+                    % module_name
+                )
+
+            for raw_dir in raw_dirs:
+                source_path = os.path.join(module_folder, raw_dir)
+
+                if os.path.isdir(source_path):
+                    yield self.makeIncludedDataDirectory(
+                        source_path=source_path,
+                        dest_path=os.path.join(target_dir, raw_dir),
+                        reason="package raw directory '%s' for %r"
+                        % (raw_dir, module_name.asString()),
+                        tags="config",
+                        raw=True,
+                    )
+
         include_pyi_file = data_file_config.get("include-pyi-file")
 
         if include_pyi_file == "yes":
             pyi_filename = changeFilenameExtension(
                 path=module.getCompileTimeFilename(), extension=".pyi"
             )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DelvewheelPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DelvewheelPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin/DillPlugin.c` & `nuitka_winsvc-2.3/tests/basics/OverflowFunctionsTest_2.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,37 +1,52 @@
-//     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
+#     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
-// C code for use when the dill-plugin is active
 
-#include "nuitka/prelude.h"
+def starImporterFunction():
+    from sys import *
 
-void registerDillPluginTables(PyThreadState *tstate, char const *module_name, PyMethodDef *reduce_compiled_function,
-                              PyMethodDef *create_compiled_function) {
-    PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
-
-    if (function_tables == NULL) {
-        CLEAR_ERROR_OCCURRED(tstate);
-
-        function_tables = MAKE_DICT_EMPTY();
-        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
-    }
-
-    PyObject *funcs =
-        MAKE_TUPLE2_0(PyCFunction_New(reduce_compiled_function, NULL), PyCFunction_New(create_compiled_function, NULL));
-
-    PyDict_SetItemString(function_tables, module_name, funcs);
-}
-
-//     Part of "Nuitka", an optimizing Python compiler that is compatible and
-//     integrates with CPython, but also works on its own.
-//
-//     Licensed under the Apache License, Version 2.0 (the "License");
-//     you may not use this file except in compliance with the License.
-//     You may obtain a copy of the License at
-//
-//        http://www.apache.org/licenses/LICENSE-2.0
-//
-//     Unless required by applicable law or agreed to in writing, software
-//     distributed under the License is distributed on an "AS IS" BASIS,
-//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//     See the License for the specific language governing permissions and
-//     limitations under the License.
+    print "Version", version.split()[0].split(".")[:-1]
+
+
+starImporterFunction()
+
+
+def deepExec():
+    for_closure = 3
+
+    def deeper():
+        for_closure_as_well = 4
+
+        def execFunction():
+            code = "f=2"
+
+            # Can fool it to nest
+            exec code in None, None
+
+            print "Locals now", locals()
+
+            print "Closure one level up was taken", for_closure_as_well
+            print "Closure two levels up was taken", for_closure
+            print "Globals still work", starImporterFunction
+            print "Added local from code", f
+
+        execFunction()
+
+    deeper()
+
+
+deepExec()
+
+#     Python tests originally created or extracted from other peoples work. The
+#     parts were too small to be protected.
+#
+#     Licensed under the Apache License, Version 2.0 (the "License");
+#     you may not use this file except in compliance with the License.
+#     You may obtain a copy of the License at
+#
+#        http://www.apache.org/licenses/LICENSE-2.0
+#
+#     Unless required by applicable law or agreed to in writing, software
+#     distributed under the License is distributed on an "AS IS" BASIS,
+#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#     See the License for the specific language governing permissions and
+#     limitations under the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin/dill-postLoad.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin/dill-postLoad.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DillPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DillPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/DllFilesPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/DllFilesPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/EnumPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/EnumPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/EventletPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/EventletPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/GeventPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/GeventPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/GiPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/GiPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/GlfwPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/GlfwPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/ImplicitImports.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/ImplicitImports.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/KivyPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/KivyPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/MatplotlibPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/MatplotlibPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/MultiprocessingPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/MultiprocessingPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/NumpyPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/NumpyPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/OptionsNannyPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/OptionsNannyPlugin.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,17 +7,15 @@
 the user wants, or even be required, as e.g. "wx" on macOS will crash unless the
 console is disabled. This reads Yaml configuration.
 """
 
 from nuitka.Options import (
     isOnefileMode,
     isStandaloneMode,
-    mayDisableConsoleWindow,
     shallCreateAppBundle,
-    shallDisableConsoleWindow,
 )
 from nuitka.plugins.PluginBase import NuitkaYamlPluginBase
 from nuitka.utils.Utils import isMacOS
 
 
 class NuitkaPluginOptionsNanny(NuitkaYamlPluginBase):
     plugin_name = "options-nanny"
@@ -68,58 +66,34 @@
             self.info(message)
         else:
             self.sysexit(
                 "Error, unknown support_info level '%s' for module '%s'"
                 % full_name.asString()
             )
 
-    def _checkConsoleMode(self, full_name, console):
-        if console == "no":
-            if shallDisableConsoleWindow() is not True:
-                self.sysexit(
-                    "Error, when using '%s', you have to use '--disable-console' option."
-                    % full_name
-                )
-        elif console == "yes":
-            pass
-        elif console == "recommend":
-            if shallDisableConsoleWindow() is None:
-                if isMacOS():
-                    downside_message = """\
-Otherwise high resolution will not be available and a terminal window will open"""
-                else:
-                    downside_message = """\
-Otherwise a terminal window will open"""
-
-                self.info(
-                    """\
-Note, when using '%s', consider using '--disable-console' option. %s. However \
-for debugging, terminal output is the easiest way to see informative traceback \
-and error information, so delay this until your program is working and remove \
-once you find it non-working, and use '--enable-console' to make it explicit \
-and not see this message."""
-                    % (full_name, downside_message)
-                )
-
-        else:
-            self.sysexitIllegalOptionValue(full_name, "console", console)
-
     def _checkMacOSBundleMode(self, full_name, macos_bundle):
         if macos_bundle == "yes":
             if isStandaloneMode() and not shallCreateAppBundle():
                 self.sysexit(
                     """\
 Error, package '%s' requires '--macos-create-app-bundle' to be used or else it cannot work."""
                     % full_name
                 )
         elif macos_bundle == "no":
             pass
         elif macos_bundle == "recommend":
-            # TODO: Not really recommending with a message it yet.
-            pass
+            self.info(
+                """\
+Note, when using '%s', consider using '--macos-create-app-bundle' option. \
+Otherwise high resolution will not be available and a terminal window will \
+open. However for debugging, terminal output is the easiest way to see \
+informative traceback and error information, so launch it from there if \
+possible."""
+                % full_name
+            )
         else:
             self.sysexitIllegalOptionValue(full_name, "macos_bundle", macos_bundle)
 
     def _checkMacOSBundleOnefileMode(self, full_name, macos_bundle_as_onefile):
         if macos_bundle_as_onefile == "yes":
             if isStandaloneMode() and shallCreateAppBundle() and not isOnefileMode():
                 self.sysexit(
@@ -147,20 +121,14 @@
                     self._checkSupportedVersion(
                         full_name=full_name,
                         support_info=check.get("support_info", "ignore"),
                         description=check.get("description", "not given"),
                         condition=condition,
                     )
 
-                    if mayDisableConsoleWindow():
-                        self._checkConsoleMode(
-                            full_name=full_name,
-                            console=check.get("console", "yes"),
-                        )
-
                     if isMacOS():
                         self._checkMacOSBundleMode(
                             full_name=full_name,
                             macos_bundle=check.get("macos_bundle", "no"),
                         )
 
                         self._checkMacOSBundleOnefileMode(
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/PbrPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/PbrPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/PkgResourcesPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/PkgResourcesPlugin.py`

 * *Files 3% similar despite different names*

```diff
@@ -48,16 +48,22 @@
 
         # First try metadata, which is what the runner also does first.
         if self.metadata:
             dist = self.metadata.distribution(dist.partition("==")[0])
 
             for entry_point in dist.entry_points:
                 if entry_point.group == group and entry_point.name == name:
-                    module_name = entry_point.module
-                    main_name = entry_point.attr
+                    try:
+                        module_name = entry_point.module
+                        main_name = entry_point.attr
+                    except AttributeError:
+                        match = entry_point.pattern.match(entry_point.value)
+
+                        module_name = match.group("module")
+                        main_name = match.group("attr")
 
                     break
 
         if module_name is None and self.pkg_resources:
             with withNoDeprecationWarning():
                 entry_point = self.pkg_resources.get_entry_info(dist, group, name)
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/PmwPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/PmwPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/PySidePyQtPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/PySidePyQtPlugin.py`

 * *Files 0% similar despite different names*

```diff
@@ -1455,14 +1455,17 @@
                         }
                     )
 
                     self.warned_about.add(top_package_name)
 
                 return (False, "Not included due to all Qt bindings disallowed.")
 
+    def getEvaluationConditionControlTags(self):
+        return {"use_noqt": True}
+
 
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
 #     integrates with CPython, but also works on its own.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/PywebViewPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/PywebViewPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/TensorflowPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/TensorflowPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/TkinterPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/TkinterPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/TorchPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/TorchPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/TransformersPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/TransformersPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/TrioPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/TrioPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/UpxPlugin.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/UpxPlugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/__init__.py` & `nuitka_winsvc-2.3/nuitka/plugins/standard/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/standard.nuitka-package.config.yml` & `nuitka_winsvc-2.3/nuitka/plugins/standard/standard.nuitka-package.config.yml`

 * *Files 0% similar despite different names*

```diff
@@ -1269,14 +1269,20 @@
 - module-name: 'Foundation' # checksum: f269907b
   options:
     checks:
       - description: "The 'Foundation' module requires bundle module"
         macos_bundle: 'yes'
         when: 'macos'
 
+- module-name: 'freetype' # checksum: 5a9431c2
+  dlls:
+    - from_filenames:
+        prefixes:
+          - 'libfreetype'
+
 - module-name: 'frozendict' # checksum: 85584475
   data-files:
     patterns:
       - 'VERSION'
 
 - module-name: 'fsspec.transaction' # checksum: f49a0729
   anti-bloat:
@@ -3684,23 +3690,23 @@
         - '.fonts'
 
 - module-name: 'pyfiglet.fonts' # checksum: 3ebe1284
   data-files:
     dirs:
       - '.'
 
-- module-name: 'pygame' # checksum: 74ba6d7b
+- module-name: 'pygame' # checksum: 5fbb83cf
   data-files:
     patterns:
       - 'freesansbold.ttf'
 
   options:
     checks:
       - description: 'PyGame is a GUI framework'
-        console: 'recommend'
+        macos_bundle: 'recommend'
 
 - module-name: 'pygame_menu' # checksum: 3f9f0b7d
   data-files:
     dirs:
       - 'resources'
 
 - module-name: 'pygeos._geometry' # checksum: 6a3a4737
@@ -3810,41 +3816,41 @@
     - description: 'remove doctest usage'
 
 - module-name: 'pyproj' # checksum: d7d7c58b
   data-files:
     dirs:
       - 'proj_dir'
 
-- module-name: 'PyQt5' # checksum: c7182cc5
+- module-name: 'PyQt5' # checksum: 8ca4bbdf
   data-files:
     empty_dirs:
       - 'Qt5'
       - 'Qt'
 
   options:
     checks:
       - description: 'PyQt5 is a GUI framework'
-        console: 'recommend'
+        macos_bundle: 'recommend'
         when: 'use_pyqt5'
       - description: 'PyQt5 cannot be used without bundle'
         macos_bundle: 'yes'
         when: 'macos and not is_conda_package("pyqt5") and use_pyqt5'
       - description: 'PyQt5 cannot be signed unless onefile'
         macos_bundle_as_onefile: 'yes'
         when: 'macos and use_pyqt5'
 
   import-hacks:
     - acceptable-missing-dlls:
         - 'libqpdf'
 
-- module-name: 'PyQt6' # checksum: 884033ec
+- module-name: 'PyQt6' # checksum: 9ddfb6bb
   options:
     checks:
       - description: 'PyQt6 is a GUI framework'
-        console: 'recommend'
+        macos_bundle: 'recommend'
         when: 'use_pyqt6'
       - description: 'PyQt6 on macOS is not supported, use PySide6 instead'
         support_info: 'error'
         when: 'macos and use_pyqt6'
 
 - module-name: 'pyqtgraph' # checksum: 1d763dc
   data-files:
@@ -3986,15 +3992,15 @@
 - module-name: 'pyscf.scf._vhf' # checksum: 801ef150
   dlls:
     - from_filenames:
         relative_path: '../lib'
         prefixes:
           - 'libcvhf'
 
-- module-name: 'PySide2' # checksum: 4e71be92
+- module-name: 'PySide2' # checksum: c07d1551
   implicit-imports:
     - post-import-code:
         - |
           def patched_disconnect(self, slot=None):
               if hasattr(slot, "im_func"):
                   if hasattr(slot.im_func, "__compiled__"):
                       patched_disconnect._protected = getattr(patched_disconnect, "_protected", [])
@@ -4005,24 +4011,24 @@
           from PySide2 import QtCore
           orig_disconnect = QtCore.SignalInstance.disconnect
           QtCore.SignalInstance.disconnect = patched_disconnect
 
   options:
     checks:
       - description: 'PySide2 is a GUI framework'
-        console: 'recommend'
+        macos_bundle: 'recommend'
         when: 'use_pyside2'
       - description: 'PySide2 cannot be signed unless onefile'
         macos_bundle_as_onefile: 'yes'
         when: 'macos and use_pyside2'
   import-hacks:
     - find-dlls-near-module:
         - 'shiboken2'
 
-- module-name: 'PySide6' # checksum: 8852cddf
+- module-name: 'PySide6' # checksum: a87b6b1
   implicit-imports:
     - post-import-code:
         - |
           def patched_disconnect(self, slot=None):
               if hasattr(slot, "im_func"):
                   if hasattr(slot.im_func, "__compiled__"):
                       patched_disconnect._protected = getattr(patched_disconnect, "_protected", [])
@@ -4052,15 +4058,15 @@
           QtCore.SignalInstance.disconnect = patched_disconnect
           orig_connect = QtCore.SignalInstance.connect
           QtCore.SignalInstance.connect = patched_connect
 
   options:
     checks:
       - description: 'PySide6 is a GUI framework'
-        console: 'recommend'
+        macos_bundle: 'recommend'
         when: 'use_pyside6'
 
   import-hacks:
     - find-dlls-near-module:
         - 'shiboken6'
     - acceptable-missing-dlls:
         - 'libeffectsplugin'
@@ -7368,19 +7374,19 @@
       when: 'win32'
 
 - module-name: 'winloop' # checksum: 9d1257f8
   implicit-imports:
     - depends:
         - '._noop'
 
-- module-name: 'wx' # checksum: 154e95cb
+- module-name: 'wx' # checksum: 9a4d4164
   options:
     checks:
       - description: 'wx will crash in console mode during startup'
-        console: 'yes'
+        macos_bundle: 'yes'
         when: 'macos'
       - description: 'wx requires program to be in bundle form'
         macos_bundle: 'yes'
         when: 'macos'
 
 - module-name: 'wx.html2' # checksum: bc8985c4
   dlls:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/stdlib2.nuitka-package.config.yml` & `nuitka_winsvc-2.3/nuitka/plugins/standard/stdlib2.nuitka-package.config.yml`

 * *Files 2% similar despite different names*

```diff
@@ -55,18 +55,18 @@
 
 - module-name: 'StringIO' # checksum: 820d21fd
   anti-bloat:
     - description: 'remove module ability to run as a binary'
       change_function:
         'test': "'(lambda: None)'"
 
-- module-name: 'Tkinter' # checksum: 16ff58dd
+- module-name: 'Tkinter' # checksum: 6eaa6fb1
   options:
     checks:
-      - console: 'recommend'
+      - macos_bundle: 'recommend'
         when: 'plugin("tk-inter")'
 
 - module-name: 'xml.sax.xmlreader' # checksum: 167cb032
   anti-bloat:
     - description: 'remove module ability to run as a binary'
       change_function:
         '_test': "'(lambda: None)'"
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/plugins/standard/stdlib3.nuitka-package.config.yml` & `nuitka_winsvc-2.3/nuitka/plugins/standard/stdlib3.nuitka-package.config.yml`

 * *Files 0% similar despite different names*

```diff
@@ -316,15 +316,15 @@
 
 - module-name: 'threading' # checksum: 167cb032
   anti-bloat:
     - description: 'remove module ability to run as a binary'
       change_function:
         '_test': "'(lambda: None)'"
 
-- module-name: 'tkinter' # checksum: cef6b613
+- module-name: 'tkinter' # checksum: 481f7b98
   anti-bloat:
     - description: 'enhanced tk-inter in case of missing tcl'
       context:
         - 'import textwrap'
       replacements:
         'self.tk = _tkinter.create(screenName, baseName, className, interactive, wantobjects, useTk, sync, use)': |
           textwrap.indent("""
@@ -334,15 +334,15 @@
             if "usable init.tcl" not in str(e):
               raise\n\
             sys.exit("Nuitka: Need to use '--enable-plugin=tk-inter' option during compilation for tk-inter to work!")
           """, "        ")
       when: 'not deployment and not plugin("tk-inter")'
   options:
     checks:
-      - console: 'recommend'
+      - macos_bundle: 'recommend'
         when: 'plugin("tk-inter")'
 
 - module-name: 'tokenize' # checksum: 6a44b57d
   anti-bloat:
     - description: 'remove module ability to run as a binary'
       change_function:
         'main': "'(lambda: None)'"
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/reports/CompilationReportReader.py` & `nuitka_winsvc-2.3/nuitka/reports/CompilationReportReader.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/reports/LicenseReport.rst.j2` & `nuitka_winsvc-2.3/nuitka/reports/LicenseReport.rst.j2`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/reports/Reports.py` & `nuitka_winsvc-2.3/nuitka/reports/Reports.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/reports/__init__.py` & `nuitka_winsvc-2.3/nuitka/reports/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinBytesOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinBytesOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinDictOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinDictOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinListOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinListOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinParameterSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinParameterSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinStrOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinStrOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinTypeOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinTypeOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/BuiltinUnicodeOperationSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/BuiltinUnicodeOperationSpecs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/HardImportSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/HardImportSpecs.py`

 * *Files 0% similar despite different names*

```diff
@@ -127,14 +127,17 @@
 os_path_exists_spec = BuiltinParameterSpec("os.path.exists", ("path",), default_count=0)
 os_path_isfile_spec = BuiltinParameterSpec("os.path.isfile", ("path",), default_count=0)
 os_path_isdir_spec = BuiltinParameterSpec("os.path.isdir", ("path",), default_count=0)
 os_path_basename_spec = BuiltinParameterSpec(
     "os.path.basename", ("p",), default_count=0
 )
 os_path_dirname_spec = BuiltinParameterSpec("os.path.dirname", ("p",), default_count=0)
+os_path_normpath_spec = BuiltinParameterSpec(
+    "os.path.normpath", ("path",), default_count=0
+)
 os_path_abspath_spec = BuiltinParameterSpec(
     "os.path.abspath", ("path",), default_count=0
 )
 os_path_isabs_spec = BuiltinParameterSpec(
     "os.path.isabs", ("s",), default_count=0, type_shape=tshape_bool
 )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/ParameterSpecs.py` & `nuitka_winsvc-2.3/nuitka/specs/ParameterSpecs.py`

 * *Files 9% similar despite different names*

```diff
@@ -387,32 +387,38 @@
 
     # Python3 does this check earlier.
     if python_version >= 0x300 and not star_dict_arg:
         for pair in pairs:
             try:
                 arg_index = (args + kw_only_args).index(pair[0])
             except ValueError:
-                if improved or python_version >= 0x370:
-                    message = "'%s' is an invalid keyword argument for %s()" % (
-                        pair[0],
-                        func_name,
-                    )
+                if python_version < 0x370 and not improved:
+                    template = "'%(arg_name)s' is an invalid keyword argument for this function"
+                elif python_version < 0x3D0 and not improved:
+                    template = "'%(arg_name)s' is an invalid keyword argument for %(func_name)s()"
                 else:
-                    message = (
-                        "'%s' is an invalid keyword argument for this function"
-                        % pair[0]
-                    )
+                    template = "%(func_name)s() got an unexpected keyword argument '%(arg_name)s'"
+
+                message = template % {
+                    "arg_name": pair[0],
+                    "func_name": func_name,
+                }
 
                 raise TooManyArguments(TypeError(message))
 
             if arg_index < num_pos_only:
-                message = "'%s' is an invalid keyword argument for %s()" % (
-                    pair[0],
-                    func_name,
-                )
+                if python_version < 0x3D0:
+                    template = "'%(arg_name)s' is an invalid keyword argument for %(func_name)s()"
+                else:
+                    template = "%(func_name)s() got an unexpected keyword argument '%(arg_name)s'"
+
+                message = template % {
+                    "arg_name": pair[0],
+                    "func_name": func_name,
+                }
 
                 raise TooManyArguments(TypeError(message))
 
     if star_list_arg:
         if num_pos > num_args:
             value = positional[-(num_pos - num_args) :]
             assign(star_list_arg, value)
@@ -442,17 +448,22 @@
             raise TooManyArguments(
                 TypeError(
                     "%s expected %d arguments, got %d"
                     % (func_name, num_args, num_total)
                 )
             )
 
+        if python_version < 0x3D0:
+            template = "%s() takes at most %d %s (%d given)"
+        else:
+            template = "%s expected at most %d %s, got %d"
+
         raise TooManyArguments(
             TypeError(
-                "%s() takes at most %d %s (%d given)"
+                template
                 % (
                     func_name,
                     num_args,
                     "argument" if num_args == 1 else "arguments",
                     num_total,
                 )
             )
@@ -503,15 +514,15 @@
                 assign(arg, None)
 
     if star_dict_arg:
         assign(star_dict_arg, pairs)
     elif pairs:
         unexpected = next(iter(dict(pairs)))
 
-        if improved:
+        if improved or python_version >= 0x3D0:
             message = "%s() got an unexpected keyword argument '%s'" % (
                 func_name,
                 unexpected,
             )
         else:
             message = (
                 "'%s' is an invalid keyword argument for this function" % unexpected
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/specs/__init__.py` & `nuitka_winsvc-2.3/nuitka/specs/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/Basics.py` & `nuitka_winsvc-2.3/nuitka/tools/Basics.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/commercial/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/commercial/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/data_composer/DataComposer.py` & `nuitka_winsvc-2.3/nuitka/tools/data_composer/DataComposer.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/data_composer/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/data_composer/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/data_composer/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/data_composer/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/environments/CreateEnvironment.py` & `nuitka_winsvc-2.3/nuitka/tools/environments/CreateEnvironment.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/environments/Virtualenv.py` & `nuitka_winsvc-2.3/nuitka/tools/environments/Virtualenv.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/environments/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/environments/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/general/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/general/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/general/dll_report/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/general/dll_report/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/general/dll_report/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/general/dll_report/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/general/find_module/FindModuleCode.py` & `nuitka_winsvc-2.3/nuitka/tools/general/find_module/FindModuleCode.py`

 * *Files 12% similar despite different names*

```diff
@@ -16,14 +16,15 @@
     ModuleName,
     addMainScriptDirectory,
     locateModule,
 )
 from nuitka.Tracing import tools_logger
 from nuitka.utils.Execution import callProcess, getExecutablePath
 from nuitka.utils.FileOperations import relpath
+from nuitka.utils.Importing import getPackageDirFilename
 from nuitka.utils.Utils import isWin32Windows
 
 
 def findModuleCode(module_name):
     module_name = ModuleName(module_name)
 
     return locateModule(module_name=module_name, parent_package=None, level=0)[1]
@@ -72,17 +73,17 @@
         addMainScriptDirectory(os.getcwd())
         module_filename = findModuleCode(module_name)
 
     if module_filename is None:
         tools_logger.sysexit("Error, did not find '%s' module" % module_name)
     else:
         if os.path.isdir(module_filename):
-            candidate = os.path.join(module_filename, ("__init__.py"))
+            candidate = getPackageDirFilename(module_filename)
 
-            if os.path.isfile(candidate):
+            if candidate is not None:
                 module_filename = candidate
 
         if os.path.isdir(module_filename):
             tools_logger.sysexit(
                 "Error, %s is a namespace package with no code" % module_name
             )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/general/find_module/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/general/find_module/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/OnefileCompressor.py` & `nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/OnefileCompressor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/onefile_compressor/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/onefile_compressor/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/podman/Podman.py` & `nuitka_winsvc-2.3/nuitka/tools/podman/Podman.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/podman/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/podman/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/podman/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/podman/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/profiler/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/profiler/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/profiler/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/profiler/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/scanning/DisplayPackageDLLs.py` & `nuitka_winsvc-2.3/nuitka/tools/scanning/DisplayPackageDLLs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/scanning/DisplayPackageData.py` & `nuitka_winsvc-2.3/nuitka/tools/scanning/DisplayPackageData.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/scanning/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/scanning/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/specialize/CTypeDescriptions.py` & `nuitka_winsvc-2.3/nuitka/tools/specialize/CTypeDescriptions.py`

 * *Files 1% similar despite different names*

```diff
@@ -666,16 +666,19 @@
             return "return %s(%s, %s) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;" % (
                 helper_name,
                 operand1,
                 operand2,
             )
 
     @staticmethod
-    def getTakeReferenceStatement(operand):
-        return "Py_INCREF(%s);" % operand
+    def getTakeReferenceStatement(operand, immortal):
+        return "%s(%s);" % (
+            ("Py_INCREF_IMMORTAL" if immortal else "Py_INCREF"),
+            operand,
+        )
 
     @classmethod
     def hasReferenceCounting(cls):
         return True
 
     @classmethod
     def getReturnFromObjectExpressionCode(
@@ -760,18 +763,17 @@
             )
         else:
             assert False, cls
 
     @classmethod
     def getAssignFromBoolExpressionCode(cls, result, operand, give_ref):
         if cls.type_name == "object":
-            # TODO: Python3?
             code = "%s = BOOL_FROM(%s);" % (result, operand)
             if give_ref:
-                code += "Py_INCREF(%s);" % result
+                code += "Py_INCREF_IMMORTAL(%s);" % result
 
             return code
         elif cls.type_name == "nbool":
             return "%s = %s;" % (
                 result,
                 cls.getToValueFromBoolExpression("%s" % operand),
             )
@@ -899,15 +901,15 @@
         else:
             assert False, (cls, cls.type_name)
 
     @classmethod
     def getAssignConversionCode(cls, result, left, value):
         def _getObjectObject():
             code = "%s = %s;" % (result, value)
-            code += cls.getTakeReferenceStatement(result)
+            code += cls.getTakeReferenceStatement(result, immortal=False)
 
             return code
 
         if cls is left:
             return _getObjectObject()
         else:
             if cls.type_name in ("object", "float"):
@@ -960,15 +962,15 @@
         }
 
     @abstractmethod
     def getTypeValueExpression(self, operand):
         pass
 
     @staticmethod
-    def getTakeReferenceStatement(operand):
+    def getTakeReferenceStatement(operand, immortal):
         return ""
 
 
 class ConcreteNonSequenceTypeBase(ConcreteTypeBase):
     """Base class for concrete types that are not sequences."""
 
     # Base classes can be abstract, pylint: disable=abstract-method
@@ -1594,15 +1596,15 @@
         return operand
 
     @staticmethod
     def getToValueFromObjectExpression(operand):
         return "CHECK_IF_TRUE(%s) == 1" % operand
 
     @staticmethod
-    def getTakeReferenceStatement(operand):
+    def getTakeReferenceStatement(operand, immortal):
         return ""
 
     @staticmethod
     def getExceptionResultIndicatorValue():
         return "false"
 
 
@@ -1640,15 +1642,15 @@
 
     @classmethod
     def getToValueFromObjectExpression(cls, operand):
         # TODO: Seems wrong, int return values only happen to match nuitka_bool here
         return cls.getToValueFromBoolExpression("CHECK_IF_TRUE(%s)" % operand)
 
     @staticmethod
-    def getTakeReferenceStatement(operand):
+    def getTakeReferenceStatement(operand, immortal):
         return ""
 
     @staticmethod
     def getExceptionResultIndicatorValue():
         return "NUITKA_BOOL_EXCEPTION"
 
 
@@ -1691,15 +1693,15 @@
 
     @classmethod
     def getToValueFromObjectExpression(cls, operand):
         # All values are the same, pylint: disable=unused-argument
         return "NUITKA_VOID_OK"
 
     @staticmethod
-    def getTakeReferenceStatement(operand):
+    def getTakeReferenceStatement(operand, immortal):
         return ""
 
     @staticmethod
     def getExceptionResultIndicatorValue():
         return "NUITKA_VOID_EXCEPTION"
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/specialize/Common.py` & `nuitka_winsvc-2.3/nuitka/tools/specialize/Common.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/specialize/SpecializeC.py` & `nuitka_winsvc-2.3/nuitka/tools/specialize/SpecializeC.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/specialize/SpecializePython.py` & `nuitka_winsvc-2.3/nuitka/tools/specialize/SpecializePython.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/specialize/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/specialize/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/Common.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/Common.py`

 * *Files 1% similar despite different names*

```diff
@@ -37,15 +37,15 @@
     isFilenameSameAsOrBelowPath,
     makePath,
     openTextFile,
     removeDirectory,
 )
 from nuitka.utils.InstalledPythons import findInstalledPython
 from nuitka.utils.Jinja2 import getTemplate
-from nuitka.utils.Utils import getOS, isMacOS, isWin32Windows
+from nuitka.utils.Utils import isFreeBSD, isLinux, isMacOS, isWin32Windows
 
 from .SearchModes import (
     SearchModeByPattern,
     SearchModeCoverage,
     SearchModeImmediate,
     SearchModeOnly,
     SearchModeResume,
@@ -201,15 +201,15 @@
 
     if tmp_dir is None:
         tmp_dir = tempfile.mkdtemp(
             prefix=os.path.basename(
                 os.path.dirname(os.path.abspath(sys.modules["__main__"].__file__))
             )
             + "-",
-            dir=tempfile.gettempdir() if not os.path.exists("/var/tmp") else "/var/tmp",
+            dir=None if not (isLinux() and os.path.exists("/var/tmp")) else "/var/tmp",
         )
 
         def removeTempDir():
             removeDirectory(path=tmp_dir, ignore_errors=True)
 
         atexit.register(removeTempDir)
 
@@ -516,15 +516,15 @@
     path = os.path.abspath(path)
 
     # TODO: Merge code for building command with below function, this is otherwise
     # horribly bad.
 
     if os.name == "posix":
         # Run with traces to help debugging, specifically in CI environment.
-        if getOS() in ("Darwin", "FreeBSD"):
+        if isMacOS() or isFreeBSD():
             test_logger.info("dtruss:")
             os.system("sudo dtruss %s" % path)
         else:
             test_logger.info("strace:")
             os.system("strace -s4096 -e file %s" % path)
 
 
@@ -727,14 +727,15 @@
     sys.stdout.flush()
 
     return result
 
 
 def createSearchMode():
     # Dealing with many options, pylint: disable=too-many-branches
+    # Return driven, pylint: disable=too-many-return-statements
 
     parser = OptionParser()
 
     select_group = parser.add_option_group("Select Tests")
 
     select_group.add_option(
         "--pattern",
@@ -800,15 +801,17 @@
         elif options.pattern:
             return SearchModeByPattern(
                 start_at=options.pattern.replace("/", os.path.sep)
             )
         else:
             return SearchModeImmediate()
     elif mode == "resume":
-        return SearchModeResume(sys.modules["__main__"].__file__)
+        return SearchModeResume(sys.modules["__main__"].__file__, skip=False)
+    elif mode == "skip":
+        return SearchModeResume(sys.modules["__main__"].__file__, skip=True)
     elif mode == "only":
         if options.pattern:
             pattern = options.pattern.replace("/", os.path.sep)
             return SearchModeOnly(pattern)
         else:
             assert False
     elif mode == "coverage":
@@ -1878,15 +1881,19 @@
 
 def getLocalWebServerDir(base_dir):
     global _web_server_process  # singleton, pylint: disable=global-statement
 
     web_dir = os.path.join(getTempDir(), "local-web-server", base_dir)
 
     if _web_server_process is None:
-        web_server_directory_supporting_pythons = ("3.11", "3.10", "3.9", "3.8", "3.7")
+        web_server_directory_supporting_pythons = tuple(
+            python_version
+            for python_version in getTestExecutionPythonVersions()
+            if python_version not in ("3.6", "3.5", "3.4", "2.7", "2.6")
+        )
 
         web_server_python = findInstalledPython(
             python_versions=web_server_directory_supporting_pythons,
             module_name=None,
             module_version=None,
         )
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/Constructs.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/Constructs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/OutputComparison.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/OutputComparison.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/Pythons.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/Pythons.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/RuntimeTracing.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/RuntimeTracing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/SearchModes.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/SearchModes.py`

 * *Files 2% similar despite different names*

```diff
@@ -105,15 +105,15 @@
 
     def finish(self):
         if not self.active:
             sys.exit("Error, became never active.")
 
 
 class SearchModeResume(SearchModeBase):
-    def __init__(self, tests_path):
+    def __init__(self, tests_path, skip):
         SearchModeBase.__init__(self)
 
         tests_path = os.path.normcase(os.path.abspath(tests_path))
         version = sys.version
 
         if str is not bytes:
             tests_path = tests_path.encode("utf8")
@@ -130,14 +130,15 @@
 
         if os.path.exists(cache_filename):
             self.resume_from = getFileContents(cache_filename) or None
         else:
             self.resume_from = None
 
         self.active = not self.resume_from
+        self.skip = skip
 
     def consider(self, dirname, filename):
         parts = [dirname, filename]
 
         while None in parts:
             parts.remove(None)
         assert parts
@@ -148,14 +149,17 @@
             putTextFileContents(self.cache_filename, contents=path)
 
             return True
 
         if areSamePaths(path, self.resume_from):
             self.active = True
 
+            if self.skip:
+                return False
+
         return self.active
 
     def finish(self):
         os.unlink(self.cache_filename)
         if not self.active:
             sys.exit("Error, became never active, restarting next time.")
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/Valgrind.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/Valgrind.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/check_reference_counts/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/check_reference_counts/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/check_reference_counts/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/check_reference_counts/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/compare_with_cpython/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/compare_with_cpython/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/compare_with_cpython/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/compare_with_cpython/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/find_sxs_modules/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/find_sxs_modules/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/find_sxs_modules/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/find_sxs_modules/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/measure_construct_performance/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/measure_construct_performance/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/measure_construct_performance/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/measure_construct_performance/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/run_nuitka_tests/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/run_nuitka_tests/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/testing/run_nuitka_tests/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/testing/run_nuitka_tests/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/watch/GitHub.py` & `nuitka_winsvc-2.3/nuitka/tools/watch/GitHub.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,31 +2,25 @@
 
 
 """ GitHub interfacing for nuitka-watch. """
 
 import os
 import sys
 
-from nuitka.tools.quality.Git import (
-    getCurrentBranchName,
-    getModifiedPaths,
-    getRemoteURL,
-)
+from nuitka.tools.quality.Git import getModifiedPaths, getRemoteURL
 from nuitka.Tracing import tools_logger
 from nuitka.utils.Execution import callProcess, check_call
 
 
 def checkInNuitkaWatch():
     remote_url = getRemoteURL("origin")
     assert remote_url in (
         "git@github.com:Nuitka/Nuitka-Watch.git",
         "https://github.com/Nuitka/Nuitka-Watch",
     ), remote_url
-    branch_name = getCurrentBranchName()
-    assert branch_name == "main", branch_name
     assert os.path.exists(".git")
 
 
 def createNuitkaWatchPR(category, description):
     checkInNuitkaWatch()
 
     modified_files = list(getModifiedPaths())
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/watch/__init__.py` & `nuitka_winsvc-2.3/nuitka/tools/watch/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tools/watch/__main__.py` & `nuitka_winsvc-2.3/nuitka/tools/watch/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/Building.py` & `nuitka_winsvc-2.3/nuitka/tree/Building.py`

 * *Files 0% similar despite different names*

```diff
@@ -127,14 +127,15 @@
     optimization_logger,
     plugins_logger,
     recursion_logger,
     unusual_logger,
 )
 from nuitka.utils import MemoryUsage
 from nuitka.utils.ModuleNames import ModuleName
+from nuitka.utils.Utils import withNoSyntaxWarning
 
 from . import SyntaxErrors
 from .ReformulationAssertStatements import buildAssertNode
 from .ReformulationAssignmentStatements import (
     buildAnnAssignNode,
     buildAssignNode,
     buildDeleteNode,
@@ -1070,14 +1071,15 @@
     main_added,
 ):
     is_stdlib = module_filename is not None and isStandardLibraryPath(module_filename)
 
     if module_kind == "extension":
         result = PythonExtensionModule(
             module_name=module_name,
+            module_filename=module_filename,
             reason=reason,
             technical=is_stdlib and module_name in detectEarlyImports(),
             source_ref=source_ref,
         )
     elif is_main:
         assert reason == "main", reason
 
@@ -1362,20 +1364,21 @@
                     exc=e,
                     module_name=module_name,
                     reason=reason,
                     module_filename=module_filename,
                 )
 
         try:
-            ast_tree = parseSourceCodeToAst(
-                source_code=source_code,
-                module_name=module_name,
-                filename=source_filename,
-                line_offset=0,
-            )
+            with withNoSyntaxWarning():
+                ast_tree = parseSourceCodeToAst(
+                    source_code=source_code,
+                    module_name=module_name,
+                    filename=source_filename,
+                    line_offset=0,
+                )
         except (SyntaxError, IndentationError) as e:
             # Do not hide SyntaxError if asked not to.
             if not hide_syntax_error:
                 raise
 
             if original_source_code is not None:
                 try:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ComplexCallHelperFunctions.py` & `nuitka_winsvc-2.3/nuitka/tree/ComplexCallHelperFunctions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/Extractions.py` & `nuitka_winsvc-2.3/nuitka/tree/Extractions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/InternalModule.py` & `nuitka_winsvc-2.3/nuitka/tree/InternalModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/Operations.py` & `nuitka_winsvc-2.3/nuitka/tree/Operations.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationAssertStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationAssertStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationAssignmentStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationAssignmentStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationBooleanExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationBooleanExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationCallExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationCallExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationClasses.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationClasses.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationClasses3.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationClasses3.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationComparisonExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationComparisonExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationContractionExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationContractionExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationDictionaryCreation.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationDictionaryCreation.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationExecStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationExecStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationForLoopStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationForLoopStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationFunctionStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationFunctionStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationImportStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationImportStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationLambdaExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationLambdaExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationMatchStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationMatchStatements.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,33 +10,38 @@
 
 import ast
 
 from nuitka.nodes.AttributeNodes import (
     ExpressionAttributeCheck,
     makeExpressionAttributeLookup,
 )
+from nuitka.nodes.BuiltinDictNodes import ExpressionBuiltinDict
 from nuitka.nodes.BuiltinLenNodes import ExpressionBuiltinLen
 from nuitka.nodes.BuiltinTypeNodes import ExpressionBuiltinList
 from nuitka.nodes.ComparisonNodes import makeComparisonExpression
 from nuitka.nodes.ConditionalNodes import makeStatementConditional
 from nuitka.nodes.ConstantRefNodes import makeConstantRefNode
+from nuitka.nodes.DictionaryNodes import StatementDictOperationRemove
 from nuitka.nodes.MatchNodes import ExpressionMatchArgs
 from nuitka.nodes.OutlineNodes import ExpressionOutlineBody
 from nuitka.nodes.ReturnNodes import makeStatementReturnConstant
 from nuitka.nodes.SubscriptNodes import (
-    ExpressionSubscriptCheck,
+    ExpressionMatchSubscriptCheck,
     ExpressionSubscriptLookup,
 )
 from nuitka.nodes.TypeMatchNodes import (
     ExpressionMatchTypeCheckMapping,
     ExpressionMatchTypeCheckSequence,
 )
 from nuitka.nodes.TypeNodes import ExpressionBuiltinIsinstance
 from nuitka.nodes.VariableAssignNodes import makeStatementAssignmentVariable
-from nuitka.nodes.VariableNameNodes import StatementAssignmentVariableName
+from nuitka.nodes.VariableNameNodes import (
+    ExpressionVariableNameRef,
+    StatementAssignmentVariableName,
+)
 from nuitka.nodes.VariableRefNodes import ExpressionTempVariableRef
 from nuitka.nodes.VariableReleaseNodes import makeStatementReleaseVariable
 
 from .ReformulationBooleanExpressions import makeAndNode, makeOrNode
 from .ReformulationTryFinallyStatements import makeTryFinallyStatement
 from .TreeHelpers import (
     buildNode,
@@ -248,15 +253,15 @@
 
     assert len(pattern.keys) == len(pattern.patterns), ast.dump(pattern)
 
     key = kwd_pattern = None
 
     for key, kwd_pattern in zip(pattern.keys, pattern.patterns):
         conditions.append(
-            ExpressionSubscriptCheck(
+            ExpressionMatchSubscriptCheck(
                 expression=make_against(),
                 subscript=buildNode(provider, key, source_ref),
                 source_ref=source_ref,
             )
         )
 
         # It's called before return, pylint: disable=cell-var-from-loop
@@ -273,14 +278,45 @@
 
         if item_conditions:
             conditions.extend(item_conditions)
 
         if item_assignments:
             assignments.extend(item_assignments)
 
+    if pattern.rest:
+        assert type(pattern.rest) is str, pattern.rest
+
+        assignments.append(
+            StatementAssignmentVariableName(
+                provider=provider,
+                variable_name=pattern.rest,
+                source=ExpressionBuiltinDict(
+                    pos_arg=make_against(),
+                    pairs=(),
+                    source_ref=source_ref,
+                ),
+                source_ref=source_ref,
+            )
+        )
+
+        for key in pattern.keys:
+            assert type(key) is ast.Constant, key
+
+            assignments.append(
+                StatementDictOperationRemove(
+                    dict_arg=ExpressionVariableNameRef(
+                        provider=provider,
+                        variable_name=pattern.rest,
+                        source_ref=source_ref,
+                    ),
+                    key=buildNode(provider, key, source_ref),
+                    source_ref=source_ref,
+                )
+            )
+
     return conditions, assignments
 
 
 def _buildMatchClass(provider, pattern, make_against, source_ref):
     cls_node = buildNode(provider, pattern.cls, source_ref)
 
     assignments = []
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationMultidist.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationMultidist.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationNamespacePackages.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationNamespacePackages.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationPrintStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationPrintStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationSequenceCreation.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationSequenceCreation.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationSubscriptExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationSubscriptExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationTryExceptStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationTryExceptStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationTryFinallyStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationTryFinallyStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationWhileLoopStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationWhileLoopStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationWithStatements.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationWithStatements.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/ReformulationYieldExpressions.py` & `nuitka_winsvc-2.3/nuitka/tree/ReformulationYieldExpressions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/SourceHandling.py` & `nuitka_winsvc-2.3/nuitka/tree/SourceHandling.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/SyntaxErrors.py` & `nuitka_winsvc-2.3/nuitka/tree/SyntaxErrors.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/TreeHelpers.py` & `nuitka_winsvc-2.3/nuitka/tree/TreeHelpers.py`

 * *Files 1% similar despite different names*

```diff
@@ -58,14 +58,17 @@
             if type(body[0].value.value) is str:
                 doc = body[0].value.value
             body = body[1:]
 
         if Options.hasPythonFlagNoDocStrings():
             doc = None
 
+    if doc is not None and python_version >= 0x3D0:
+        doc = doc.lstrip()
+
     return body, doc
 
 
 def parseSourceCodeToAst(source_code, module_name, filename, line_offset):
     # Workaround: ast.parse cannot cope with some situations where a file is not
     # terminated by a new line.
     if not source_code.endswith("\n"):
@@ -287,14 +290,16 @@
 
     build_nodes_args3 = path_args3
     build_nodes_args2 = path_args2
     build_nodes_args1 = path_args1
 
 
 def buildNode(provider, node, source_ref, allow_none=False):
+    # too many exception handlers, pylint: disable=too-many-branches
+
     if node is None and allow_none:
         return None
 
     try:
         kind = getKind(node)
 
         if hasattr(node, "lineno"):
@@ -326,14 +331,17 @@
         # code exception, don't warn about it with a code dump then.
         raise
     except KeyboardInterrupt:
         # User interrupting is not a problem with the source, but tell where
         # we got interrupted.
         optimization_logger.info("Interrupted at '%s'." % source_ref)
         raise
+    except SystemExit:
+        optimization_logger.warning("Problem at '%s'." % source_ref.getAsString())
+        raise
     except:
         optimization_logger.warning(
             "Problem at '%s' with %s." % (source_ref.getAsString(), ast.dump(node))
         )
         raise
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/VariableClosure.py` & `nuitka_winsvc-2.3/nuitka/tree/VariableClosure.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/tree/__init__.py` & `nuitka_winsvc-2.3/nuitka/tree/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/AppDirs.py` & `nuitka_winsvc-2.3/nuitka/utils/AppDirs.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/CStrings.py` & `nuitka_winsvc-2.3/nuitka/utils/CStrings.py`

 * *Files 4% similar despite different names*

```diff
@@ -59,24 +59,31 @@
 
 
 def encodePythonUnicodeToC(value):
     """Encode a string, so that it gives a wide C string literal."""
     assert type(value) is unicode, type(value)
 
     result = ""
+    last_was_hex = False
 
     for c in value:
         cv = ord(c)
 
         if c == "\\":
             result += "\\\\"
+            last_was_hex = False
         elif 34 < cv < 128:
+            if last_was_hex:
+                result += '" L"'
+
             result += c
+            last_was_hex = False
         else:
             result += r"\x%04x" % cv
+            last_was_hex = True
 
     return 'L"%s"' % result
 
 
 def encodePythonStringToC(value):
     """Encode bytes, so that it gives a C string literal."""
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/CommandLineOptions.py` & `nuitka_winsvc-2.3/nuitka/utils/CommandLineOptions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Distributions.py` & `nuitka_winsvc-2.3/nuitka/utils/Distributions.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Download.py` & `nuitka_winsvc-2.3/nuitka/utils/Download.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Execution.py` & `nuitka_winsvc-2.3/nuitka/utils/Execution.py`

 * *Files 1% similar despite different names*

```diff
@@ -417,16 +417,25 @@
         **kw_args
     )
 
     return process
 
 
 def executeProcess(
-    command, env=None, stdin=False, shell=False, external_cwd=False, timeout=None
+    command,
+    env=None,
+    stdin=False,
+    shell=False,
+    external_cwd=False,
+    timeout=None,
+    logger=None,
 ):
+    if logger is not None:
+        logger.info("Executing command '%s'." % " ".join(command), keep_format=True)
+
     process = createProcess(
         command=command, env=env, stdin=stdin, shell=shell, external_cwd=external_cwd
     )
 
     if stdin is True:
         process_input = None
     elif stdin is not False:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/FileOperations.py` & `nuitka_winsvc-2.3/nuitka/utils/FileOperations.py`

 * *Files 2% similar despite different names*

```diff
@@ -726,31 +726,39 @@
     much more stable during tests.
 
     All kinds of programs that scan files might cause this, but they do
     it hopefully only briefly.
     """
 
     def onError(func, path, exc_info):
-        # Try again immediately, ignore what happened, pylint: disable=unused-argument
-        try:
-            func(path)
-        except OSError:
-            time.sleep(0.1)
-
-        func(path)
+        # Record what happened what happened, pylint: disable=unused-argument
+        last_error.append(func, path)
 
     with withFileLock("removing directory %s" % path):
         if os.path.exists(path):
-            try:
+            previous_error = []
+
+            while True:
+                last_error = []
                 shutil.rmtree(path, ignore_errors=False, onerror=onError)
-            except OSError:
-                if ignore_errors:
+
+                # onError as a side effect, modifies last_error
+                if previous_error == last_error:
+                    break
+
+                previous_error = list(last_error)
+                time.sleep(0.1)
+
+            # if it still exists, try one more time, this time not ignoring errors.
+            if os.path.exists(path):
+                try:
                     shutil.rmtree(path, ignore_errors=ignore_errors)
-                else:
-                    raise
+                except OSError:
+                    if not ignore_errors:
+                        raise
 
 
 def resetDirectory(path, ignore_errors):
     removeDirectory(path=path, ignore_errors=ignore_errors)
     makePath(path)
 
 
@@ -1434,15 +1442,15 @@
         except AttributeError:
             # Too old to have "syncfs" available.
             return
 
 
 def isFilesystemEncodable(filename):
     """Decide if a filename is safe for use as a file system path with tools."""
-    if os.name == "nt":
+    if os.name == "nt" and type(filename) is unicode:
         value = (
             unicodedata.normalize("NFKD", filename)
             .encode("ascii", "ignore")
             .decode("ascii")
         )
 
         return value == filename
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Hashing.py` & `nuitka_winsvc-2.3/nuitka/utils/Hashing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Images.py` & `nuitka_winsvc-2.3/nuitka/utils/Images.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Importing.py` & `nuitka_winsvc-2.3/nuitka/utils/Importing.py`

 * *Files 7% similar despite different names*

```diff
@@ -303,14 +303,38 @@
                 ModuleName(os.path.basename(module_filename)[: -len(suffix)]),
                 "extension",
             )
 
     return None, None
 
 
+def hasPackageDirFilename(path):
+    path = os.path.basename(path)
+
+    for suffix in (".py",) + getSharedLibrarySuffixes():
+        candidate = "__init__" + suffix
+
+        if candidate == path:
+            return True
+
+    return False
+
+
+def getPackageDirFilename(path):
+    assert os.path.isdir(path)
+
+    for suffix in (".py",) + getSharedLibrarySuffixes():
+        candidate = os.path.join(path, "__init__" + suffix)
+
+        if os.path.isfile(candidate):
+            return candidate
+
+    return None
+
+
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
 #     integrates with CPython, but also works on its own.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
 #
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/InstalledPythons.py` & `nuitka_winsvc-2.3/nuitka/utils/InstalledPythons.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/InstanceCounters.py` & `nuitka_winsvc-2.3/nuitka/utils/InstanceCounters.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Jinja2.py` & `nuitka_winsvc-2.3/nuitka/utils/Jinja2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Json.py` & `nuitka_winsvc-2.3/nuitka/utils/Json.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/MacOSApp.py` & `nuitka_winsvc-2.3/nuitka/utils/MacOSApp.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/MemoryUsage.py` & `nuitka_winsvc-2.3/nuitka/utils/MemoryUsage.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/ModuleNames.py` & `nuitka_winsvc-2.3/nuitka/utils/ModuleNames.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/ReExecute.py` & `nuitka_winsvc-2.3/nuitka/utils/ReExecute.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 spell-checker: ignore execl, Popen
 """
 
 import os
 import sys
 
 
-def callExecProcess(args):
+def callExecProcess(args, uac):
     """Do exec in a portable way preserving exit code.
 
     On Windows, unfortunately there is no real exec, so we have to spawn
     a new process instead.
     """
 
     # We better flush these, "os.execl" won't do it anymore.
@@ -29,27 +29,31 @@
         import subprocess
 
         args = list(args)
         del args[1]
 
         try:
             # Context manager is not available on all Python versions, pylint: disable=consider-using-with
-            process = subprocess.Popen(args=args)
+            process = subprocess.Popen(args=args, shell=uac)
             process.communicate()
             # No point in cleaning up, just exit the hard way.
             try:
                 os._exit(process.returncode)
             except OverflowError:
                 # Seems negative values go wrong otherwise,
                 # see https://bugs.python.org/issue28474
                 os._exit(process.returncode - 2**32)
         except KeyboardInterrupt:
             # There was a more relevant stack trace already, so abort this
             # right here.
             os._exit(2)
+        except OSError as e:
+            print("Error, executing: %s" % e)
+            os._exit(2)
+
     else:
         # The star arguments is the API of execl
         os.execl(*args)
 
 
 def reExecuteNuitka(pgo_filename):
     # Execute with full path as the process name, so it can find itself and its
@@ -116,15 +120,15 @@
         os.environ["NUITKA_NOSITE_FLAG"] = "1"
 
     os.environ["PYTHONHASHSEED"] = "0"
 
     os.environ["NUITKA_REEXECUTION"] = "1"
 
     # Does not return:
-    callExecProcess(args)
+    callExecProcess(args, uac=False)
 
 
 #     Part of "Nuitka", an optimizing Python compiler that is compatible and
 #     integrates with CPython, but also works on its own.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Rest.py` & `nuitka_winsvc-2.3/nuitka/utils/Rest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/SharedLibraries.py` & `nuitka_winsvc-2.3/nuitka/utils/SharedLibraries.py`

 * *Files 2% similar despite different names*

```diff
@@ -360,14 +360,31 @@
 
 
 _patchelf_usage = """\
 Error, needs 'patchelf' on your system, to modify 'RPATH' settings that \
 need to be updated."""
 
 
+def checkPatchElfPresenceAndUsability(logger):
+    """Checks if patchelf is present and usable."""
+
+    output = executeToolChecked(
+        logger=logger,
+        command=("patchelf", "--version"),
+        absence_message="""\
+Error, standalone mode on Linux requires 'patchelf' to be \
+installed. Use 'apt/dnf/yum install patchelf' first.""",
+    )
+
+    if output.split() == b"0.18.0":
+        logger.sysexit(
+            "Error, patchelf version 0.18.0 is a known buggy release and cannot be used. Please upgrade or downgrade it."
+        )
+
+
 def _setSharedLibraryRPATHElf(filename, rpath):
     # patchelf --set-rpath "$ORIGIN/path/to/library" <executable>
     with withEnvironmentVarOverridden("LANG", "C"):
         executeToolChecked(
             logger=postprocessing_logger,
             command=("patchelf", "--set-rpath", rpath, filename),
             stderr_filter=_filterPatchelfErrorOutput,
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Shebang.py` & `nuitka_winsvc-2.3/nuitka/utils/Shebang.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Signing.py` & `nuitka_winsvc-2.3/nuitka/utils/Signing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/SlotMetaClasses.py` & `nuitka_winsvc-2.3/nuitka/utils/SlotMetaClasses.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/StaticLibraries.py` & `nuitka_winsvc-2.3/nuitka/utils/StaticLibraries.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/ThreadedExecutor.py` & `nuitka_winsvc-2.3/nuitka/utils/ThreadedExecutor.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Timing.py` & `nuitka_winsvc-2.3/nuitka/utils/Timing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Utils.py` & `nuitka_winsvc-2.3/nuitka/utils/Utils.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/WindowsFileUsage.py` & `nuitka_winsvc-2.3/nuitka/utils/WindowsFileUsage.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/WindowsResources.py` & `nuitka_winsvc-2.3/nuitka/utils/WindowsResources.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/Yaml.py` & `nuitka_winsvc-2.3/nuitka/utils/Yaml.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,15 +34,23 @@
     )
 
     def __init__(self, name, file_data):
         self.name = name
 
         assert type(file_data) is bytes
         data = parseYaml(file_data)
-        assert type(data) is list
+
+        if not data:
+            general.sysexit(
+                """\
+Error, empty (or malformed?) user package configuration '%s' used."""
+                % name
+            )
+
+        assert type(data) is list, type(data)
 
         self.data = OrderedDict()
 
         for item in data:
             module_name = item.pop("module-name")
 
             if not module_name:
```

### Comparing `nuitka_winsvc-2.2.3/nuitka/utils/__init__.py` & `nuitka_winsvc-2.3/nuitka/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/pyproject.toml` & `nuitka_winsvc-2.3/pyproject.toml`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/setup.py` & `nuitka_winsvc-2.3/setup.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/AssertsTest.py` & `nuitka_winsvc-2.3/tests/basics/AssertsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/AssignmentsTest.py` & `nuitka_winsvc-2.3/tests/basics/AssignmentsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/AssignmentsTest32.py` & `nuitka_winsvc-2.3/tests/basics/AssignmentsTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/BranchingTest.py` & `nuitka_winsvc-2.3/tests/basics/BranchingTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/BuiltinOverload.py` & `nuitka_winsvc-2.3/tests/basics/BuiltinOverload.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/BuiltinSuperTest.py` & `nuitka_winsvc-2.3/tests/basics/BuiltinSuperTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/BuiltinsTest.py` & `nuitka_winsvc-2.3/tests/basics/BuiltinsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ClassMinimalTest.py` & `nuitka_winsvc-2.3/tests/basics/ClassMinimalTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ClassesTest.py` & `nuitka_winsvc-2.3/tests/basics/ClassesTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ClassesTest32.py` & `nuitka_winsvc-2.3/tests/basics/ClassesTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ClassesTest34.py` & `nuitka_winsvc-2.3/tests/basics/ClassesTest34.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ComparisonChainsTest.py` & `nuitka_winsvc-2.3/tests/basics/ComparisonChainsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ConstantsTest.py` & `nuitka_winsvc-2.3/tests/basics/ConstantsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ConstantsTest27.py` & `nuitka_winsvc-2.3/tests/basics/ConstantsTest27.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/DecoratorsTest.py` & `nuitka_winsvc-2.3/tests/basics/DecoratorsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/DefaultParametersTest.py` & `nuitka_winsvc-2.3/tests/basics/DefaultParametersTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/DoubleDeletionsTest.py` & `nuitka_winsvc-2.3/tests/basics/DoubleDeletionsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/EmptyModuleTest.py` & `nuitka_winsvc-2.3/tests/basics/EmptyModuleTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest.py` & `nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest32.py` & `nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ExceptionRaisingTest33.py` & `nuitka_winsvc-2.3/tests/basics/ExceptionRaisingTest33.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ExecEvalTest.py` & `nuitka_winsvc-2.3/tests/basics/ExecEvalTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ExtremeClosureTest.py` & `nuitka_winsvc-2.3/tests/basics/ExtremeClosureTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/FunctionObjectsTest.py` & `nuitka_winsvc-2.3/tests/basics/FunctionObjectsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/FunctionsTest.py` & `nuitka_winsvc-2.3/tests/basics/FunctionsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/FunctionsTest32.py` & `nuitka_winsvc-2.3/tests/basics/FunctionsTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/FunctionsTest_2.py` & `nuitka_winsvc-2.3/tests/basics/FunctionsTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/FutureTest32.py` & `nuitka_winsvc-2.3/tests/basics/FutureTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/GeneratorExpressionsTest.py` & `nuitka_winsvc-2.3/tests/basics/GeneratorExpressionsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/GeneratorExpressionsTest_37.py` & `nuitka_winsvc-2.3/tests/basics/GeneratorExpressionsTest_37.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/GlobalStatementTest.py` & `nuitka_winsvc-2.3/tests/basics/GlobalStatementTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/HelloWorldTest_2.py` & `nuitka_winsvc-2.3/tests/basics/HelloWorldTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ImportingTest.py` & `nuitka_winsvc-2.3/tests/basics/ImportingTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/InplaceOperationsTest.py` & `nuitka_winsvc-2.3/tests/basics/InplaceOperationsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/InspectionTest.py` & `nuitka_winsvc-2.3/tests/basics/InspectionTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/InspectionTest_35.py` & `nuitka_winsvc-2.3/tests/basics/InspectionTest_35.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/InspectionTest_36.py` & `nuitka_winsvc-2.3/tests/basics/InspectionTest_36.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/LambdasTest.py` & `nuitka_winsvc-2.3/tests/basics/LambdasTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/LateClosureAssignmentTest.py` & `nuitka_winsvc-2.3/tests/basics/LateClosureAssignmentTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ListContractionsTest.py` & `nuitka_winsvc-2.3/tests/basics/ListContractionsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/LoopingTest.py` & `nuitka_winsvc-2.3/tests/basics/LoopingTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/MainProgramsTest.py` & `nuitka_winsvc-2.3/tests/basics/MainProgramsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ModuleAttributesTest.py` & `nuitka_winsvc-2.3/tests/basics/ModuleAttributesTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/OperatorsTest.py` & `nuitka_winsvc-2.3/tests/basics/OperatorsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/OrderChecksTest.py` & `nuitka_winsvc-2.3/tests/basics/OrderChecksTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/OrderChecksTest27.py` & `nuitka_winsvc-2.3/tests/basics/OrderChecksTest27.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/OverflowFunctionsTest_2.py` & `nuitka_winsvc-2.3/tests/plugins/code_signing/CodeSigningMain.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,52 +1,28 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-def starImporterFunction():
-    from sys import *
+from __future__ import print_function
 
-    print "Version", version.split()[0].split(".")[:-1]
-
-
-starImporterFunction()
-
-
-def deepExec():
-    for_closure = 3
-
-    def deeper():
-        for_closure_as_well = 4
-
-        def execFunction():
-            code = "f=2"
-
-            # Can fool it to nest
-            exec code in None, None
-
-            print "Locals now", locals()
-
-            print "Closure one level up was taken", for_closure_as_well
-            print "Closure two levels up was taken", for_closure
-            print "Globals still work", starImporterFunction
-            print "Added local from code", f
-
-        execFunction()
-
-    deeper()
-
-
-deepExec()
-
-#     Python tests originally created or extracted from other peoples work. The
-#     parts were too small to be protected.
+# nuitka-project: --onefile
+# nuitka-project: --enable-plugin=signing
+# nuitka-project: --windows-certificate-filename={MAIN_DIRECTORY}/../../../misc/test-cert.pfx
+# nuitka-project: --windows-certificate-password=password
+
+print("OK.")
+
+#     Python test originally created or extracted from other peoples work. The
+#     parts from me are licensed as below. It is at least Free Software where
+#     it's copied from other people. In these cases, that will normally be
+#     indicated.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
 #
-#        http://www.apache.org/licenses/LICENSE-2.0
+#         http://www.apache.org/licenses/LICENSE-2.0
 #
 #     Unless required by applicable law or agreed to in writing, software
 #     distributed under the License is distributed on an "AS IS" BASIS,
 #     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #     See the License for the specific language governing permissions and
 #     limitations under the License.
```

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ParameterErrorsTest.py` & `nuitka_winsvc-2.3/tests/basics/ParameterErrorsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ParameterErrorsTest32.py` & `nuitka_winsvc-2.3/tests/basics/ParameterErrorsTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/PrintFutureTest.py` & `nuitka_winsvc-2.3/tests/basics/PrintFutureTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/PrintingTest_2.py` & `nuitka_winsvc-2.3/tests/basics/PrintingTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/RecursionTest.py` & `nuitka_winsvc-2.3/tests/basics/RecursionTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest27.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest27.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest33.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest33.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest35.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest35.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest36.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest36.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ReferencingTest_2.py` & `nuitka_winsvc-2.3/tests/basics/ReferencingTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/SlotsTest.py` & `nuitka_winsvc-2.3/tests/basics/SlotsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/ThreadedGeneratorsTest.py` & `nuitka_winsvc-2.3/tests/basics/ThreadedGeneratorsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest32.py` & `nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest35.py` & `nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest35.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TrickAssignmentsTest_2.py` & `nuitka_winsvc-2.3/tests/basics/TrickAssignmentsTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryContinueFinallyTest.py` & `nuitka_winsvc-2.3/tests/basics/TryContinueFinallyTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryExceptContinueTest.py` & `nuitka_winsvc-2.3/tests/basics/TryExceptContinueTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryExceptFinallyTest.py` & `nuitka_winsvc-2.3/tests/basics/TryExceptFinallyTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryExceptFramesTest.py` & `nuitka_winsvc-2.3/tests/basics/TryExceptFramesTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryReturnFinallyTest.py` & `nuitka_winsvc-2.3/tests/basics/TryReturnFinallyTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/TryYieldFinallyTest.py` & `nuitka_winsvc-2.3/tests/basics/TryYieldFinallyTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/UnicodeTest.py` & `nuitka_winsvc-2.3/tests/basics/UnicodeTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/UnpackingTest35.py` & `nuitka_winsvc-2.3/tests/basics/UnpackingTest35.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/VarargsTest.py` & `nuitka_winsvc-2.3/tests/basics/VarargsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/WithStatementsTest.py` & `nuitka_winsvc-2.3/tests/basics/WithStatementsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/YieldFromTest33.py` & `nuitka_winsvc-2.3/tests/basics/YieldFromTest33.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/run_all.py` & `nuitka_winsvc-2.3/tests/basics/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/basics/run_xml.py` & `nuitka_winsvc-2.3/tests/basics/run_xml.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/onefile/HelloWorldTest.py` & `nuitka_winsvc-2.3/tests/onefile/HelloWorldTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/onefile/KeyboardInterruptTest.py` & `nuitka_winsvc-2.3/tests/onefile/KeyboardInterruptTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/onefile/run_all.py` & `nuitka_winsvc-2.3/tests/onefile/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/ArgumentTypes.py` & `nuitka_winsvc-2.3/tests/optimizations/ArgumentTypes.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/AttributesTest.py` & `nuitka_winsvc-2.3/tests/optimizations/AttributesTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/CallsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/CallsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/ConditionsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/ConditionsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/DecodingOperationsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/DecodingOperationsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/FormatStringsTest36.py` & `nuitka_winsvc-2.3/tests/optimizations/FormatStringsTest36.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/HardImportsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/HardImportsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/HardImportsTest_2.py` & `nuitka_winsvc-2.3/tests/optimizations/HardImportsTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/Iterations.py` & `nuitka_winsvc-2.3/tests/optimizations/Iterations.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/LenTest.py` & `nuitka_winsvc-2.3/tests/optimizations/LenTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/MatchingTest310.py` & `nuitka_winsvc-2.3/tests/optimizations/MatchingTest310.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/OperationsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/OperationsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/SubscriptsTest.py` & `nuitka_winsvc-2.3/tests/optimizations/SubscriptsTest.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/optimizations/run_all.py` & `nuitka_winsvc-2.3/tests/optimizations/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/package_data_files_embedding/PackageDataFilesEmbedding.py` & `nuitka_winsvc-2.3/tests/packages/package_data_files_embedding/PackageDataFilesEmbedding.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/package_data_files_embedding/__init__.py` & `nuitka_winsvc-2.3/tests/packages/package_data_files_embedding/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/PackageImportSuccessAfterFailure.py` & `nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/PackageImportSuccessAfterFailure.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/variable_package/SomeModule.py` & `nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/variable_package/SomeModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/package_import_success_after_failure/variable_package/__init__.py` & `nuitka_winsvc-2.3/tests/packages/package_import_success_after_failure/variable_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/run_all.py` & `nuitka_winsvc-2.3/tests/packages/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/__init__.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/bigkitty.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/bigkitty.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/smallkitty.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/smallkitty.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/__init__.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/hello.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/hello.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/miau.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/miau.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/sub_package/kitty/speak/purr.py` & `nuitka_winsvc-2.3/tests/packages/sub_package/kitty/speak/purr.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/packages/top_level_attributes_3/some_package/some_module.py` & `nuitka_winsvc-2.3/tests/packages/top_level_attributes_3/some_package/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/code_signing/CodeSigningMain.py` & `nuitka_winsvc-2.3/tests/standalone/PyQt5SSLSupport.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,22 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-from __future__ import print_function
+# nuitka-skip-unless-imports: PyQt5.QtGui
 
-# nuitka-project: --onefile
-# nuitka-project: --enable-plugin=signing
-# nuitka-project: --windows-certificate-filename={MAIN_DIRECTORY}/../../../misc/test-cert.pfx
-# nuitka-project: --windows-certificate-password=password
+# nuitka-project: --standalone
+# nuitka-project: --enable-plugin=pyqt5
 
-print("OK.")
+# nuitka-project-if: {OS} == "Darwin":
+#   nuitka-project: --macos-create-app-bundle
+#   nuitka-project: --onefile
+
+from PyQt5.QtNetwork import QSslSocket
+
+print("SSL support: %r" % (QSslSocket.supportsSsl(),))
 
 #     Python test originally created or extracted from other peoples work. The
 #     parts from me are licensed as below. It is at least Free Software where
 #     it's copied from other people. In these cases, that will normally be
 #     indicated.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
```

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/data_files/DataFilesMain.py` & `nuitka_winsvc-2.3/tests/plugins/data_files/DataFilesMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/data_files/data_files_package/__init__.py` & `nuitka_winsvc-2.3/tests/plugins/data_files/data_files_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/parameters/ParametersMain.py` & `nuitka_winsvc-2.3/tests/plugins/parameters/ParametersMain.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,14 +2,15 @@
 
 
 """ Just something to allow the plugin to look at.
 
 """
 
 # nuitka-project: --user-plugin={MAIN_DIRECTORY}/parameter-using-plugin.py
+# nuitka-project: --trace-my-plugin
 # nuitka-project: --follow-imports
 
 from __future__ import print_function
 
 import math
 
 print(math.pi)
```

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/parameters/parameter-using-plugin.py` & `nuitka_winsvc-2.3/tests/plugins/parameters/parameter-using-plugin.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/plugins/run_all.py` & `nuitka_winsvc-2.3/tests/plugins/run_all.py`

 * *Files 9% similar despite different names*

```diff
@@ -36,16 +36,14 @@
 
 def main():
     # Complex stuff, even more should become common code though.
     setup(suite="plugins", needs_io_encoding=True)
 
     search_mode = createSearchMode()
 
-    extra_options = os.environ.get("NUITKA_EXTRA_OPTIONS", "")
-
     # TODO: Add a directory test case scanner instead of duplicating this kind of code.
     for filename in sorted(os.listdir(".")):
         if (
             not os.path.isdir(filename)
             or filename.endswith(".build")
             or filename.endswith(".dist")
         ):
@@ -54,19 +52,14 @@
         filename = os.path.relpath(filename)
 
         extra_flags = ["expect_success"]
 
         # We annotate some tests, use that to lower warnings.
         extra_flags.append("remove_output")
 
-        if filename == "parameters":
-            os.environ["NUITKA_EXTRA_OPTIONS"] = extra_options + " --trace-my-plugin"
-        else:
-            os.environ["NUITKA_EXTRA_OPTIONS"] = extra_options
-
         active = search_mode.consider(dirname=None, filename=filename)
 
         if active:
             my_print("Consider output of recursively compiled program:", filename)
 
             if filename in ("code_signing",):
                 if getCommercialVersion() is None:
```

### Comparing `nuitka_winsvc-2.2.3/tests/programs/absolute_import/AbsoluteImportMain.py` & `nuitka_winsvc-2.3/tests/programs/absolute_import/AbsoluteImportMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/__init__.py` & `nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/foobar.py` & `nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/foobar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/local.py` & `nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/local.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/absolute_import/foobar/util.py` & `nuitka_winsvc-2.3/tests/programs/absolute_import/foobar/util.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports1/CasedImportingMain.py` & `nuitka_winsvc-2.3/tests/programs/case_imports1/CasedImportingMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/Some_Module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports1/path1/Some_Module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports1/path1/Some_Package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports1/path1/Some_Package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/some_module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports1/path2/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports1/path2/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports1/path2/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports2/CasedImportingMain.py` & `nuitka_winsvc-2.3/tests/programs/case_imports2/CasedImportingMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/some_module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports2/path1/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports2/path1/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports2/path1/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/Some_Module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports2/path2/Some_Module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports2/path2/Some_Package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports2/path2/Some_Package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports3/CasedImportingMain.py` & `nuitka_winsvc-2.3/tests/programs/case_imports3/CasedImportingMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/Some_Module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports3/path1/Some_Module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports3/path1/Some_Package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports3/path1/Some_Package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/Some_Module.py` & `nuitka_winsvc-2.3/tests/programs/case_imports3/path2/Some_Module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/case_imports3/path2/Some_Package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/case_imports3/path2/Some_Package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/CyclicImportsMain.py` & `nuitka_winsvc-2.3/tests/programs/cyclic_imports/CyclicImportsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child1.py` & `nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child1.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child2.py` & `nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/Child2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/cyclic_imports/cyclic_importing_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/cyclic_imports/cyclic_importing_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dash_import/DashImportMain.py` & `nuitka_winsvc-2.3/tests/programs/dash_import/DashImportMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dash_import/dash-module.py` & `nuitka_winsvc-2.3/tests/programs/dash_import/dash-module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dash_import/plus+module.py` & `nuitka_winsvc-2.3/tests/programs/dash_import/plus+module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dash_main/Dash-Main.py` & `nuitka_winsvc-2.3/tests/programs/dash_main/Dash-Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/DeepProgramMain.py` & `nuitka_winsvc-2.3/tests/programs/deep/DeepProgramMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/some_package/DeepBrother.py` & `nuitka_winsvc-2.3/tests/programs/deep/some_package/DeepBrother.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/some_package/DeepChild.py` & `nuitka_winsvc-2.3/tests/programs/deep/some_package/DeepChild.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/deep/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/some_package/deep_package/DeepDeepChild.py` & `nuitka_winsvc-2.3/tests/programs/deep/some_package/deep_package/DeepDeepChild.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/deep/some_package/deep_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/deep/some_package/deep_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/DunderInitImportsMain.py` & `nuitka_winsvc-2.3/tests/programs/dunderinit_imports/DunderInitImportsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/package/SubModule.py` & `nuitka_winsvc-2.3/tests/programs/dunderinit_imports/package/SubModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/dunderinit_imports/package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/dunderinit_imports/package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/import_variants/ImportVariationsMain.py` & `nuitka_winsvc-2.3/tests/programs/import_variants/ImportVariationsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child1.py` & `nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child1.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child2.py` & `nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/Child3.py` & `nuitka_winsvc-2.3/tests/programs/import_variants/some_package/Child3.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/import_variants/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/import_variants/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/main_raises/ErrorMain.py` & `nuitka_winsvc-2.3/tests/programs/main_raises/ErrorMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/main_raises/ErrorRaising.py` & `nuitka_winsvc-2.3/tests/programs/main_raises/ErrorRaising.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/main_raises2/ErrorInFunctionMain.py` & `nuitka_winsvc-2.3/tests/programs/main_raises2/ErrorInFunctionMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/main_raises2/ErrorRaising.py` & `nuitka_winsvc-2.3/tests/programs/main_raises2/ErrorRaising.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/ModuleAttributesMain.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/ModuleAttributesMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/Nearby1.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/Nearby1.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/__init__.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/Nearby2.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/Nearby2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/__init__.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/Nearby3.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/Nearby3.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/__init__.py` & `nuitka_winsvc-2.3/tests/programs/module_attributes/package_level1/package_level2/package_level3/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_exits/ErrorExitingModule.py` & `nuitka_winsvc-2.3/tests/programs/module_exits/ErrorExitingModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_exits/Main.py` & `nuitka_winsvc-2.3/tests/programs/module_exits/Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_object_replacing/ModuleObjectReplacingMain.py` & `nuitka_winsvc-2.3/tests/programs/module_object_replacing/ModuleObjectReplacingMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/module_object_replacing/SelfReplacingModule.py` & `nuitka_winsvc-2.3/tests/programs/module_object_replacing/SelfReplacingModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/MultiprocessingUsingMain.py` & `nuitka_winsvc-2.3/tests/programs/multiprocessing_using/MultiprocessingUsingMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/__init__.py` & `nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/__main__.py` & `nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/multiprocessing_using/foo/entry.py` & `nuitka_winsvc-2.3/tests/programs/multiprocessing_using/foo/entry.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/named_imports/NamedImportsMain.py` & `nuitka_winsvc-2.3/tests/programs/named_imports/NamedImportsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/SomeModule.py` & `nuitka_winsvc-2.3/tests/programs/named_imports/some_package/SomeModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/named_imports/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/named_imports/some_package/sub_package/SomeModule.py` & `nuitka_winsvc-2.3/tests/programs/named_imports/some_package/sub_package/SomeModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_code/PackageInitCodeMain.py` & `nuitka_winsvc-2.3/tests/programs/package_code/PackageInitCodeMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_code/some_package/SomeModule.py` & `nuitka_winsvc-2.3/tests/programs/package_code/some_package/SomeModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_code/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_code/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_contains_main/PackageContainsMain.py` & `nuitka_winsvc-2.3/tests/programs/package_contains_main/PackageContainsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_contains_main/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_contains_main/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_contains_main/local.py` & `nuitka_winsvc-2.3/tests/programs/package_contains_main/local.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_import/PackageInitImportMain.py` & `nuitka_winsvc-2.3/tests/programs/package_init_import/PackageInitImportMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_import/some_package/PackageLocal.py` & `nuitka_winsvc-2.3/tests/programs/package_init_import/some_package/PackageLocal.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_import/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_init_import/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_issue/PackageInitIssueMain.py` & `nuitka_winsvc-2.3/tests/programs/package_init_issue/PackageInitIssueMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/child_package/SomeModule.py` & `nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/child_package/SomeModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_init_issue/some_package/child_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_init_issue/some_package/child_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_missing_init/PackageMissingInitMain.py` & `nuitka_winsvc-2.3/tests/programs/package_missing_init/PackageMissingInitMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/some_module.py` & `nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_missing_init/some_package/sub_package/some_sub_module.py` & `nuitka_winsvc-2.3/tests/programs/package_missing_init/some_package/sub_package/some_sub_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_module_collision/PackageAndModuleNamedSameMain.py` & `nuitka_winsvc-2.3/tests/programs/package_module_collision/PackageAndModuleNamedSameMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_module_collision/Something/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_module_collision/Something/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_module_collision/something.py` & `nuitka_winsvc-2.3/tests/programs/package_module_collision/something.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_overload/Main.py` & `nuitka_winsvc-2.3/tests/programs/package_overload/Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_overload/foo/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/bar.py` & `nuitka_winsvc-2.3/tests/programs/package_overload/foo/bar.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_overload/foo/bar2.py` & `nuitka_winsvc-2.3/tests/programs/package_overload/foo/bar2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/PackagePreventsSubmoduleMain.py` & `nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/PackagePreventsSubmoduleMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_prevents_submodule/some_package/some_module.py` & `nuitka_winsvc-2.3/tests/programs/package_prevents_submodule/some_package/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_program/PackageAsMain/__init__.py` & `nuitka_winsvc-2.3/tests/programs/package_program/PackageAsMain/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/package_program/PackageAsMain/__main__.py` & `nuitka_winsvc-2.3/tests/programs/package_program/PackageAsMain/__main__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/PkgUtilIterModulesMain.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/PkgUtilIterModulesMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleC.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleC.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleD.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/SomeModuleD.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/__init__.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package1/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleA.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleA.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleB.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/SomeModuleB.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/__init__.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_itermodules/some_package/sub_package2/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/PkgUtilUsageMain.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_usage/PkgUtilUsageMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/pkgutil_usage/package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/pkgutil_usage/package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/plugin_import/PluginImportMain.py` & `nuitka_winsvc-2.3/tests/programs/plugin_import/PluginImportMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/plugin_import/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/plugin_import/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/plugin_import/some_package/some_module.py` & `nuitka_winsvc-2.3/tests/programs/plugin_import/some_package/some_module.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/reimport_main_dynamic/ImportItselfDynamicMain.py` & `nuitka_winsvc-2.3/tests/programs/reimport_main_dynamic/ImportItselfDynamicMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/reimport_main_static/ImportItselfStaticMain.py` & `nuitka_winsvc-2.3/tests/programs/reimport_main_static/ImportItselfStaticMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/relative_import/RelativeImportMain.py` & `nuitka_winsvc-2.3/tests/programs/relative_import/RelativeImportMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/relative_import/dircache.py` & `nuitka_winsvc-2.3/tests/programs/relative_import/dircache.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/resource_reader37/ResourceReaderMain.py` & `nuitka_winsvc-2.3/tests/programs/resource_reader37/ResourceReaderMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/resource_reader37/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/resource_reader37/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/run_all.py` & `nuitka_winsvc-2.3/tests/programs/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/StdlibOverloadMain.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/StdlibOverloadMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/pyexpat.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/pyexpat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/__init__.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/__init__.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/normal_importing.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/normal_importing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/pyexpat.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/pyexpat.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/stdlib_overload/some_package/star_importing.py` & `nuitka_winsvc-2.3/tests/programs/stdlib_overload/some_package/star_importing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/syntax_errors/IndentationErroring.py` & `nuitka_winsvc-2.3/tests/programs/syntax_errors/IndentationErroring.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/syntax_errors/SyntaxErroring.py` & `nuitka_winsvc-2.3/tests/programs/syntax_errors/SyntaxErroring.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/syntax_errors/SyntaxErrorsMain.py` & `nuitka_winsvc-2.3/tests/programs/syntax_errors/SyntaxErrorsMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/unicode_bom/UnicodeBomMain.py` & `nuitka_winsvc-2.3/tests/programs/unicode_bom/UnicodeBomMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/unicode_bom/unicode_bom.py` & `nuitka_winsvc-2.3/tests/programs/unicode_bom/unicode_bom.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/programs/with space/Space Main.py` & `nuitka_winsvc-2.3/tests/programs/with space/Space Main.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/reflected/compile_itself.py` & `nuitka_winsvc-2.3/tests/reflected/compile_itself.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/run-tests` & `nuitka_winsvc-2.3/tests/run-tests`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/BrotliUsing.py` & `nuitka_winsvc-2.3/tests/standalone/BrotliUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/CtypesUsing.py` & `nuitka_winsvc-2.3/tests/standalone/CtypesUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/DateutilsUsing.py` & `nuitka_winsvc-2.3/tests/standalone/DateutilsUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/FlaskUsing.py` & `nuitka_winsvc-2.3/tests/standalone/FlaskUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/GiUsing.py` & `nuitka_winsvc-2.3/tests/standalone/GiUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/GlfwUsing.py` & `nuitka_winsvc-2.3/tests/standalone/GlfwUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/GtkUsing.py` & `nuitka_winsvc-2.3/tests/standalone/GtkUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/HexEncodingTest_2.py` & `nuitka_winsvc-2.3/tests/standalone/HexEncodingTest_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/IdnaUsing.py` & `nuitka_winsvc-2.3/tests/standalone/IdnaUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/LxmlUsing.py` & `nuitka_winsvc-2.3/tests/standalone/LxmlUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/MatplotlibUsing.py` & `nuitka_winsvc-2.3/tests/standalone/MatplotlibUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/MetadataPackagesUsing.py` & `nuitka_winsvc-2.3/tests/standalone/MetadataPackagesUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/NumpyUsing.py` & `nuitka_winsvc-2.3/tests/standalone/NumpyUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/OpenGLUsing.py` & `nuitka_winsvc-2.3/tests/standalone/OpenGLUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PandasUsing.py` & `nuitka_winsvc-2.3/tests/standalone/PandasUsing.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 
 # Avoid Qt, not being used
 # nuitka-project: --enable-plugin=no-qt
 
 # Make sure, the usual bad ones are not included with anti-bloat.
 
 # nuitka-project: --noinclude-default-mode=error
+# nuitka-project: --noinclude-numba-mode=allow
 # nuitka-project: --noinclude-custom-mode=numpy.distutils:error
 
 # scipy.lib._docscrape insists on it, and seems not easy to get
 # rid of.
 ## nuitka-project: --noinclude-custom-mode=pydoc:error
 
 # isort:start
```

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PasslibUsing.py` & `nuitka_winsvc-2.3/tests/standalone/PasslibUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PendulumUsing.py` & `nuitka_winsvc-2.3/tests/standalone/PendulumUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PkgResourcesRequiresUsing.py` & `nuitka_winsvc-2.3/tests/standalone/PkgResourcesRequiresUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PmwUsing.py` & `nuitka_winsvc-2.3/tests/standalone/PmwUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PyQt5Plugins.py` & `nuitka_winsvc-2.3/tests/standalone/PyQt5Plugins.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PyQt5SSLSupport.py` & `nuitka_winsvc-2.3/tests/standalone/PyQt6Plugins.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,22 +1,21 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-# nuitka-skip-unless-imports: PyQt5.QtGui
+from PyQt6 import QtGui
 
 # nuitka-project: --standalone
-# nuitka-project: --enable-plugin=pyqt5
+# nuitka-project: --enable-plugin=pyqt6
 
 # nuitka-project-if: {OS} == "Darwin":
 #   nuitka-project: --macos-create-app-bundle
-#   nuitka-project: --onefile
 
-from PyQt5.QtNetwork import QSslSocket
+# nuitka-skip-unless-imports: PyQt6.QtGui
 
-print("SSL support: %r" % (QSslSocket.supportsSsl(),))
+print(QtGui.QImageReader.supportedImageFormats())
 
 #     Python test originally created or extracted from other peoples work. The
 #     parts from me are licensed as below. It is at least Free Software where
 #     it's copied from other people. In these cases, that will normally be
 #     indicated.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
```

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PyQt5Using.py` & `nuitka_winsvc-2.3/tests/standalone/PyQt5Using.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PyQt6Plugins.py` & `nuitka_winsvc-2.3/tests/standalone/PySide6Plugins.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,16 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-from PyQt6 import QtGui
+from PySide6 import QtGui
 
 # nuitka-project: --standalone
-# nuitka-project: --enable-plugin=pyqt6
+# nuitka-project: --enable-plugin=pyside6
 
-# nuitka-project-if: {OS} == "Darwin":
-#   nuitka-project: --macos-create-app-bundle
-
-# nuitka-skip-unless-imports: PyQt6.QtGui
+# nuitka-skip-unless-imports: PySide6.QtGui
 
 print(QtGui.QImageReader.supportedImageFormats())
 
 #     Python test originally created or extracted from other peoples work. The
 #     parts from me are licensed as below. It is at least Free Software where
 #     it's copied from other people. In these cases, that will normally be
 #     indicated.
```

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PyQt6Using.py` & `nuitka_winsvc-2.3/tests/standalone/PyQt6Using.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PySide2Using.py` & `nuitka_winsvc-2.3/tests/standalone/PySide2Using.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PySide6Plugins.py` & `nuitka_winsvc-2.3/tests/standalone/SetuptoolsUsing_311.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,24 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-from PySide6 import QtGui
-
 # nuitka-project: --standalone
-# nuitka-project: --enable-plugin=pyside6
+# nuitka-project: --noinclude-setuptools-mode=allow
+
+from __future__ import print_function
+
+import setuptools
+
+# Demonstrate that this module, that anti-bloat fights really hard to
+# avoid, actually still works.
+
+# nuitka-skip-unless-imports: setuptools
 
-# nuitka-skip-unless-imports: PySide6.QtGui
 
-print(QtGui.QImageReader.supportedImageFormats())
+print("OK.")
 
 #     Python test originally created or extracted from other peoples work. The
 #     parts from me are licensed as below. It is at least Free Software where
 #     it's copied from other people. In these cases, that will normally be
 #     indicated.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
```

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/PySide6Using.py` & `nuitka_winsvc-2.3/tests/standalone/PySide6Using.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/RsaUsing.py` & `nuitka_winsvc-2.3/tests/standalone/RsaUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/SetuptoolsUsing_311.py` & `nuitka_winsvc-2.3/tests/syntax/LateFutureImport.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,34 +1,24 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-# nuitka-project: --standalone
-# nuitka-project: --noinclude-setuptools-mode=allow
+# Not allowed to do future imports that are not the first statements of the
+# module.
 
-from __future__ import print_function
+a = 1
 
-import setuptools
+from __future__ import print_function  # isort:skip
 
-# Demonstrate that this module, that anti-bloat fights really hard to
-# avoid, actually still works.
-
-# nuitka-skip-unless-imports: setuptools
-
-
-print("OK.")
-
-#     Python test originally created or extracted from other peoples work. The
-#     parts from me are licensed as below. It is at least Free Software where
-#     it's copied from other people. In these cases, that will normally be
-#     indicated.
+#     Python tests originally created or extracted from other peoples work. The
+#     parts were too small to be protected.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
 #
-#         http://www.apache.org/licenses/LICENSE-2.0
+#        http://www.apache.org/licenses/LICENSE-2.0
 #
 #     Unless required by applicable law or agreed to in writing, software
 #     distributed under the License is distributed on an "AS IS" BASIS,
 #     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #     See the License for the specific language governing permissions and
 #     limitations under the License.
```

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/ShlibUsing.py` & `nuitka_winsvc-2.3/tests/standalone/ShlibUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/SocketUsing.py` & `nuitka_winsvc-2.3/tests/standalone/SocketUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/TkInterUsing.py` & `nuitka_winsvc-2.3/tests/standalone/TkInterUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/Urllib3Using.py` & `nuitka_winsvc-2.3/tests/standalone/Urllib3Using.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/Win32ComUsing.py` & `nuitka_winsvc-2.3/tests/standalone/Win32ComUsing.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/run_all.py` & `nuitka_winsvc-2.3/tests/standalone/run_all.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/standalone/zip_importer/ZipImporterMain.py` & `nuitka_winsvc-2.3/tests/standalone/zip_importer/ZipImporterMain.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/AsyncgenReturn36.py` & `nuitka_winsvc-2.3/tests/syntax/AsyncgenReturn36.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/AwaitInModule36.py` & `nuitka_winsvc-2.3/tests/syntax/AwaitInModule36.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/BreakWithoutLoop.py` & `nuitka_winsvc-2.3/tests/syntax/BreakWithoutLoop.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/ClassReturn.py` & `nuitka_winsvc-2.3/tests/syntax/ClassReturn.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/ClosureDel_2.py` & `nuitka_winsvc-2.3/tests/syntax/ClosureDel_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/ContinueWithoutLoop.py` & `nuitka_winsvc-2.3/tests/syntax/ContinueWithoutLoop.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/DuplicateArgument.py` & `nuitka_winsvc-2.3/tests/syntax/DuplicateArgument.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/ExecWithNesting_2.py` & `nuitka_winsvc-2.3/tests/syntax/ExecWithNesting_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/FutureBraces.py` & `nuitka_winsvc-2.3/tests/syntax/FutureBraces.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/FutureUnknown.py` & `nuitka_winsvc-2.3/tests/syntax/FutureUnknown.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/GeneratorExpressions38.py` & `nuitka_winsvc-2.3/tests/syntax/GeneratorExpressions38.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/GeneratorReturn_2.py` & `nuitka_winsvc-2.3/tests/syntax/GeneratorReturn_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/GlobalForParameter.py` & `nuitka_winsvc-2.3/tests/syntax/GlobalForParameter.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/Importing32.py` & `nuitka_winsvc-2.3/tests/syntax/Importing32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/IndentationError.py` & `nuitka_winsvc-2.3/tests/syntax/IndentationError.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/LateFutureImport.py` & `nuitka_winsvc-2.3/tests/syntax/TryFinallyContinue_37.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-# Not allowed to do future imports that are not the first statements of the
-# module.
+def f():
+    for i in range(10):
+        try:
+            undefined
+        finally:
+            continue
 
-a = 1
-
-from __future__ import print_function  # isort:skip
 
 #     Python tests originally created or extracted from other peoples work. The
 #     parts were too small to be protected.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/MisplacedFutureImport.py` & `nuitka_winsvc-2.3/tests/syntax/MisplacedFutureImport.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/ModuleReturn.py` & `nuitka_winsvc-2.3/tests/syntax/ModuleReturn.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/NonAsciiWithoutEncoding_2.py` & `nuitka_winsvc-2.3/tests/syntax/NonAsciiWithoutEncoding_2.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/NonlocalForParameter32.py` & `nuitka_winsvc-2.3/tests/syntax/NonlocalForParameter32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/NonlocalNotFound32.py` & `nuitka_winsvc-2.3/tests/syntax/NonlocalNotFound32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/StarImportExtra.py` & `nuitka_winsvc-2.3/tests/syntax/StarImportExtra.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/SyntaxError.py` & `nuitka_winsvc-2.3/tests/syntax/SyntaxError.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/TryExceptAllNotLast.py` & `nuitka_winsvc-2.3/tests/syntax/TryExceptAllNotLast.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/TryFinallyContinue_37.py` & `nuitka_winsvc-2.3/tests/syntax/UnpackNoTuple.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,11 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-def f():
-    for i in range(10):
-        try:
-            undefined
-        finally:
-            continue
-
+*a = 1
 
 #     Python tests originally created or extracted from other peoples work. The
 #     parts were too small to be protected.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/UnpackNoTuple.py` & `nuitka_winsvc-2.3/tests/syntax/YieldInModule.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 #     Copyright 2024, Kay Hayen, mailto:kay.hayen@gmail.com find license text at end of file
 
 
-*a = 1
+x = yield i
 
 #     Python tests originally created or extracted from other peoples work. The
 #     parts were too small to be protected.
 #
 #     Licensed under the Apache License, Version 2.0 (the "License");
 #     you may not use this file except in compliance with the License.
 #     You may obtain a copy of the License at
```

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/UnpackTwoStars32.py` & `nuitka_winsvc-2.3/tests/syntax/UnpackTwoStars32.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/YieldFromInModule.py` & `nuitka_winsvc-2.3/tests/syntax/YieldFromInModule.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/YieldInAsync35.py` & `nuitka_winsvc-2.3/tests/syntax/YieldInAsync35.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/YieldInGenexp38.py` & `nuitka_winsvc-2.3/tests/syntax/YieldInGenexp38.py`

 * *Files identical despite different names*

### Comparing `nuitka_winsvc-2.2.3/tests/syntax/run_all.py` & `nuitka_winsvc-2.3/tests/syntax/run_all.py`

 * *Files identical despite different names*

